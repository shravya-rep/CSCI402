
user/usr/bin/memtest.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <overflow>:

static char root_dir[64];

/* Overflow the stack */
static void overflow(void)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	81 ec a8 0f 00 00    	sub    $0xfa8,%esp
        int junk[1000];
        overflow();
 804809d:	e8 f2 ff ff ff       	call   8048094 <overflow>
}
 80480a2:	90                   	nop
 80480a3:	c9                   	leave  
 80480a4:	c3                   	ret    

080480a5 <test_overflow>:

static int test_overflow(void)
{
 80480a5:	55                   	push   %ebp
 80480a6:	89 e5                	mov    %esp,%ebp
 80480a8:	83 ec 38             	sub    $0x38,%esp
        printf("Testing stack overflow\n");
 80480ab:	c7 04 24 84 22 05 08 	movl   $0x8052284,(%esp)
 80480b2:	e8 e9 87 00 00       	call   80508a0 <printf>
        assert_fault(overflow(), "Stack overflow");
 80480b7:	e8 76 51 00 00       	call   804d232 <fork>
 80480bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80480bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80480c3:	75 0c                	jne    80480d1 <test_overflow+0x2c>
 80480c5:	e8 ca ff ff ff       	call   8048094 <overflow>
 80480ca:	b8 00 00 00 00       	mov    $0x0,%eax
 80480cf:	eb 53                	jmp    8048124 <test_overflow+0x7f>
 80480d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80480d4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80480d8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80480df:	00 
 80480e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80480e3:	89 04 24             	mov    %eax,(%esp)
 80480e6:	e8 e5 52 00 00       	call   804d3d0 <waitpid>
 80480eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80480ee:	83 f8 0e             	cmp    $0xe,%eax
 80480f1:	0f 94 c0             	sete   %al
 80480f4:	0f b6 c0             	movzbl %al,%eax
 80480f7:	c7 44 24 10 9c 22 05 	movl   $0x805229c,0x10(%esp)
 80480fe:	08 
 80480ff:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048106:	08 
 8048107:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
 804810e:	00 
 804810f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048116:	08 
 8048117:	89 04 24             	mov    %eax,(%esp)
 804811a:	e8 d1 a0 00 00       	call   80521f0 <_test_assert>
        return 0;
 804811f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048124:	c9                   	leave  
 8048125:	c3                   	ret    

08048126 <test_mmap_bounds>:

static int test_mmap_bounds(void)
{
 8048126:	55                   	push   %ebp
 8048127:	89 e5                	mov    %esp,%ebp
 8048129:	81 ec e8 00 00 00    	sub    $0xe8,%esp
        int fd, status;
        void *addr;

        printf("Testing boundaries and permissions of mmap()\n");
 804812f:	c7 04 24 04 23 05 08 	movl   $0x8052304,(%esp)
 8048136:	e8 65 87 00 00       	call   80508a0 <printf>

        test_assert(0 < (fd = open("/dev/zero", O_RDWR, 0)), NULL);
 804813b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8048142:	00 
 8048143:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804814a:	00 
 804814b:	c7 04 24 32 23 05 08 	movl   $0x8052332,(%esp)
 8048152:	e8 75 54 00 00       	call   804d5cc <open>
 8048157:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804815a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804815e:	0f 9f c0             	setg   %al
 8048161:	0f b6 c0             	movzbl %al,%eax
 8048164:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804816b:	00 
 804816c:	c7 44 24 0c 3c 23 05 	movl   $0x805233c,0xc(%esp)
 8048173:	08 
 8048174:	c7 44 24 08 4b 00 00 	movl   $0x4b,0x8(%esp)
 804817b:	00 
 804817c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048183:	08 
 8048184:	89 04 24             	mov    %eax,(%esp)
 8048187:	e8 64 a0 00 00       	call   80521f0 <_test_assert>
        test_assert(MAP_FAILED != (addr = mmap(NULL, PAGE_SIZE * 3,
 804818c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8048193:	00 
 8048194:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048197:	89 44 24 10          	mov    %eax,0x10(%esp)
 804819b:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 80481a2:	00 
 80481a3:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 80481aa:	00 
 80481ab:	c7 44 24 04 00 30 00 	movl   $0x3000,0x4(%esp)
 80481b2:	00 
 80481b3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80481ba:	e8 21 53 00 00       	call   804d4e0 <mmap>
 80481bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
 80481c2:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 80481c6:	0f 95 c0             	setne  %al
 80481c9:	0f b6 c0             	movzbl %al,%eax
 80481cc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80481d3:	00 
 80481d4:	c7 44 24 0c 64 23 05 	movl   $0x8052364,0xc(%esp)
 80481db:	08 
 80481dc:	c7 44 24 08 4d 00 00 	movl   $0x4d,0x8(%esp)
 80481e3:	00 
 80481e4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80481eb:	08 
 80481ec:	89 04 24             	mov    %eax,(%esp)
 80481ef:	e8 fc 9f 00 00       	call   80521f0 <_test_assert>
                                               PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)), NULL);
        /* Make sure we can actually access these addresses */
        test_assert('\0' == *(char *)addr, NULL);
 80481f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80481f7:	0f b6 00             	movzbl (%eax),%eax
 80481fa:	84 c0                	test   %al,%al
 80481fc:	0f 94 c0             	sete   %al
 80481ff:	0f b6 c0             	movzbl %al,%eax
 8048202:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048209:	00 
 804820a:	c7 44 24 0c c1 23 05 	movl   $0x80523c1,0xc(%esp)
 8048211:	08 
 8048212:	c7 44 24 08 4f 00 00 	movl   $0x4f,0x8(%esp)
 8048219:	00 
 804821a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048221:	08 
 8048222:	89 04 24             	mov    %eax,(%esp)
 8048225:	e8 c6 9f 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)addr + PAGE_SIZE), NULL);
 804822a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804822d:	05 00 10 00 00       	add    $0x1000,%eax
 8048232:	0f b6 00             	movzbl (%eax),%eax
 8048235:	84 c0                	test   %al,%al
 8048237:	0f 94 c0             	sete   %al
 804823a:	0f b6 c0             	movzbl %al,%eax
 804823d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048244:	00 
 8048245:	c7 44 24 0c d8 23 05 	movl   $0x80523d8,0xc(%esp)
 804824c:	08 
 804824d:	c7 44 24 08 50 00 00 	movl   $0x50,0x8(%esp)
 8048254:	00 
 8048255:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804825c:	08 
 804825d:	89 04 24             	mov    %eax,(%esp)
 8048260:	e8 8b 9f 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)addr + PAGE_SIZE * 2), NULL);
 8048265:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048268:	05 00 20 00 00       	add    $0x2000,%eax
 804826d:	0f b6 00             	movzbl (%eax),%eax
 8048270:	84 c0                	test   %al,%al
 8048272:	0f 94 c0             	sete   %al
 8048275:	0f b6 c0             	movzbl %al,%eax
 8048278:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804827f:	00 
 8048280:	c7 44 24 0c fc 23 05 	movl   $0x80523fc,0xc(%esp)
 8048287:	08 
 8048288:	c7 44 24 08 51 00 00 	movl   $0x51,0x8(%esp)
 804828f:	00 
 8048290:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048297:	08 
 8048298:	89 04 24             	mov    %eax,(%esp)
 804829b:	e8 50 9f 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)addr + PAGE_SIZE * 3 - 1), NULL);
 80482a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80482a3:	05 ff 2f 00 00       	add    $0x2fff,%eax
 80482a8:	0f b6 00             	movzbl (%eax),%eax
 80482ab:	84 c0                	test   %al,%al
 80482ad:	0f 94 c0             	sete   %al
 80482b0:	0f b6 c0             	movzbl %al,%eax
 80482b3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80482ba:	00 
 80482bb:	c7 44 24 0c 24 24 05 	movl   $0x8052424,0xc(%esp)
 80482c2:	08 
 80482c3:	c7 44 24 08 52 00 00 	movl   $0x52,0x8(%esp)
 80482ca:	00 
 80482cb:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80482d2:	08 
 80482d3:	89 04 24             	mov    %eax,(%esp)
 80482d6:	e8 15 9f 00 00       	call   80521f0 <_test_assert>

        /* Unmap the ends */
        test_assert(0 == munmap(addr, PAGE_SIZE), NULL);
 80482db:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 80482e2:	00 
 80482e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80482e6:	89 04 24             	mov    %eax,(%esp)
 80482e9:	e8 55 52 00 00       	call   804d543 <munmap>
 80482ee:	85 c0                	test   %eax,%eax
 80482f0:	0f 94 c0             	sete   %al
 80482f3:	0f b6 c0             	movzbl %al,%eax
 80482f6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80482fd:	00 
 80482fe:	c7 44 24 0c 50 24 05 	movl   $0x8052450,0xc(%esp)
 8048305:	08 
 8048306:	c7 44 24 08 55 00 00 	movl   $0x55,0x8(%esp)
 804830d:	00 
 804830e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048315:	08 
 8048316:	89 04 24             	mov    %eax,(%esp)
 8048319:	e8 d2 9e 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == munmap((char *)addr + PAGE_SIZE * 2, PAGE_SIZE), NULL);
 804831e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048321:	05 00 20 00 00       	add    $0x2000,%eax
 8048326:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804832d:	00 
 804832e:	89 04 24             	mov    %eax,(%esp)
 8048331:	e8 0d 52 00 00       	call   804d543 <munmap>
 8048336:	85 c0                	test   %eax,%eax
 8048338:	0f 94 c0             	sete   %al
 804833b:	0f b6 c0             	movzbl %al,%eax
 804833e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048345:	00 
 8048346:	c7 44 24 0c 70 24 05 	movl   $0x8052470,0xc(%esp)
 804834d:	08 
 804834e:	c7 44 24 08 56 00 00 	movl   $0x56,0x8(%esp)
 8048355:	00 
 8048356:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804835d:	08 
 804835e:	89 04 24             	mov    %eax,(%esp)
 8048361:	e8 8a 9e 00 00       	call   80521f0 <_test_assert>

        /* Adjust to center, now surrounded by unmapped regions */
        addr = (char *)addr + PAGE_SIZE;
 8048366:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)

        /* Make sure we didn't unmap the middle */
        test_assert('\0' == *((char *)addr), NULL);
 804836d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048370:	0f b6 00             	movzbl (%eax),%eax
 8048373:	84 c0                	test   %al,%al
 8048375:	0f 94 c0             	sete   %al
 8048378:	0f b6 c0             	movzbl %al,%eax
 804837b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048382:	00 
 8048383:	c7 44 24 0c a5 24 05 	movl   $0x80524a5,0xc(%esp)
 804838a:	08 
 804838b:	c7 44 24 08 5c 00 00 	movl   $0x5c,0x8(%esp)
 8048392:	00 
 8048393:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804839a:	08 
 804839b:	89 04 24             	mov    %eax,(%esp)
 804839e:	e8 4d 9e 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)addr + PAGE_SIZE - 1), NULL);
 80483a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80483a6:	05 ff 0f 00 00       	add    $0xfff,%eax
 80483ab:	0f b6 00             	movzbl (%eax),%eax
 80483ae:	84 c0                	test   %al,%al
 80483b0:	0f 94 c0             	sete   %al
 80483b3:	0f b6 c0             	movzbl %al,%eax
 80483b6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80483bd:	00 
 80483be:	c7 44 24 0c c0 24 05 	movl   $0x80524c0,0xc(%esp)
 80483c5:	08 
 80483c6:	c7 44 24 08 5d 00 00 	movl   $0x5d,0x8(%esp)
 80483cd:	00 
 80483ce:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80483d5:	08 
 80483d6:	89 04 24             	mov    %eax,(%esp)
 80483d9:	e8 12 9e 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*(char *)addr = 'a', "");
 80483de:	e8 4f 4e 00 00       	call   804d232 <fork>
 80483e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
 80483e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 80483ea:	75 10                	jne    80483fc <test_mmap_bounds+0x2d6>
 80483ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80483ef:	c6 00 61             	movb   $0x61,(%eax)
 80483f2:	b8 00 00 00 00       	mov    $0x0,%eax
 80483f7:	e9 92 0a 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 80483fc:	8d 45 80             	lea    -0x80(%ebp),%eax
 80483ff:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048403:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804840a:	00 
 804840b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804840e:	89 04 24             	mov    %eax,(%esp)
 8048411:	e8 ba 4f 00 00       	call   804d3d0 <waitpid>
 8048416:	8b 45 80             	mov    -0x80(%ebp),%eax
 8048419:	85 c0                	test   %eax,%eax
 804841b:	0f 94 c0             	sete   %al
 804841e:	0f b6 c0             	movzbl %al,%eax
 8048421:	c7 44 24 10 e8 24 05 	movl   $0x80524e8,0x10(%esp)
 8048428:	08 
 8048429:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 8048430:	08 
 8048431:	c7 44 24 08 5e 00 00 	movl   $0x5e,0x8(%esp)
 8048438:	00 
 8048439:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048440:	08 
 8048441:	89 04 24             	mov    %eax,(%esp)
 8048444:	e8 a7 9d 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*((char *)addr + PAGE_SIZE - 1) = 'b', "");
 8048449:	e8 e4 4d 00 00       	call   804d232 <fork>
 804844e:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8048451:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 8048455:	75 15                	jne    804846c <test_mmap_bounds+0x346>
 8048457:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804845a:	05 ff 0f 00 00       	add    $0xfff,%eax
 804845f:	c6 00 62             	movb   $0x62,(%eax)
 8048462:	b8 00 00 00 00       	mov    $0x0,%eax
 8048467:	e9 22 0a 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 804846c:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 8048472:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048476:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804847d:	00 
 804847e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8048481:	89 04 24             	mov    %eax,(%esp)
 8048484:	e8 47 4f 00 00       	call   804d3d0 <waitpid>
 8048489:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 804848f:	85 c0                	test   %eax,%eax
 8048491:	0f 94 c0             	sete   %al
 8048494:	0f b6 c0             	movzbl %al,%eax
 8048497:	c7 44 24 10 24 25 05 	movl   $0x8052524,0x10(%esp)
 804849e:	08 
 804849f:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 80484a6:	08 
 80484a7:	c7 44 24 08 5f 00 00 	movl   $0x5f,0x8(%esp)
 80484ae:	00 
 80484af:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80484b6:	08 
 80484b7:	89 04 24             	mov    %eax,(%esp)
 80484ba:	e8 31 9d 00 00       	call   80521f0 <_test_assert>

        /* Regions around it are unmapped */
        assert_fault(char foo = *((char *) addr + PAGE_SIZE), "");
 80484bf:	e8 6e 4d 00 00       	call   804d232 <fork>
 80484c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80484c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 80484cb:	75 17                	jne    80484e4 <test_mmap_bounds+0x3be>
 80484cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80484d0:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 80484d7:	88 45 e3             	mov    %al,-0x1d(%ebp)
 80484da:	b8 00 00 00 00       	mov    $0x0,%eax
 80484df:	e9 aa 09 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 80484e4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
 80484ea:	89 44 24 08          	mov    %eax,0x8(%esp)
 80484ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80484f5:	00 
 80484f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80484f9:	89 04 24             	mov    %eax,(%esp)
 80484fc:	e8 cf 4e 00 00       	call   804d3d0 <waitpid>
 8048501:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 8048507:	83 f8 0e             	cmp    $0xe,%eax
 804850a:	0f 94 c0             	sete   %al
 804850d:	0f b6 c0             	movzbl %al,%eax
 8048510:	c7 44 24 10 64 25 05 	movl   $0x8052564,0x10(%esp)
 8048517:	08 
 8048518:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804851f:	08 
 8048520:	c7 44 24 08 62 00 00 	movl   $0x62,0x8(%esp)
 8048527:	00 
 8048528:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804852f:	08 
 8048530:	89 04 24             	mov    %eax,(%esp)
 8048533:	e8 b8 9c 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *((char *) addr - PAGE_SIZE), "");
 8048538:	e8 f5 4c 00 00       	call   804d232 <fork>
 804853d:	89 45 dc             	mov    %eax,-0x24(%ebp)
 8048540:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 8048544:	75 17                	jne    804855d <test_mmap_bounds+0x437>
 8048546:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048549:	0f b6 80 00 f0 ff ff 	movzbl -0x1000(%eax),%eax
 8048550:	88 45 db             	mov    %al,-0x25(%ebp)
 8048553:	b8 00 00 00 00       	mov    $0x0,%eax
 8048558:	e9 31 09 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 804855d:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
 8048563:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048567:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804856e:	00 
 804856f:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048572:	89 04 24             	mov    %eax,(%esp)
 8048575:	e8 56 4e 00 00       	call   804d3d0 <waitpid>
 804857a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 8048580:	83 f8 0e             	cmp    $0xe,%eax
 8048583:	0f 94 c0             	sete   %al
 8048586:	0f b6 c0             	movzbl %al,%eax
 8048589:	c7 44 24 10 b0 25 05 	movl   $0x80525b0,0x10(%esp)
 8048590:	08 
 8048591:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048598:	08 
 8048599:	c7 44 24 08 63 00 00 	movl   $0x63,0x8(%esp)
 80485a0:	00 
 80485a1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80485a8:	08 
 80485a9:	89 04 24             	mov    %eax,(%esp)
 80485ac:	e8 3f 9c 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *((char *) addr - 1), "");
 80485b1:	e8 7c 4c 00 00       	call   804d232 <fork>
 80485b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80485b9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 80485bd:	75 14                	jne    80485d3 <test_mmap_bounds+0x4ad>
 80485bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80485c2:	0f b6 40 ff          	movzbl -0x1(%eax),%eax
 80485c6:	88 45 d3             	mov    %al,-0x2d(%ebp)
 80485c9:	b8 00 00 00 00       	mov    $0x0,%eax
 80485ce:	e9 bb 08 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 80485d3:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 80485d9:	89 44 24 08          	mov    %eax,0x8(%esp)
 80485dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80485e4:	00 
 80485e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80485e8:	89 04 24             	mov    %eax,(%esp)
 80485eb:	e8 e0 4d 00 00       	call   804d3d0 <waitpid>
 80485f0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 80485f6:	83 f8 0e             	cmp    $0xe,%eax
 80485f9:	0f 94 c0             	sete   %al
 80485fc:	0f b6 c0             	movzbl %al,%eax
 80485ff:	c7 44 24 10 fc 25 05 	movl   $0x80525fc,0x10(%esp)
 8048606:	08 
 8048607:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804860e:	08 
 804860f:	c7 44 24 08 64 00 00 	movl   $0x64,0x8(%esp)
 8048616:	00 
 8048617:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804861e:	08 
 804861f:	89 04 24             	mov    %eax,(%esp)
 8048622:	e8 c9 9b 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr + PAGE_SIZE) = 'a', "");
 8048627:	e8 06 4c 00 00       	call   804d232 <fork>
 804862c:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804862f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 8048633:	75 15                	jne    804864a <test_mmap_bounds+0x524>
 8048635:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048638:	05 00 10 00 00       	add    $0x1000,%eax
 804863d:	c6 00 61             	movb   $0x61,(%eax)
 8048640:	b8 00 00 00 00       	mov    $0x0,%eax
 8048645:	e9 44 08 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 804864a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
 8048650:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048654:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804865b:	00 
 804865c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804865f:	89 04 24             	mov    %eax,(%esp)
 8048662:	e8 69 4d 00 00       	call   804d3d0 <waitpid>
 8048667:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804866d:	83 f8 0e             	cmp    $0xe,%eax
 8048670:	0f 94 c0             	sete   %al
 8048673:	0f b6 c0             	movzbl %al,%eax
 8048676:	c7 44 24 10 40 26 05 	movl   $0x8052640,0x10(%esp)
 804867d:	08 
 804867e:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048685:	08 
 8048686:	c7 44 24 08 65 00 00 	movl   $0x65,0x8(%esp)
 804868d:	00 
 804868e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048695:	08 
 8048696:	89 04 24             	mov    %eax,(%esp)
 8048699:	e8 52 9b 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr - 1) = 'a', "");
 804869e:	e8 8f 4b 00 00       	call   804d232 <fork>
 80486a3:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80486a6:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 80486aa:	75 11                	jne    80486bd <test_mmap_bounds+0x597>
 80486ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80486af:	48                   	dec    %eax
 80486b0:	c6 00 61             	movb   $0x61,(%eax)
 80486b3:	b8 00 00 00 00       	mov    $0x0,%eax
 80486b8:	e9 d1 07 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 80486bd:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 80486c3:	89 44 24 08          	mov    %eax,0x8(%esp)
 80486c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80486ce:	00 
 80486cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80486d2:	89 04 24             	mov    %eax,(%esp)
 80486d5:	e8 f6 4c 00 00       	call   804d3d0 <waitpid>
 80486da:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
 80486e0:	83 f8 0e             	cmp    $0xe,%eax
 80486e3:	0f 94 c0             	sete   %al
 80486e6:	0f b6 c0             	movzbl %al,%eax
 80486e9:	c7 44 24 10 88 26 05 	movl   $0x8052688,0x10(%esp)
 80486f0:	08 
 80486f1:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 80486f8:	08 
 80486f9:	c7 44 24 08 66 00 00 	movl   $0x66,0x8(%esp)
 8048700:	00 
 8048701:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048708:	08 
 8048709:	89 04 24             	mov    %eax,(%esp)
 804870c:	e8 df 9a 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr + PAGE_SIZE * 2 - 1) = 'a', "");
 8048711:	e8 1c 4b 00 00       	call   804d232 <fork>
 8048716:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 8048719:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 804871d:	75 15                	jne    8048734 <test_mmap_bounds+0x60e>
 804871f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048722:	05 ff 1f 00 00       	add    $0x1fff,%eax
 8048727:	c6 00 61             	movb   $0x61,(%eax)
 804872a:	b8 00 00 00 00       	mov    $0x0,%eax
 804872f:	e9 5a 07 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048734:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
 804873a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804873e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048745:	00 
 8048746:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8048749:	89 04 24             	mov    %eax,(%esp)
 804874c:	e8 7f 4c 00 00       	call   804d3d0 <waitpid>
 8048751:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
 8048757:	83 f8 0e             	cmp    $0xe,%eax
 804875a:	0f 94 c0             	sete   %al
 804875d:	0f b6 c0             	movzbl %al,%eax
 8048760:	c7 44 24 10 c8 26 05 	movl   $0x80526c8,0x10(%esp)
 8048767:	08 
 8048768:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804876f:	08 
 8048770:	c7 44 24 08 67 00 00 	movl   $0x67,0x8(%esp)
 8048777:	00 
 8048778:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804877f:	08 
 8048780:	89 04 24             	mov    %eax,(%esp)
 8048783:	e8 68 9a 00 00       	call   80521f0 <_test_assert>

        /* Remap as read-only */
        test_assert(addr == mmap(addr, 1,
 8048788:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804878f:	00 
 8048790:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048793:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048797:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
 804879e:	00 
 804879f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 80487a6:	00 
 80487a7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80487ae:	00 
 80487af:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80487b2:	89 04 24             	mov    %eax,(%esp)
 80487b5:	e8 26 4d 00 00       	call   804d4e0 <mmap>
 80487ba:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 80487bd:	0f 94 c0             	sete   %al
 80487c0:	0f b6 c0             	movzbl %al,%eax
 80487c3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80487ca:	00 
 80487cb:	c7 44 24 0c 18 27 05 	movl   $0x8052718,0xc(%esp)
 80487d2:	08 
 80487d3:	c7 44 24 08 6b 00 00 	movl   $0x6b,0x8(%esp)
 80487da:	00 
 80487db:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80487e2:	08 
 80487e3:	89 04 24             	mov    %eax,(%esp)
 80487e6:	e8 05 9a 00 00       	call   80521f0 <_test_assert>
                                 PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, 0), NULL);

        assert_fault(*((char *) addr) = 'a', "");
 80487eb:	e8 42 4a 00 00       	call   804d232 <fork>
 80487f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
 80487f3:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 80487f7:	75 10                	jne    8048809 <test_mmap_bounds+0x6e3>
 80487f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80487fc:	c6 00 61             	movb   $0x61,(%eax)
 80487ff:	b8 00 00 00 00       	mov    $0x0,%eax
 8048804:	e9 85 06 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048809:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
 804880f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048813:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804881a:	00 
 804881b:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804881e:	89 04 24             	mov    %eax,(%esp)
 8048821:	e8 aa 4b 00 00       	call   804d3d0 <waitpid>
 8048826:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
 804882c:	83 f8 0e             	cmp    $0xe,%eax
 804882f:	0f 94 c0             	sete   %al
 8048832:	0f b6 c0             	movzbl %al,%eax
 8048835:	c7 44 24 10 5c 27 05 	movl   $0x805275c,0x10(%esp)
 804883c:	08 
 804883d:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048844:	08 
 8048845:	c7 44 24 08 6d 00 00 	movl   $0x6d,0x8(%esp)
 804884c:	00 
 804884d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048854:	08 
 8048855:	89 04 24             	mov    %eax,(%esp)
 8048858:	e8 93 99 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr + PAGE_SIZE - 1) = 'a', "");
 804885d:	e8 d0 49 00 00       	call   804d232 <fork>
 8048862:	89 45 bc             	mov    %eax,-0x44(%ebp)
 8048865:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
 8048869:	75 15                	jne    8048880 <test_mmap_bounds+0x75a>
 804886b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804886e:	05 ff 0f 00 00       	add    $0xfff,%eax
 8048873:	c6 00 61             	movb   $0x61,(%eax)
 8048876:	b8 00 00 00 00       	mov    $0x0,%eax
 804887b:	e9 0e 06 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048880:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
 8048886:	89 44 24 08          	mov    %eax,0x8(%esp)
 804888a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048891:	00 
 8048892:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8048895:	89 04 24             	mov    %eax,(%esp)
 8048898:	e8 33 4b 00 00       	call   804d3d0 <waitpid>
 804889d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
 80488a3:	83 f8 0e             	cmp    $0xe,%eax
 80488a6:	0f 94 c0             	sete   %al
 80488a9:	0f b6 c0             	movzbl %al,%eax
 80488ac:	c7 44 24 10 98 27 05 	movl   $0x8052798,0x10(%esp)
 80488b3:	08 
 80488b4:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 80488bb:	08 
 80488bc:	c7 44 24 08 6e 00 00 	movl   $0x6e,0x8(%esp)
 80488c3:	00 
 80488c4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80488cb:	08 
 80488cc:	89 04 24             	mov    %eax,(%esp)
 80488cf:	e8 1c 99 00 00       	call   80521f0 <_test_assert>

        /* "Unmap" */
        test_assert(0 == munmap((char *)addr - PAGE_SIZE, PAGE_SIZE), NULL);
 80488d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80488d7:	2d 00 10 00 00       	sub    $0x1000,%eax
 80488dc:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 80488e3:	00 
 80488e4:	89 04 24             	mov    %eax,(%esp)
 80488e7:	e8 57 4c 00 00       	call   804d543 <munmap>
 80488ec:	85 c0                	test   %eax,%eax
 80488ee:	0f 94 c0             	sete   %al
 80488f1:	0f b6 c0             	movzbl %al,%eax
 80488f4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80488fb:	00 
 80488fc:	c7 44 24 0c e4 27 05 	movl   $0x80527e4,0xc(%esp)
 8048903:	08 
 8048904:	c7 44 24 08 71 00 00 	movl   $0x71,0x8(%esp)
 804890b:	00 
 804890c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048913:	08 
 8048914:	89 04 24             	mov    %eax,(%esp)
 8048917:	e8 d4 98 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == munmap((char *)addr + PAGE_SIZE, PAGE_SIZE), NULL);
 804891c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804891f:	05 00 10 00 00       	add    $0x1000,%eax
 8048924:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804892b:	00 
 804892c:	89 04 24             	mov    %eax,(%esp)
 804892f:	e8 0f 4c 00 00       	call   804d543 <munmap>
 8048934:	85 c0                	test   %eax,%eax
 8048936:	0f 94 c0             	sete   %al
 8048939:	0f b6 c0             	movzbl %al,%eax
 804893c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048943:	00 
 8048944:	c7 44 24 0c 18 28 05 	movl   $0x8052818,0xc(%esp)
 804894b:	08 
 804894c:	c7 44 24 08 72 00 00 	movl   $0x72,0x8(%esp)
 8048953:	00 
 8048954:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804895b:	08 
 804895c:	89 04 24             	mov    %eax,(%esp)
 804895f:	e8 8c 98 00 00       	call   80521f0 <_test_assert>

        /* Make sure it's still there, also that it's overwritten */
        test_assert('\0' == *((char *)addr), NULL);
 8048964:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048967:	0f b6 00             	movzbl (%eax),%eax
 804896a:	84 c0                	test   %al,%al
 804896c:	0f 94 c0             	sete   %al
 804896f:	0f b6 c0             	movzbl %al,%eax
 8048972:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048979:	00 
 804897a:	c7 44 24 0c a5 24 05 	movl   $0x80524a5,0xc(%esp)
 8048981:	08 
 8048982:	c7 44 24 08 75 00 00 	movl   $0x75,0x8(%esp)
 8048989:	00 
 804898a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048991:	08 
 8048992:	89 04 24             	mov    %eax,(%esp)
 8048995:	e8 56 98 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)addr + PAGE_SIZE - 1), NULL);
 804899a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804899d:	05 ff 0f 00 00       	add    $0xfff,%eax
 80489a2:	0f b6 00             	movzbl (%eax),%eax
 80489a5:	84 c0                	test   %al,%al
 80489a7:	0f 94 c0             	sete   %al
 80489aa:	0f b6 c0             	movzbl %al,%eax
 80489ad:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80489b4:	00 
 80489b5:	c7 44 24 0c c0 24 05 	movl   $0x80524c0,0xc(%esp)
 80489bc:	08 
 80489bd:	c7 44 24 08 76 00 00 	movl   $0x76,0x8(%esp)
 80489c4:	00 
 80489c5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80489cc:	08 
 80489cd:	89 04 24             	mov    %eax,(%esp)
 80489d0:	e8 1b 98 00 00       	call   80521f0 <_test_assert>

        /* Unmap for real */
        test_assert(0 == munmap(addr, 1), NULL);
 80489d5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80489dc:	00 
 80489dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80489e0:	89 04 24             	mov    %eax,(%esp)
 80489e3:	e8 5b 4b 00 00       	call   804d543 <munmap>
 80489e8:	85 c0                	test   %eax,%eax
 80489ea:	0f 94 c0             	sete   %al
 80489ed:	0f b6 c0             	movzbl %al,%eax
 80489f0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80489f7:	00 
 80489f8:	c7 44 24 0c 49 28 05 	movl   $0x8052849,0xc(%esp)
 80489ff:	08 
 8048a00:	c7 44 24 08 79 00 00 	movl   $0x79,0x8(%esp)
 8048a07:	00 
 8048a08:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048a0f:	08 
 8048a10:	89 04 24             	mov    %eax,(%esp)
 8048a13:	e8 d8 97 00 00       	call   80521f0 <_test_assert>

        assert_fault(char foo = *(char *) addr, "");
 8048a18:	e8 15 48 00 00       	call   804d232 <fork>
 8048a1d:	89 45 b8             	mov    %eax,-0x48(%ebp)
 8048a20:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
 8048a24:	75 13                	jne    8048a39 <test_mmap_bounds+0x913>
 8048a26:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048a29:	0f b6 00             	movzbl (%eax),%eax
 8048a2c:	88 45 b7             	mov    %al,-0x49(%ebp)
 8048a2f:	b8 00 00 00 00       	mov    $0x0,%eax
 8048a34:	e9 55 04 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048a39:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
 8048a3f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a43:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048a4a:	00 
 8048a4b:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8048a4e:	89 04 24             	mov    %eax,(%esp)
 8048a51:	e8 7a 49 00 00       	call   804d3d0 <waitpid>
 8048a56:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 8048a5c:	83 f8 0e             	cmp    $0xe,%eax
 8048a5f:	0f 94 c0             	sete   %al
 8048a62:	0f b6 c0             	movzbl %al,%eax
 8048a65:	c7 44 24 10 60 28 05 	movl   $0x8052860,0x10(%esp)
 8048a6c:	08 
 8048a6d:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048a74:	08 
 8048a75:	c7 44 24 08 7b 00 00 	movl   $0x7b,0x8(%esp)
 8048a7c:	00 
 8048a7d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048a84:	08 
 8048a85:	89 04 24             	mov    %eax,(%esp)
 8048a88:	e8 63 97 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *((char *) addr + PAGE_SIZE - 1), "");
 8048a8d:	e8 a0 47 00 00       	call   804d232 <fork>
 8048a92:	89 45 b0             	mov    %eax,-0x50(%ebp)
 8048a95:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 8048a99:	75 17                	jne    8048ab2 <test_mmap_bounds+0x98c>
 8048a9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048a9e:	0f b6 80 ff 0f 00 00 	movzbl 0xfff(%eax),%eax
 8048aa5:	88 45 af             	mov    %al,-0x51(%ebp)
 8048aa8:	b8 00 00 00 00       	mov    $0x0,%eax
 8048aad:	e9 dc 03 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048ab2:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
 8048ab8:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048abc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048ac3:	00 
 8048ac4:	8b 45 b0             	mov    -0x50(%ebp),%eax
 8048ac7:	89 04 24             	mov    %eax,(%esp)
 8048aca:	e8 01 49 00 00       	call   804d3d0 <waitpid>
 8048acf:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
 8048ad5:	83 f8 0e             	cmp    $0xe,%eax
 8048ad8:	0f 94 c0             	sete   %al
 8048adb:	0f b6 c0             	movzbl %al,%eax
 8048ade:	c7 44 24 10 9c 28 05 	movl   $0x805289c,0x10(%esp)
 8048ae5:	08 
 8048ae6:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048aed:	08 
 8048aee:	c7 44 24 08 7c 00 00 	movl   $0x7c,0x8(%esp)
 8048af5:	00 
 8048af6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048afd:	08 
 8048afe:	89 04 24             	mov    %eax,(%esp)
 8048b01:	e8 ea 96 00 00       	call   80521f0 <_test_assert>

        /* Test fun permissions */
        test_assert(addr == mmap(addr, PAGE_SIZE,
 8048b06:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8048b0d:	00 
 8048b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b11:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048b15:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
 8048b1c:	00 
 8048b1d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 8048b24:	00 
 8048b25:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 8048b2c:	00 
 8048b2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048b30:	89 04 24             	mov    %eax,(%esp)
 8048b33:	e8 a8 49 00 00       	call   804d4e0 <mmap>
 8048b38:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 8048b3b:	0f 94 c0             	sete   %al
 8048b3e:	0f b6 c0             	movzbl %al,%eax
 8048b41:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048b48:	00 
 8048b49:	c7 44 24 0c ec 28 05 	movl   $0x80528ec,0xc(%esp)
 8048b50:	08 
 8048b51:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
 8048b58:	00 
 8048b59:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048b60:	08 
 8048b61:	89 04 24             	mov    %eax,(%esp)
 8048b64:	e8 87 96 00 00       	call   80521f0 <_test_assert>
                                 PROT_EXEC, MAP_PRIVATE | MAP_FIXED, fd, 0), NULL);
        assert_fault(char foo = *(char *) addr, "");
 8048b69:	e8 c4 46 00 00       	call   804d232 <fork>
 8048b6e:	89 45 a8             	mov    %eax,-0x58(%ebp)
 8048b71:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
 8048b75:	75 13                	jne    8048b8a <test_mmap_bounds+0xa64>
 8048b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048b7a:	0f b6 00             	movzbl (%eax),%eax
 8048b7d:	88 45 a7             	mov    %al,-0x59(%ebp)
 8048b80:	b8 00 00 00 00       	mov    $0x0,%eax
 8048b85:	e9 04 03 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048b8a:	8d 85 50 ff ff ff    	lea    -0xb0(%ebp),%eax
 8048b90:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048b94:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048b9b:	00 
 8048b9c:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8048b9f:	89 04 24             	mov    %eax,(%esp)
 8048ba2:	e8 29 48 00 00       	call   804d3d0 <waitpid>
 8048ba7:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 8048bad:	83 f8 0e             	cmp    $0xe,%eax
 8048bb0:	0f 94 c0             	sete   %al
 8048bb3:	0f b6 c0             	movzbl %al,%eax
 8048bb6:	c7 44 24 10 60 28 05 	movl   $0x8052860,0x10(%esp)
 8048bbd:	08 
 8048bbe:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048bc5:	08 
 8048bc6:	c7 44 24 08 81 00 00 	movl   $0x81,0x8(%esp)
 8048bcd:	00 
 8048bce:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048bd5:	08 
 8048bd6:	89 04 24             	mov    %eax,(%esp)
 8048bd9:	e8 12 96 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *((char *) addr + PAGE_SIZE - 1), "");
 8048bde:	e8 4f 46 00 00       	call   804d232 <fork>
 8048be3:	89 45 a0             	mov    %eax,-0x60(%ebp)
 8048be6:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 8048bea:	75 17                	jne    8048c03 <test_mmap_bounds+0xadd>
 8048bec:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048bef:	0f b6 80 ff 0f 00 00 	movzbl 0xfff(%eax),%eax
 8048bf6:	88 45 9f             	mov    %al,-0x61(%ebp)
 8048bf9:	b8 00 00 00 00       	mov    $0x0,%eax
 8048bfe:	e9 8b 02 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048c03:	8d 85 4c ff ff ff    	lea    -0xb4(%ebp),%eax
 8048c09:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048c0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048c14:	00 
 8048c15:	8b 45 a0             	mov    -0x60(%ebp),%eax
 8048c18:	89 04 24             	mov    %eax,(%esp)
 8048c1b:	e8 b0 47 00 00       	call   804d3d0 <waitpid>
 8048c20:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 8048c26:	83 f8 0e             	cmp    $0xe,%eax
 8048c29:	0f 94 c0             	sete   %al
 8048c2c:	0f b6 c0             	movzbl %al,%eax
 8048c2f:	c7 44 24 10 9c 28 05 	movl   $0x805289c,0x10(%esp)
 8048c36:	08 
 8048c37:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048c3e:	08 
 8048c3f:	c7 44 24 08 82 00 00 	movl   $0x82,0x8(%esp)
 8048c46:	00 
 8048c47:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048c4e:	08 
 8048c4f:	89 04 24             	mov    %eax,(%esp)
 8048c52:	e8 99 95 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr) = 'a', "");
 8048c57:	e8 d6 45 00 00       	call   804d232 <fork>
 8048c5c:	89 45 98             	mov    %eax,-0x68(%ebp)
 8048c5f:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
 8048c63:	75 10                	jne    8048c75 <test_mmap_bounds+0xb4f>
 8048c65:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048c68:	c6 00 61             	movb   $0x61,(%eax)
 8048c6b:	b8 00 00 00 00       	mov    $0x0,%eax
 8048c70:	e9 19 02 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048c75:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
 8048c7b:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048c7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048c86:	00 
 8048c87:	8b 45 98             	mov    -0x68(%ebp),%eax
 8048c8a:	89 04 24             	mov    %eax,(%esp)
 8048c8d:	e8 3e 47 00 00       	call   804d3d0 <waitpid>
 8048c92:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
 8048c98:	83 f8 0e             	cmp    $0xe,%eax
 8048c9b:	0f 94 c0             	sete   %al
 8048c9e:	0f b6 c0             	movzbl %al,%eax
 8048ca1:	c7 44 24 10 5c 27 05 	movl   $0x805275c,0x10(%esp)
 8048ca8:	08 
 8048ca9:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048cb0:	08 
 8048cb1:	c7 44 24 08 83 00 00 	movl   $0x83,0x8(%esp)
 8048cb8:	00 
 8048cb9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048cc0:	08 
 8048cc1:	89 04 24             	mov    %eax,(%esp)
 8048cc4:	e8 27 95 00 00       	call   80521f0 <_test_assert>

        test_assert(addr == mmap(addr, PAGE_SIZE,
 8048cc9:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8048cd0:	00 
 8048cd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cd4:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048cd8:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
 8048cdf:	00 
 8048ce0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8048ce7:	00 
 8048ce8:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 8048cef:	00 
 8048cf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048cf3:	89 04 24             	mov    %eax,(%esp)
 8048cf6:	e8 e5 47 00 00       	call   804d4e0 <mmap>
 8048cfb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 8048cfe:	0f 94 c0             	sete   %al
 8048d01:	0f b6 c0             	movzbl %al,%eax
 8048d04:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048d0b:	00 
 8048d0c:	c7 44 24 0c 38 29 05 	movl   $0x8052938,0xc(%esp)
 8048d13:	08 
 8048d14:	c7 44 24 08 86 00 00 	movl   $0x86,0x8(%esp)
 8048d1b:	00 
 8048d1c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048d23:	08 
 8048d24:	89 04 24             	mov    %eax,(%esp)
 8048d27:	e8 c4 94 00 00       	call   80521f0 <_test_assert>
                                 0, MAP_PRIVATE | MAP_FIXED, fd, 0), NULL);
        assert_fault(char foo = *(char *) addr, "");
 8048d2c:	e8 01 45 00 00       	call   804d232 <fork>
 8048d31:	89 45 94             	mov    %eax,-0x6c(%ebp)
 8048d34:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
 8048d38:	75 13                	jne    8048d4d <test_mmap_bounds+0xc27>
 8048d3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048d3d:	0f b6 00             	movzbl (%eax),%eax
 8048d40:	88 45 93             	mov    %al,-0x6d(%ebp)
 8048d43:	b8 00 00 00 00       	mov    $0x0,%eax
 8048d48:	e9 41 01 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048d4d:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
 8048d53:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048d57:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048d5e:	00 
 8048d5f:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8048d62:	89 04 24             	mov    %eax,(%esp)
 8048d65:	e8 66 46 00 00       	call   804d3d0 <waitpid>
 8048d6a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
 8048d70:	83 f8 0e             	cmp    $0xe,%eax
 8048d73:	0f 94 c0             	sete   %al
 8048d76:	0f b6 c0             	movzbl %al,%eax
 8048d79:	c7 44 24 10 60 28 05 	movl   $0x8052860,0x10(%esp)
 8048d80:	08 
 8048d81:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048d88:	08 
 8048d89:	c7 44 24 08 87 00 00 	movl   $0x87,0x8(%esp)
 8048d90:	00 
 8048d91:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048d98:	08 
 8048d99:	89 04 24             	mov    %eax,(%esp)
 8048d9c:	e8 4f 94 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *((char *) addr + PAGE_SIZE - 1), "");
 8048da1:	e8 8c 44 00 00       	call   804d232 <fork>
 8048da6:	89 45 8c             	mov    %eax,-0x74(%ebp)
 8048da9:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
 8048dad:	75 17                	jne    8048dc6 <test_mmap_bounds+0xca0>
 8048daf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048db2:	0f b6 80 ff 0f 00 00 	movzbl 0xfff(%eax),%eax
 8048db9:	88 45 8b             	mov    %al,-0x75(%ebp)
 8048dbc:	b8 00 00 00 00       	mov    $0x0,%eax
 8048dc1:	e9 c8 00 00 00       	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048dc6:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 8048dcc:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048dd0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048dd7:	00 
 8048dd8:	8b 45 8c             	mov    -0x74(%ebp),%eax
 8048ddb:	89 04 24             	mov    %eax,(%esp)
 8048dde:	e8 ed 45 00 00       	call   804d3d0 <waitpid>
 8048de3:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
 8048de9:	83 f8 0e             	cmp    $0xe,%eax
 8048dec:	0f 94 c0             	sete   %al
 8048def:	0f b6 c0             	movzbl %al,%eax
 8048df2:	c7 44 24 10 9c 28 05 	movl   $0x805289c,0x10(%esp)
 8048df9:	08 
 8048dfa:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048e01:	08 
 8048e02:	c7 44 24 08 88 00 00 	movl   $0x88,0x8(%esp)
 8048e09:	00 
 8048e0a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048e11:	08 
 8048e12:	89 04 24             	mov    %eax,(%esp)
 8048e15:	e8 d6 93 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *) addr) = 'a', "");
 8048e1a:	e8 13 44 00 00       	call   804d232 <fork>
 8048e1f:	89 45 84             	mov    %eax,-0x7c(%ebp)
 8048e22:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
 8048e26:	75 0d                	jne    8048e35 <test_mmap_bounds+0xd0f>
 8048e28:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048e2b:	c6 00 61             	movb   $0x61,(%eax)
 8048e2e:	b8 00 00 00 00       	mov    $0x0,%eax
 8048e33:	eb 59                	jmp    8048e8e <test_mmap_bounds+0xd68>
 8048e35:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
 8048e3b:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048e3f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048e46:	00 
 8048e47:	8b 45 84             	mov    -0x7c(%ebp),%eax
 8048e4a:	89 04 24             	mov    %eax,(%esp)
 8048e4d:	e8 7e 45 00 00       	call   804d3d0 <waitpid>
 8048e52:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
 8048e58:	83 f8 0e             	cmp    $0xe,%eax
 8048e5b:	0f 94 c0             	sete   %al
 8048e5e:	0f b6 c0             	movzbl %al,%eax
 8048e61:	c7 44 24 10 5c 27 05 	movl   $0x805275c,0x10(%esp)
 8048e68:	08 
 8048e69:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048e70:	08 
 8048e71:	c7 44 24 08 89 00 00 	movl   $0x89,0x8(%esp)
 8048e78:	00 
 8048e79:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048e80:	08 
 8048e81:	89 04 24             	mov    %eax,(%esp)
 8048e84:	e8 67 93 00 00       	call   80521f0 <_test_assert>


        return 0;
 8048e89:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048e8e:	c9                   	leave  
 8048e8f:	c3                   	ret    

08048e90 <test_brk_bounds>:

static int test_brk_bounds(void)
{
 8048e90:	55                   	push   %ebp
 8048e91:	89 e5                	mov    %esp,%ebp
 8048e93:	83 ec 78             	sub    $0x78,%esp
        void *oldbrk, *newbrk;
        int status;

        printf("Testing boundaries and permissions of brk()\n");
 8048e96:	c7 04 24 7c 29 05 08 	movl   $0x805297c,(%esp)
 8048e9d:	e8 fe 79 00 00       	call   80508a0 <printf>

        /* "Stabilize" our old brk at a page boundary */
        test_assert((void *) - 1 != (oldbrk = sbrk(0)), NULL);
 8048ea2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8048ea9:	e8 51 42 00 00       	call   804d0ff <sbrk>
 8048eae:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8048eb1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 8048eb5:	0f 95 c0             	setne  %al
 8048eb8:	0f b6 c0             	movzbl %al,%eax
 8048ebb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048ec2:	00 
 8048ec3:	c7 44 24 0c ac 29 05 	movl   $0x80529ac,0xc(%esp)
 8048eca:	08 
 8048ecb:	c7 44 24 08 97 00 00 	movl   $0x97,0x8(%esp)
 8048ed2:	00 
 8048ed3:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048eda:	08 
 8048edb:	89 04 24             	mov    %eax,(%esp)
 8048ede:	e8 0d 93 00 00       	call   80521f0 <_test_assert>
        oldbrk = PAGE_ALIGN_UP(oldbrk);
 8048ee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048ee6:	48                   	dec    %eax
 8048ee7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8048eec:	05 00 10 00 00       	add    $0x1000,%eax
 8048ef1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        test_assert(0 == brk(oldbrk), NULL);
 8048ef4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048ef7:	89 04 24             	mov    %eax,(%esp)
 8048efa:	e8 c9 42 00 00       	call   804d1c8 <brk>
 8048eff:	85 c0                	test   %eax,%eax
 8048f01:	0f 94 c0             	sete   %al
 8048f04:	0f b6 c0             	movzbl %al,%eax
 8048f07:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8048f0e:	00 
 8048f0f:	c7 44 24 0c cf 29 05 	movl   $0x80529cf,0xc(%esp)
 8048f16:	08 
 8048f17:	c7 44 24 08 99 00 00 	movl   $0x99,0x8(%esp)
 8048f1e:	00 
 8048f1f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048f26:	08 
 8048f27:	89 04 24             	mov    %eax,(%esp)
 8048f2a:	e8 c1 92 00 00       	call   80521f0 <_test_assert>

        /* Look at next page-aligned addr */
        newbrk = (char *)oldbrk + PAGE_SIZE;
 8048f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048f32:	05 00 10 00 00       	add    $0x1000,%eax
 8048f37:	89 45 f0             	mov    %eax,-0x10(%ebp)

        assert_fault(char foo = *(char *)newbrk, "");
 8048f3a:	e8 f3 42 00 00       	call   804d232 <fork>
 8048f3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
 8048f42:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 8048f46:	75 13                	jne    8048f5b <test_brk_bounds+0xcb>
 8048f48:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048f4b:	0f b6 00             	movzbl (%eax),%eax
 8048f4e:	88 45 eb             	mov    %al,-0x15(%ebp)
 8048f51:	b8 00 00 00 00       	mov    $0x0,%eax
 8048f56:	e9 40 07 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 8048f5b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
 8048f5e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048f62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048f69:	00 
 8048f6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8048f6d:	89 04 24             	mov    %eax,(%esp)
 8048f70:	e8 5b 44 00 00       	call   804d3d0 <waitpid>
 8048f75:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8048f78:	83 f8 0e             	cmp    $0xe,%eax
 8048f7b:	0f 94 c0             	sete   %al
 8048f7e:	0f b6 c0             	movzbl %al,%eax
 8048f81:	c7 44 24 10 e0 29 05 	movl   $0x80529e0,0x10(%esp)
 8048f88:	08 
 8048f89:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048f90:	08 
 8048f91:	c7 44 24 08 9e 00 00 	movl   $0x9e,0x8(%esp)
 8048f98:	00 
 8048f99:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8048fa0:	08 
 8048fa1:	89 04 24             	mov    %eax,(%esp)
 8048fa4:	e8 47 92 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(char *)newbrk = 'a', "");
 8048fa9:	e8 84 42 00 00       	call   804d232 <fork>
 8048fae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 8048fb1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 8048fb5:	75 10                	jne    8048fc7 <test_brk_bounds+0x137>
 8048fb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048fba:	c6 00 61             	movb   $0x61,(%eax)
 8048fbd:	b8 00 00 00 00       	mov    $0x0,%eax
 8048fc2:	e9 d4 06 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 8048fc7:	8d 45 c0             	lea    -0x40(%ebp),%eax
 8048fca:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048fce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048fd5:	00 
 8048fd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048fd9:	89 04 24             	mov    %eax,(%esp)
 8048fdc:	e8 ef 43 00 00       	call   804d3d0 <waitpid>
 8048fe1:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8048fe4:	83 f8 0e             	cmp    $0xe,%eax
 8048fe7:	0f 94 c0             	sete   %al
 8048fea:	0f b6 c0             	movzbl %al,%eax
 8048fed:	c7 44 24 10 20 2a 05 	movl   $0x8052a20,0x10(%esp)
 8048ff4:	08 
 8048ff5:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8048ffc:	08 
 8048ffd:	c7 44 24 08 9f 00 00 	movl   $0x9f,0x8(%esp)
 8049004:	00 
 8049005:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804900c:	08 
 804900d:	89 04 24             	mov    %eax,(%esp)
 8049010:	e8 db 91 00 00       	call   80521f0 <_test_assert>

        /* Move brk to next page-aligned addr */
        test_assert(0 == brk(newbrk), NULL);
 8049015:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049018:	89 04 24             	mov    %eax,(%esp)
 804901b:	e8 a8 41 00 00       	call   804d1c8 <brk>
 8049020:	85 c0                	test   %eax,%eax
 8049022:	0f 94 c0             	sete   %al
 8049025:	0f b6 c0             	movzbl %al,%eax
 8049028:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804902f:	00 
 8049030:	c7 44 24 0c 58 2a 05 	movl   $0x8052a58,0xc(%esp)
 8049037:	08 
 8049038:	c7 44 24 08 a2 00 00 	movl   $0xa2,0x8(%esp)
 804903f:	00 
 8049040:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049047:	08 
 8049048:	89 04 24             	mov    %eax,(%esp)
 804904b:	e8 a0 91 00 00       	call   80521f0 <_test_assert>

        /* Access the new memory */
        test_assert('\0' == *(char *)oldbrk, NULL);
 8049050:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049053:	0f b6 00             	movzbl (%eax),%eax
 8049056:	84 c0                	test   %al,%al
 8049058:	0f 94 c0             	sete   %al
 804905b:	0f b6 c0             	movzbl %al,%eax
 804905e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049065:	00 
 8049066:	c7 44 24 0c 69 2a 05 	movl   $0x8052a69,0xc(%esp)
 804906d:	08 
 804906e:	c7 44 24 08 a5 00 00 	movl   $0xa5,0x8(%esp)
 8049075:	00 
 8049076:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804907d:	08 
 804907e:	89 04 24             	mov    %eax,(%esp)
 8049081:	e8 6a 91 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)newbrk - 1), NULL);
 8049086:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049089:	48                   	dec    %eax
 804908a:	0f b6 00             	movzbl (%eax),%eax
 804908d:	84 c0                	test   %al,%al
 804908f:	0f 94 c0             	sete   %al
 8049092:	0f b6 c0             	movzbl %al,%eax
 8049095:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804909c:	00 
 804909d:	c7 44 24 0c 81 2a 05 	movl   $0x8052a81,0xc(%esp)
 80490a4:	08 
 80490a5:	c7 44 24 08 a6 00 00 	movl   $0xa6,0x8(%esp)
 80490ac:	00 
 80490ad:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80490b4:	08 
 80490b5:	89 04 24             	mov    %eax,(%esp)
 80490b8:	e8 33 91 00 00       	call   80521f0 <_test_assert>
        *((char *)newbrk - 1) = 'a';
 80490bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80490c0:	48                   	dec    %eax
 80490c1:	c6 00 61             	movb   $0x61,(%eax)

        assert_fault(char foo = *(char *)newbrk, "");
 80490c4:	e8 69 41 00 00       	call   804d232 <fork>
 80490c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
 80490cc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 80490d0:	75 13                	jne    80490e5 <test_brk_bounds+0x255>
 80490d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80490d5:	0f b6 00             	movzbl (%eax),%eax
 80490d8:	88 45 df             	mov    %al,-0x21(%ebp)
 80490db:	b8 00 00 00 00       	mov    $0x0,%eax
 80490e0:	e9 b6 05 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 80490e5:	8d 45 bc             	lea    -0x44(%ebp),%eax
 80490e8:	89 44 24 08          	mov    %eax,0x8(%esp)
 80490ec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80490f3:	00 
 80490f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80490f7:	89 04 24             	mov    %eax,(%esp)
 80490fa:	e8 d1 42 00 00       	call   804d3d0 <waitpid>
 80490ff:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8049102:	83 f8 0e             	cmp    $0xe,%eax
 8049105:	0f 94 c0             	sete   %al
 8049108:	0f b6 c0             	movzbl %al,%eax
 804910b:	c7 44 24 10 e0 29 05 	movl   $0x80529e0,0x10(%esp)
 8049112:	08 
 8049113:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804911a:	08 
 804911b:	c7 44 24 08 a9 00 00 	movl   $0xa9,0x8(%esp)
 8049122:	00 
 8049123:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804912a:	08 
 804912b:	89 04 24             	mov    %eax,(%esp)
 804912e:	e8 bd 90 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(char *)newbrk = 'a', "");
 8049133:	e8 fa 40 00 00       	call   804d232 <fork>
 8049138:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804913b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804913f:	75 10                	jne    8049151 <test_brk_bounds+0x2c1>
 8049141:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049144:	c6 00 61             	movb   $0x61,(%eax)
 8049147:	b8 00 00 00 00       	mov    $0x0,%eax
 804914c:	e9 4a 05 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 8049151:	8d 45 b8             	lea    -0x48(%ebp),%eax
 8049154:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049158:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804915f:	00 
 8049160:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049163:	89 04 24             	mov    %eax,(%esp)
 8049166:	e8 65 42 00 00       	call   804d3d0 <waitpid>
 804916b:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804916e:	83 f8 0e             	cmp    $0xe,%eax
 8049171:	0f 94 c0             	sete   %al
 8049174:	0f b6 c0             	movzbl %al,%eax
 8049177:	c7 44 24 10 20 2a 05 	movl   $0x8052a20,0x10(%esp)
 804917e:	08 
 804917f:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8049186:	08 
 8049187:	c7 44 24 08 aa 00 00 	movl   $0xaa,0x8(%esp)
 804918e:	00 
 804918f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049196:	08 
 8049197:	89 04 24             	mov    %eax,(%esp)
 804919a:	e8 51 90 00 00       	call   80521f0 <_test_assert>

        /* Move brk up by 1 byte */
        test_assert(0 == brk((char *)newbrk + 1), NULL);
 804919f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80491a2:	40                   	inc    %eax
 80491a3:	89 04 24             	mov    %eax,(%esp)
 80491a6:	e8 1d 40 00 00       	call   804d1c8 <brk>
 80491ab:	85 c0                	test   %eax,%eax
 80491ad:	0f 94 c0             	sete   %al
 80491b0:	0f b6 c0             	movzbl %al,%eax
 80491b3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80491ba:	00 
 80491bb:	c7 44 24 0c 9f 2a 05 	movl   $0x8052a9f,0xc(%esp)
 80491c2:	08 
 80491c3:	c7 44 24 08 ad 00 00 	movl   $0xad,0x8(%esp)
 80491ca:	00 
 80491cb:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80491d2:	08 
 80491d3:	89 04 24             	mov    %eax,(%esp)
 80491d6:	e8 15 90 00 00       	call   80521f0 <_test_assert>

        /* Access the new memory */
        test_assert('\0' == *(char *)newbrk, NULL);
 80491db:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80491de:	0f b6 00             	movzbl (%eax),%eax
 80491e1:	84 c0                	test   %al,%al
 80491e3:	0f 94 c0             	sete   %al
 80491e6:	0f b6 c0             	movzbl %al,%eax
 80491e9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80491f0:	00 
 80491f1:	c7 44 24 0c bc 2a 05 	movl   $0x8052abc,0xc(%esp)
 80491f8:	08 
 80491f9:	c7 44 24 08 b0 00 00 	movl   $0xb0,0x8(%esp)
 8049200:	00 
 8049201:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049208:	08 
 8049209:	89 04 24             	mov    %eax,(%esp)
 804920c:	e8 df 8f 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)newbrk + PAGE_SIZE - 1), NULL);
 8049211:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049214:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049219:	0f b6 00             	movzbl (%eax),%eax
 804921c:	84 c0                	test   %al,%al
 804921e:	0f 94 c0             	sete   %al
 8049221:	0f b6 c0             	movzbl %al,%eax
 8049224:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804922b:	00 
 804922c:	c7 44 24 0c d4 2a 05 	movl   $0x8052ad4,0xc(%esp)
 8049233:	08 
 8049234:	c7 44 24 08 b1 00 00 	movl   $0xb1,0x8(%esp)
 804923b:	00 
 804923c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049243:	08 
 8049244:	89 04 24             	mov    %eax,(%esp)
 8049247:	e8 a4 8f 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*(char *)newbrk = 'b', "");
 804924c:	e8 e1 3f 00 00       	call   804d232 <fork>
 8049251:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049254:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8049258:	75 10                	jne    804926a <test_brk_bounds+0x3da>
 804925a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804925d:	c6 00 62             	movb   $0x62,(%eax)
 8049260:	b8 00 00 00 00       	mov    $0x0,%eax
 8049265:	e9 31 04 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 804926a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
 804926d:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049271:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049278:	00 
 8049279:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804927c:	89 04 24             	mov    %eax,(%esp)
 804927f:	e8 4c 41 00 00       	call   804d3d0 <waitpid>
 8049284:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049287:	85 c0                	test   %eax,%eax
 8049289:	0f 94 c0             	sete   %al
 804928c:	0f b6 c0             	movzbl %al,%eax
 804928f:	c7 44 24 10 00 2b 05 	movl   $0x8052b00,0x10(%esp)
 8049296:	08 
 8049297:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 804929e:	08 
 804929f:	c7 44 24 08 b2 00 00 	movl   $0xb2,0x8(%esp)
 80492a6:	00 
 80492a7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80492ae:	08 
 80492af:	89 04 24             	mov    %eax,(%esp)
 80492b2:	e8 39 8f 00 00       	call   80521f0 <_test_assert>

        /* Old memory didn't change */
        test_assert('a' == *((char *)newbrk - 1), NULL);
 80492b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80492ba:	48                   	dec    %eax
 80492bb:	0f b6 00             	movzbl (%eax),%eax
 80492be:	3c 61                	cmp    $0x61,%al
 80492c0:	0f 94 c0             	sete   %al
 80492c3:	0f b6 c0             	movzbl %al,%eax
 80492c6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80492cd:	00 
 80492ce:	c7 44 24 0c 30 2b 05 	movl   $0x8052b30,0xc(%esp)
 80492d5:	08 
 80492d6:	c7 44 24 08 b5 00 00 	movl   $0xb5,0x8(%esp)
 80492dd:	00 
 80492de:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80492e5:	08 
 80492e6:	89 04 24             	mov    %eax,(%esp)
 80492e9:	e8 02 8f 00 00       	call   80521f0 <_test_assert>

        /* Move it back */
        test_assert(0 == brk(newbrk), NULL);
 80492ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80492f1:	89 04 24             	mov    %eax,(%esp)
 80492f4:	e8 cf 3e 00 00       	call   804d1c8 <brk>
 80492f9:	85 c0                	test   %eax,%eax
 80492fb:	0f 94 c0             	sete   %al
 80492fe:	0f b6 c0             	movzbl %al,%eax
 8049301:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049308:	00 
 8049309:	c7 44 24 0c 58 2a 05 	movl   $0x8052a58,0xc(%esp)
 8049310:	08 
 8049311:	c7 44 24 08 b8 00 00 	movl   $0xb8,0x8(%esp)
 8049318:	00 
 8049319:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049320:	08 
 8049321:	89 04 24             	mov    %eax,(%esp)
 8049324:	e8 c7 8e 00 00       	call   80521f0 <_test_assert>

        assert_fault(char foo = *(char *)newbrk, "");
 8049329:	e8 04 3f 00 00       	call   804d232 <fork>
 804932e:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8049331:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8049335:	75 13                	jne    804934a <test_brk_bounds+0x4ba>
 8049337:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804933a:	0f b6 00             	movzbl (%eax),%eax
 804933d:	88 45 cf             	mov    %al,-0x31(%ebp)
 8049340:	b8 00 00 00 00       	mov    $0x0,%eax
 8049345:	e9 51 03 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 804934a:	8d 45 b0             	lea    -0x50(%ebp),%eax
 804934d:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049351:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049358:	00 
 8049359:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804935c:	89 04 24             	mov    %eax,(%esp)
 804935f:	e8 6c 40 00 00       	call   804d3d0 <waitpid>
 8049364:	8b 45 b0             	mov    -0x50(%ebp),%eax
 8049367:	83 f8 0e             	cmp    $0xe,%eax
 804936a:	0f 94 c0             	sete   %al
 804936d:	0f b6 c0             	movzbl %al,%eax
 8049370:	c7 44 24 10 e0 29 05 	movl   $0x80529e0,0x10(%esp)
 8049377:	08 
 8049378:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804937f:	08 
 8049380:	c7 44 24 08 ba 00 00 	movl   $0xba,0x8(%esp)
 8049387:	00 
 8049388:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804938f:	08 
 8049390:	89 04 24             	mov    %eax,(%esp)
 8049393:	e8 58 8e 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(char *)newbrk = 'a', "");
 8049398:	e8 95 3e 00 00       	call   804d232 <fork>
 804939d:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80493a0:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 80493a4:	75 10                	jne    80493b6 <test_brk_bounds+0x526>
 80493a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80493a9:	c6 00 61             	movb   $0x61,(%eax)
 80493ac:	b8 00 00 00 00       	mov    $0x0,%eax
 80493b1:	e9 e5 02 00 00       	jmp    804969b <test_brk_bounds+0x80b>
 80493b6:	8d 45 ac             	lea    -0x54(%ebp),%eax
 80493b9:	89 44 24 08          	mov    %eax,0x8(%esp)
 80493bd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80493c4:	00 
 80493c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80493c8:	89 04 24             	mov    %eax,(%esp)
 80493cb:	e8 00 40 00 00       	call   804d3d0 <waitpid>
 80493d0:	8b 45 ac             	mov    -0x54(%ebp),%eax
 80493d3:	83 f8 0e             	cmp    $0xe,%eax
 80493d6:	0f 94 c0             	sete   %al
 80493d9:	0f b6 c0             	movzbl %al,%eax
 80493dc:	c7 44 24 10 20 2a 05 	movl   $0x8052a20,0x10(%esp)
 80493e3:	08 
 80493e4:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 80493eb:	08 
 80493ec:	c7 44 24 08 bb 00 00 	movl   $0xbb,0x8(%esp)
 80493f3:	00 
 80493f4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80493fb:	08 
 80493fc:	89 04 24             	mov    %eax,(%esp)
 80493ff:	e8 ec 8d 00 00       	call   80521f0 <_test_assert>

        /* Move it up, make sure region wiped. Note that the actual wipe test is
         * 'evil' and is in eviltest. This just checks to make sure the brk region
         * is private mapped (modified in subprocesses) */
        test_assert(0 == brk((char *)newbrk + PAGE_SIZE), NULL);
 8049404:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049407:	05 00 10 00 00       	add    $0x1000,%eax
 804940c:	89 04 24             	mov    %eax,(%esp)
 804940f:	e8 b4 3d 00 00       	call   804d1c8 <brk>
 8049414:	85 c0                	test   %eax,%eax
 8049416:	0f 94 c0             	sete   %al
 8049419:	0f b6 c0             	movzbl %al,%eax
 804941c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049423:	00 
 8049424:	c7 44 24 0c 50 2b 05 	movl   $0x8052b50,0xc(%esp)
 804942b:	08 
 804942c:	c7 44 24 08 c0 00 00 	movl   $0xc0,0x8(%esp)
 8049433:	00 
 8049434:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804943b:	08 
 804943c:	89 04 24             	mov    %eax,(%esp)
 804943f:	e8 ac 8d 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(char *)newbrk, NULL);
 8049444:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049447:	0f b6 00             	movzbl (%eax),%eax
 804944a:	84 c0                	test   %al,%al
 804944c:	0f 94 c0             	sete   %al
 804944f:	0f b6 c0             	movzbl %al,%eax
 8049452:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049459:	00 
 804945a:	c7 44 24 0c bc 2a 05 	movl   $0x8052abc,0xc(%esp)
 8049461:	08 
 8049462:	c7 44 24 08 c1 00 00 	movl   $0xc1,0x8(%esp)
 8049469:	00 
 804946a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049471:	08 
 8049472:	89 04 24             	mov    %eax,(%esp)
 8049475:	e8 76 8d 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *((char *)newbrk + PAGE_SIZE - 1), NULL);
 804947a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804947d:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049482:	0f b6 00             	movzbl (%eax),%eax
 8049485:	84 c0                	test   %al,%al
 8049487:	0f 94 c0             	sete   %al
 804948a:	0f b6 c0             	movzbl %al,%eax
 804948d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049494:	00 
 8049495:	c7 44 24 0c d4 2a 05 	movl   $0x8052ad4,0xc(%esp)
 804949c:	08 
 804949d:	c7 44 24 08 c2 00 00 	movl   $0xc2,0x8(%esp)
 80494a4:	00 
 80494a5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80494ac:	08 
 80494ad:	89 04 24             	mov    %eax,(%esp)
 80494b0:	e8 3b 8d 00 00       	call   80521f0 <_test_assert>

        /* Move it down by 1 byte */
        test_assert(0 == brk((char *)newbrk - 1), NULL);
 80494b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80494b8:	48                   	dec    %eax
 80494b9:	89 04 24             	mov    %eax,(%esp)
 80494bc:	e8 07 3d 00 00       	call   804d1c8 <brk>
 80494c1:	85 c0                	test   %eax,%eax
 80494c3:	0f 94 c0             	sete   %al
 80494c6:	0f b6 c0             	movzbl %al,%eax
 80494c9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80494d0:	00 
 80494d1:	c7 44 24 0c 75 2b 05 	movl   $0x8052b75,0xc(%esp)
 80494d8:	08 
 80494d9:	c7 44 24 08 c5 00 00 	movl   $0xc5,0x8(%esp)
 80494e0:	00 
 80494e1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80494e8:	08 
 80494e9:	89 04 24             	mov    %eax,(%esp)
 80494ec:	e8 ff 8c 00 00       	call   80521f0 <_test_assert>

        /* Access still-accessible memory */
        test_assert('a' == *((char *)newbrk - 1), NULL);
 80494f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80494f4:	48                   	dec    %eax
 80494f5:	0f b6 00             	movzbl (%eax),%eax
 80494f8:	3c 61                	cmp    $0x61,%al
 80494fa:	0f 94 c0             	sete   %al
 80494fd:	0f b6 c0             	movzbl %al,%eax
 8049500:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049507:	00 
 8049508:	c7 44 24 0c 30 2b 05 	movl   $0x8052b30,0xc(%esp)
 804950f:	08 
 8049510:	c7 44 24 08 c8 00 00 	movl   $0xc8,0x8(%esp)
 8049517:	00 
 8049518:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804951f:	08 
 8049520:	89 04 24             	mov    %eax,(%esp)
 8049523:	e8 c8 8c 00 00       	call   80521f0 <_test_assert>
        *((char *)newbrk - 2) = 'z';
 8049528:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804952b:	83 e8 02             	sub    $0x2,%eax
 804952e:	c6 00 7a             	movb   $0x7a,(%eax)

        /* Move brk to multiple addrs on same page, make sure page remains */
        test_assert(0 == brk((char *)newbrk - 1000), NULL);
 8049531:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049534:	2d e8 03 00 00       	sub    $0x3e8,%eax
 8049539:	89 04 24             	mov    %eax,(%esp)
 804953c:	e8 87 3c 00 00       	call   804d1c8 <brk>
 8049541:	85 c0                	test   %eax,%eax
 8049543:	0f 94 c0             	sete   %al
 8049546:	0f b6 c0             	movzbl %al,%eax
 8049549:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049550:	00 
 8049551:	c7 44 24 0c 94 2b 05 	movl   $0x8052b94,0xc(%esp)
 8049558:	08 
 8049559:	c7 44 24 08 cc 00 00 	movl   $0xcc,0x8(%esp)
 8049560:	00 
 8049561:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049568:	08 
 8049569:	89 04 24             	mov    %eax,(%esp)
 804956c:	e8 7f 8c 00 00       	call   80521f0 <_test_assert>
        test_assert('z' == *((char *)newbrk - 2), NULL);
 8049571:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049574:	83 e8 02             	sub    $0x2,%eax
 8049577:	0f b6 00             	movzbl (%eax),%eax
 804957a:	3c 7a                	cmp    $0x7a,%al
 804957c:	0f 94 c0             	sete   %al
 804957f:	0f b6 c0             	movzbl %al,%eax
 8049582:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049589:	00 
 804958a:	c7 44 24 0c b4 2b 05 	movl   $0x8052bb4,0xc(%esp)
 8049591:	08 
 8049592:	c7 44 24 08 cd 00 00 	movl   $0xcd,0x8(%esp)
 8049599:	00 
 804959a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80495a1:	08 
 80495a2:	89 04 24             	mov    %eax,(%esp)
 80495a5:	e8 46 8c 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == brk((char *)oldbrk + 1), NULL);
 80495aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80495ad:	40                   	inc    %eax
 80495ae:	89 04 24             	mov    %eax,(%esp)
 80495b1:	e8 12 3c 00 00       	call   804d1c8 <brk>
 80495b6:	85 c0                	test   %eax,%eax
 80495b8:	0f 94 c0             	sete   %al
 80495bb:	0f b6 c0             	movzbl %al,%eax
 80495be:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80495c5:	00 
 80495c6:	c7 44 24 0c d1 2b 05 	movl   $0x8052bd1,0xc(%esp)
 80495cd:	08 
 80495ce:	c7 44 24 08 ce 00 00 	movl   $0xce,0x8(%esp)
 80495d5:	00 
 80495d6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80495dd:	08 
 80495de:	89 04 24             	mov    %eax,(%esp)
 80495e1:	e8 0a 8c 00 00       	call   80521f0 <_test_assert>
        test_assert('z' == *((char *)newbrk - 2), NULL);
 80495e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80495e9:	83 e8 02             	sub    $0x2,%eax
 80495ec:	0f b6 00             	movzbl (%eax),%eax
 80495ef:	3c 7a                	cmp    $0x7a,%al
 80495f1:	0f 94 c0             	sete   %al
 80495f4:	0f b6 c0             	movzbl %al,%eax
 80495f7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80495fe:	00 
 80495ff:	c7 44 24 0c b4 2b 05 	movl   $0x8052bb4,0xc(%esp)
 8049606:	08 
 8049607:	c7 44 24 08 cf 00 00 	movl   $0xcf,0x8(%esp)
 804960e:	00 
 804960f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049616:	08 
 8049617:	89 04 24             	mov    %eax,(%esp)
 804961a:	e8 d1 8b 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == brk((char *)oldbrk + 1000), NULL);
 804961f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049622:	05 e8 03 00 00       	add    $0x3e8,%eax
 8049627:	89 04 24             	mov    %eax,(%esp)
 804962a:	e8 99 3b 00 00       	call   804d1c8 <brk>
 804962f:	85 c0                	test   %eax,%eax
 8049631:	0f 94 c0             	sete   %al
 8049634:	0f b6 c0             	movzbl %al,%eax
 8049637:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804963e:	00 
 804963f:	c7 44 24 0c f0 2b 05 	movl   $0x8052bf0,0xc(%esp)
 8049646:	08 
 8049647:	c7 44 24 08 d0 00 00 	movl   $0xd0,0x8(%esp)
 804964e:	00 
 804964f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049656:	08 
 8049657:	89 04 24             	mov    %eax,(%esp)
 804965a:	e8 91 8b 00 00       	call   80521f0 <_test_assert>
        test_assert('a' == *((char *)newbrk - 1), NULL);
 804965f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049662:	48                   	dec    %eax
 8049663:	0f b6 00             	movzbl (%eax),%eax
 8049666:	3c 61                	cmp    $0x61,%al
 8049668:	0f 94 c0             	sete   %al
 804966b:	0f b6 c0             	movzbl %al,%eax
 804966e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049675:	00 
 8049676:	c7 44 24 0c 30 2b 05 	movl   $0x8052b30,0xc(%esp)
 804967d:	08 
 804967e:	c7 44 24 08 d1 00 00 	movl   $0xd1,0x8(%esp)
 8049685:	00 
 8049686:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804968d:	08 
 804968e:	89 04 24             	mov    %eax,(%esp)
 8049691:	e8 5a 8b 00 00       	call   80521f0 <_test_assert>

        return 0;
 8049696:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804969b:	c9                   	leave  
 804969c:	c3                   	ret    

0804969d <test_munmap>:

static int test_munmap(void)
{
 804969d:	55                   	push   %ebp
 804969e:	89 e5                	mov    %esp,%ebp
 80496a0:	81 ec b8 00 00 00    	sub    $0xb8,%esp
        char *addr, *middle;

        printf("Testing munmap()\n");
 80496a6:	c7 04 24 10 2c 05 08 	movl   $0x8052c10,(%esp)
 80496ad:	e8 ee 71 00 00       	call   80508a0 <printf>

        /* Map lots of areas. We're kind of lazy, so for now they're all anonymous */
        test_assert(MAP_FAILED != (addr = mmap(NULL, PAGE_SIZE * 20,
 80496b2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 80496b9:	00 
 80496ba:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 80496c1:	ff 
 80496c2:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 80496c9:	00 
 80496ca:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 80496d1:	00 
 80496d2:	c7 44 24 04 00 40 01 	movl   $0x14000,0x4(%esp)
 80496d9:	00 
 80496da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80496e1:	e8 fa 3d 00 00       	call   804d4e0 <mmap>
 80496e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80496e9:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 80496ed:	0f 95 c0             	setne  %al
 80496f0:	0f b6 c0             	movzbl %al,%eax
 80496f3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80496fa:	00 
 80496fb:	c7 44 24 0c 24 2c 05 	movl   $0x8052c24,0xc(%esp)
 8049702:	08 
 8049703:	c7 44 24 08 de 00 00 	movl   $0xde,0x8(%esp)
 804970a:	00 
 804970b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049712:	08 
 8049713:	89 04 24             	mov    %eax,(%esp)
 8049716:	e8 d5 8a 00 00       	call   80521f0 <_test_assert>
                                               PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0)), NULL);

        *(addr + PAGE_SIZE * 8) = '^';
 804971b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804971e:	05 00 80 00 00       	add    $0x8000,%eax
 8049723:	c6 00 5e             	movb   $0x5e,(%eax)
        *(addr + PAGE_SIZE * 12) = '$';
 8049726:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049729:	05 00 c0 00 00       	add    $0xc000,%eax
 804972e:	c6 00 24             	movb   $0x24,(%eax)

        /* Make sure TLB / page tables are cleared on unmap */
        assert_fault(*addr = 'a';
 8049731:	e8 fc 3a 00 00       	call   804d232 <fork>
 8049736:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049739:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804973d:	75 2c                	jne    804976b <test_munmap+0xce>
 804973f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049742:	c6 00 61             	movb   $0x61,(%eax)
 8049745:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804974c:	00 
 804974d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049750:	89 04 24             	mov    %eax,(%esp)
 8049753:	e8 eb 3d 00 00       	call   804d543 <munmap>
 8049758:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804975b:	0f b6 00             	movzbl (%eax),%eax
 804975e:	88 45 ef             	mov    %al,-0x11(%ebp)
 8049761:	b8 00 00 00 00       	mov    $0x0,%eax
 8049766:	e9 40 0a 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 804976b:	8d 45 98             	lea    -0x68(%ebp),%eax
 804976e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049772:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049779:	00 
 804977a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804977d:	89 04 24             	mov    %eax,(%esp)
 8049780:	e8 4b 3c 00 00       	call   804d3d0 <waitpid>
 8049785:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049788:	83 f8 0e             	cmp    $0xe,%eax
 804978b:	0f 94 c0             	sete   %al
 804978e:	0f b6 c0             	movzbl %al,%eax
 8049791:	c7 44 24 10 90 2c 05 	movl   $0x8052c90,0x10(%esp)
 8049798:	08 
 8049799:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 80497a0:	08 
 80497a1:	c7 44 24 08 e6 00 00 	movl   $0xe6,0x8(%esp)
 80497a8:	00 
 80497a9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80497b0:	08 
 80497b1:	89 04 24             	mov    %eax,(%esp)
 80497b4:	e8 37 8a 00 00       	call   80521f0 <_test_assert>
                     munmap(addr, PAGE_SIZE);
                     char foo = *addr; , "");
        assert_fault(*addr = 'a';
 80497b9:	e8 74 3a 00 00       	call   804d232 <fork>
 80497be:	89 45 e8             	mov    %eax,-0x18(%ebp)
 80497c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 80497c5:	75 2c                	jne    80497f3 <test_munmap+0x156>
 80497c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80497ca:	c6 00 61             	movb   $0x61,(%eax)
 80497cd:	c7 44 24 04 00 40 01 	movl   $0x14000,0x4(%esp)
 80497d4:	00 
 80497d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80497d8:	89 04 24             	mov    %eax,(%esp)
 80497db:	e8 63 3d 00 00       	call   804d543 <munmap>
 80497e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80497e3:	0f b6 00             	movzbl (%eax),%eax
 80497e6:	88 45 e7             	mov    %al,-0x19(%ebp)
 80497e9:	b8 00 00 00 00       	mov    $0x0,%eax
 80497ee:	e9 b8 09 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 80497f3:	8d 45 94             	lea    -0x6c(%ebp),%eax
 80497f6:	89 44 24 08          	mov    %eax,0x8(%esp)
 80497fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049801:	00 
 8049802:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049805:	89 04 24             	mov    %eax,(%esp)
 8049808:	e8 c3 3b 00 00       	call   804d3d0 <waitpid>
 804980d:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8049810:	83 f8 0e             	cmp    $0xe,%eax
 8049813:	0f 94 c0             	sete   %al
 8049816:	0f b6 c0             	movzbl %al,%eax
 8049819:	c7 44 24 10 ec 2c 05 	movl   $0x8052cec,0x10(%esp)
 8049820:	08 
 8049821:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8049828:	08 
 8049829:	c7 44 24 08 e9 00 00 	movl   $0xe9,0x8(%esp)
 8049830:	00 
 8049831:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049838:	08 
 8049839:	89 04 24             	mov    %eax,(%esp)
 804983c:	e8 af 89 00 00       	call   80521f0 <_test_assert>
                     munmap(addr, PAGE_SIZE * 20);
                     char foo = *addr; , "");
        assert_fault(*(addr + PAGE_SIZE * 10) = 'a';
 8049841:	e8 ec 39 00 00       	call   804d232 <fork>
 8049846:	89 45 e0             	mov    %eax,-0x20(%ebp)
 8049849:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804984d:	75 3a                	jne    8049889 <test_munmap+0x1ec>
 804984f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049852:	05 00 a0 00 00       	add    $0xa000,%eax
 8049857:	c6 00 61             	movb   $0x61,(%eax)
 804985a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804985d:	05 00 a0 00 00       	add    $0xa000,%eax
 8049862:	c7 44 24 04 00 50 00 	movl   $0x5000,0x4(%esp)
 8049869:	00 
 804986a:	89 04 24             	mov    %eax,(%esp)
 804986d:	e8 d1 3c 00 00       	call   804d543 <munmap>
 8049872:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049875:	0f b6 80 00 a0 00 00 	movzbl 0xa000(%eax),%eax
 804987c:	88 45 df             	mov    %al,-0x21(%ebp)
 804987f:	b8 00 00 00 00       	mov    $0x0,%eax
 8049884:	e9 22 09 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049889:	8d 45 90             	lea    -0x70(%ebp),%eax
 804988c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049890:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049897:	00 
 8049898:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804989b:	89 04 24             	mov    %eax,(%esp)
 804989e:	e8 2d 3b 00 00       	call   804d3d0 <waitpid>
 80498a3:	8b 45 90             	mov    -0x70(%ebp),%eax
 80498a6:	83 f8 0e             	cmp    $0xe,%eax
 80498a9:	0f 94 c0             	sete   %al
 80498ac:	0f b6 c0             	movzbl %al,%eax
 80498af:	c7 44 24 10 4c 2d 05 	movl   $0x8052d4c,0x10(%esp)
 80498b6:	08 
 80498b7:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 80498be:	08 
 80498bf:	c7 44 24 08 ec 00 00 	movl   $0xec,0x8(%esp)
 80498c6:	00 
 80498c7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80498ce:	08 
 80498cf:	89 04 24             	mov    %eax,(%esp)
 80498d2:	e8 19 89 00 00       	call   80521f0 <_test_assert>
                     munmap(addr + PAGE_SIZE * 10, PAGE_SIZE * 5);
                     char foo = *(addr + PAGE_SIZE * 10); , "");

        /* Overwrite middle of area (implicit unmap) */
        test_assert(MAP_FAILED != (middle = mmap(addr + PAGE_SIZE * 10, PAGE_SIZE,
 80498d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80498da:	05 00 a0 00 00       	add    $0xa000,%eax
 80498df:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 80498e6:	00 
 80498e7:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 80498ee:	ff 
 80498ef:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
 80498f6:	00 
 80498f7:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 80498fe:	00 
 80498ff:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 8049906:	00 
 8049907:	89 04 24             	mov    %eax,(%esp)
 804990a:	e8 d1 3b 00 00       	call   804d4e0 <mmap>
 804990f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049912:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
 8049916:	0f 95 c0             	setne  %al
 8049919:	0f b6 c0             	movzbl %al,%eax
 804991c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049923:	00 
 8049924:	c7 44 24 0c e4 2d 05 	movl   $0x8052de4,0xc(%esp)
 804992b:	08 
 804992c:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
 8049933:	00 
 8049934:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804993b:	08 
 804993c:	89 04 24             	mov    %eax,(%esp)
 804993f:	e8 ac 88 00 00       	call   80521f0 <_test_assert>
                                            PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0)), NULL);

        /* Make sure we overwrote the middle but not the whole thing */
        test_assert('\0' == *middle, NULL);
 8049944:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8049947:	0f b6 00             	movzbl (%eax),%eax
 804994a:	84 c0                	test   %al,%al
 804994c:	0f 94 c0             	sete   %al
 804994f:	0f b6 c0             	movzbl %al,%eax
 8049952:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049959:	00 
 804995a:	c7 44 24 0c 66 2e 05 	movl   $0x8052e66,0xc(%esp)
 8049961:	08 
 8049962:	c7 44 24 08 f3 00 00 	movl   $0xf3,0x8(%esp)
 8049969:	00 
 804996a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049971:	08 
 8049972:	89 04 24             	mov    %eax,(%esp)
 8049975:	e8 76 88 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*middle = 'a', "");
 804997a:	e8 b3 38 00 00       	call   804d232 <fork>
 804997f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 8049982:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8049986:	75 10                	jne    8049998 <test_munmap+0x2fb>
 8049988:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804998b:	c6 00 61             	movb   $0x61,(%eax)
 804998e:	b8 00 00 00 00       	mov    $0x0,%eax
 8049993:	e9 13 08 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049998:	8d 45 8c             	lea    -0x74(%ebp),%eax
 804999b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804999f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80499a6:	00 
 80499a7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80499aa:	89 04 24             	mov    %eax,(%esp)
 80499ad:	e8 1e 3a 00 00       	call   804d3d0 <waitpid>
 80499b2:	8b 45 8c             	mov    -0x74(%ebp),%eax
 80499b5:	85 c0                	test   %eax,%eax
 80499b7:	0f 94 c0             	sete   %al
 80499ba:	0f b6 c0             	movzbl %al,%eax
 80499bd:	c7 44 24 10 78 2e 05 	movl   $0x8052e78,0x10(%esp)
 80499c4:	08 
 80499c5:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 80499cc:	08 
 80499cd:	c7 44 24 08 f4 00 00 	movl   $0xf4,0x8(%esp)
 80499d4:	00 
 80499d5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 80499dc:	08 
 80499dd:	89 04 24             	mov    %eax,(%esp)
 80499e0:	e8 0b 88 00 00       	call   80521f0 <_test_assert>
        test_assert('a' == *middle, NULL);
 80499e5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80499e8:	0f b6 00             	movzbl (%eax),%eax
 80499eb:	3c 61                	cmp    $0x61,%al
 80499ed:	0f 94 c0             	sete   %al
 80499f0:	0f b6 c0             	movzbl %al,%eax
 80499f3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 80499fa:	00 
 80499fb:	c7 44 24 0c a0 2e 05 	movl   $0x8052ea0,0xc(%esp)
 8049a02:	08 
 8049a03:	c7 44 24 08 f5 00 00 	movl   $0xf5,0x8(%esp)
 8049a0a:	00 
 8049a0b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049a12:	08 
 8049a13:	89 04 24             	mov    %eax,(%esp)
 8049a16:	e8 d5 87 00 00       	call   80521f0 <_test_assert>

        test_assert('\0' == *(addr + PAGE_SIZE * 9), NULL);
 8049a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a1e:	05 00 90 00 00       	add    $0x9000,%eax
 8049a23:	0f b6 00             	movzbl (%eax),%eax
 8049a26:	84 c0                	test   %al,%al
 8049a28:	0f 94 c0             	sete   %al
 8049a2b:	0f b6 c0             	movzbl %al,%eax
 8049a2e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049a35:	00 
 8049a36:	c7 44 24 0c b0 2e 05 	movl   $0x8052eb0,0xc(%esp)
 8049a3d:	08 
 8049a3e:	c7 44 24 08 f7 00 00 	movl   $0xf7,0x8(%esp)
 8049a45:	00 
 8049a46:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049a4d:	08 
 8049a4e:	89 04 24             	mov    %eax,(%esp)
 8049a51:	e8 9a 87 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*(addr + PAGE_SIZE * 9) = 'a', "");
 8049a56:	e8 d7 37 00 00       	call   804d232 <fork>
 8049a5b:	89 45 d0             	mov    %eax,-0x30(%ebp)
 8049a5e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8049a62:	75 15                	jne    8049a79 <test_munmap+0x3dc>
 8049a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a67:	05 00 90 00 00       	add    $0x9000,%eax
 8049a6c:	c6 00 61             	movb   $0x61,(%eax)
 8049a6f:	b8 00 00 00 00       	mov    $0x0,%eax
 8049a74:	e9 32 07 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049a79:	8d 45 88             	lea    -0x78(%ebp),%eax
 8049a7c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049a80:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049a87:	00 
 8049a88:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8049a8b:	89 04 24             	mov    %eax,(%esp)
 8049a8e:	e8 3d 39 00 00       	call   804d3d0 <waitpid>
 8049a93:	8b 45 88             	mov    -0x78(%ebp),%eax
 8049a96:	85 c0                	test   %eax,%eax
 8049a98:	0f 94 c0             	sete   %al
 8049a9b:	0f b6 c0             	movzbl %al,%eax
 8049a9e:	c7 44 24 10 d0 2e 05 	movl   $0x8052ed0,0x10(%esp)
 8049aa5:	08 
 8049aa6:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 8049aad:	08 
 8049aae:	c7 44 24 08 f8 00 00 	movl   $0xf8,0x8(%esp)
 8049ab5:	00 
 8049ab6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049abd:	08 
 8049abe:	89 04 24             	mov    %eax,(%esp)
 8049ac1:	e8 2a 87 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr + PAGE_SIZE * 9), NULL);
 8049ac6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ac9:	05 00 90 00 00       	add    $0x9000,%eax
 8049ace:	0f b6 00             	movzbl (%eax),%eax
 8049ad1:	84 c0                	test   %al,%al
 8049ad3:	0f 94 c0             	sete   %al
 8049ad6:	0f b6 c0             	movzbl %al,%eax
 8049ad9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049ae0:	00 
 8049ae1:	c7 44 24 0c b0 2e 05 	movl   $0x8052eb0,0xc(%esp)
 8049ae8:	08 
 8049ae9:	c7 44 24 08 f9 00 00 	movl   $0xf9,0x8(%esp)
 8049af0:	00 
 8049af1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049af8:	08 
 8049af9:	89 04 24             	mov    %eax,(%esp)
 8049afc:	e8 ef 86 00 00       	call   80521f0 <_test_assert>

        test_assert('\0' == *(addr + PAGE_SIZE * 11), NULL);
 8049b01:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b04:	05 00 b0 00 00       	add    $0xb000,%eax
 8049b09:	0f b6 00             	movzbl (%eax),%eax
 8049b0c:	84 c0                	test   %al,%al
 8049b0e:	0f 94 c0             	sete   %al
 8049b11:	0f b6 c0             	movzbl %al,%eax
 8049b14:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049b1b:	00 
 8049b1c:	c7 44 24 0c 08 2f 05 	movl   $0x8052f08,0xc(%esp)
 8049b23:	08 
 8049b24:	c7 44 24 08 fb 00 00 	movl   $0xfb,0x8(%esp)
 8049b2b:	00 
 8049b2c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049b33:	08 
 8049b34:	89 04 24             	mov    %eax,(%esp)
 8049b37:	e8 b4 86 00 00       	call   80521f0 <_test_assert>
        assert_nofault(*(addr + PAGE_SIZE * 11) = 'a', "");
 8049b3c:	e8 f1 36 00 00       	call   804d232 <fork>
 8049b41:	89 45 cc             	mov    %eax,-0x34(%ebp)
 8049b44:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 8049b48:	75 15                	jne    8049b5f <test_munmap+0x4c2>
 8049b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b4d:	05 00 b0 00 00       	add    $0xb000,%eax
 8049b52:	c6 00 61             	movb   $0x61,(%eax)
 8049b55:	b8 00 00 00 00       	mov    $0x0,%eax
 8049b5a:	e9 4c 06 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049b5f:	8d 45 84             	lea    -0x7c(%ebp),%eax
 8049b62:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b66:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049b6d:	00 
 8049b6e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8049b71:	89 04 24             	mov    %eax,(%esp)
 8049b74:	e8 57 38 00 00       	call   804d3d0 <waitpid>
 8049b79:	8b 45 84             	mov    -0x7c(%ebp),%eax
 8049b7c:	85 c0                	test   %eax,%eax
 8049b7e:	0f 94 c0             	sete   %al
 8049b81:	0f b6 c0             	movzbl %al,%eax
 8049b84:	c7 44 24 10 2c 2f 05 	movl   $0x8052f2c,0x10(%esp)
 8049b8b:	08 
 8049b8c:	c7 44 24 0c 16 25 05 	movl   $0x8052516,0xc(%esp)
 8049b93:	08 
 8049b94:	c7 44 24 08 fc 00 00 	movl   $0xfc,0x8(%esp)
 8049b9b:	00 
 8049b9c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049ba3:	08 
 8049ba4:	89 04 24             	mov    %eax,(%esp)
 8049ba7:	e8 44 86 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr + PAGE_SIZE * 11), NULL);
 8049bac:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049baf:	05 00 b0 00 00       	add    $0xb000,%eax
 8049bb4:	0f b6 00             	movzbl (%eax),%eax
 8049bb7:	84 c0                	test   %al,%al
 8049bb9:	0f 94 c0             	sete   %al
 8049bbc:	0f b6 c0             	movzbl %al,%eax
 8049bbf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049bc6:	00 
 8049bc7:	c7 44 24 0c 08 2f 05 	movl   $0x8052f08,0xc(%esp)
 8049bce:	08 
 8049bcf:	c7 44 24 08 fd 00 00 	movl   $0xfd,0x8(%esp)
 8049bd6:	00 
 8049bd7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049bde:	08 
 8049bdf:	89 04 24             	mov    %eax,(%esp)
 8049be2:	e8 09 86 00 00       	call   80521f0 <_test_assert>

        test_assert('\0' == *addr, NULL);
 8049be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049bea:	0f b6 00             	movzbl (%eax),%eax
 8049bed:	84 c0                	test   %al,%al
 8049bef:	0f 94 c0             	sete   %al
 8049bf2:	0f b6 c0             	movzbl %al,%eax
 8049bf5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049bfc:	00 
 8049bfd:	c7 44 24 0c 65 2f 05 	movl   $0x8052f65,0xc(%esp)
 8049c04:	08 
 8049c05:	c7 44 24 08 ff 00 00 	movl   $0xff,0x8(%esp)
 8049c0c:	00 
 8049c0d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049c14:	08 
 8049c15:	89 04 24             	mov    %eax,(%esp)
 8049c18:	e8 d3 85 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr + PAGE_SIZE * 20 - 1), NULL);
 8049c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c20:	05 ff 3f 01 00       	add    $0x13fff,%eax
 8049c25:	0f b6 00             	movzbl (%eax),%eax
 8049c28:	84 c0                	test   %al,%al
 8049c2a:	0f 94 c0             	sete   %al
 8049c2d:	0f b6 c0             	movzbl %al,%eax
 8049c30:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049c37:	00 
 8049c38:	c7 44 24 0c 74 2f 05 	movl   $0x8052f74,0xc(%esp)
 8049c3f:	08 
 8049c40:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
 8049c47:	00 
 8049c48:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049c4f:	08 
 8049c50:	89 04 24             	mov    %eax,(%esp)
 8049c53:	e8 98 85 00 00       	call   80521f0 <_test_assert>

        /* Make sure the offsets are appropriate */
        test_assert('^' == *(addr + PAGE_SIZE * 8), NULL);
 8049c58:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c5b:	05 00 80 00 00       	add    $0x8000,%eax
 8049c60:	0f b6 00             	movzbl (%eax),%eax
 8049c63:	3c 5e                	cmp    $0x5e,%al
 8049c65:	0f 94 c0             	sete   %al
 8049c68:	0f b6 c0             	movzbl %al,%eax
 8049c6b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049c72:	00 
 8049c73:	c7 44 24 0c 9c 2f 05 	movl   $0x8052f9c,0xc(%esp)
 8049c7a:	08 
 8049c7b:	c7 44 24 08 03 01 00 	movl   $0x103,0x8(%esp)
 8049c82:	00 
 8049c83:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049c8a:	08 
 8049c8b:	89 04 24             	mov    %eax,(%esp)
 8049c8e:	e8 5d 85 00 00       	call   80521f0 <_test_assert>
        test_assert('$' == *(addr + PAGE_SIZE * 12), NULL);
 8049c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c96:	05 00 c0 00 00       	add    $0xc000,%eax
 8049c9b:	0f b6 00             	movzbl (%eax),%eax
 8049c9e:	3c 24                	cmp    $0x24,%al
 8049ca0:	0f 94 c0             	sete   %al
 8049ca3:	0f b6 c0             	movzbl %al,%eax
 8049ca6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049cad:	00 
 8049cae:	c7 44 24 0c bc 2f 05 	movl   $0x8052fbc,0xc(%esp)
 8049cb5:	08 
 8049cb6:	c7 44 24 08 04 01 00 	movl   $0x104,0x8(%esp)
 8049cbd:	00 
 8049cbe:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049cc5:	08 
 8049cc6:	89 04 24             	mov    %eax,(%esp)
 8049cc9:	e8 22 85 00 00       	call   80521f0 <_test_assert>

        /* Unmap a weird overlapping region */
        test_assert(0 == munmap(addr + PAGE_SIZE * 9, PAGE_SIZE * 3), NULL);
 8049cce:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049cd1:	05 00 90 00 00       	add    $0x9000,%eax
 8049cd6:	c7 44 24 04 00 30 00 	movl   $0x3000,0x4(%esp)
 8049cdd:	00 
 8049cde:	89 04 24             	mov    %eax,(%esp)
 8049ce1:	e8 5d 38 00 00       	call   804d543 <munmap>
 8049ce6:	85 c0                	test   %eax,%eax
 8049ce8:	0f 94 c0             	sete   %al
 8049ceb:	0f b6 c0             	movzbl %al,%eax
 8049cee:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049cf5:	00 
 8049cf6:	c7 44 24 0c dc 2f 05 	movl   $0x8052fdc,0xc(%esp)
 8049cfd:	08 
 8049cfe:	c7 44 24 08 07 01 00 	movl   $0x107,0x8(%esp)
 8049d05:	00 
 8049d06:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049d0d:	08 
 8049d0e:	89 04 24             	mov    %eax,(%esp)
 8049d11:	e8 da 84 00 00       	call   80521f0 <_test_assert>

        /* Make sure everything's gone */
        assert_fault(char foo = *(addr + PAGE_SIZE * 9), "");
 8049d16:	e8 17 35 00 00       	call   804d232 <fork>
 8049d1b:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8049d1e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 8049d22:	75 17                	jne    8049d3b <test_munmap+0x69e>
 8049d24:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d27:	0f b6 80 00 90 00 00 	movzbl 0x9000(%eax),%eax
 8049d2e:	88 45 c7             	mov    %al,-0x39(%ebp)
 8049d31:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d36:	e9 70 04 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049d3b:	8d 45 80             	lea    -0x80(%ebp),%eax
 8049d3e:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049d42:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049d49:	00 
 8049d4a:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8049d4d:	89 04 24             	mov    %eax,(%esp)
 8049d50:	e8 7b 36 00 00       	call   804d3d0 <waitpid>
 8049d55:	8b 45 80             	mov    -0x80(%ebp),%eax
 8049d58:	83 f8 0e             	cmp    $0xe,%eax
 8049d5b:	0f 94 c0             	sete   %al
 8049d5e:	0f b6 c0             	movzbl %al,%eax
 8049d61:	c7 44 24 10 10 30 05 	movl   $0x8053010,0x10(%esp)
 8049d68:	08 
 8049d69:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8049d70:	08 
 8049d71:	c7 44 24 08 0a 01 00 	movl   $0x10a,0x8(%esp)
 8049d78:	00 
 8049d79:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049d80:	08 
 8049d81:	89 04 24             	mov    %eax,(%esp)
 8049d84:	e8 67 84 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE * 10), "");
 8049d89:	e8 a4 34 00 00       	call   804d232 <fork>
 8049d8e:	89 45 c0             	mov    %eax,-0x40(%ebp)
 8049d91:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 8049d95:	75 17                	jne    8049dae <test_munmap+0x711>
 8049d97:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d9a:	0f b6 80 00 a0 00 00 	movzbl 0xa000(%eax),%eax
 8049da1:	88 45 bf             	mov    %al,-0x41(%ebp)
 8049da4:	b8 00 00 00 00       	mov    $0x0,%eax
 8049da9:	e9 fd 03 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049dae:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 8049db4:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049db8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049dbf:	00 
 8049dc0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049dc3:	89 04 24             	mov    %eax,(%esp)
 8049dc6:	e8 05 36 00 00       	call   804d3d0 <waitpid>
 8049dcb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 8049dd1:	83 f8 0e             	cmp    $0xe,%eax
 8049dd4:	0f 94 c0             	sete   %al
 8049dd7:	0f b6 c0             	movzbl %al,%eax
 8049dda:	c7 44 24 10 58 30 05 	movl   $0x8053058,0x10(%esp)
 8049de1:	08 
 8049de2:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8049de9:	08 
 8049dea:	c7 44 24 08 0b 01 00 	movl   $0x10b,0x8(%esp)
 8049df1:	00 
 8049df2:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049df9:	08 
 8049dfa:	89 04 24             	mov    %eax,(%esp)
 8049dfd:	e8 ee 83 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE * 12 - 1), "");
 8049e02:	e8 2b 34 00 00       	call   804d232 <fork>
 8049e07:	89 45 b8             	mov    %eax,-0x48(%ebp)
 8049e0a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
 8049e0e:	75 17                	jne    8049e27 <test_munmap+0x78a>
 8049e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049e13:	0f b6 80 ff bf 00 00 	movzbl 0xbfff(%eax),%eax
 8049e1a:	88 45 b7             	mov    %al,-0x49(%ebp)
 8049e1d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e22:	e9 84 03 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 8049e27:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
 8049e2d:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049e31:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049e38:	00 
 8049e39:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8049e3c:	89 04 24             	mov    %eax,(%esp)
 8049e3f:	e8 8c 35 00 00       	call   804d3d0 <waitpid>
 8049e44:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 8049e4a:	83 f8 0e             	cmp    $0xe,%eax
 8049e4d:	0f 94 c0             	sete   %al
 8049e50:	0f b6 c0             	movzbl %al,%eax
 8049e53:	c7 44 24 10 a0 30 05 	movl   $0x80530a0,0x10(%esp)
 8049e5a:	08 
 8049e5b:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 8049e62:	08 
 8049e63:	c7 44 24 08 0c 01 00 	movl   $0x10c,0x8(%esp)
 8049e6a:	00 
 8049e6b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049e72:	08 
 8049e73:	89 04 24             	mov    %eax,(%esp)
 8049e76:	e8 75 83 00 00       	call   80521f0 <_test_assert>

        /* Make sure offsets are still correct */
        test_assert('^' == *(addr + PAGE_SIZE * 8), NULL);
 8049e7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049e7e:	05 00 80 00 00       	add    $0x8000,%eax
 8049e83:	0f b6 00             	movzbl (%eax),%eax
 8049e86:	3c 5e                	cmp    $0x5e,%al
 8049e88:	0f 94 c0             	sete   %al
 8049e8b:	0f b6 c0             	movzbl %al,%eax
 8049e8e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049e95:	00 
 8049e96:	c7 44 24 0c 9c 2f 05 	movl   $0x8052f9c,0xc(%esp)
 8049e9d:	08 
 8049e9e:	c7 44 24 08 0f 01 00 	movl   $0x10f,0x8(%esp)
 8049ea5:	00 
 8049ea6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049ead:	08 
 8049eae:	89 04 24             	mov    %eax,(%esp)
 8049eb1:	e8 3a 83 00 00       	call   80521f0 <_test_assert>
        test_assert('$' == *(addr + PAGE_SIZE * 12), NULL);
 8049eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049eb9:	05 00 c0 00 00       	add    $0xc000,%eax
 8049ebe:	0f b6 00             	movzbl (%eax),%eax
 8049ec1:	3c 24                	cmp    $0x24,%al
 8049ec3:	0f 94 c0             	sete   %al
 8049ec6:	0f b6 c0             	movzbl %al,%eax
 8049ec9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049ed0:	00 
 8049ed1:	c7 44 24 0c bc 2f 05 	movl   $0x8052fbc,0xc(%esp)
 8049ed8:	08 
 8049ed9:	c7 44 24 08 10 01 00 	movl   $0x110,0x8(%esp)
 8049ee0:	00 
 8049ee1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049ee8:	08 
 8049ee9:	89 04 24             	mov    %eax,(%esp)
 8049eec:	e8 ff 82 00 00       	call   80521f0 <_test_assert>

        /* Unmap nothing at all */
        test_assert(0 == munmap(addr + PAGE_SIZE * 10, PAGE_SIZE), NULL);
 8049ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ef4:	05 00 a0 00 00       	add    $0xa000,%eax
 8049ef9:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 8049f00:	00 
 8049f01:	89 04 24             	mov    %eax,(%esp)
 8049f04:	e8 3a 36 00 00       	call   804d543 <munmap>
 8049f09:	85 c0                	test   %eax,%eax
 8049f0b:	0f 94 c0             	sete   %al
 8049f0e:	0f b6 c0             	movzbl %al,%eax
 8049f11:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049f18:	00 
 8049f19:	c7 44 24 0c ec 30 05 	movl   $0x80530ec,0xc(%esp)
 8049f20:	08 
 8049f21:	c7 44 24 08 13 01 00 	movl   $0x113,0x8(%esp)
 8049f28:	00 
 8049f29:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049f30:	08 
 8049f31:	89 04 24             	mov    %eax,(%esp)
 8049f34:	e8 b7 82 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == munmap(addr + PAGE_SIZE * 9, PAGE_SIZE * 3), NULL);
 8049f39:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049f3c:	05 00 90 00 00       	add    $0x9000,%eax
 8049f41:	c7 44 24 04 00 30 00 	movl   $0x3000,0x4(%esp)
 8049f48:	00 
 8049f49:	89 04 24             	mov    %eax,(%esp)
 8049f4c:	e8 f2 35 00 00       	call   804d543 <munmap>
 8049f51:	85 c0                	test   %eax,%eax
 8049f53:	0f 94 c0             	sete   %al
 8049f56:	0f b6 c0             	movzbl %al,%eax
 8049f59:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049f60:	00 
 8049f61:	c7 44 24 0c dc 2f 05 	movl   $0x8052fdc,0xc(%esp)
 8049f68:	08 
 8049f69:	c7 44 24 08 14 01 00 	movl   $0x114,0x8(%esp)
 8049f70:	00 
 8049f71:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049f78:	08 
 8049f79:	89 04 24             	mov    %eax,(%esp)
 8049f7c:	e8 6f 82 00 00       	call   80521f0 <_test_assert>

        /* Unmap almost the whole (remaining) thing */
        test_assert(0 == munmap(addr + PAGE_SIZE, PAGE_SIZE * 19), NULL);
 8049f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049f84:	05 00 10 00 00       	add    $0x1000,%eax
 8049f89:	c7 44 24 04 00 30 01 	movl   $0x13000,0x4(%esp)
 8049f90:	00 
 8049f91:	89 04 24             	mov    %eax,(%esp)
 8049f94:	e8 aa 35 00 00       	call   804d543 <munmap>
 8049f99:	85 c0                	test   %eax,%eax
 8049f9b:	0f 94 c0             	sete   %al
 8049f9e:	0f b6 c0             	movzbl %al,%eax
 8049fa1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049fa8:	00 
 8049fa9:	c7 44 24 0c 1c 31 05 	movl   $0x805311c,0xc(%esp)
 8049fb0:	08 
 8049fb1:	c7 44 24 08 17 01 00 	movl   $0x117,0x8(%esp)
 8049fb8:	00 
 8049fb9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049fc0:	08 
 8049fc1:	89 04 24             	mov    %eax,(%esp)
 8049fc4:	e8 27 82 00 00       	call   80521f0 <_test_assert>

        /* Make sure the beginning's still there */
        test_assert('\0' == *addr, NULL);
 8049fc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049fcc:	0f b6 00             	movzbl (%eax),%eax
 8049fcf:	84 c0                	test   %al,%al
 8049fd1:	0f 94 c0             	sete   %al
 8049fd4:	0f b6 c0             	movzbl %al,%eax
 8049fd7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8049fde:	00 
 8049fdf:	c7 44 24 0c 65 2f 05 	movl   $0x8052f65,0xc(%esp)
 8049fe6:	08 
 8049fe7:	c7 44 24 08 1a 01 00 	movl   $0x11a,0x8(%esp)
 8049fee:	00 
 8049fef:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 8049ff6:	08 
 8049ff7:	89 04 24             	mov    %eax,(%esp)
 8049ffa:	e8 f1 81 00 00       	call   80521f0 <_test_assert>

        /* Finish up, make sure everything's gone */
        test_assert(0 == munmap(addr, PAGE_SIZE * 15), NULL);
 8049fff:	c7 44 24 04 00 f0 00 	movl   $0xf000,0x4(%esp)
 804a006:	00 
 804a007:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a00a:	89 04 24             	mov    %eax,(%esp)
 804a00d:	e8 31 35 00 00       	call   804d543 <munmap>
 804a012:	85 c0                	test   %eax,%eax
 804a014:	0f 94 c0             	sete   %al
 804a017:	0f b6 c0             	movzbl %al,%eax
 804a01a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a021:	00 
 804a022:	c7 44 24 0c 4c 31 05 	movl   $0x805314c,0xc(%esp)
 804a029:	08 
 804a02a:	c7 44 24 08 1d 01 00 	movl   $0x11d,0x8(%esp)
 804a031:	00 
 804a032:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a039:	08 
 804a03a:	89 04 24             	mov    %eax,(%esp)
 804a03d:	e8 ae 81 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE), "");
 804a042:	e8 eb 31 00 00       	call   804d232 <fork>
 804a047:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804a04a:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 804a04e:	75 17                	jne    804a067 <test_munmap+0x9ca>
 804a050:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a053:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804a05a:	88 45 af             	mov    %al,-0x51(%ebp)
 804a05d:	b8 00 00 00 00       	mov    $0x0,%eax
 804a062:	e9 44 01 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 804a067:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
 804a06d:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a071:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a078:	00 
 804a079:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804a07c:	89 04 24             	mov    %eax,(%esp)
 804a07f:	e8 4c 33 00 00       	call   804d3d0 <waitpid>
 804a084:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804a08a:	83 f8 0e             	cmp    $0xe,%eax
 804a08d:	0f 94 c0             	sete   %al
 804a090:	0f b6 c0             	movzbl %al,%eax
 804a093:	c7 44 24 10 70 31 05 	movl   $0x8053170,0x10(%esp)
 804a09a:	08 
 804a09b:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a0a2:	08 
 804a0a3:	c7 44 24 08 1e 01 00 	movl   $0x11e,0x8(%esp)
 804a0aa:	00 
 804a0ab:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a0b2:	08 
 804a0b3:	89 04 24             	mov    %eax,(%esp)
 804a0b6:	e8 35 81 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr), "");
 804a0bb:	e8 72 31 00 00       	call   804d232 <fork>
 804a0c0:	89 45 a8             	mov    %eax,-0x58(%ebp)
 804a0c3:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
 804a0c7:	75 13                	jne    804a0dc <test_munmap+0xa3f>
 804a0c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a0cc:	0f b6 00             	movzbl (%eax),%eax
 804a0cf:	88 45 a7             	mov    %al,-0x59(%ebp)
 804a0d2:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0d7:	e9 cf 00 00 00       	jmp    804a1ab <test_munmap+0xb0e>
 804a0dc:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 804a0e2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a0e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a0ed:	00 
 804a0ee:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804a0f1:	89 04 24             	mov    %eax,(%esp)
 804a0f4:	e8 d7 32 00 00       	call   804d3d0 <waitpid>
 804a0f9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804a0ff:	83 f8 0e             	cmp    $0xe,%eax
 804a102:	0f 94 c0             	sete   %al
 804a105:	0f b6 c0             	movzbl %al,%eax
 804a108:	c7 44 24 10 b4 31 05 	movl   $0x80531b4,0x10(%esp)
 804a10f:	08 
 804a110:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a117:	08 
 804a118:	c7 44 24 08 1f 01 00 	movl   $0x11f,0x8(%esp)
 804a11f:	00 
 804a120:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a127:	08 
 804a128:	89 04 24             	mov    %eax,(%esp)
 804a12b:	e8 c0 80 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE * 20 - 1), "");
 804a130:	e8 fd 30 00 00       	call   804d232 <fork>
 804a135:	89 45 a0             	mov    %eax,-0x60(%ebp)
 804a138:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804a13c:	75 14                	jne    804a152 <test_munmap+0xab5>
 804a13e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a141:	0f b6 80 ff 3f 01 00 	movzbl 0x13fff(%eax),%eax
 804a148:	88 45 9f             	mov    %al,-0x61(%ebp)
 804a14b:	b8 00 00 00 00       	mov    $0x0,%eax
 804a150:	eb 59                	jmp    804a1ab <test_munmap+0xb0e>
 804a152:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
 804a158:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a15c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a163:	00 
 804a164:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804a167:	89 04 24             	mov    %eax,(%esp)
 804a16a:	e8 61 32 00 00       	call   804d3d0 <waitpid>
 804a16f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804a175:	83 f8 0e             	cmp    $0xe,%eax
 804a178:	0f 94 c0             	sete   %al
 804a17b:	0f b6 c0             	movzbl %al,%eax
 804a17e:	c7 44 24 10 ec 31 05 	movl   $0x80531ec,0x10(%esp)
 804a185:	08 
 804a186:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a18d:	08 
 804a18e:	c7 44 24 08 20 01 00 	movl   $0x120,0x8(%esp)
 804a195:	00 
 804a196:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a19d:	08 
 804a19e:	89 04 24             	mov    %eax,(%esp)
 804a1a1:	e8 4a 80 00 00       	call   80521f0 <_test_assert>

        return 0;
 804a1a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804a1ab:	c9                   	leave  
 804a1ac:	c3                   	ret    

0804a1ad <test_start_brk>:

static int test_start_brk(void)
{
 804a1ad:	55                   	push   %ebp
 804a1ae:	89 e5                	mov    %esp,%ebp
 804a1b0:	81 ec 98 00 00 00    	sub    $0x98,%esp
        printf("Testing using brk() near starting brk\n");
 804a1b6:	c7 04 24 38 32 05 08 	movl   $0x8053238,(%esp)
 804a1bd:	e8 de 66 00 00       	call   80508a0 <printf>
        test_assert(bss_end == sbrk(0), "brk should not have moved yet");
 804a1c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a1c9:	e8 31 2f 00 00       	call   804d0ff <sbrk>
 804a1ce:	3d d0 7b 05 08       	cmp    $0x8057bd0,%eax
 804a1d3:	0f 94 c0             	sete   %al
 804a1d6:	0f b6 c0             	movzbl %al,%eax
 804a1d9:	c7 44 24 10 5f 32 05 	movl   $0x805325f,0x10(%esp)
 804a1e0:	08 
 804a1e1:	c7 44 24 0c 7d 32 05 	movl   $0x805327d,0xc(%esp)
 804a1e8:	08 
 804a1e9:	c7 44 24 08 28 01 00 	movl   $0x128,0x8(%esp)
 804a1f0:	00 
 804a1f1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a1f8:	08 
 804a1f9:	89 04 24             	mov    %eax,(%esp)
 804a1fc:	e8 ef 7f 00 00       	call   80521f0 <_test_assert>
        test_assert(!PAGE_ALIGNED(bss_end) && !PAGE_ALIGNED((char *)bss_end + 1), "starting brk is page aligned; test is too easy...");
 804a201:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804a206:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a20b:	85 c0                	test   %eax,%eax
 804a20d:	74 15                	je     804a224 <test_start_brk+0x77>
 804a20f:	b8 d1 7b 05 08       	mov    $0x8057bd1,%eax
 804a214:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a219:	85 c0                	test   %eax,%eax
 804a21b:	74 07                	je     804a224 <test_start_brk+0x77>
 804a21d:	b8 01 00 00 00       	mov    $0x1,%eax
 804a222:	eb 05                	jmp    804a229 <test_start_brk+0x7c>
 804a224:	b8 00 00 00 00       	mov    $0x0,%eax
 804a229:	c7 44 24 10 90 32 05 	movl   $0x8053290,0x10(%esp)
 804a230:	08 
 804a231:	c7 44 24 0c c4 32 05 	movl   $0x80532c4,0xc(%esp)
 804a238:	08 
 804a239:	c7 44 24 08 29 01 00 	movl   $0x129,0x8(%esp)
 804a240:	00 
 804a241:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a248:	08 
 804a249:	89 04 24             	mov    %eax,(%esp)
 804a24c:	e8 9f 7f 00 00       	call   80521f0 <_test_assert>

        /* Up to next page boundary should already be accessible (end of bss) */
        char *oldbrk = PAGE_ALIGN_UP(bss_end);
 804a251:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804a256:	48                   	dec    %eax
 804a257:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a25c:	05 00 10 00 00       	add    $0x1000,%eax
 804a261:	89 45 f4             	mov    %eax,-0xc(%ebp)
        test_assert('\0' == *(oldbrk - 1), NULL);
 804a264:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a267:	48                   	dec    %eax
 804a268:	0f b6 00             	movzbl (%eax),%eax
 804a26b:	84 c0                	test   %al,%al
 804a26d:	0f 94 c0             	sete   %al
 804a270:	0f b6 c0             	movzbl %al,%eax
 804a273:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a27a:	00 
 804a27b:	c7 44 24 0c 01 33 05 	movl   $0x8053301,0xc(%esp)
 804a282:	08 
 804a283:	c7 44 24 08 2d 01 00 	movl   $0x12d,0x8(%esp)
 804a28a:	00 
 804a28b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a292:	08 
 804a293:	89 04 24             	mov    %eax,(%esp)
 804a296:	e8 55 7f 00 00       	call   80521f0 <_test_assert>
        *(oldbrk - 1) = 'a';
 804a29b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a29e:	48                   	dec    %eax
 804a29f:	c6 00 61             	movb   $0x61,(%eax)
        assert_fault(char foo = *oldbrk, "");
 804a2a2:	e8 8b 2f 00 00       	call   804d232 <fork>
 804a2a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804a2aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a2ae:	75 13                	jne    804a2c3 <test_start_brk+0x116>
 804a2b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a2b3:	0f b6 00             	movzbl (%eax),%eax
 804a2b6:	88 45 ef             	mov    %al,-0x11(%ebp)
 804a2b9:	b8 00 00 00 00       	mov    $0x0,%eax
 804a2be:	e9 f5 06 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a2c3:	8d 45 ac             	lea    -0x54(%ebp),%eax
 804a2c6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a2ca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a2d1:	00 
 804a2d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a2d5:	89 04 24             	mov    %eax,(%esp)
 804a2d8:	e8 f3 30 00 00       	call   804d3d0 <waitpid>
 804a2dd:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804a2e0:	83 f8 0e             	cmp    $0xe,%eax
 804a2e3:	0f 94 c0             	sete   %al
 804a2e6:	0f b6 c0             	movzbl %al,%eax
 804a2e9:	c7 44 24 10 18 33 05 	movl   $0x8053318,0x10(%esp)
 804a2f0:	08 
 804a2f1:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a2f8:	08 
 804a2f9:	c7 44 24 08 2f 01 00 	movl   $0x12f,0x8(%esp)
 804a300:	00 
 804a301:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a308:	08 
 804a309:	89 04 24             	mov    %eax,(%esp)
 804a30c:	e8 df 7e 00 00       	call   80521f0 <_test_assert>

        /* Move brk up to next page boundary */
        test_assert(0 == brk(oldbrk), NULL);
 804a311:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a314:	89 04 24             	mov    %eax,(%esp)
 804a317:	e8 ac 2e 00 00       	call   804d1c8 <brk>
 804a31c:	85 c0                	test   %eax,%eax
 804a31e:	0f 94 c0             	sete   %al
 804a321:	0f b6 c0             	movzbl %al,%eax
 804a324:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a32b:	00 
 804a32c:	c7 44 24 0c cf 29 05 	movl   $0x80529cf,0xc(%esp)
 804a333:	08 
 804a334:	c7 44 24 08 32 01 00 	movl   $0x132,0x8(%esp)
 804a33b:	00 
 804a33c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a343:	08 
 804a344:	89 04 24             	mov    %eax,(%esp)
 804a347:	e8 a4 7e 00 00       	call   80521f0 <_test_assert>
        test_assert('a' == *(oldbrk - 1), NULL);
 804a34c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a34f:	48                   	dec    %eax
 804a350:	0f b6 00             	movzbl (%eax),%eax
 804a353:	3c 61                	cmp    $0x61,%al
 804a355:	0f 94 c0             	sete   %al
 804a358:	0f b6 c0             	movzbl %al,%eax
 804a35b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a362:	00 
 804a363:	c7 44 24 0c 4d 33 05 	movl   $0x805334d,0xc(%esp)
 804a36a:	08 
 804a36b:	c7 44 24 08 33 01 00 	movl   $0x133,0x8(%esp)
 804a372:	00 
 804a373:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a37a:	08 
 804a37b:	89 04 24             	mov    %eax,(%esp)
 804a37e:	e8 6d 7e 00 00       	call   80521f0 <_test_assert>
        *(oldbrk - 1) = 'b';
 804a383:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a386:	48                   	dec    %eax
 804a387:	c6 00 62             	movb   $0x62,(%eax)
        assert_fault(char foo = *oldbrk, "");
 804a38a:	e8 a3 2e 00 00       	call   804d232 <fork>
 804a38f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a392:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a396:	75 13                	jne    804a3ab <test_start_brk+0x1fe>
 804a398:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a39b:	0f b6 00             	movzbl (%eax),%eax
 804a39e:	88 45 e7             	mov    %al,-0x19(%ebp)
 804a3a1:	b8 00 00 00 00       	mov    $0x0,%eax
 804a3a6:	e9 0d 06 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a3ab:	8d 45 a8             	lea    -0x58(%ebp),%eax
 804a3ae:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a3b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a3b9:	00 
 804a3ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a3bd:	89 04 24             	mov    %eax,(%esp)
 804a3c0:	e8 0b 30 00 00       	call   804d3d0 <waitpid>
 804a3c5:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804a3c8:	83 f8 0e             	cmp    $0xe,%eax
 804a3cb:	0f 94 c0             	sete   %al
 804a3ce:	0f b6 c0             	movzbl %al,%eax
 804a3d1:	c7 44 24 10 18 33 05 	movl   $0x8053318,0x10(%esp)
 804a3d8:	08 
 804a3d9:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a3e0:	08 
 804a3e1:	c7 44 24 08 35 01 00 	movl   $0x135,0x8(%esp)
 804a3e8:	00 
 804a3e9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a3f0:	08 
 804a3f1:	89 04 24             	mov    %eax,(%esp)
 804a3f4:	e8 f7 7d 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(oldbrk + PAGE_SIZE), "");
 804a3f9:	e8 34 2e 00 00       	call   804d232 <fork>
 804a3fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804a401:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804a405:	75 17                	jne    804a41e <test_start_brk+0x271>
 804a407:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a40a:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804a411:	88 45 df             	mov    %al,-0x21(%ebp)
 804a414:	b8 00 00 00 00       	mov    $0x0,%eax
 804a419:	e9 9a 05 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a41e:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 804a421:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a425:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a42c:	00 
 804a42d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a430:	89 04 24             	mov    %eax,(%esp)
 804a433:	e8 98 2f 00 00       	call   804d3d0 <waitpid>
 804a438:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a43b:	83 f8 0e             	cmp    $0xe,%eax
 804a43e:	0f 94 c0             	sete   %al
 804a441:	0f b6 c0             	movzbl %al,%eax
 804a444:	c7 44 24 10 64 33 05 	movl   $0x8053364,0x10(%esp)
 804a44b:	08 
 804a44c:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a453:	08 
 804a454:	c7 44 24 08 36 01 00 	movl   $0x136,0x8(%esp)
 804a45b:	00 
 804a45c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a463:	08 
 804a464:	89 04 24             	mov    %eax,(%esp)
 804a467:	e8 84 7d 00 00       	call   80521f0 <_test_assert>

        /* Try to move before starting brk */
        test_assert(0 != brk((char *)bss_end - 1), NULL);
 804a46c:	b8 cf 7b 05 08       	mov    $0x8057bcf,%eax
 804a471:	89 04 24             	mov    %eax,(%esp)
 804a474:	e8 4f 2d 00 00       	call   804d1c8 <brk>
 804a479:	85 c0                	test   %eax,%eax
 804a47b:	0f 95 c0             	setne  %al
 804a47e:	0f b6 c0             	movzbl %al,%eax
 804a481:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a488:	00 
 804a489:	c7 44 24 0c a7 33 05 	movl   $0x80533a7,0xc(%esp)
 804a490:	08 
 804a491:	c7 44 24 08 39 01 00 	movl   $0x139,0x8(%esp)
 804a498:	00 
 804a499:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a4a0:	08 
 804a4a1:	89 04 24             	mov    %eax,(%esp)
 804a4a4:	e8 47 7d 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(PAGE_ALIGN_DOWN(bss_end)), NULL);
 804a4a9:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804a4ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a4b3:	89 04 24             	mov    %eax,(%esp)
 804a4b6:	e8 0d 2d 00 00       	call   804d1c8 <brk>
 804a4bb:	85 c0                	test   %eax,%eax
 804a4bd:	0f 95 c0             	setne  %al
 804a4c0:	0f b6 c0             	movzbl %al,%eax
 804a4c3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a4ca:	00 
 804a4cb:	c7 44 24 0c c8 33 05 	movl   $0x80533c8,0xc(%esp)
 804a4d2:	08 
 804a4d3:	c7 44 24 08 3a 01 00 	movl   $0x13a,0x8(%esp)
 804a4da:	00 
 804a4db:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a4e2:	08 
 804a4e3:	89 04 24             	mov    %eax,(%esp)
 804a4e6:	e8 05 7d 00 00       	call   80521f0 <_test_assert>

        /* Move it up another page */
        char *newbrk = oldbrk + PAGE_SIZE;
 804a4eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a4ee:	05 00 10 00 00       	add    $0x1000,%eax
 804a4f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
        test_assert(0 == brk(newbrk), NULL);
 804a4f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a4f9:	89 04 24             	mov    %eax,(%esp)
 804a4fc:	e8 c7 2c 00 00       	call   804d1c8 <brk>
 804a501:	85 c0                	test   %eax,%eax
 804a503:	0f 94 c0             	sete   %al
 804a506:	0f b6 c0             	movzbl %al,%eax
 804a509:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a510:	00 
 804a511:	c7 44 24 0c 58 2a 05 	movl   $0x8052a58,0xc(%esp)
 804a518:	08 
 804a519:	c7 44 24 08 3e 01 00 	movl   $0x13e,0x8(%esp)
 804a520:	00 
 804a521:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a528:	08 
 804a529:	89 04 24             	mov    %eax,(%esp)
 804a52c:	e8 bf 7c 00 00       	call   80521f0 <_test_assert>

        /* Make sure everything accessible (read/write) */
        test_assert('b' == *(oldbrk - 1), NULL);
 804a531:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a534:	48                   	dec    %eax
 804a535:	0f b6 00             	movzbl (%eax),%eax
 804a538:	3c 62                	cmp    $0x62,%al
 804a53a:	0f 94 c0             	sete   %al
 804a53d:	0f b6 c0             	movzbl %al,%eax
 804a540:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a547:	00 
 804a548:	c7 44 24 0c eb 33 05 	movl   $0x80533eb,0xc(%esp)
 804a54f:	08 
 804a550:	c7 44 24 08 41 01 00 	movl   $0x141,0x8(%esp)
 804a557:	00 
 804a558:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a55f:	08 
 804a560:	89 04 24             	mov    %eax,(%esp)
 804a563:	e8 88 7c 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *oldbrk, NULL);
 804a568:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a56b:	0f b6 00             	movzbl (%eax),%eax
 804a56e:	84 c0                	test   %al,%al
 804a570:	0f 94 c0             	sete   %al
 804a573:	0f b6 c0             	movzbl %al,%eax
 804a576:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a57d:	00 
 804a57e:	c7 44 24 0c 00 34 05 	movl   $0x8053400,0xc(%esp)
 804a585:	08 
 804a586:	c7 44 24 08 42 01 00 	movl   $0x142,0x8(%esp)
 804a58d:	00 
 804a58e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a595:	08 
 804a596:	89 04 24             	mov    %eax,(%esp)
 804a599:	e8 52 7c 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(newbrk - 1), NULL);
 804a59e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a5a1:	48                   	dec    %eax
 804a5a2:	0f b6 00             	movzbl (%eax),%eax
 804a5a5:	84 c0                	test   %al,%al
 804a5a7:	0f 94 c0             	sete   %al
 804a5aa:	0f b6 c0             	movzbl %al,%eax
 804a5ad:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a5b4:	00 
 804a5b5:	c7 44 24 0c 10 34 05 	movl   $0x8053410,0xc(%esp)
 804a5bc:	08 
 804a5bd:	c7 44 24 08 43 01 00 	movl   $0x143,0x8(%esp)
 804a5c4:	00 
 804a5c5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a5cc:	08 
 804a5cd:	89 04 24             	mov    %eax,(%esp)
 804a5d0:	e8 1b 7c 00 00       	call   80521f0 <_test_assert>
        *oldbrk = 'z';
 804a5d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a5d8:	c6 00 7a             	movb   $0x7a,(%eax)
        *(newbrk - 1) = 'y';
 804a5db:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a5de:	48                   	dec    %eax
 804a5df:	c6 00 79             	movb   $0x79,(%eax)
        assert_fault(char foo = *newbrk, "");
 804a5e2:	e8 4b 2c 00 00       	call   804d232 <fork>
 804a5e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804a5ea:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a5ee:	75 13                	jne    804a603 <test_start_brk+0x456>
 804a5f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a5f3:	0f b6 00             	movzbl (%eax),%eax
 804a5f6:	88 45 d3             	mov    %al,-0x2d(%ebp)
 804a5f9:	b8 00 00 00 00       	mov    $0x0,%eax
 804a5fe:	e9 b5 03 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a603:	8d 45 a0             	lea    -0x60(%ebp),%eax
 804a606:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a60a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a611:	00 
 804a612:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a615:	89 04 24             	mov    %eax,(%esp)
 804a618:	e8 b3 2d 00 00       	call   804d3d0 <waitpid>
 804a61d:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804a620:	83 f8 0e             	cmp    $0xe,%eax
 804a623:	0f 94 c0             	sete   %al
 804a626:	0f b6 c0             	movzbl %al,%eax
 804a629:	c7 44 24 10 28 34 05 	movl   $0x8053428,0x10(%esp)
 804a630:	08 
 804a631:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a638:	08 
 804a639:	c7 44 24 08 46 01 00 	movl   $0x146,0x8(%esp)
 804a640:	00 
 804a641:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a648:	08 
 804a649:	89 04 24             	mov    %eax,(%esp)
 804a64c:	e8 9f 7b 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(newbrk + PAGE_SIZE), "");
 804a651:	e8 dc 2b 00 00       	call   804d232 <fork>
 804a656:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804a659:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804a65d:	75 17                	jne    804a676 <test_start_brk+0x4c9>
 804a65f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a662:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804a669:	88 45 cb             	mov    %al,-0x35(%ebp)
 804a66c:	b8 00 00 00 00       	mov    $0x0,%eax
 804a671:	e9 42 03 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a676:	8d 45 9c             	lea    -0x64(%ebp),%eax
 804a679:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a67d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a684:	00 
 804a685:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a688:	89 04 24             	mov    %eax,(%esp)
 804a68b:	e8 40 2d 00 00       	call   804d3d0 <waitpid>
 804a690:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804a693:	83 f8 0e             	cmp    $0xe,%eax
 804a696:	0f 94 c0             	sete   %al
 804a699:	0f b6 c0             	movzbl %al,%eax
 804a69c:	c7 44 24 10 60 34 05 	movl   $0x8053460,0x10(%esp)
 804a6a3:	08 
 804a6a4:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a6ab:	08 
 804a6ac:	c7 44 24 08 47 01 00 	movl   $0x147,0x8(%esp)
 804a6b3:	00 
 804a6b4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a6bb:	08 
 804a6bc:	89 04 24             	mov    %eax,(%esp)
 804a6bf:	e8 2c 7b 00 00       	call   80521f0 <_test_assert>

        /* Try to move before starting brk */
        test_assert(0 != brk((char *)bss_end - 1), NULL);
 804a6c4:	b8 cf 7b 05 08       	mov    $0x8057bcf,%eax
 804a6c9:	89 04 24             	mov    %eax,(%esp)
 804a6cc:	e8 f7 2a 00 00       	call   804d1c8 <brk>
 804a6d1:	85 c0                	test   %eax,%eax
 804a6d3:	0f 95 c0             	setne  %al
 804a6d6:	0f b6 c0             	movzbl %al,%eax
 804a6d9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a6e0:	00 
 804a6e1:	c7 44 24 0c a7 33 05 	movl   $0x80533a7,0xc(%esp)
 804a6e8:	08 
 804a6e9:	c7 44 24 08 4a 01 00 	movl   $0x14a,0x8(%esp)
 804a6f0:	00 
 804a6f1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a6f8:	08 
 804a6f9:	89 04 24             	mov    %eax,(%esp)
 804a6fc:	e8 ef 7a 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(PAGE_ALIGN_DOWN(bss_end)), NULL);
 804a701:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804a706:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a70b:	89 04 24             	mov    %eax,(%esp)
 804a70e:	e8 b5 2a 00 00       	call   804d1c8 <brk>
 804a713:	85 c0                	test   %eax,%eax
 804a715:	0f 95 c0             	setne  %al
 804a718:	0f b6 c0             	movzbl %al,%eax
 804a71b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a722:	00 
 804a723:	c7 44 24 0c c8 33 05 	movl   $0x80533c8,0xc(%esp)
 804a72a:	08 
 804a72b:	c7 44 24 08 4b 01 00 	movl   $0x14b,0x8(%esp)
 804a732:	00 
 804a733:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a73a:	08 
 804a73b:	89 04 24             	mov    %eax,(%esp)
 804a73e:	e8 ad 7a 00 00       	call   80521f0 <_test_assert>

        /* Move back to starting brk */
        test_assert(0 == brk((char *)bss_end + 1), NULL);
 804a743:	b8 d1 7b 05 08       	mov    $0x8057bd1,%eax
 804a748:	89 04 24             	mov    %eax,(%esp)
 804a74b:	e8 78 2a 00 00       	call   804d1c8 <brk>
 804a750:	85 c0                	test   %eax,%eax
 804a752:	0f 94 c0             	sete   %al
 804a755:	0f b6 c0             	movzbl %al,%eax
 804a758:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a75f:	00 
 804a760:	c7 44 24 0c a3 34 05 	movl   $0x80534a3,0xc(%esp)
 804a767:	08 
 804a768:	c7 44 24 08 4e 01 00 	movl   $0x14e,0x8(%esp)
 804a76f:	00 
 804a770:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a777:	08 
 804a778:	89 04 24             	mov    %eax,(%esp)
 804a77b:	e8 70 7a 00 00       	call   80521f0 <_test_assert>
        /* Make sure region is gone */
        test_assert('b' == *(oldbrk - 1), NULL);
 804a780:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a783:	48                   	dec    %eax
 804a784:	0f b6 00             	movzbl (%eax),%eax
 804a787:	3c 62                	cmp    $0x62,%al
 804a789:	0f 94 c0             	sete   %al
 804a78c:	0f b6 c0             	movzbl %al,%eax
 804a78f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a796:	00 
 804a797:	c7 44 24 0c eb 33 05 	movl   $0x80533eb,0xc(%esp)
 804a79e:	08 
 804a79f:	c7 44 24 08 50 01 00 	movl   $0x150,0x8(%esp)
 804a7a6:	00 
 804a7a7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a7ae:	08 
 804a7af:	89 04 24             	mov    %eax,(%esp)
 804a7b2:	e8 39 7a 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *oldbrk, "");
 804a7b7:	e8 76 2a 00 00       	call   804d232 <fork>
 804a7bc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804a7bf:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 804a7c3:	75 13                	jne    804a7d8 <test_start_brk+0x62b>
 804a7c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a7c8:	0f b6 00             	movzbl (%eax),%eax
 804a7cb:	88 45 c3             	mov    %al,-0x3d(%ebp)
 804a7ce:	b8 00 00 00 00       	mov    $0x0,%eax
 804a7d3:	e9 e0 01 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a7d8:	8d 45 98             	lea    -0x68(%ebp),%eax
 804a7db:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a7df:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a7e6:	00 
 804a7e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a7ea:	89 04 24             	mov    %eax,(%esp)
 804a7ed:	e8 de 2b 00 00       	call   804d3d0 <waitpid>
 804a7f2:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a7f5:	83 f8 0e             	cmp    $0xe,%eax
 804a7f8:	0f 94 c0             	sete   %al
 804a7fb:	0f b6 c0             	movzbl %al,%eax
 804a7fe:	c7 44 24 10 18 33 05 	movl   $0x8053318,0x10(%esp)
 804a805:	08 
 804a806:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a80d:	08 
 804a80e:	c7 44 24 08 51 01 00 	movl   $0x151,0x8(%esp)
 804a815:	00 
 804a816:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a81d:	08 
 804a81e:	89 04 24             	mov    %eax,(%esp)
 804a821:	e8 ca 79 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *newbrk, "");
 804a826:	e8 07 2a 00 00       	call   804d232 <fork>
 804a82b:	89 45 bc             	mov    %eax,-0x44(%ebp)
 804a82e:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
 804a832:	75 13                	jne    804a847 <test_start_brk+0x69a>
 804a834:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a837:	0f b6 00             	movzbl (%eax),%eax
 804a83a:	88 45 bb             	mov    %al,-0x45(%ebp)
 804a83d:	b8 00 00 00 00       	mov    $0x0,%eax
 804a842:	e9 71 01 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a847:	8d 45 94             	lea    -0x6c(%ebp),%eax
 804a84a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a84e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a855:	00 
 804a856:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804a859:	89 04 24             	mov    %eax,(%esp)
 804a85c:	e8 6f 2b 00 00       	call   804d3d0 <waitpid>
 804a861:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804a864:	83 f8 0e             	cmp    $0xe,%eax
 804a867:	0f 94 c0             	sete   %al
 804a86a:	0f b6 c0             	movzbl %al,%eax
 804a86d:	c7 44 24 10 28 34 05 	movl   $0x8053428,0x10(%esp)
 804a874:	08 
 804a875:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a87c:	08 
 804a87d:	c7 44 24 08 52 01 00 	movl   $0x152,0x8(%esp)
 804a884:	00 
 804a885:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a88c:	08 
 804a88d:	89 04 24             	mov    %eax,(%esp)
 804a890:	e8 5b 79 00 00       	call   80521f0 <_test_assert>

        /* Move it up, make sure we have new clean region */
        test_assert(0 == brk(oldbrk + 1), NULL);
 804a895:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a898:	40                   	inc    %eax
 804a899:	89 04 24             	mov    %eax,(%esp)
 804a89c:	e8 27 29 00 00       	call   804d1c8 <brk>
 804a8a1:	85 c0                	test   %eax,%eax
 804a8a3:	0f 94 c0             	sete   %al
 804a8a6:	0f b6 c0             	movzbl %al,%eax
 804a8a9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a8b0:	00 
 804a8b1:	c7 44 24 0c c1 34 05 	movl   $0x80534c1,0xc(%esp)
 804a8b8:	08 
 804a8b9:	c7 44 24 08 55 01 00 	movl   $0x155,0x8(%esp)
 804a8c0:	00 
 804a8c1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a8c8:	08 
 804a8c9:	89 04 24             	mov    %eax,(%esp)
 804a8cc:	e8 1f 79 00 00       	call   80521f0 <_test_assert>
        /* This behavior is undefined, this represents how it
         * works on Linux but these need not pass
         */
        /*test_assert('\0' == *oldbrk, NULL);
        test_assert('\0' == *(newbrk - 1), NULL);*/
        assert_fault(char foo = *newbrk, "");
 804a8d1:	e8 5c 29 00 00       	call   804d232 <fork>
 804a8d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 804a8d9:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
 804a8dd:	75 13                	jne    804a8f2 <test_start_brk+0x745>
 804a8df:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a8e2:	0f b6 00             	movzbl (%eax),%eax
 804a8e5:	88 45 b3             	mov    %al,-0x4d(%ebp)
 804a8e8:	b8 00 00 00 00       	mov    $0x0,%eax
 804a8ed:	e9 c6 00 00 00       	jmp    804a9b8 <test_start_brk+0x80b>
 804a8f2:	8d 45 90             	lea    -0x70(%ebp),%eax
 804a8f5:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a8f9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a900:	00 
 804a901:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804a904:	89 04 24             	mov    %eax,(%esp)
 804a907:	e8 c4 2a 00 00       	call   804d3d0 <waitpid>
 804a90c:	8b 45 90             	mov    -0x70(%ebp),%eax
 804a90f:	83 f8 0e             	cmp    $0xe,%eax
 804a912:	0f 94 c0             	sete   %al
 804a915:	0f b6 c0             	movzbl %al,%eax
 804a918:	c7 44 24 10 28 34 05 	movl   $0x8053428,0x10(%esp)
 804a91f:	08 
 804a920:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804a927:	08 
 804a928:	c7 44 24 08 5b 01 00 	movl   $0x15b,0x8(%esp)
 804a92f:	00 
 804a930:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a937:	08 
 804a938:	89 04 24             	mov    %eax,(%esp)
 804a93b:	e8 b0 78 00 00       	call   80521f0 <_test_assert>

        /* Move back and finish */
        test_assert(0 == brk(bss_end), NULL);
 804a940:	c7 04 24 d0 7b 05 08 	movl   $0x8057bd0,(%esp)
 804a947:	e8 7c 28 00 00       	call   804d1c8 <brk>
 804a94c:	85 c0                	test   %eax,%eax
 804a94e:	0f 94 c0             	sete   %al
 804a951:	0f b6 c0             	movzbl %al,%eax
 804a954:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a95b:	00 
 804a95c:	c7 44 24 0c d6 34 05 	movl   $0x80534d6,0xc(%esp)
 804a963:	08 
 804a964:	c7 44 24 08 5e 01 00 	movl   $0x15e,0x8(%esp)
 804a96b:	00 
 804a96c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a973:	08 
 804a974:	89 04 24             	mov    %eax,(%esp)
 804a977:	e8 74 78 00 00       	call   80521f0 <_test_assert>
        test_assert('b' == *(oldbrk - 1), NULL);
 804a97c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a97f:	48                   	dec    %eax
 804a980:	0f b6 00             	movzbl (%eax),%eax
 804a983:	3c 62                	cmp    $0x62,%al
 804a985:	0f 94 c0             	sete   %al
 804a988:	0f b6 c0             	movzbl %al,%eax
 804a98b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804a992:	00 
 804a993:	c7 44 24 0c eb 33 05 	movl   $0x80533eb,0xc(%esp)
 804a99a:	08 
 804a99b:	c7 44 24 08 5f 01 00 	movl   $0x15f,0x8(%esp)
 804a9a2:	00 
 804a9a3:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804a9aa:	08 
 804a9ab:	89 04 24             	mov    %eax,(%esp)
 804a9ae:	e8 3d 78 00 00       	call   80521f0 <_test_assert>

        return 0;
 804a9b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804a9b8:	c9                   	leave  
 804a9b9:	c3                   	ret    

0804a9ba <test_brk_mmap>:

static int test_brk_mmap(void)
{
 804a9ba:	55                   	push   %ebp
 804a9bb:	89 e5                	mov    %esp,%ebp
 804a9bd:	83 ec 48             	sub    $0x48,%esp
        printf("Testing interactions of brk() and mmap()\n");
 804a9c0:	c7 04 24 e8 34 05 08 	movl   $0x80534e8,(%esp)
 804a9c7:	e8 d4 5e 00 00       	call   80508a0 <printf>
        test_assert(bss_end == sbrk(0), "brk should not have moved yet");
 804a9cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a9d3:	e8 27 27 00 00       	call   804d0ff <sbrk>
 804a9d8:	3d d0 7b 05 08       	cmp    $0x8057bd0,%eax
 804a9dd:	0f 94 c0             	sete   %al
 804a9e0:	0f b6 c0             	movzbl %al,%eax
 804a9e3:	c7 44 24 10 5f 32 05 	movl   $0x805325f,0x10(%esp)
 804a9ea:	08 
 804a9eb:	c7 44 24 0c 7d 32 05 	movl   $0x805327d,0xc(%esp)
 804a9f2:	08 
 804a9f3:	c7 44 24 08 67 01 00 	movl   $0x167,0x8(%esp)
 804a9fa:	00 
 804a9fb:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804aa02:	08 
 804aa03:	89 04 24             	mov    %eax,(%esp)
 804aa06:	e8 e5 77 00 00       	call   80521f0 <_test_assert>
        char *oldbrk = PAGE_ALIGN_UP(bss_end);
 804aa0b:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804aa10:	48                   	dec    %eax
 804aa11:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804aa16:	05 00 10 00 00       	add    $0x1000,%eax
 804aa1b:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Put a mapping in the way */
        test_assert(MAP_FAILED != mmap(oldbrk, PAGE_SIZE * 2,
 804aa1e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804aa25:	00 
 804aa26:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804aa2d:	ff 
 804aa2e:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
 804aa35:	00 
 804aa36:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804aa3d:	00 
 804aa3e:	c7 44 24 04 00 20 00 	movl   $0x2000,0x4(%esp)
 804aa45:	00 
 804aa46:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aa49:	89 04 24             	mov    %eax,(%esp)
 804aa4c:	e8 8f 2a 00 00       	call   804d4e0 <mmap>
 804aa51:	83 f8 ff             	cmp    $0xffffffff,%eax
 804aa54:	0f 95 c0             	setne  %al
 804aa57:	0f b6 c0             	movzbl %al,%eax
 804aa5a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804aa61:	00 
 804aa62:	c7 44 24 0c 14 35 05 	movl   $0x8053514,0xc(%esp)
 804aa69:	08 
 804aa6a:	c7 44 24 08 6c 01 00 	movl   $0x16c,0x8(%esp)
 804aa71:	00 
 804aa72:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804aa79:	08 
 804aa7a:	89 04 24             	mov    %eax,(%esp)
 804aa7d:	e8 6e 77 00 00       	call   80521f0 <_test_assert>
                                       PROT_READ, MAP_ANON | MAP_FIXED | MAP_PRIVATE, -1, 0), NULL);
        /* Mapping is there */
        test_assert('\0' == *oldbrk, NULL);
 804aa82:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aa85:	0f b6 00             	movzbl (%eax),%eax
 804aa88:	84 c0                	test   %al,%al
 804aa8a:	0f 94 c0             	sete   %al
 804aa8d:	0f b6 c0             	movzbl %al,%eax
 804aa90:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804aa97:	00 
 804aa98:	c7 44 24 0c 00 34 05 	movl   $0x8053400,0xc(%esp)
 804aa9f:	08 
 804aaa0:	c7 44 24 08 6e 01 00 	movl   $0x16e,0x8(%esp)
 804aaa7:	00 
 804aaa8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804aaaf:	08 
 804aab0:	89 04 24             	mov    %eax,(%esp)
 804aab3:	e8 38 77 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(oldbrk - 1), NULL);
 804aab8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aabb:	48                   	dec    %eax
 804aabc:	0f b6 00             	movzbl (%eax),%eax
 804aabf:	84 c0                	test   %al,%al
 804aac1:	0f 94 c0             	sete   %al
 804aac4:	0f b6 c0             	movzbl %al,%eax
 804aac7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804aace:	00 
 804aacf:	c7 44 24 0c 01 33 05 	movl   $0x8053301,0xc(%esp)
 804aad6:	08 
 804aad7:	c7 44 24 08 6f 01 00 	movl   $0x16f,0x8(%esp)
 804aade:	00 
 804aadf:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804aae6:	08 
 804aae7:	89 04 24             	mov    %eax,(%esp)
 804aaea:	e8 01 77 00 00       	call   80521f0 <_test_assert>

        /* Moving brk without getting area is fine */
        test_assert(0 == brk(oldbrk), NULL);
 804aaef:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aaf2:	89 04 24             	mov    %eax,(%esp)
 804aaf5:	e8 ce 26 00 00       	call   804d1c8 <brk>
 804aafa:	85 c0                	test   %eax,%eax
 804aafc:	0f 94 c0             	sete   %al
 804aaff:	0f b6 c0             	movzbl %al,%eax
 804ab02:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ab09:	00 
 804ab0a:	c7 44 24 0c cf 29 05 	movl   $0x80529cf,0xc(%esp)
 804ab11:	08 
 804ab12:	c7 44 24 08 72 01 00 	movl   $0x172,0x8(%esp)
 804ab19:	00 
 804ab1a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ab21:	08 
 804ab22:	89 04 24             	mov    %eax,(%esp)
 804ab25:	e8 c6 76 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *oldbrk, NULL);
 804ab2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ab2d:	0f b6 00             	movzbl (%eax),%eax
 804ab30:	84 c0                	test   %al,%al
 804ab32:	0f 94 c0             	sete   %al
 804ab35:	0f b6 c0             	movzbl %al,%eax
 804ab38:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ab3f:	00 
 804ab40:	c7 44 24 0c 00 34 05 	movl   $0x8053400,0xc(%esp)
 804ab47:	08 
 804ab48:	c7 44 24 08 73 01 00 	movl   $0x173,0x8(%esp)
 804ab4f:	00 
 804ab50:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ab57:	08 
 804ab58:	89 04 24             	mov    %eax,(%esp)
 804ab5b:	e8 90 76 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(oldbrk - 1), NULL);
 804ab60:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ab63:	48                   	dec    %eax
 804ab64:	0f b6 00             	movzbl (%eax),%eax
 804ab67:	84 c0                	test   %al,%al
 804ab69:	0f 94 c0             	sete   %al
 804ab6c:	0f b6 c0             	movzbl %al,%eax
 804ab6f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ab76:	00 
 804ab77:	c7 44 24 0c 01 33 05 	movl   $0x8053301,0xc(%esp)
 804ab7e:	08 
 804ab7f:	c7 44 24 08 74 01 00 	movl   $0x174,0x8(%esp)
 804ab86:	00 
 804ab87:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ab8e:	08 
 804ab8f:	89 04 24             	mov    %eax,(%esp)
 804ab92:	e8 59 76 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == brk((char *)bss_end + 1), NULL);
 804ab97:	b8 d1 7b 05 08       	mov    $0x8057bd1,%eax
 804ab9c:	89 04 24             	mov    %eax,(%esp)
 804ab9f:	e8 24 26 00 00       	call   804d1c8 <brk>
 804aba4:	85 c0                	test   %eax,%eax
 804aba6:	0f 94 c0             	sete   %al
 804aba9:	0f b6 c0             	movzbl %al,%eax
 804abac:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804abb3:	00 
 804abb4:	c7 44 24 0c a3 34 05 	movl   $0x80534a3,0xc(%esp)
 804abbb:	08 
 804abbc:	c7 44 24 08 75 01 00 	movl   $0x175,0x8(%esp)
 804abc3:	00 
 804abc4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804abcb:	08 
 804abcc:	89 04 24             	mov    %eax,(%esp)
 804abcf:	e8 1c 76 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *oldbrk, NULL);
 804abd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804abd7:	0f b6 00             	movzbl (%eax),%eax
 804abda:	84 c0                	test   %al,%al
 804abdc:	0f 94 c0             	sete   %al
 804abdf:	0f b6 c0             	movzbl %al,%eax
 804abe2:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804abe9:	00 
 804abea:	c7 44 24 0c 00 34 05 	movl   $0x8053400,0xc(%esp)
 804abf1:	08 
 804abf2:	c7 44 24 08 76 01 00 	movl   $0x176,0x8(%esp)
 804abf9:	00 
 804abfa:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ac01:	08 
 804ac02:	89 04 24             	mov    %eax,(%esp)
 804ac05:	e8 e6 75 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(oldbrk - 1), NULL);
 804ac0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ac0d:	48                   	dec    %eax
 804ac0e:	0f b6 00             	movzbl (%eax),%eax
 804ac11:	84 c0                	test   %al,%al
 804ac13:	0f 94 c0             	sete   %al
 804ac16:	0f b6 c0             	movzbl %al,%eax
 804ac19:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ac20:	00 
 804ac21:	c7 44 24 0c 01 33 05 	movl   $0x8053301,0xc(%esp)
 804ac28:	08 
 804ac29:	c7 44 24 08 77 01 00 	movl   $0x177,0x8(%esp)
 804ac30:	00 
 804ac31:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ac38:	08 
 804ac39:	89 04 24             	mov    %eax,(%esp)
 804ac3c:	e8 af 75 00 00       	call   80521f0 <_test_assert>

        /* But can't move it up at all */
        test_assert(0 != brk(oldbrk + 1), NULL);
 804ac41:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ac44:	40                   	inc    %eax
 804ac45:	89 04 24             	mov    %eax,(%esp)
 804ac48:	e8 7b 25 00 00       	call   804d1c8 <brk>
 804ac4d:	85 c0                	test   %eax,%eax
 804ac4f:	0f 95 c0             	setne  %al
 804ac52:	0f b6 c0             	movzbl %al,%eax
 804ac55:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ac5c:	00 
 804ac5d:	c7 44 24 0c 74 35 05 	movl   $0x8053574,0xc(%esp)
 804ac64:	08 
 804ac65:	c7 44 24 08 7a 01 00 	movl   $0x17a,0x8(%esp)
 804ac6c:	00 
 804ac6d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ac74:	08 
 804ac75:	89 04 24             	mov    %eax,(%esp)
 804ac78:	e8 73 75 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(oldbrk + PAGE_SIZE), NULL);
 804ac7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ac80:	05 00 10 00 00       	add    $0x1000,%eax
 804ac85:	89 04 24             	mov    %eax,(%esp)
 804ac88:	e8 3b 25 00 00       	call   804d1c8 <brk>
 804ac8d:	85 c0                	test   %eax,%eax
 804ac8f:	0f 95 c0             	setne  %al
 804ac92:	0f b6 c0             	movzbl %al,%eax
 804ac95:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ac9c:	00 
 804ac9d:	c7 44 24 0c 89 35 05 	movl   $0x8053589,0xc(%esp)
 804aca4:	08 
 804aca5:	c7 44 24 08 7b 01 00 	movl   $0x17b,0x8(%esp)
 804acac:	00 
 804acad:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804acb4:	08 
 804acb5:	89 04 24             	mov    %eax,(%esp)
 804acb8:	e8 33 75 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(oldbrk + PAGE_SIZE * 2), NULL);
 804acbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804acc0:	05 00 20 00 00       	add    $0x2000,%eax
 804acc5:	89 04 24             	mov    %eax,(%esp)
 804acc8:	e8 fb 24 00 00       	call   804d1c8 <brk>
 804accd:	85 c0                	test   %eax,%eax
 804accf:	0f 95 c0             	setne  %al
 804acd2:	0f b6 c0             	movzbl %al,%eax
 804acd5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804acdc:	00 
 804acdd:	c7 44 24 0c a8 35 05 	movl   $0x80535a8,0xc(%esp)
 804ace4:	08 
 804ace5:	c7 44 24 08 7c 01 00 	movl   $0x17c,0x8(%esp)
 804acec:	00 
 804aced:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804acf4:	08 
 804acf5:	89 04 24             	mov    %eax,(%esp)
 804acf8:	e8 f3 74 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(oldbrk + PAGE_SIZE * 3), NULL);
 804acfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ad00:	05 00 30 00 00       	add    $0x3000,%eax
 804ad05:	89 04 24             	mov    %eax,(%esp)
 804ad08:	e8 bb 24 00 00       	call   804d1c8 <brk>
 804ad0d:	85 c0                	test   %eax,%eax
 804ad0f:	0f 95 c0             	setne  %al
 804ad12:	0f b6 c0             	movzbl %al,%eax
 804ad15:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ad1c:	00 
 804ad1d:	c7 44 24 0c cc 35 05 	movl   $0x80535cc,0xc(%esp)
 804ad24:	08 
 804ad25:	c7 44 24 08 7d 01 00 	movl   $0x17d,0x8(%esp)
 804ad2c:	00 
 804ad2d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ad34:	08 
 804ad35:	89 04 24             	mov    %eax,(%esp)
 804ad38:	e8 b3 74 00 00       	call   80521f0 <_test_assert>

        /* Make it smaller */
        test_assert(0 == munmap(oldbrk, PAGE_SIZE), NULL);
 804ad3d:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804ad44:	00 
 804ad45:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ad48:	89 04 24             	mov    %eax,(%esp)
 804ad4b:	e8 f3 27 00 00       	call   804d543 <munmap>
 804ad50:	85 c0                	test   %eax,%eax
 804ad52:	0f 94 c0             	sete   %al
 804ad55:	0f b6 c0             	movzbl %al,%eax
 804ad58:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ad5f:	00 
 804ad60:	c7 44 24 0c f0 35 05 	movl   $0x80535f0,0xc(%esp)
 804ad67:	08 
 804ad68:	c7 44 24 08 80 01 00 	movl   $0x180,0x8(%esp)
 804ad6f:	00 
 804ad70:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ad77:	08 
 804ad78:	89 04 24             	mov    %eax,(%esp)
 804ad7b:	e8 70 74 00 00       	call   80521f0 <_test_assert>
        /* Region inaccessible */
        assert_fault(char foo = *oldbrk, "");
 804ad80:	e8 ad 24 00 00       	call   804d232 <fork>
 804ad85:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ad88:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804ad8c:	75 13                	jne    804ada1 <test_brk_mmap+0x3e7>
 804ad8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ad91:	0f b6 00             	movzbl (%eax),%eax
 804ad94:	88 45 ef             	mov    %al,-0x11(%ebp)
 804ad97:	b8 00 00 00 00       	mov    $0x0,%eax
 804ad9c:	e9 3d 02 00 00       	jmp    804afde <test_brk_mmap+0x624>
 804ada1:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804ada4:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ada8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804adaf:	00 
 804adb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adb3:	89 04 24             	mov    %eax,(%esp)
 804adb6:	e8 15 26 00 00       	call   804d3d0 <waitpid>
 804adbb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804adbe:	83 f8 0e             	cmp    $0xe,%eax
 804adc1:	0f 94 c0             	sete   %al
 804adc4:	0f b6 c0             	movzbl %al,%eax
 804adc7:	c7 44 24 10 18 33 05 	movl   $0x8053318,0x10(%esp)
 804adce:	08 
 804adcf:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804add6:	08 
 804add7:	c7 44 24 08 82 01 00 	movl   $0x182,0x8(%esp)
 804adde:	00 
 804addf:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ade6:	08 
 804ade7:	89 04 24             	mov    %eax,(%esp)
 804adea:	e8 01 74 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(oldbrk + PAGE_SIZE - 1), "");
 804adef:	e8 3e 24 00 00       	call   804d232 <fork>
 804adf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804adf7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804adfb:	75 17                	jne    804ae14 <test_brk_mmap+0x45a>
 804adfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ae00:	0f b6 80 ff 0f 00 00 	movzbl 0xfff(%eax),%eax
 804ae07:	88 45 e7             	mov    %al,-0x19(%ebp)
 804ae0a:	b8 00 00 00 00       	mov    $0x0,%eax
 804ae0f:	e9 ca 01 00 00       	jmp    804afde <test_brk_mmap+0x624>
 804ae14:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804ae17:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ae1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804ae22:	00 
 804ae23:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ae26:	89 04 24             	mov    %eax,(%esp)
 804ae29:	e8 a2 25 00 00       	call   804d3d0 <waitpid>
 804ae2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804ae31:	83 f8 0e             	cmp    $0xe,%eax
 804ae34:	0f 94 c0             	sete   %al
 804ae37:	0f b6 c0             	movzbl %al,%eax
 804ae3a:	c7 44 24 10 10 36 05 	movl   $0x8053610,0x10(%esp)
 804ae41:	08 
 804ae42:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804ae49:	08 
 804ae4a:	c7 44 24 08 83 01 00 	movl   $0x183,0x8(%esp)
 804ae51:	00 
 804ae52:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ae59:	08 
 804ae5a:	89 04 24             	mov    %eax,(%esp)
 804ae5d:	e8 8e 73 00 00       	call   80521f0 <_test_assert>

        /* Expand brk accordingly */
        test_assert(0 == brk(oldbrk + PAGE_SIZE), NULL);
 804ae62:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ae65:	05 00 10 00 00       	add    $0x1000,%eax
 804ae6a:	89 04 24             	mov    %eax,(%esp)
 804ae6d:	e8 56 23 00 00       	call   804d1c8 <brk>
 804ae72:	85 c0                	test   %eax,%eax
 804ae74:	0f 94 c0             	sete   %al
 804ae77:	0f b6 c0             	movzbl %al,%eax
 804ae7a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ae81:	00 
 804ae82:	c7 44 24 0c 57 36 05 	movl   $0x8053657,0xc(%esp)
 804ae89:	08 
 804ae8a:	c7 44 24 08 86 01 00 	movl   $0x186,0x8(%esp)
 804ae91:	00 
 804ae92:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ae99:	08 
 804ae9a:	89 04 24             	mov    %eax,(%esp)
 804ae9d:	e8 4e 73 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *oldbrk, NULL);
 804aea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aea5:	0f b6 00             	movzbl (%eax),%eax
 804aea8:	84 c0                	test   %al,%al
 804aeaa:	0f 94 c0             	sete   %al
 804aead:	0f b6 c0             	movzbl %al,%eax
 804aeb0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804aeb7:	00 
 804aeb8:	c7 44 24 0c 00 34 05 	movl   $0x8053400,0xc(%esp)
 804aebf:	08 
 804aec0:	c7 44 24 08 87 01 00 	movl   $0x187,0x8(%esp)
 804aec7:	00 
 804aec8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804aecf:	08 
 804aed0:	89 04 24             	mov    %eax,(%esp)
 804aed3:	e8 18 73 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(oldbrk + PAGE_SIZE - 1), NULL);
 804aed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aedb:	05 ff 0f 00 00       	add    $0xfff,%eax
 804aee0:	0f b6 00             	movzbl (%eax),%eax
 804aee3:	84 c0                	test   %al,%al
 804aee5:	0f 94 c0             	sete   %al
 804aee8:	0f b6 c0             	movzbl %al,%eax
 804aeeb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804aef2:	00 
 804aef3:	c7 44 24 0c 74 36 05 	movl   $0x8053674,0xc(%esp)
 804aefa:	08 
 804aefb:	c7 44 24 08 88 01 00 	movl   $0x188,0x8(%esp)
 804af02:	00 
 804af03:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804af0a:	08 
 804af0b:	89 04 24             	mov    %eax,(%esp)
 804af0e:	e8 dd 72 00 00       	call   80521f0 <_test_assert>
        *oldbrk = 'a';
 804af13:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af16:	c6 00 61             	movb   $0x61,(%eax)

        /* Can't go too far */
        test_assert(0 != brk(oldbrk + PAGE_SIZE + 1), NULL);
 804af19:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af1c:	05 01 10 00 00       	add    $0x1001,%eax
 804af21:	89 04 24             	mov    %eax,(%esp)
 804af24:	e8 9f 22 00 00       	call   804d1c8 <brk>
 804af29:	85 c0                	test   %eax,%eax
 804af2b:	0f 95 c0             	setne  %al
 804af2e:	0f b6 c0             	movzbl %al,%eax
 804af31:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804af38:	00 
 804af39:	c7 44 24 0c 98 36 05 	movl   $0x8053698,0xc(%esp)
 804af40:	08 
 804af41:	c7 44 24 08 8c 01 00 	movl   $0x18c,0x8(%esp)
 804af48:	00 
 804af49:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804af50:	08 
 804af51:	89 04 24             	mov    %eax,(%esp)
 804af54:	e8 97 72 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(oldbrk + PAGE_SIZE * 2), NULL);
 804af59:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af5c:	05 00 20 00 00       	add    $0x2000,%eax
 804af61:	89 04 24             	mov    %eax,(%esp)
 804af64:	e8 5f 22 00 00       	call   804d1c8 <brk>
 804af69:	85 c0                	test   %eax,%eax
 804af6b:	0f 95 c0             	setne  %al
 804af6e:	0f b6 c0             	movzbl %al,%eax
 804af71:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804af78:	00 
 804af79:	c7 44 24 0c a8 35 05 	movl   $0x80535a8,0xc(%esp)
 804af80:	08 
 804af81:	c7 44 24 08 8d 01 00 	movl   $0x18d,0x8(%esp)
 804af88:	00 
 804af89:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804af90:	08 
 804af91:	89 04 24             	mov    %eax,(%esp)
 804af94:	e8 57 72 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(oldbrk + PAGE_SIZE * 3), NULL);
 804af99:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af9c:	05 00 30 00 00       	add    $0x3000,%eax
 804afa1:	89 04 24             	mov    %eax,(%esp)
 804afa4:	e8 1f 22 00 00       	call   804d1c8 <brk>
 804afa9:	85 c0                	test   %eax,%eax
 804afab:	0f 95 c0             	setne  %al
 804afae:	0f b6 c0             	movzbl %al,%eax
 804afb1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804afb8:	00 
 804afb9:	c7 44 24 0c cc 35 05 	movl   $0x80535cc,0xc(%esp)
 804afc0:	08 
 804afc1:	c7 44 24 08 8e 01 00 	movl   $0x18e,0x8(%esp)
 804afc8:	00 
 804afc9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804afd0:	08 
 804afd1:	89 04 24             	mov    %eax,(%esp)
 804afd4:	e8 17 72 00 00       	call   80521f0 <_test_assert>

        return 0;
 804afd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804afde:	c9                   	leave  
 804afdf:	c3                   	ret    

0804afe0 <test_mmap_fill>:

static int test_mmap_fill(void)
{
 804afe0:	55                   	push   %ebp
 804afe1:	89 e5                	mov    %esp,%ebp
 804afe3:	83 ec 48             	sub    $0x48,%esp
        printf("Testing filling up virtual address space\n");
 804afe6:	c7 04 24 bc 36 05 08 	movl   $0x80536bc,(%esp)
 804afed:	e8 ae 58 00 00       	call   80508a0 <printf>
        char *hi, *lo, *addr;
        /* map something and remove it to find out how high we can go */
        test_assert(MAP_FAILED != (hi = mmap(NULL, 1,
 804aff2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804aff9:	00 
 804affa:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b001:	ff 
 804b002:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b009:	00 
 804b00a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b011:	00 
 804b012:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b019:	00 
 804b01a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b021:	e8 ba 24 00 00       	call   804d4e0 <mmap>
 804b026:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b029:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 804b02d:	0f 95 c0             	setne  %al
 804b030:	0f b6 c0             	movzbl %al,%eax
 804b033:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b03a:	00 
 804b03b:	c7 44 24 0c e8 36 05 	movl   $0x80536e8,0xc(%esp)
 804b042:	08 
 804b043:	c7 44 24 08 99 01 00 	movl   $0x199,0x8(%esp)
 804b04a:	00 
 804b04b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b052:	08 
 804b053:	89 04 24             	mov    %eax,(%esp)
 804b056:	e8 95 71 00 00       	call   80521f0 <_test_assert>
                                             0, MAP_ANON | MAP_PRIVATE, -1, 0)), NULL);
        test_assert(0 == munmap(hi, 1), NULL);
 804b05b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b062:	00 
 804b063:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b066:	89 04 24             	mov    %eax,(%esp)
 804b069:	e8 d5 24 00 00       	call   804d543 <munmap>
 804b06e:	85 c0                	test   %eax,%eax
 804b070:	0f 94 c0             	sete   %al
 804b073:	0f b6 c0             	movzbl %al,%eax
 804b076:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b07d:	00 
 804b07e:	c7 44 24 0c 2d 37 05 	movl   $0x805372d,0xc(%esp)
 804b085:	08 
 804b086:	c7 44 24 08 9a 01 00 	movl   $0x19a,0x8(%esp)
 804b08d:	00 
 804b08e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b095:	08 
 804b096:	89 04 24             	mov    %eax,(%esp)
 804b099:	e8 52 71 00 00       	call   80521f0 <_test_assert>
        hi += PAGE_SIZE;
 804b09e:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)

        test_assert(bss_end == sbrk(0), NULL);
 804b0a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b0ac:	e8 4e 20 00 00       	call   804d0ff <sbrk>
 804b0b1:	3d d0 7b 05 08       	cmp    $0x8057bd0,%eax
 804b0b6:	0f 94 c0             	sete   %al
 804b0b9:	0f b6 c0             	movzbl %al,%eax
 804b0bc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b0c3:	00 
 804b0c4:	c7 44 24 0c 7d 32 05 	movl   $0x805327d,0xc(%esp)
 804b0cb:	08 
 804b0cc:	c7 44 24 08 9d 01 00 	movl   $0x19d,0x8(%esp)
 804b0d3:	00 
 804b0d4:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b0db:	08 
 804b0dc:	89 04 24             	mov    %eax,(%esp)
 804b0df:	e8 0c 71 00 00       	call   80521f0 <_test_assert>
        lo = PAGE_ALIGN_UP(bss_end);
 804b0e4:	b8 d0 7b 05 08       	mov    $0x8057bd0,%eax
 804b0e9:	48                   	dec    %eax
 804b0ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804b0ef:	05 00 10 00 00       	add    $0x1000,%eax
 804b0f4:	89 45 ec             	mov    %eax,-0x14(%ebp)

        /* Fill this up with 2 mappings */
#define MID_ADDR ((char *)0x80000000)
        if (MID_ADDR > lo) {
 804b0f7:	81 7d ec ff ff ff 7f 	cmpl   $0x7fffffff,-0x14(%ebp)
 804b0fe:	77 6b                	ja     804b16b <test_mmap_fill+0x18b>
                test_assert(MID_ADDR == mmap(NULL,
 804b100:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b103:	05 00 00 00 80       	add    $0x80000000,%eax
 804b108:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b10f:	00 
 804b110:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b117:	ff 
 804b118:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b11f:	00 
 804b120:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b127:	00 
 804b128:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b12c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b133:	e8 a8 23 00 00       	call   804d4e0 <mmap>
 804b138:	3d 00 00 00 80       	cmp    $0x80000000,%eax
 804b13d:	0f 94 c0             	sete   %al
 804b140:	0f b6 c0             	movzbl %al,%eax
 804b143:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b14a:	00 
 804b14b:	c7 44 24 0c 40 37 05 	movl   $0x8053740,0xc(%esp)
 804b152:	08 
 804b153:	c7 44 24 08 a5 01 00 	movl   $0x1a5,0x8(%esp)
 804b15a:	00 
 804b15b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b162:	08 
 804b163:	89 04 24             	mov    %eax,(%esp)
 804b166:	e8 85 70 00 00       	call   80521f0 <_test_assert>
                                             (size_t)((uintptr_t)hi - (uintptr_t)MID_ADDR),
                                             0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);
        }
        if (MID_ADDR < hi) {
 804b16b:	81 7d f0 00 00 00 80 	cmpl   $0x80000000,-0x10(%ebp)
 804b172:	76 6d                	jbe    804b1e1 <test_mmap_fill+0x201>
                test_assert(lo == mmap(NULL,
 804b174:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b177:	ba 00 00 00 80       	mov    $0x80000000,%edx
 804b17c:	29 c2                	sub    %eax,%edx
 804b17e:	89 d0                	mov    %edx,%eax
 804b180:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b187:	00 
 804b188:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b18f:	ff 
 804b190:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b197:	00 
 804b198:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b19f:	00 
 804b1a0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b1a4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b1ab:	e8 30 23 00 00       	call   804d4e0 <mmap>
 804b1b0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 804b1b3:	0f 94 c0             	sete   %al
 804b1b6:	0f b6 c0             	movzbl %al,%eax
 804b1b9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b1c0:	00 
 804b1c1:	c7 44 24 0c a8 37 05 	movl   $0x80537a8,0xc(%esp)
 804b1c8:	08 
 804b1c9:	c7 44 24 08 aa 01 00 	movl   $0x1aa,0x8(%esp)
 804b1d0:	00 
 804b1d1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b1d8:	08 
 804b1d9:	89 04 24             	mov    %eax,(%esp)
 804b1dc:	e8 0f 70 00 00       	call   80521f0 <_test_assert>
                                       (size_t)((uintptr_t)MID_ADDR - (uintptr_t)lo),
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);
        }

        /* mmap file below stack */
        test_assert(MAP_FAILED != (addr = mmap(NULL, 1,
 804b1e1:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b1e8:	00 
 804b1e9:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b1f0:	ff 
 804b1f1:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b1f8:	00 
 804b1f9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804b200:	00 
 804b201:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b208:	00 
 804b209:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b210:	e8 cb 22 00 00       	call   804d4e0 <mmap>
 804b215:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804b218:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b21b:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b21e:	0f 95 c0             	setne  %al
 804b221:	0f b6 c0             	movzbl %al,%eax
 804b224:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b22b:	00 
 804b22c:	c7 44 24 0c 0c 38 05 	movl   $0x805380c,0xc(%esp)
 804b233:	08 
 804b234:	c7 44 24 08 af 01 00 	movl   $0x1af,0x8(%esp)
 804b23b:	00 
 804b23c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b243:	08 
 804b244:	89 04 24             	mov    %eax,(%esp)
 804b247:	e8 a4 6f 00 00       	call   80521f0 <_test_assert>
                                               PROT_READ, MAP_ANON | MAP_PRIVATE, -1, 0)), NULL);
        test_assert((uintptr_t)addr < (uintptr_t)&addr, NULL);
 804b24c:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804b24f:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804b252:	39 d0                	cmp    %edx,%eax
 804b254:	0f 97 c0             	seta   %al
 804b257:	0f b6 c0             	movzbl %al,%eax
 804b25a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b261:	00 
 804b262:	c7 44 24 0c 5c 38 05 	movl   $0x805385c,0xc(%esp)
 804b269:	08 
 804b26a:	c7 44 24 08 b0 01 00 	movl   $0x1b0,0x8(%esp)
 804b271:	00 
 804b272:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b279:	08 
 804b27a:	89 04 24             	mov    %eax,(%esp)
 804b27d:	e8 6e 6f 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *addr, NULL);
 804b282:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b285:	0f b6 00             	movzbl (%eax),%eax
 804b288:	84 c0                	test   %al,%al
 804b28a:	0f 94 c0             	sete   %al
 804b28d:	0f b6 c0             	movzbl %al,%eax
 804b290:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b297:	00 
 804b298:	c7 44 24 0c 65 2f 05 	movl   $0x8052f65,0xc(%esp)
 804b29f:	08 
 804b2a0:	c7 44 24 08 b1 01 00 	movl   $0x1b1,0x8(%esp)
 804b2a7:	00 
 804b2a8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b2af:	08 
 804b2b0:	89 04 24             	mov    %eax,(%esp)
 804b2b3:	e8 38 6f 00 00       	call   80521f0 <_test_assert>
        /* mmap fixed on top of it */
        test_assert(MAP_FAILED != mmap(addr, 1,
 804b2b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b2bb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b2c2:	00 
 804b2c3:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b2ca:	ff 
 804b2cb:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
 804b2d2:	00 
 804b2d3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804b2da:	00 
 804b2db:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b2e2:	00 
 804b2e3:	89 04 24             	mov    %eax,(%esp)
 804b2e6:	e8 f5 21 00 00       	call   804d4e0 <mmap>
 804b2eb:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b2ee:	0f 95 c0             	setne  %al
 804b2f1:	0f b6 c0             	movzbl %al,%eax
 804b2f4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b2fb:	00 
 804b2fc:	c7 44 24 0c 80 38 05 	movl   $0x8053880,0xc(%esp)
 804b303:	08 
 804b304:	c7 44 24 08 b4 01 00 	movl   $0x1b4,0x8(%esp)
 804b30b:	00 
 804b30c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b313:	08 
 804b314:	89 04 24             	mov    %eax,(%esp)
 804b317:	e8 d4 6e 00 00       	call   80521f0 <_test_assert>
                                       PROT_READ, MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0), NULL);
        test_assert('\0' == *addr, NULL);
 804b31c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b31f:	0f b6 00             	movzbl (%eax),%eax
 804b322:	84 c0                	test   %al,%al
 804b324:	0f 94 c0             	sete   %al
 804b327:	0f b6 c0             	movzbl %al,%eax
 804b32a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b331:	00 
 804b332:	c7 44 24 0c 65 2f 05 	movl   $0x8052f65,0xc(%esp)
 804b339:	08 
 804b33a:	c7 44 24 08 b5 01 00 	movl   $0x1b5,0x8(%esp)
 804b341:	00 
 804b342:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b349:	08 
 804b34a:	89 04 24             	mov    %eax,(%esp)
 804b34d:	e8 9e 6e 00 00       	call   80521f0 <_test_assert>

        /* Try something too big */
        test_assert(MAP_FAILED == mmap(NULL, (size_t)addr,
 804b352:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b355:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b35c:	00 
 804b35d:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b364:	ff 
 804b365:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b36c:	00 
 804b36d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b374:	00 
 804b375:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b379:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b380:	e8 5b 21 00 00       	call   804d4e0 <mmap>
 804b385:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b388:	0f 94 c0             	sete   %al
 804b38b:	0f b6 c0             	movzbl %al,%eax
 804b38e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b395:	00 
 804b396:	c7 44 24 0c d4 38 05 	movl   $0x80538d4,0xc(%esp)
 804b39d:	08 
 804b39e:	c7 44 24 08 b9 01 00 	movl   $0x1b9,0x8(%esp)
 804b3a5:	00 
 804b3a6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b3ad:	08 
 804b3ae:	89 04 24             	mov    %eax,(%esp)
 804b3b1:	e8 3a 6e 00 00       	call   80521f0 <_test_assert>
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);

        /* Fill up the entire remaining space */
        test_assert(MAP_FAILED != mmap(NULL,
 804b3b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b3b9:	2d 00 00 40 00       	sub    $0x400000,%eax
 804b3be:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b3c5:	00 
 804b3c6:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b3cd:	ff 
 804b3ce:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b3d5:	00 
 804b3d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b3dd:	00 
 804b3de:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b3e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b3e9:	e8 f2 20 00 00       	call   804d4e0 <mmap>
 804b3ee:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b3f1:	0f 95 c0             	setne  %al
 804b3f4:	0f b6 c0             	movzbl %al,%eax
 804b3f7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b3fe:	00 
 804b3ff:	c7 44 24 0c 20 39 05 	movl   $0x8053920,0xc(%esp)
 804b406:	08 
 804b407:	c7 44 24 08 be 01 00 	movl   $0x1be,0x8(%esp)
 804b40e:	00 
 804b40f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b416:	08 
 804b417:	89 04 24             	mov    %eax,(%esp)
 804b41a:	e8 d1 6d 00 00       	call   80521f0 <_test_assert>
                                       (size_t)((uintptr_t)addr - (uintptr_t)USER_MEM_LOW),
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);


        /* No space left */
        test_assert(MAP_FAILED == mmap(NULL, 1,
 804b41f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b426:	00 
 804b427:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b42e:	ff 
 804b42f:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b436:	00 
 804b437:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b43e:	00 
 804b43f:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b446:	00 
 804b447:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b44e:	e8 8d 20 00 00       	call   804d4e0 <mmap>
 804b453:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b456:	0f 94 c0             	sete   %al
 804b459:	0f b6 c0             	movzbl %al,%eax
 804b45c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b463:	00 
 804b464:	c7 44 24 0c 90 39 05 	movl   $0x8053990,0xc(%esp)
 804b46b:	08 
 804b46c:	c7 44 24 08 c3 01 00 	movl   $0x1c3,0x8(%esp)
 804b473:	00 
 804b474:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b47b:	08 
 804b47c:	89 04 24             	mov    %eax,(%esp)
 804b47f:	e8 6c 6d 00 00       	call   80521f0 <_test_assert>
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);

        /* Make some space, we should fill it */
        test_assert(0 == munmap(addr, 1), NULL);
 804b484:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b487:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b48e:	00 
 804b48f:	89 04 24             	mov    %eax,(%esp)
 804b492:	e8 ac 20 00 00       	call   804d543 <munmap>
 804b497:	85 c0                	test   %eax,%eax
 804b499:	0f 94 c0             	sete   %al
 804b49c:	0f b6 c0             	movzbl %al,%eax
 804b49f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b4a6:	00 
 804b4a7:	c7 44 24 0c 49 28 05 	movl   $0x8052849,0xc(%esp)
 804b4ae:	08 
 804b4af:	c7 44 24 08 c6 01 00 	movl   $0x1c6,0x8(%esp)
 804b4b6:	00 
 804b4b7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b4be:	08 
 804b4bf:	89 04 24             	mov    %eax,(%esp)
 804b4c2:	e8 29 6d 00 00       	call   80521f0 <_test_assert>
        test_assert(addr == mmap(NULL, 1,
 804b4c7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b4ce:	00 
 804b4cf:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b4d6:	ff 
 804b4d7:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b4de:	00 
 804b4df:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804b4e6:	00 
 804b4e7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b4ee:	00 
 804b4ef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b4f6:	e8 e5 1f 00 00       	call   804d4e0 <mmap>
 804b4fb:	89 c2                	mov    %eax,%edx
 804b4fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b500:	39 c2                	cmp    %eax,%edx
 804b502:	0f 94 c0             	sete   %al
 804b505:	0f b6 c0             	movzbl %al,%eax
 804b508:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b50f:	00 
 804b510:	c7 44 24 0c d0 39 05 	movl   $0x80539d0,0xc(%esp)
 804b517:	08 
 804b518:	c7 44 24 08 c8 01 00 	movl   $0x1c8,0x8(%esp)
 804b51f:	00 
 804b520:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b527:	08 
 804b528:	89 04 24             	mov    %eax,(%esp)
 804b52b:	e8 c0 6c 00 00       	call   80521f0 <_test_assert>
                                 PROT_READ, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);
        test_assert('\0' == *addr, NULL);
 804b530:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804b533:	0f b6 00             	movzbl (%eax),%eax
 804b536:	84 c0                	test   %al,%al
 804b538:	0f 94 c0             	sete   %al
 804b53b:	0f b6 c0             	movzbl %al,%eax
 804b53e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b545:	00 
 804b546:	c7 44 24 0c 65 2f 05 	movl   $0x8052f65,0xc(%esp)
 804b54d:	08 
 804b54e:	c7 44 24 08 c9 01 00 	movl   $0x1c9,0x8(%esp)
 804b555:	00 
 804b556:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b55d:	08 
 804b55e:	89 04 24             	mov    %eax,(%esp)
 804b561:	e8 8a 6c 00 00       	call   80521f0 <_test_assert>

        test_assert(MAP_FAILED == mmap(NULL, 1,
 804b566:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b56d:	00 
 804b56e:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b575:	ff 
 804b576:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b57d:	00 
 804b57e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b585:	00 
 804b586:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b58d:	00 
 804b58e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b595:	e8 46 1f 00 00       	call   804d4e0 <mmap>
 804b59a:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b59d:	0f 94 c0             	sete   %al
 804b5a0:	0f b6 c0             	movzbl %al,%eax
 804b5a3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b5aa:	00 
 804b5ab:	c7 44 24 0c 90 39 05 	movl   $0x8053990,0xc(%esp)
 804b5b2:	08 
 804b5b3:	c7 44 24 08 cc 01 00 	movl   $0x1cc,0x8(%esp)
 804b5ba:	00 
 804b5bb:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b5c2:	08 
 804b5c3:	89 04 24             	mov    %eax,(%esp)
 804b5c6:	e8 25 6c 00 00       	call   80521f0 <_test_assert>
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);

        /* Clean out some more space */
        test_assert(0 == munmap(MID_ADDR - PAGE_SIZE, PAGE_SIZE * 2), NULL);
 804b5cb:	c7 44 24 04 00 20 00 	movl   $0x2000,0x4(%esp)
 804b5d2:	00 
 804b5d3:	c7 04 24 00 f0 ff 7f 	movl   $0x7ffff000,(%esp)
 804b5da:	e8 64 1f 00 00       	call   804d543 <munmap>
 804b5df:	85 c0                	test   %eax,%eax
 804b5e1:	0f 94 c0             	sete   %al
 804b5e4:	0f b6 c0             	movzbl %al,%eax
 804b5e7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b5ee:	00 
 804b5ef:	c7 44 24 0c 10 3a 05 	movl   $0x8053a10,0xc(%esp)
 804b5f6:	08 
 804b5f7:	c7 44 24 08 cf 01 00 	movl   $0x1cf,0x8(%esp)
 804b5fe:	00 
 804b5ff:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b606:	08 
 804b607:	89 04 24             	mov    %eax,(%esp)
 804b60a:	e8 e1 6b 00 00       	call   80521f0 <_test_assert>
        test_assert(MID_ADDR - PAGE_SIZE == mmap(NULL, PAGE_SIZE * 2,
 804b60f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b616:	00 
 804b617:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b61e:	ff 
 804b61f:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b626:	00 
 804b627:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804b62e:	00 
 804b62f:	c7 44 24 04 00 20 00 	movl   $0x2000,0x4(%esp)
 804b636:	00 
 804b637:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b63e:	e8 9d 1e 00 00       	call   804d4e0 <mmap>
 804b643:	3d 00 f0 ff 7f       	cmp    $0x7ffff000,%eax
 804b648:	0f 94 c0             	sete   %al
 804b64b:	0f b6 c0             	movzbl %al,%eax
 804b64e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b655:	00 
 804b656:	c7 44 24 0c 44 3a 05 	movl   $0x8053a44,0xc(%esp)
 804b65d:	08 
 804b65e:	c7 44 24 08 d1 01 00 	movl   $0x1d1,0x8(%esp)
 804b665:	00 
 804b666:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b66d:	08 
 804b66e:	89 04 24             	mov    %eax,(%esp)
 804b671:	e8 7a 6b 00 00       	call   80521f0 <_test_assert>
                        PROT_READ, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);
        test_assert('\0' == *MID_ADDR, NULL);
 804b676:	b8 00 00 00 80       	mov    $0x80000000,%eax
 804b67b:	0f b6 00             	movzbl (%eax),%eax
 804b67e:	84 c0                	test   %al,%al
 804b680:	0f 94 c0             	sete   %al
 804b683:	0f b6 c0             	movzbl %al,%eax
 804b686:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b68d:	00 
 804b68e:	c7 44 24 0c a0 3a 05 	movl   $0x8053aa0,0xc(%esp)
 804b695:	08 
 804b696:	c7 44 24 08 d2 01 00 	movl   $0x1d2,0x8(%esp)
 804b69d:	00 
 804b69e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b6a5:	08 
 804b6a6:	89 04 24             	mov    %eax,(%esp)
 804b6a9:	e8 42 6b 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(MID_ADDR - PAGE_SIZE), NULL);
 804b6ae:	b8 00 f0 ff 7f       	mov    $0x7ffff000,%eax
 804b6b3:	0f b6 00             	movzbl (%eax),%eax
 804b6b6:	84 c0                	test   %al,%al
 804b6b8:	0f 94 c0             	sete   %al
 804b6bb:	0f b6 c0             	movzbl %al,%eax
 804b6be:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b6c5:	00 
 804b6c6:	c7 44 24 0c b4 3a 05 	movl   $0x8053ab4,0xc(%esp)
 804b6cd:	08 
 804b6ce:	c7 44 24 08 d3 01 00 	movl   $0x1d3,0x8(%esp)
 804b6d5:	00 
 804b6d6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b6dd:	08 
 804b6de:	89 04 24             	mov    %eax,(%esp)
 804b6e1:	e8 0a 6b 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(MID_ADDR + PAGE_SIZE - 1), NULL);
 804b6e6:	b8 ff 0f 00 80       	mov    $0x80000fff,%eax
 804b6eb:	0f b6 00             	movzbl (%eax),%eax
 804b6ee:	84 c0                	test   %al,%al
 804b6f0:	0f 94 c0             	sete   %al
 804b6f3:	0f b6 c0             	movzbl %al,%eax
 804b6f6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b6fd:	00 
 804b6fe:	c7 44 24 0c d4 3a 05 	movl   $0x8053ad4,0xc(%esp)
 804b705:	08 
 804b706:	c7 44 24 08 d4 01 00 	movl   $0x1d4,0x8(%esp)
 804b70d:	00 
 804b70e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b715:	08 
 804b716:	89 04 24             	mov    %eax,(%esp)
 804b719:	e8 d2 6a 00 00       	call   80521f0 <_test_assert>

        /* Cut into pieces, access each of them */
        char *p;
        for (p = lo + PAGE_SIZE; p < lo + PAGE_SIZE * 20; p += PAGE_SIZE * 2) {
 804b71e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b721:	05 00 10 00 00       	add    $0x1000,%eax
 804b726:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b729:	e9 1a 01 00 00       	jmp    804b848 <test_mmap_fill+0x868>
                test_assert(MAP_FAILED != mmap(p, 1, PROT_READ | PROT_WRITE,
 804b72e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b735:	00 
 804b736:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b73d:	ff 
 804b73e:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
 804b745:	00 
 804b746:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804b74d:	00 
 804b74e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b755:	00 
 804b756:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b759:	89 04 24             	mov    %eax,(%esp)
 804b75c:	e8 7f 1d 00 00       	call   804d4e0 <mmap>
 804b761:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b764:	0f 95 c0             	setne  %al
 804b767:	0f b6 c0             	movzbl %al,%eax
 804b76a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b771:	00 
 804b772:	c7 44 24 0c f8 3a 05 	movl   $0x8053af8,0xc(%esp)
 804b779:	08 
 804b77a:	c7 44 24 08 da 01 00 	movl   $0x1da,0x8(%esp)
 804b781:	00 
 804b782:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b789:	08 
 804b78a:	89 04 24             	mov    %eax,(%esp)
 804b78d:	e8 5e 6a 00 00       	call   80521f0 <_test_assert>
                                               MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0), NULL);
                test_assert('\0' == *p, NULL);
 804b792:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b795:	0f b6 00             	movzbl (%eax),%eax
 804b798:	84 c0                	test   %al,%al
 804b79a:	0f 94 c0             	sete   %al
 804b79d:	0f b6 c0             	movzbl %al,%eax
 804b7a0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b7a7:	00 
 804b7a8:	c7 44 24 0c 54 3b 05 	movl   $0x8053b54,0xc(%esp)
 804b7af:	08 
 804b7b0:	c7 44 24 08 db 01 00 	movl   $0x1db,0x8(%esp)
 804b7b7:	00 
 804b7b8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b7bf:	08 
 804b7c0:	89 04 24             	mov    %eax,(%esp)
 804b7c3:	e8 28 6a 00 00       	call   80521f0 <_test_assert>
                *p = 'a';
 804b7c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b7cb:	c6 00 61             	movb   $0x61,(%eax)
                assert_fault(char foo = *(p + PAGE_SIZE), "");
 804b7ce:	e8 5f 1a 00 00       	call   804d232 <fork>
 804b7d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804b7d6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804b7da:	75 17                	jne    804b7f3 <test_mmap_fill+0x813>
 804b7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b7df:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804b7e6:	88 45 e7             	mov    %al,-0x19(%ebp)
 804b7e9:	b8 00 00 00 00       	mov    $0x0,%eax
 804b7ee:	e9 90 01 00 00       	jmp    804b983 <test_mmap_fill+0x9a3>
 804b7f3:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804b7f6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b7fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b801:	00 
 804b802:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b805:	89 04 24             	mov    %eax,(%esp)
 804b808:	e8 c3 1b 00 00       	call   804d3d0 <waitpid>
 804b80d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b810:	83 f8 0e             	cmp    $0xe,%eax
 804b813:	0f 94 c0             	sete   %al
 804b816:	0f b6 c0             	movzbl %al,%eax
 804b819:	c7 44 24 10 60 3b 05 	movl   $0x8053b60,0x10(%esp)
 804b820:	08 
 804b821:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804b828:	08 
 804b829:	c7 44 24 08 dd 01 00 	movl   $0x1dd,0x8(%esp)
 804b830:	00 
 804b831:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b838:	08 
 804b839:	89 04 24             	mov    %eax,(%esp)
 804b83c:	e8 af 69 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(MID_ADDR - PAGE_SIZE), NULL);
        test_assert('\0' == *(MID_ADDR + PAGE_SIZE - 1), NULL);

        /* Cut into pieces, access each of them */
        char *p;
        for (p = lo + PAGE_SIZE; p < lo + PAGE_SIZE * 20; p += PAGE_SIZE * 2) {
 804b841:	81 45 f4 00 20 00 00 	addl   $0x2000,-0xc(%ebp)
 804b848:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b84b:	05 00 40 01 00       	add    $0x14000,%eax
 804b850:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804b853:	0f 87 d5 fe ff ff    	ja     804b72e <test_mmap_fill+0x74e>
                test_assert('\0' == *p, NULL);
                *p = 'a';
                assert_fault(char foo = *(p + PAGE_SIZE), "");
        }

        test_assert(MAP_FAILED == mmap(NULL, 1,
 804b859:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b860:	00 
 804b861:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
 804b868:	ff 
 804b869:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
 804b870:	00 
 804b871:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b878:	00 
 804b879:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b880:	00 
 804b881:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b888:	e8 53 1c 00 00       	call   804d4e0 <mmap>
 804b88d:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b890:	0f 94 c0             	sete   %al
 804b893:	0f b6 c0             	movzbl %al,%eax
 804b896:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b89d:	00 
 804b89e:	c7 44 24 0c 90 39 05 	movl   $0x8053990,0xc(%esp)
 804b8a5:	08 
 804b8a6:	c7 44 24 08 e1 01 00 	movl   $0x1e1,0x8(%esp)
 804b8ad:	00 
 804b8ae:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b8b5:	08 
 804b8b6:	89 04 24             	mov    %eax,(%esp)
 804b8b9:	e8 32 69 00 00       	call   80521f0 <_test_assert>
                                       0, MAP_ANON | MAP_PRIVATE, -1, 0), NULL);

        /* Try brk too */
        test_assert(0 == brk(lo), NULL);
 804b8be:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b8c1:	89 04 24             	mov    %eax,(%esp)
 804b8c4:	e8 ff 18 00 00       	call   804d1c8 <brk>
 804b8c9:	85 c0                	test   %eax,%eax
 804b8cb:	0f 94 c0             	sete   %al
 804b8ce:	0f b6 c0             	movzbl %al,%eax
 804b8d1:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b8d8:	00 
 804b8d9:	c7 44 24 0c 9e 3b 05 	movl   $0x8053b9e,0xc(%esp)
 804b8e0:	08 
 804b8e1:	c7 44 24 08 e4 01 00 	movl   $0x1e4,0x8(%esp)
 804b8e8:	00 
 804b8e9:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b8f0:	08 
 804b8f1:	89 04 24             	mov    %eax,(%esp)
 804b8f4:	e8 f7 68 00 00       	call   80521f0 <_test_assert>
        test_assert(0 != brk(lo + 1), NULL);
 804b8f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b8fc:	40                   	inc    %eax
 804b8fd:	89 04 24             	mov    %eax,(%esp)
 804b900:	e8 c3 18 00 00       	call   804d1c8 <brk>
 804b905:	85 c0                	test   %eax,%eax
 804b907:	0f 95 c0             	setne  %al
 804b90a:	0f b6 c0             	movzbl %al,%eax
 804b90d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b914:	00 
 804b915:	c7 44 24 0c ab 3b 05 	movl   $0x8053bab,0xc(%esp)
 804b91c:	08 
 804b91d:	c7 44 24 08 e5 01 00 	movl   $0x1e5,0x8(%esp)
 804b924:	00 
 804b925:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b92c:	08 
 804b92d:	89 04 24             	mov    %eax,(%esp)
 804b930:	e8 bb 68 00 00       	call   80521f0 <_test_assert>

        /* Clean it all up */
        test_assert(0 == munmap(lo, (size_t)((uintptr_t)hi - (uintptr_t)lo)), NULL);
 804b935:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b938:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b93b:	29 c2                	sub    %eax,%edx
 804b93d:	89 d0                	mov    %edx,%eax
 804b93f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b943:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b946:	89 04 24             	mov    %eax,(%esp)
 804b949:	e8 f5 1b 00 00       	call   804d543 <munmap>
 804b94e:	85 c0                	test   %eax,%eax
 804b950:	0f 94 c0             	sete   %al
 804b953:	0f b6 c0             	movzbl %al,%eax
 804b956:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b95d:	00 
 804b95e:	c7 44 24 0c bc 3b 05 	movl   $0x8053bbc,0xc(%esp)
 804b965:	08 
 804b966:	c7 44 24 08 e8 01 00 	movl   $0x1e8,0x8(%esp)
 804b96d:	00 
 804b96e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b975:	08 
 804b976:	89 04 24             	mov    %eax,(%esp)
 804b979:	e8 72 68 00 00       	call   80521f0 <_test_assert>
        return 0;
 804b97e:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b983:	c9                   	leave  
 804b984:	c3                   	ret    

0804b985 <test_mmap_repeat>:

static int test_mmap_repeat(void)
{
 804b985:	55                   	push   %ebp
 804b986:	89 e5                	mov    %esp,%ebp
 804b988:	83 ec 58             	sub    $0x58,%esp
#define MMAP_REPEAT_FILE "mmaprepeattest"
#define REPEAT_STR "FooFooFoo"

        int fd, i;
        char *addrs[10];
        printf("Testing repeated mmap() of same file\n");
 804b98b:	c7 04 24 f8 3b 05 08 	movl   $0x8053bf8,(%esp)
 804b992:	e8 09 4f 00 00       	call   80508a0 <printf>

        /* Set up test file */
        test_assert(-1 != (fd = open(MMAP_REPEAT_FILE, O_RDWR | O_CREAT, 0)), NULL);
 804b997:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b99e:	00 
 804b99f:	c7 44 24 04 02 01 00 	movl   $0x102,0x4(%esp)
 804b9a6:	00 
 804b9a7:	c7 04 24 1e 3c 05 08 	movl   $0x8053c1e,(%esp)
 804b9ae:	e8 19 1c 00 00       	call   804d5cc <open>
 804b9b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b9b6:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 804b9ba:	0f 95 c0             	setne  %al
 804b9bd:	0f b6 c0             	movzbl %al,%eax
 804b9c0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804b9c7:	00 
 804b9c8:	c7 44 24 0c 30 3c 05 	movl   $0x8053c30,0xc(%esp)
 804b9cf:	08 
 804b9d0:	c7 44 24 08 f6 01 00 	movl   $0x1f6,0x8(%esp)
 804b9d7:	00 
 804b9d8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804b9df:	08 
 804b9e0:	89 04 24             	mov    %eax,(%esp)
 804b9e3:	e8 08 68 00 00       	call   80521f0 <_test_assert>
        test_assert(10 == write(fd, REPEAT_STR, 10), NULL);
 804b9e8:	c7 44 24 08 0a 00 00 	movl   $0xa,0x8(%esp)
 804b9ef:	00 
 804b9f0:	c7 44 24 04 69 3c 05 	movl   $0x8053c69,0x4(%esp)
 804b9f7:	08 
 804b9f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b9fb:	89 04 24             	mov    %eax,(%esp)
 804b9fe:	e8 cf 1c 00 00       	call   804d6d2 <write>
 804ba03:	83 f8 0a             	cmp    $0xa,%eax
 804ba06:	0f 94 c0             	sete   %al
 804ba09:	0f b6 c0             	movzbl %al,%eax
 804ba0c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ba13:	00 
 804ba14:	c7 44 24 0c 74 3c 05 	movl   $0x8053c74,0xc(%esp)
 804ba1b:	08 
 804ba1c:	c7 44 24 08 f7 01 00 	movl   $0x1f7,0x8(%esp)
 804ba23:	00 
 804ba24:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ba2b:	08 
 804ba2c:	89 04 24             	mov    %eax,(%esp)
 804ba2f:	e8 bc 67 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == unlink(MMAP_REPEAT_FILE), NULL);
 804ba34:	c7 04 24 1e 3c 05 08 	movl   $0x8053c1e,(%esp)
 804ba3b:	e8 64 1e 00 00       	call   804d8a4 <unlink>
 804ba40:	85 c0                	test   %eax,%eax
 804ba42:	0f 94 c0             	sete   %al
 804ba45:	0f b6 c0             	movzbl %al,%eax
 804ba48:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ba4f:	00 
 804ba50:	c7 44 24 0c 94 3c 05 	movl   $0x8053c94,0xc(%esp)
 804ba57:	08 
 804ba58:	c7 44 24 08 f8 01 00 	movl   $0x1f8,0x8(%esp)
 804ba5f:	00 
 804ba60:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ba67:	08 
 804ba68:	89 04 24             	mov    %eax,(%esp)
 804ba6b:	e8 80 67 00 00       	call   80521f0 <_test_assert>

        /* map it private many times */
        for (i = 0; i < 10; i++) {
 804ba70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804ba77:	e9 be 00 00 00       	jmp    804bb3a <test_mmap_repeat+0x1b5>
                test_assert(MAP_FAILED != (addrs[i] = mmap(NULL, PAGE_SIZE,
 804ba7c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804ba83:	00 
 804ba84:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ba87:	89 44 24 10          	mov    %eax,0x10(%esp)
 804ba8b:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804ba92:	00 
 804ba93:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804ba9a:	00 
 804ba9b:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804baa2:	00 
 804baa3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804baaa:	e8 31 1a 00 00       	call   804d4e0 <mmap>
 804baaf:	89 c2                	mov    %eax,%edx
 804bab1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bab4:	89 54 85 c8          	mov    %edx,-0x38(%ebp,%eax,4)
 804bab8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804babb:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804babf:	83 f8 ff             	cmp    $0xffffffff,%eax
 804bac2:	0f 95 c0             	setne  %al
 804bac5:	0f b6 c0             	movzbl %al,%eax
 804bac8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bacf:	00 
 804bad0:	c7 44 24 0c b4 3c 05 	movl   $0x8053cb4,0xc(%esp)
 804bad7:	08 
 804bad8:	c7 44 24 08 fd 01 00 	movl   $0x1fd,0x8(%esp)
 804badf:	00 
 804bae0:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bae7:	08 
 804bae8:	89 04 24             	mov    %eax,(%esp)
 804baeb:	e8 00 67 00 00       	call   80521f0 <_test_assert>
                                                      PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)), NULL);
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
 804baf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804baf3:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804baf7:	c7 44 24 04 69 3c 05 	movl   $0x8053c69,0x4(%esp)
 804bafe:	08 
 804baff:	89 04 24             	mov    %eax,(%esp)
 804bb02:	e8 3f 24 00 00       	call   804df46 <strcmp>
 804bb07:	85 c0                	test   %eax,%eax
 804bb09:	0f 94 c0             	sete   %al
 804bb0c:	0f b6 c0             	movzbl %al,%eax
 804bb0f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bb16:	00 
 804bb17:	c7 44 24 0c 11 3d 05 	movl   $0x8053d11,0xc(%esp)
 804bb1e:	08 
 804bb1f:	c7 44 24 08 fe 01 00 	movl   $0x1fe,0x8(%esp)
 804bb26:	00 
 804bb27:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bb2e:	08 
 804bb2f:	89 04 24             	mov    %eax,(%esp)
 804bb32:	e8 b9 66 00 00       	call   80521f0 <_test_assert>
        test_assert(-1 != (fd = open(MMAP_REPEAT_FILE, O_RDWR | O_CREAT, 0)), NULL);
        test_assert(10 == write(fd, REPEAT_STR, 10), NULL);
        test_assert(0 == unlink(MMAP_REPEAT_FILE), NULL);

        /* map it private many times */
        for (i = 0; i < 10; i++) {
 804bb37:	ff 45 f4             	incl   -0xc(%ebp)
 804bb3a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 804bb3e:	0f 8e 38 ff ff ff    	jle    804ba7c <test_mmap_repeat+0xf7>
                test_assert(MAP_FAILED != (addrs[i] = mmap(NULL, PAGE_SIZE,
                                                      PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)), NULL);
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
        }
        /* Make sure changes don't propagate */
        *addrs[0] = 'Z';
 804bb44:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804bb47:	c6 00 5a             	movb   $0x5a,(%eax)
        *(addrs[0] + PAGE_SIZE - 1) = 'Q';
 804bb4a:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804bb4d:	05 ff 0f 00 00       	add    $0xfff,%eax
 804bb52:	c6 00 51             	movb   $0x51,(%eax)
        for (i = 1; i < 10; i++) {
 804bb55:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804bb5c:	e9 89 00 00 00       	jmp    804bbea <test_mmap_repeat+0x265>
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
 804bb61:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bb64:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bb68:	c7 44 24 04 69 3c 05 	movl   $0x8053c69,0x4(%esp)
 804bb6f:	08 
 804bb70:	89 04 24             	mov    %eax,(%esp)
 804bb73:	e8 ce 23 00 00       	call   804df46 <strcmp>
 804bb78:	85 c0                	test   %eax,%eax
 804bb7a:	0f 94 c0             	sete   %al
 804bb7d:	0f b6 c0             	movzbl %al,%eax
 804bb80:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bb87:	00 
 804bb88:	c7 44 24 0c 11 3d 05 	movl   $0x8053d11,0xc(%esp)
 804bb8f:	08 
 804bb90:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
 804bb97:	00 
 804bb98:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bb9f:	08 
 804bba0:	89 04 24             	mov    %eax,(%esp)
 804bba3:	e8 48 66 00 00       	call   80521f0 <_test_assert>
                test_assert('\0' == *(addrs[i] + PAGE_SIZE - 1), NULL);
 804bba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bbab:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bbaf:	05 ff 0f 00 00       	add    $0xfff,%eax
 804bbb4:	0f b6 00             	movzbl (%eax),%eax
 804bbb7:	84 c0                	test   %al,%al
 804bbb9:	0f 94 c0             	sete   %al
 804bbbc:	0f b6 c0             	movzbl %al,%eax
 804bbbf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bbc6:	00 
 804bbc7:	c7 44 24 0c 30 3d 05 	movl   $0x8053d30,0xc(%esp)
 804bbce:	08 
 804bbcf:	c7 44 24 08 05 02 00 	movl   $0x205,0x8(%esp)
 804bbd6:	00 
 804bbd7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bbde:	08 
 804bbdf:	89 04 24             	mov    %eax,(%esp)
 804bbe2:	e8 09 66 00 00       	call   80521f0 <_test_assert>
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
        }
        /* Make sure changes don't propagate */
        *addrs[0] = 'Z';
        *(addrs[0] + PAGE_SIZE - 1) = 'Q';
        for (i = 1; i < 10; i++) {
 804bbe7:	ff 45 f4             	incl   -0xc(%ebp)
 804bbea:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 804bbee:	0f 8e 6d ff ff ff    	jle    804bb61 <test_mmap_repeat+0x1dc>
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
                test_assert('\0' == *(addrs[i] + PAGE_SIZE - 1), NULL);
        }

        /* map it shared many times */
        for (i = 0; i < 10; i++) {
 804bbf4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804bbfb:	e9 be 00 00 00       	jmp    804bcbe <test_mmap_repeat+0x339>
                test_assert(MAP_FAILED != (addrs[i] = mmap(NULL, PAGE_SIZE,
 804bc00:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804bc07:	00 
 804bc08:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bc0b:	89 44 24 10          	mov    %eax,0x10(%esp)
 804bc0f:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804bc16:	00 
 804bc17:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804bc1e:	00 
 804bc1f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804bc26:	00 
 804bc27:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bc2e:	e8 ad 18 00 00       	call   804d4e0 <mmap>
 804bc33:	89 c2                	mov    %eax,%edx
 804bc35:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bc38:	89 54 85 c8          	mov    %edx,-0x38(%ebp,%eax,4)
 804bc3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bc3f:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bc43:	83 f8 ff             	cmp    $0xffffffff,%eax
 804bc46:	0f 95 c0             	setne  %al
 804bc49:	0f b6 c0             	movzbl %al,%eax
 804bc4c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bc53:	00 
 804bc54:	c7 44 24 0c 54 3d 05 	movl   $0x8053d54,0xc(%esp)
 804bc5b:	08 
 804bc5c:	c7 44 24 08 0b 02 00 	movl   $0x20b,0x8(%esp)
 804bc63:	00 
 804bc64:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bc6b:	08 
 804bc6c:	89 04 24             	mov    %eax,(%esp)
 804bc6f:	e8 7c 65 00 00       	call   80521f0 <_test_assert>
                                                      PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)), NULL);
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
 804bc74:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bc77:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bc7b:	c7 44 24 04 69 3c 05 	movl   $0x8053c69,0x4(%esp)
 804bc82:	08 
 804bc83:	89 04 24             	mov    %eax,(%esp)
 804bc86:	e8 bb 22 00 00       	call   804df46 <strcmp>
 804bc8b:	85 c0                	test   %eax,%eax
 804bc8d:	0f 94 c0             	sete   %al
 804bc90:	0f b6 c0             	movzbl %al,%eax
 804bc93:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bc9a:	00 
 804bc9b:	c7 44 24 0c 11 3d 05 	movl   $0x8053d11,0xc(%esp)
 804bca2:	08 
 804bca3:	c7 44 24 08 0c 02 00 	movl   $0x20c,0x8(%esp)
 804bcaa:	00 
 804bcab:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bcb2:	08 
 804bcb3:	89 04 24             	mov    %eax,(%esp)
 804bcb6:	e8 35 65 00 00       	call   80521f0 <_test_assert>
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
                test_assert('\0' == *(addrs[i] + PAGE_SIZE - 1), NULL);
        }

        /* map it shared many times */
        for (i = 0; i < 10; i++) {
 804bcbb:	ff 45 f4             	incl   -0xc(%ebp)
 804bcbe:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 804bcc2:	0f 8e 38 ff ff ff    	jle    804bc00 <test_mmap_repeat+0x27b>
                test_assert(MAP_FAILED != (addrs[i] = mmap(NULL, PAGE_SIZE,
                                                      PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)), NULL);
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
        }
        /* Make sure changes propagate */
        *addrs[3] = 'Z';
 804bcc8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804bccb:	c6 00 5a             	movb   $0x5a,(%eax)
        *(addrs[5] + PAGE_SIZE - 1) = 'Q';
 804bcce:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804bcd1:	05 ff 0f 00 00       	add    $0xfff,%eax
 804bcd6:	c6 00 51             	movb   $0x51,(%eax)
        for (i = 0; i < 10; i++) {
 804bcd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804bce0:	eb 7c                	jmp    804bd5e <test_mmap_repeat+0x3d9>
                test_assert('Z' == *addrs[i], NULL);
 804bce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bce5:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bce9:	0f b6 00             	movzbl (%eax),%eax
 804bcec:	3c 5a                	cmp    $0x5a,%al
 804bcee:	0f 94 c0             	sete   %al
 804bcf1:	0f b6 c0             	movzbl %al,%eax
 804bcf4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bcfb:	00 
 804bcfc:	c7 44 24 0c b0 3d 05 	movl   $0x8053db0,0xc(%esp)
 804bd03:	08 
 804bd04:	c7 44 24 08 12 02 00 	movl   $0x212,0x8(%esp)
 804bd0b:	00 
 804bd0c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bd13:	08 
 804bd14:	89 04 24             	mov    %eax,(%esp)
 804bd17:	e8 d4 64 00 00       	call   80521f0 <_test_assert>
                test_assert('Q' == *(addrs[i] + PAGE_SIZE - 1), NULL);
 804bd1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bd1f:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
 804bd23:	05 ff 0f 00 00       	add    $0xfff,%eax
 804bd28:	0f b6 00             	movzbl (%eax),%eax
 804bd2b:	3c 51                	cmp    $0x51,%al
 804bd2d:	0f 94 c0             	sete   %al
 804bd30:	0f b6 c0             	movzbl %al,%eax
 804bd33:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bd3a:	00 
 804bd3b:	c7 44 24 0c c4 3d 05 	movl   $0x8053dc4,0xc(%esp)
 804bd42:	08 
 804bd43:	c7 44 24 08 13 02 00 	movl   $0x213,0x8(%esp)
 804bd4a:	00 
 804bd4b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bd52:	08 
 804bd53:	89 04 24             	mov    %eax,(%esp)
 804bd56:	e8 95 64 00 00       	call   80521f0 <_test_assert>
                test_assert(!strcmp(addrs[i], REPEAT_STR), NULL);
        }
        /* Make sure changes propagate */
        *addrs[3] = 'Z';
        *(addrs[5] + PAGE_SIZE - 1) = 'Q';
        for (i = 0; i < 10; i++) {
 804bd5b:	ff 45 f4             	incl   -0xc(%ebp)
 804bd5e:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
 804bd62:	0f 8e 7a ff ff ff    	jle    804bce2 <test_mmap_repeat+0x35d>
                test_assert('Z' == *addrs[i], NULL);
                test_assert('Q' == *(addrs[i] + PAGE_SIZE - 1), NULL);
        }

        return 0;
 804bd68:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804bd6d:	c9                   	leave  
 804bd6e:	c3                   	ret    

0804bd6f <test_mmap_beyond>:

static int test_mmap_beyond(void)
{
 804bd6f:	55                   	push   %ebp
 804bd70:	89 e5                	mov    %esp,%ebp
 804bd72:	81 ec b8 00 00 00    	sub    $0xb8,%esp

        int fd;
        char *addr, *addr2;
        int status;

        printf("Testing mmap() beyond end of backing object\n");
 804bd78:	c7 04 24 e8 3d 05 08 	movl   $0x8053de8,(%esp)
 804bd7f:	e8 1c 4b 00 00       	call   80508a0 <printf>

        /* Set up test file */
        test_assert(-1 != (fd = open(MMAP_BEYOND_FILE, O_RDWR | O_CREAT, 0)), NULL);
 804bd84:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804bd8b:	00 
 804bd8c:	c7 44 24 04 02 01 00 	movl   $0x102,0x4(%esp)
 804bd93:	00 
 804bd94:	c7 04 24 15 3e 05 08 	movl   $0x8053e15,(%esp)
 804bd9b:	e8 2c 18 00 00       	call   804d5cc <open>
 804bda0:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804bda3:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 804bda7:	0f 95 c0             	setne  %al
 804bdaa:	0f b6 c0             	movzbl %al,%eax
 804bdad:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bdb4:	00 
 804bdb5:	c7 44 24 0c 24 3e 05 	movl   $0x8053e24,0xc(%esp)
 804bdbc:	08 
 804bdbd:	c7 44 24 08 26 02 00 	movl   $0x226,0x8(%esp)
 804bdc4:	00 
 804bdc5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bdcc:	08 
 804bdcd:	89 04 24             	mov    %eax,(%esp)
 804bdd0:	e8 1b 64 00 00       	call   80521f0 <_test_assert>
        test_assert(8 == write(fd, BEYOND_STR, 8), NULL);
 804bdd5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
 804bddc:	00 
 804bddd:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804bde4:	08 
 804bde5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bde8:	89 04 24             	mov    %eax,(%esp)
 804bdeb:	e8 e2 18 00 00       	call   804d6d2 <write>
 804bdf0:	83 f8 08             	cmp    $0x8,%eax
 804bdf3:	0f 94 c0             	sete   %al
 804bdf6:	0f b6 c0             	movzbl %al,%eax
 804bdf9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804be00:	00 
 804be01:	c7 44 24 0c 65 3e 05 	movl   $0x8053e65,0xc(%esp)
 804be08:	08 
 804be09:	c7 44 24 08 27 02 00 	movl   $0x227,0x8(%esp)
 804be10:	00 
 804be11:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804be18:	08 
 804be19:	89 04 24             	mov    %eax,(%esp)
 804be1c:	e8 cf 63 00 00       	call   80521f0 <_test_assert>
        test_assert(0 == unlink(MMAP_BEYOND_FILE), NULL);
 804be21:	c7 04 24 15 3e 05 08 	movl   $0x8053e15,(%esp)
 804be28:	e8 77 1a 00 00       	call   804d8a4 <unlink>
 804be2d:	85 c0                	test   %eax,%eax
 804be2f:	0f 94 c0             	sete   %al
 804be32:	0f b6 c0             	movzbl %al,%eax
 804be35:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804be3c:	00 
 804be3d:	c7 44 24 0c 83 3e 05 	movl   $0x8053e83,0xc(%esp)
 804be44:	08 
 804be45:	c7 44 24 08 28 02 00 	movl   $0x228,0x8(%esp)
 804be4c:	00 
 804be4d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804be54:	08 
 804be55:	89 04 24             	mov    %eax,(%esp)
 804be58:	e8 93 63 00 00       	call   80521f0 <_test_assert>

        /* Set up test mmap */
        test_assert(MAP_FAILED != (addr = mmap(NULL, PAGE_SIZE * 10,
 804be5d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804be64:	00 
 804be65:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804be68:	89 44 24 10          	mov    %eax,0x10(%esp)
 804be6c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804be73:	00 
 804be74:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804be7b:	00 
 804be7c:	c7 44 24 04 00 a0 00 	movl   $0xa000,0x4(%esp)
 804be83:	00 
 804be84:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804be8b:	e8 50 16 00 00       	call   804d4e0 <mmap>
 804be90:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804be93:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
 804be97:	0f 95 c0             	setne  %al
 804be9a:	0f b6 c0             	movzbl %al,%eax
 804be9d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bea4:	00 
 804bea5:	c7 44 24 0c a4 3e 05 	movl   $0x8053ea4,0xc(%esp)
 804beac:	08 
 804bead:	c7 44 24 08 2c 02 00 	movl   $0x22c,0x8(%esp)
 804beb4:	00 
 804beb5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bebc:	08 
 804bebd:	89 04 24             	mov    %eax,(%esp)
 804bec0:	e8 2b 63 00 00       	call   80521f0 <_test_assert>
                                               PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)), NULL);
        /* make sure it's there */
        test_assert(!strcmp(addr, BEYOND_STR), NULL);
 804bec5:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804becc:	08 
 804becd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bed0:	89 04 24             	mov    %eax,(%esp)
 804bed3:	e8 6e 20 00 00       	call   804df46 <strcmp>
 804bed8:	85 c0                	test   %eax,%eax
 804beda:	0f 94 c0             	sete   %al
 804bedd:	0f b6 c0             	movzbl %al,%eax
 804bee0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bee7:	00 
 804bee8:	c7 44 24 0c 01 3f 05 	movl   $0x8053f01,0xc(%esp)
 804beef:	08 
 804bef0:	c7 44 24 08 2e 02 00 	movl   $0x22e,0x8(%esp)
 804bef7:	00 
 804bef8:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804beff:	08 
 804bf00:	89 04 24             	mov    %eax,(%esp)
 804bf03:	e8 e8 62 00 00       	call   80521f0 <_test_assert>

        /* Do it again, but with private mapping. */
        test_assert(MAP_FAILED != (addr2 = mmap(NULL, PAGE_SIZE * 10,
 804bf08:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804bf0f:	00 
 804bf10:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bf13:	89 44 24 10          	mov    %eax,0x10(%esp)
 804bf17:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804bf1e:	00 
 804bf1f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804bf26:	00 
 804bf27:	c7 44 24 04 00 a0 00 	movl   $0xa000,0x4(%esp)
 804bf2e:	00 
 804bf2f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bf36:	e8 a5 15 00 00       	call   804d4e0 <mmap>
 804bf3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804bf3e:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 804bf42:	0f 95 c0             	setne  %al
 804bf45:	0f b6 c0             	movzbl %al,%eax
 804bf48:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bf4f:	00 
 804bf50:	c7 44 24 0c 1c 3f 05 	movl   $0x8053f1c,0xc(%esp)
 804bf57:	08 
 804bf58:	c7 44 24 08 32 02 00 	movl   $0x232,0x8(%esp)
 804bf5f:	00 
 804bf60:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bf67:	08 
 804bf68:	89 04 24             	mov    %eax,(%esp)
 804bf6b:	e8 80 62 00 00       	call   80521f0 <_test_assert>
                                                PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0)), NULL);
        /* make sure it's there */
        test_assert(!strcmp(addr2, BEYOND_STR), NULL);
 804bf70:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804bf77:	08 
 804bf78:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bf7b:	89 04 24             	mov    %eax,(%esp)
 804bf7e:	e8 c3 1f 00 00       	call   804df46 <strcmp>
 804bf83:	85 c0                	test   %eax,%eax
 804bf85:	0f 94 c0             	sete   %al
 804bf88:	0f b6 c0             	movzbl %al,%eax
 804bf8b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804bf92:	00 
 804bf93:	c7 44 24 0c 7b 3f 05 	movl   $0x8053f7b,0xc(%esp)
 804bf9a:	08 
 804bf9b:	c7 44 24 08 34 02 00 	movl   $0x234,0x8(%esp)
 804bfa2:	00 
 804bfa3:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804bfaa:	08 
 804bfab:	89 04 24             	mov    %eax,(%esp)
 804bfae:	e8 3d 62 00 00       	call   80521f0 <_test_assert>
        *addr2 = 'a';
 804bfb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bfb6:	c6 00 61             	movb   $0x61,(%eax)

        /* Can't go too far on either */
        assert_fault(char foo = *(addr + PAGE_SIZE), "");
 804bfb9:	e8 74 12 00 00       	call   804d232 <fork>
 804bfbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804bfc1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804bfc5:	75 17                	jne    804bfde <test_mmap_beyond+0x26f>
 804bfc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bfca:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804bfd1:	88 45 e7             	mov    %al,-0x19(%ebp)
 804bfd4:	b8 00 00 00 00       	mov    $0x0,%eax
 804bfd9:	e9 9e 07 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804bfde:	8d 45 98             	lea    -0x68(%ebp),%eax
 804bfe1:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bfe5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804bfec:	00 
 804bfed:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804bff0:	89 04 24             	mov    %eax,(%esp)
 804bff3:	e8 d8 13 00 00       	call   804d3d0 <waitpid>
 804bff8:	8b 45 98             	mov    -0x68(%ebp),%eax
 804bffb:	83 f8 0e             	cmp    $0xe,%eax
 804bffe:	0f 94 c0             	sete   %al
 804c001:	0f b6 c0             	movzbl %al,%eax
 804c004:	c7 44 24 10 70 31 05 	movl   $0x8053170,0x10(%esp)
 804c00b:	08 
 804c00c:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c013:	08 
 804c014:	c7 44 24 08 38 02 00 	movl   $0x238,0x8(%esp)
 804c01b:	00 
 804c01c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c023:	08 
 804c024:	89 04 24             	mov    %eax,(%esp)
 804c027:	e8 c4 61 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE * 5), "");
 804c02c:	e8 01 12 00 00       	call   804d232 <fork>
 804c031:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804c034:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804c038:	75 17                	jne    804c051 <test_mmap_beyond+0x2e2>
 804c03a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c03d:	0f b6 80 00 50 00 00 	movzbl 0x5000(%eax),%eax
 804c044:	88 45 df             	mov    %al,-0x21(%ebp)
 804c047:	b8 00 00 00 00       	mov    $0x0,%eax
 804c04c:	e9 2b 07 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c051:	8d 45 94             	lea    -0x6c(%ebp),%eax
 804c054:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c058:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c05f:	00 
 804c060:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c063:	89 04 24             	mov    %eax,(%esp)
 804c066:	e8 65 13 00 00       	call   804d3d0 <waitpid>
 804c06b:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804c06e:	83 f8 0e             	cmp    $0xe,%eax
 804c071:	0f 94 c0             	sete   %al
 804c074:	0f b6 c0             	movzbl %al,%eax
 804c077:	c7 44 24 10 98 3f 05 	movl   $0x8053f98,0x10(%esp)
 804c07e:	08 
 804c07f:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c086:	08 
 804c087:	c7 44 24 08 39 02 00 	movl   $0x239,0x8(%esp)
 804c08e:	00 
 804c08f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c096:	08 
 804c097:	89 04 24             	mov    %eax,(%esp)
 804c09a:	e8 51 61 00 00       	call   80521f0 <_test_assert>
        assert_fault(*((char *)addr + PAGE_SIZE * 5) = 'a', "");
 804c09f:	e8 8e 11 00 00       	call   804d232 <fork>
 804c0a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c0a7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804c0ab:	75 15                	jne    804c0c2 <test_mmap_beyond+0x353>
 804c0ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c0b0:	05 00 50 00 00       	add    $0x5000,%eax
 804c0b5:	c6 00 61             	movb   $0x61,(%eax)
 804c0b8:	b8 00 00 00 00       	mov    $0x0,%eax
 804c0bd:	e9 ba 06 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c0c2:	8d 45 90             	lea    -0x70(%ebp),%eax
 804c0c5:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c0c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c0d0:	00 
 804c0d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c0d4:	89 04 24             	mov    %eax,(%esp)
 804c0d7:	e8 f4 12 00 00       	call   804d3d0 <waitpid>
 804c0dc:	8b 45 90             	mov    -0x70(%ebp),%eax
 804c0df:	83 f8 0e             	cmp    $0xe,%eax
 804c0e2:	0f 94 c0             	sete   %al
 804c0e5:	0f b6 c0             	movzbl %al,%eax
 804c0e8:	c7 44 24 10 e0 3f 05 	movl   $0x8053fe0,0x10(%esp)
 804c0ef:	08 
 804c0f0:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c0f7:	08 
 804c0f8:	c7 44 24 08 3a 02 00 	movl   $0x23a,0x8(%esp)
 804c0ff:	00 
 804c100:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c107:	08 
 804c108:	89 04 24             	mov    %eax,(%esp)
 804c10b:	e8 e0 60 00 00       	call   80521f0 <_test_assert>

        assert_fault(char foo = *(addr2 + PAGE_SIZE), "");
 804c110:	e8 1d 11 00 00       	call   804d232 <fork>
 804c115:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804c118:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c11c:	75 17                	jne    804c135 <test_mmap_beyond+0x3c6>
 804c11e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c121:	0f b6 80 00 10 00 00 	movzbl 0x1000(%eax),%eax
 804c128:	88 45 d3             	mov    %al,-0x2d(%ebp)
 804c12b:	b8 00 00 00 00       	mov    $0x0,%eax
 804c130:	e9 47 06 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c135:	8d 45 8c             	lea    -0x74(%ebp),%eax
 804c138:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c13c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c143:	00 
 804c144:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c147:	89 04 24             	mov    %eax,(%esp)
 804c14a:	e8 81 12 00 00       	call   804d3d0 <waitpid>
 804c14f:	8b 45 8c             	mov    -0x74(%ebp),%eax
 804c152:	83 f8 0e             	cmp    $0xe,%eax
 804c155:	0f 94 c0             	sete   %al
 804c158:	0f b6 c0             	movzbl %al,%eax
 804c15b:	c7 44 24 10 28 40 05 	movl   $0x8054028,0x10(%esp)
 804c162:	08 
 804c163:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c16a:	08 
 804c16b:	c7 44 24 08 3c 02 00 	movl   $0x23c,0x8(%esp)
 804c172:	00 
 804c173:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c17a:	08 
 804c17b:	89 04 24             	mov    %eax,(%esp)
 804c17e:	e8 6d 60 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr2 + PAGE_SIZE * 5), "");
 804c183:	e8 aa 10 00 00       	call   804d232 <fork>
 804c188:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804c18b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804c18f:	75 17                	jne    804c1a8 <test_mmap_beyond+0x439>
 804c191:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c194:	0f b6 80 00 50 00 00 	movzbl 0x5000(%eax),%eax
 804c19b:	88 45 cb             	mov    %al,-0x35(%ebp)
 804c19e:	b8 00 00 00 00       	mov    $0x0,%eax
 804c1a3:	e9 d4 05 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c1a8:	8d 45 88             	lea    -0x78(%ebp),%eax
 804c1ab:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c1af:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c1b6:	00 
 804c1b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c1ba:	89 04 24             	mov    %eax,(%esp)
 804c1bd:	e8 0e 12 00 00       	call   804d3d0 <waitpid>
 804c1c2:	8b 45 88             	mov    -0x78(%ebp),%eax
 804c1c5:	83 f8 0e             	cmp    $0xe,%eax
 804c1c8:	0f 94 c0             	sete   %al
 804c1cb:	0f b6 c0             	movzbl %al,%eax
 804c1ce:	c7 44 24 10 6c 40 05 	movl   $0x805406c,0x10(%esp)
 804c1d5:	08 
 804c1d6:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c1dd:	08 
 804c1de:	c7 44 24 08 3d 02 00 	movl   $0x23d,0x8(%esp)
 804c1e5:	00 
 804c1e6:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c1ed:	08 
 804c1ee:	89 04 24             	mov    %eax,(%esp)
 804c1f1:	e8 fa 5f 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(addr2 + PAGE_SIZE * 5) = 'a', "");
 804c1f6:	e8 37 10 00 00       	call   804d232 <fork>
 804c1fb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804c1fe:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
 804c202:	75 15                	jne    804c219 <test_mmap_beyond+0x4aa>
 804c204:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c207:	05 00 50 00 00       	add    $0x5000,%eax
 804c20c:	c6 00 61             	movb   $0x61,(%eax)
 804c20f:	b8 00 00 00 00       	mov    $0x0,%eax
 804c214:	e9 63 05 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c219:	8d 45 84             	lea    -0x7c(%ebp),%eax
 804c21c:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c220:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c227:	00 
 804c228:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804c22b:	89 04 24             	mov    %eax,(%esp)
 804c22e:	e8 9d 11 00 00       	call   804d3d0 <waitpid>
 804c233:	8b 45 84             	mov    -0x7c(%ebp),%eax
 804c236:	83 f8 0e             	cmp    $0xe,%eax
 804c239:	0f 94 c0             	sete   %al
 804c23c:	0f b6 c0             	movzbl %al,%eax
 804c23f:	c7 44 24 10 b4 40 05 	movl   $0x80540b4,0x10(%esp)
 804c246:	08 
 804c247:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c24e:	08 
 804c24f:	c7 44 24 08 3e 02 00 	movl   $0x23e,0x8(%esp)
 804c256:	00 
 804c257:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c25e:	08 
 804c25f:	89 04 24             	mov    %eax,(%esp)
 804c262:	e8 89 5f 00 00       	call   80521f0 <_test_assert>

        /* Write more to it */
        test_assert(PAGE_SIZE * 3 == lseek(fd, PAGE_SIZE * 3, SEEK_SET), NULL);
 804c267:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804c26e:	00 
 804c26f:	c7 44 24 04 00 30 00 	movl   $0x3000,0x4(%esp)
 804c276:	00 
 804c277:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c27a:	89 04 24             	mov    %eax,(%esp)
 804c27d:	e8 ae 13 00 00       	call   804d630 <lseek>
 804c282:	3d 00 30 00 00       	cmp    $0x3000,%eax
 804c287:	0f 94 c0             	sete   %al
 804c28a:	0f b6 c0             	movzbl %al,%eax
 804c28d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c294:	00 
 804c295:	c7 44 24 0c f8 40 05 	movl   $0x80540f8,0xc(%esp)
 804c29c:	08 
 804c29d:	c7 44 24 08 41 02 00 	movl   $0x241,0x8(%esp)
 804c2a4:	00 
 804c2a5:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c2ac:	08 
 804c2ad:	89 04 24             	mov    %eax,(%esp)
 804c2b0:	e8 3b 5f 00 00       	call   80521f0 <_test_assert>
        test_assert(8 == write(fd, BEYOND_STR, 8), NULL);
 804c2b5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
 804c2bc:	00 
 804c2bd:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804c2c4:	08 
 804c2c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c2c8:	89 04 24             	mov    %eax,(%esp)
 804c2cb:	e8 02 14 00 00       	call   804d6d2 <write>
 804c2d0:	83 f8 08             	cmp    $0x8,%eax
 804c2d3:	0f 94 c0             	sete   %al
 804c2d6:	0f b6 c0             	movzbl %al,%eax
 804c2d9:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c2e0:	00 
 804c2e1:	c7 44 24 0c 65 3e 05 	movl   $0x8053e65,0xc(%esp)
 804c2e8:	08 
 804c2e9:	c7 44 24 08 42 02 00 	movl   $0x242,0x8(%esp)
 804c2f0:	00 
 804c2f1:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c2f8:	08 
 804c2f9:	89 04 24             	mov    %eax,(%esp)
 804c2fc:	e8 ef 5e 00 00       	call   80521f0 <_test_assert>

        /* Can go up to new location */
        test_assert(!strcmp(addr, BEYOND_STR), NULL);
 804c301:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804c308:	08 
 804c309:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c30c:	89 04 24             	mov    %eax,(%esp)
 804c30f:	e8 32 1c 00 00       	call   804df46 <strcmp>
 804c314:	85 c0                	test   %eax,%eax
 804c316:	0f 94 c0             	sete   %al
 804c319:	0f b6 c0             	movzbl %al,%eax
 804c31c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c323:	00 
 804c324:	c7 44 24 0c 01 3f 05 	movl   $0x8053f01,0xc(%esp)
 804c32b:	08 
 804c32c:	c7 44 24 08 45 02 00 	movl   $0x245,0x8(%esp)
 804c333:	00 
 804c334:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c33b:	08 
 804c33c:	89 04 24             	mov    %eax,(%esp)
 804c33f:	e8 ac 5e 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr + PAGE_SIZE), NULL);
 804c344:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c347:	05 00 10 00 00       	add    $0x1000,%eax
 804c34c:	0f b6 00             	movzbl (%eax),%eax
 804c34f:	84 c0                	test   %al,%al
 804c351:	0f 94 c0             	sete   %al
 804c354:	0f b6 c0             	movzbl %al,%eax
 804c357:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c35e:	00 
 804c35f:	c7 44 24 0c 2c 41 05 	movl   $0x805412c,0xc(%esp)
 804c366:	08 
 804c367:	c7 44 24 08 46 02 00 	movl   $0x246,0x8(%esp)
 804c36e:	00 
 804c36f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c376:	08 
 804c377:	89 04 24             	mov    %eax,(%esp)
 804c37a:	e8 71 5e 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr + PAGE_SIZE * 2), NULL);
 804c37f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c382:	05 00 20 00 00       	add    $0x2000,%eax
 804c387:	0f b6 00             	movzbl (%eax),%eax
 804c38a:	84 c0                	test   %al,%al
 804c38c:	0f 94 c0             	sete   %al
 804c38f:	0f b6 c0             	movzbl %al,%eax
 804c392:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c399:	00 
 804c39a:	c7 44 24 0c 48 41 05 	movl   $0x8054148,0xc(%esp)
 804c3a1:	08 
 804c3a2:	c7 44 24 08 47 02 00 	movl   $0x247,0x8(%esp)
 804c3a9:	00 
 804c3aa:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c3b1:	08 
 804c3b2:	89 04 24             	mov    %eax,(%esp)
 804c3b5:	e8 36 5e 00 00       	call   80521f0 <_test_assert>
        test_assert(!strcmp(addr + PAGE_SIZE * 3, BEYOND_STR), NULL);
 804c3ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c3bd:	05 00 30 00 00       	add    $0x3000,%eax
 804c3c2:	c7 44 24 04 5d 3e 05 	movl   $0x8053e5d,0x4(%esp)
 804c3c9:	08 
 804c3ca:	89 04 24             	mov    %eax,(%esp)
 804c3cd:	e8 74 1b 00 00       	call   804df46 <strcmp>
 804c3d2:	85 c0                	test   %eax,%eax
 804c3d4:	0f 94 c0             	sete   %al
 804c3d7:	0f b6 c0             	movzbl %al,%eax
 804c3da:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c3e1:	00 
 804c3e2:	c7 44 24 0c 68 41 05 	movl   $0x8054168,0xc(%esp)
 804c3e9:	08 
 804c3ea:	c7 44 24 08 48 02 00 	movl   $0x248,0x8(%esp)
 804c3f1:	00 
 804c3f2:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c3f9:	08 
 804c3fa:	89 04 24             	mov    %eax,(%esp)
 804c3fd:	e8 ee 5d 00 00       	call   80521f0 <_test_assert>

        test_assert('a' == *addr2, NULL);
 804c402:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c405:	0f b6 00             	movzbl (%eax),%eax
 804c408:	3c 61                	cmp    $0x61,%al
 804c40a:	0f 94 c0             	sete   %al
 804c40d:	0f b6 c0             	movzbl %al,%eax
 804c410:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c417:	00 
 804c418:	c7 44 24 0c 92 41 05 	movl   $0x8054192,0xc(%esp)
 804c41f:	08 
 804c420:	c7 44 24 08 4a 02 00 	movl   $0x24a,0x8(%esp)
 804c427:	00 
 804c428:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c42f:	08 
 804c430:	89 04 24             	mov    %eax,(%esp)
 804c433:	e8 b8 5d 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr2 + PAGE_SIZE), NULL);
 804c438:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c43b:	05 00 10 00 00       	add    $0x1000,%eax
 804c440:	0f b6 00             	movzbl (%eax),%eax
 804c443:	84 c0                	test   %al,%al
 804c445:	0f 94 c0             	sete   %al
 804c448:	0f b6 c0             	movzbl %al,%eax
 804c44b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c452:	00 
 804c453:	c7 44 24 0c a0 41 05 	movl   $0x80541a0,0xc(%esp)
 804c45a:	08 
 804c45b:	c7 44 24 08 4b 02 00 	movl   $0x24b,0x8(%esp)
 804c462:	00 
 804c463:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c46a:	08 
 804c46b:	89 04 24             	mov    %eax,(%esp)
 804c46e:	e8 7d 5d 00 00       	call   80521f0 <_test_assert>
        test_assert('\0' == *(addr2 + PAGE_SIZE * 2), NULL);
 804c473:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c476:	05 00 20 00 00       	add    $0x2000,%eax
 804c47b:	0f b6 00             	movzbl (%eax),%eax
 804c47e:	84 c0                	test   %al,%al
 804c480:	0f 94 c0             	sete   %al
 804c483:	0f b6 c0             	movzbl %al,%eax
 804c486:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c48d:	00 
 804c48e:	c7 44 24 0c c0 41 05 	movl   $0x80541c0,0xc(%esp)
 804c495:	08 
 804c496:	c7 44 24 08 4c 02 00 	movl   $0x24c,0x8(%esp)
 804c49d:	00 
 804c49e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c4a5:	08 
 804c4a6:	89 04 24             	mov    %eax,(%esp)
 804c4a9:	e8 42 5d 00 00       	call   80521f0 <_test_assert>

        /* Can't go beyond it */
        assert_fault(char foo = *(addr + PAGE_SIZE * 4), "");
 804c4ae:	e8 7f 0d 00 00       	call   804d232 <fork>
 804c4b3:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804c4b6:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
 804c4ba:	75 17                	jne    804c4d3 <test_mmap_beyond+0x764>
 804c4bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c4bf:	0f b6 80 00 40 00 00 	movzbl 0x4000(%eax),%eax
 804c4c6:	88 45 bf             	mov    %al,-0x41(%ebp)
 804c4c9:	b8 00 00 00 00       	mov    $0x0,%eax
 804c4ce:	e9 a9 02 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c4d3:	8d 45 80             	lea    -0x80(%ebp),%eax
 804c4d6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c4da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c4e1:	00 
 804c4e2:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c4e5:	89 04 24             	mov    %eax,(%esp)
 804c4e8:	e8 e3 0e 00 00       	call   804d3d0 <waitpid>
 804c4ed:	8b 45 80             	mov    -0x80(%ebp),%eax
 804c4f0:	83 f8 0e             	cmp    $0xe,%eax
 804c4f3:	0f 94 c0             	sete   %al
 804c4f6:	0f b6 c0             	movzbl %al,%eax
 804c4f9:	c7 44 24 10 e4 41 05 	movl   $0x80541e4,0x10(%esp)
 804c500:	08 
 804c501:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c508:	08 
 804c509:	c7 44 24 08 4f 02 00 	movl   $0x24f,0x8(%esp)
 804c510:	00 
 804c511:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c518:	08 
 804c519:	89 04 24             	mov    %eax,(%esp)
 804c51c:	e8 cf 5c 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr + PAGE_SIZE * 8), "");
 804c521:	e8 0c 0d 00 00       	call   804d232 <fork>
 804c526:	89 45 b8             	mov    %eax,-0x48(%ebp)
 804c529:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
 804c52d:	75 17                	jne    804c546 <test_mmap_beyond+0x7d7>
 804c52f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c532:	0f b6 80 00 80 00 00 	movzbl 0x8000(%eax),%eax
 804c539:	88 45 b7             	mov    %al,-0x49(%ebp)
 804c53c:	b8 00 00 00 00       	mov    $0x0,%eax
 804c541:	e9 36 02 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c546:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 804c54c:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c550:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c557:	00 
 804c558:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c55b:	89 04 24             	mov    %eax,(%esp)
 804c55e:	e8 6d 0e 00 00       	call   804d3d0 <waitpid>
 804c563:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
 804c569:	83 f8 0e             	cmp    $0xe,%eax
 804c56c:	0f 94 c0             	sete   %al
 804c56f:	0f b6 c0             	movzbl %al,%eax
 804c572:	c7 44 24 10 2c 42 05 	movl   $0x805422c,0x10(%esp)
 804c579:	08 
 804c57a:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c581:	08 
 804c582:	c7 44 24 08 50 02 00 	movl   $0x250,0x8(%esp)
 804c589:	00 
 804c58a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c591:	08 
 804c592:	89 04 24             	mov    %eax,(%esp)
 804c595:	e8 56 5c 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(addr + PAGE_SIZE * 5) = 'a', "");
 804c59a:	e8 93 0c 00 00       	call   804d232 <fork>
 804c59f:	89 45 b0             	mov    %eax,-0x50(%ebp)
 804c5a2:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
 804c5a6:	75 15                	jne    804c5bd <test_mmap_beyond+0x84e>
 804c5a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c5ab:	05 00 50 00 00       	add    $0x5000,%eax
 804c5b0:	c6 00 61             	movb   $0x61,(%eax)
 804c5b3:	b8 00 00 00 00       	mov    $0x0,%eax
 804c5b8:	e9 bf 01 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c5bd:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
 804c5c3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c5c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c5ce:	00 
 804c5cf:	8b 45 b0             	mov    -0x50(%ebp),%eax
 804c5d2:	89 04 24             	mov    %eax,(%esp)
 804c5d5:	e8 f6 0d 00 00       	call   804d3d0 <waitpid>
 804c5da:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 804c5e0:	83 f8 0e             	cmp    $0xe,%eax
 804c5e3:	0f 94 c0             	sete   %al
 804c5e6:	0f b6 c0             	movzbl %al,%eax
 804c5e9:	c7 44 24 10 74 42 05 	movl   $0x8054274,0x10(%esp)
 804c5f0:	08 
 804c5f1:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c5f8:	08 
 804c5f9:	c7 44 24 08 51 02 00 	movl   $0x251,0x8(%esp)
 804c600:	00 
 804c601:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c608:	08 
 804c609:	89 04 24             	mov    %eax,(%esp)
 804c60c:	e8 df 5b 00 00       	call   80521f0 <_test_assert>

        assert_fault(char foo = *(addr2 + PAGE_SIZE * 4), "");
 804c611:	e8 1c 0c 00 00       	call   804d232 <fork>
 804c616:	89 45 ac             	mov    %eax,-0x54(%ebp)
 804c619:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
 804c61d:	75 17                	jne    804c636 <test_mmap_beyond+0x8c7>
 804c61f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c622:	0f b6 80 00 40 00 00 	movzbl 0x4000(%eax),%eax
 804c629:	88 45 ab             	mov    %al,-0x55(%ebp)
 804c62c:	b8 00 00 00 00       	mov    $0x0,%eax
 804c631:	e9 46 01 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c636:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
 804c63c:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c640:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c647:	00 
 804c648:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804c64b:	89 04 24             	mov    %eax,(%esp)
 804c64e:	e8 7d 0d 00 00       	call   804d3d0 <waitpid>
 804c653:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804c659:	83 f8 0e             	cmp    $0xe,%eax
 804c65c:	0f 94 c0             	sete   %al
 804c65f:	0f b6 c0             	movzbl %al,%eax
 804c662:	c7 44 24 10 b4 42 05 	movl   $0x80542b4,0x10(%esp)
 804c669:	08 
 804c66a:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c671:	08 
 804c672:	c7 44 24 08 53 02 00 	movl   $0x253,0x8(%esp)
 804c679:	00 
 804c67a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c681:	08 
 804c682:	89 04 24             	mov    %eax,(%esp)
 804c685:	e8 66 5b 00 00       	call   80521f0 <_test_assert>
        assert_fault(char foo = *(addr2 + PAGE_SIZE * 8), "");
 804c68a:	e8 a3 0b 00 00       	call   804d232 <fork>
 804c68f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c692:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
 804c696:	75 17                	jne    804c6af <test_mmap_beyond+0x940>
 804c698:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c69b:	0f b6 80 00 80 00 00 	movzbl 0x8000(%eax),%eax
 804c6a2:	88 45 a3             	mov    %al,-0x5d(%ebp)
 804c6a5:	b8 00 00 00 00       	mov    $0x0,%eax
 804c6aa:	e9 cd 00 00 00       	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c6af:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
 804c6b5:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c6b9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c6c0:	00 
 804c6c1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c6c4:	89 04 24             	mov    %eax,(%esp)
 804c6c7:	e8 04 0d 00 00       	call   804d3d0 <waitpid>
 804c6cc:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804c6d2:	83 f8 0e             	cmp    $0xe,%eax
 804c6d5:	0f 94 c0             	sete   %al
 804c6d8:	0f b6 c0             	movzbl %al,%eax
 804c6db:	c7 44 24 10 fc 42 05 	movl   $0x80542fc,0x10(%esp)
 804c6e2:	08 
 804c6e3:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c6ea:	08 
 804c6eb:	c7 44 24 08 54 02 00 	movl   $0x254,0x8(%esp)
 804c6f2:	00 
 804c6f3:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c6fa:	08 
 804c6fb:	89 04 24             	mov    %eax,(%esp)
 804c6fe:	e8 ed 5a 00 00       	call   80521f0 <_test_assert>
        assert_fault(*(addr2 + PAGE_SIZE * 5) = 'a', "");
 804c703:	e8 2a 0b 00 00       	call   804d232 <fork>
 804c708:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804c70b:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
 804c70f:	75 12                	jne    804c723 <test_mmap_beyond+0x9b4>
 804c711:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c714:	05 00 50 00 00       	add    $0x5000,%eax
 804c719:	c6 00 61             	movb   $0x61,(%eax)
 804c71c:	b8 00 00 00 00       	mov    $0x0,%eax
 804c721:	eb 59                	jmp    804c77c <test_mmap_beyond+0xa0d>
 804c723:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
 804c729:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c72d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c734:	00 
 804c735:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804c738:	89 04 24             	mov    %eax,(%esp)
 804c73b:	e8 90 0c 00 00       	call   804d3d0 <waitpid>
 804c740:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804c746:	83 f8 0e             	cmp    $0xe,%eax
 804c749:	0f 94 c0             	sete   %al
 804c74c:	0f b6 c0             	movzbl %al,%eax
 804c74f:	c7 44 24 10 b4 40 05 	movl   $0x80540b4,0x10(%esp)
 804c756:	08 
 804c757:	c7 44 24 0c d7 22 05 	movl   $0x80522d7,0xc(%esp)
 804c75e:	08 
 804c75f:	c7 44 24 08 55 02 00 	movl   $0x255,0x8(%esp)
 804c766:	00 
 804c767:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804c76e:	08 
 804c76f:	89 04 24             	mov    %eax,(%esp)
 804c772:	e8 79 5a 00 00       	call   80521f0 <_test_assert>

        return 0;
 804c777:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c77c:	c9                   	leave  
 804c77d:	c3                   	ret    

0804c77e <make_rootdir>:

/* TODO Figure out a way to not have these be repeated. */
/* Copied from vfstest. Linking stuff prevents use of the same file. */
static void
make_rootdir(void)
{
 804c77e:	55                   	push   %ebp
 804c77f:	89 e5                	mov    %esp,%ebp
 804c781:	83 ec 28             	sub    $0x28,%esp
        int err;

        root_dir[0] = '\0';
 804c784:	c6 05 80 7a 05 08 00 	movb   $0x0,0x8057a80
        do {
                sprintf(root_dir, "memtest-%d", rand());
 804c78b:	e8 84 40 00 00       	call   8050814 <rand>
 804c790:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c794:	c7 44 24 04 42 43 05 	movl   $0x8054342,0x4(%esp)
 804c79b:	08 
 804c79c:	c7 04 24 80 7a 05 08 	movl   $0x8057a80,(%esp)
 804c7a3:	e8 6d 41 00 00       	call   8050915 <sprintf>
                err = mkdir(root_dir, 0777);
 804c7a8:	c7 44 24 04 ff 01 00 	movl   $0x1ff,0x4(%esp)
 804c7af:	00 
 804c7b0:	c7 04 24 80 7a 05 08 	movl   $0x8057a80,(%esp)
 804c7b7:	e8 32 10 00 00       	call   804d7ee <mkdir>
 804c7bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        } while (err != 0);
 804c7bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c7c3:	75 c6                	jne    804c78b <make_rootdir+0xd>
        printf("Created test root directory: ./%s\n", root_dir);
 804c7c5:	c7 44 24 04 80 7a 05 	movl   $0x8057a80,0x4(%esp)
 804c7cc:	08 
 804c7cd:	c7 04 24 50 43 05 08 	movl   $0x8054350,(%esp)
 804c7d4:	e8 c7 40 00 00       	call   80508a0 <printf>
}
 804c7d9:	90                   	nop
 804c7da:	c9                   	leave  
 804c7db:	c3                   	ret    

0804c7dc <getdent>:

/* Copied from vfstest. Linking stuff prevents use of the same file. */
static int
getdent(const char *dir, dirent_t *dirent)
{
 804c7dc:	55                   	push   %ebp
 804c7dd:	89 e5                	mov    %esp,%ebp
 804c7df:	83 ec 28             	sub    $0x28,%esp
        int ret, fd = -1;
 804c7e2:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)

        if (0 > (fd = open(dir, O_RDONLY, 0777))) {
 804c7e9:	c7 44 24 08 ff 01 00 	movl   $0x1ff,0x8(%esp)
 804c7f0:	00 
 804c7f1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804c7f8:	00 
 804c7f9:	8b 45 08             	mov    0x8(%ebp),%eax
 804c7fc:	89 04 24             	mov    %eax,(%esp)
 804c7ff:	e8 c8 0d 00 00       	call   804d5cc <open>
 804c804:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c807:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804c80b:	79 0a                	jns    804c817 <getdent+0x3b>
                return -1;
 804c80d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804c812:	e9 8f 00 00 00       	jmp    804c8a6 <getdent+0xca>
        }

        ret = 1;
 804c817:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        while (ret != 0) {
 804c81e:	eb 70                	jmp    804c890 <getdent+0xb4>
                if (0 > (ret = getdents(fd, dirent, sizeof(*dirent)))) {
 804c820:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
 804c827:	00 
 804c828:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c82b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c82f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c832:	89 04 24             	mov    %eax,(%esp)
 804c835:	e8 90 14 00 00       	call   804dcca <getdents>
 804c83a:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c83d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c841:	79 07                	jns    804c84a <getdent+0x6e>
                        return -1;
 804c843:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804c848:	eb 5c                	jmp    804c8a6 <getdent+0xca>
                }
                if (0 != strcmp(".", dirent->d_name) && 0 != strcmp("..", dirent->d_name)) {
 804c84a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c84d:	83 c0 08             	add    $0x8,%eax
 804c850:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c854:	c7 04 24 73 43 05 08 	movl   $0x8054373,(%esp)
 804c85b:	e8 e6 16 00 00       	call   804df46 <strcmp>
 804c860:	85 c0                	test   %eax,%eax
 804c862:	74 2c                	je     804c890 <getdent+0xb4>
 804c864:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c867:	83 c0 08             	add    $0x8,%eax
 804c86a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c86e:	c7 04 24 75 43 05 08 	movl   $0x8054375,(%esp)
 804c875:	e8 cc 16 00 00       	call   804df46 <strcmp>
 804c87a:	85 c0                	test   %eax,%eax
 804c87c:	74 12                	je     804c890 <getdent+0xb4>
                        close(fd);
 804c87e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c881:	89 04 24             	mov    %eax,(%esp)
 804c884:	e8 9a 0e 00 00       	call   804d723 <close>
                        return 1;
 804c889:	b8 01 00 00 00       	mov    $0x1,%eax
 804c88e:	eb 16                	jmp    804c8a6 <getdent+0xca>
        if (0 > (fd = open(dir, O_RDONLY, 0777))) {
                return -1;
        }

        ret = 1;
        while (ret != 0) {
 804c890:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c894:	75 8a                	jne    804c820 <getdent+0x44>
                        close(fd);
                        return 1;
                }
        }

        close(fd);
 804c896:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c899:	89 04 24             	mov    %eax,(%esp)
 804c89c:	e8 82 0e 00 00       	call   804d723 <close>
        return 0;
 804c8a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c8a6:	c9                   	leave  
 804c8a7:	c3                   	ret    

0804c8a8 <removeall>:

/* Copied from vfstest. Linking stuff prevents use of the same file. */
static int
removeall(const char *dir)
{
 804c8a8:	55                   	push   %ebp
 804c8a9:	89 e5                	mov    %esp,%ebp
 804c8ab:	81 ec 88 00 00 00    	sub    $0x88,%esp
        int ret, fd = -1;
 804c8b1:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
        dirent_t dirent;
        struct stat status;

        if (0 > chdir(dir)) {
 804c8b8:	8b 45 08             	mov    0x8(%ebp),%eax
 804c8bb:	89 04 24             	mov    %eax,(%esp)
 804c8be:	e8 11 11 00 00       	call   804d9d4 <chdir>
 804c8c3:	85 c0                	test   %eax,%eax
 804c8c5:	0f 88 c9 00 00 00    	js     804c994 <removeall+0xec>
                goto error;
        }

        ret = 1;
 804c8cb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        while (ret != 0) {
 804c8d2:	eb 78                	jmp    804c94c <removeall+0xa4>
                if (0 > (ret = getdent(".", &dirent))) {
 804c8d4:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c8d7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c8db:	c7 04 24 73 43 05 08 	movl   $0x8054373,(%esp)
 804c8e2:	e8 f5 fe ff ff       	call   804c7dc <getdent>
 804c8e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c8ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c8ee:	0f 88 a3 00 00 00    	js     804c997 <removeall+0xef>
                        goto error;
                }
                if (0 == ret) {
 804c8f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c8f8:	74 5a                	je     804c954 <removeall+0xac>
                        break;
                }

                if (0 > stat(dirent.d_name, &status)) {
 804c8fa:	8d 45 94             	lea    -0x6c(%ebp),%eax
 804c8fd:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c901:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c904:	83 c0 08             	add    $0x8,%eax
 804c907:	89 04 24             	mov    %eax,(%esp)
 804c90a:	e8 0c 14 00 00       	call   804dd1b <stat>
 804c90f:	85 c0                	test   %eax,%eax
 804c911:	0f 88 83 00 00 00    	js     804c99a <removeall+0xf2>
                        goto error;
                }

                if (S_ISDIR(status.st_mode)) {
 804c917:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804c91a:	25 00 ff 00 00       	and    $0xff00,%eax
 804c91f:	3d 00 02 00 00       	cmp    $0x200,%eax
 804c924:	75 14                	jne    804c93a <removeall+0x92>
                        if (0 > removeall(dirent.d_name)) {
 804c926:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c929:	83 c0 08             	add    $0x8,%eax
 804c92c:	89 04 24             	mov    %eax,(%esp)
 804c92f:	e8 74 ff ff ff       	call   804c8a8 <removeall>
 804c934:	85 c0                	test   %eax,%eax
 804c936:	79 14                	jns    804c94c <removeall+0xa4>
                                goto error;
 804c938:	eb 64                	jmp    804c99e <removeall+0xf6>
                        }
                } else {
                        if (0 > unlink(dirent.d_name)) {
 804c93a:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804c93d:	83 c0 08             	add    $0x8,%eax
 804c940:	89 04 24             	mov    %eax,(%esp)
 804c943:	e8 5c 0f 00 00       	call   804d8a4 <unlink>
 804c948:	85 c0                	test   %eax,%eax
 804c94a:	78 51                	js     804c99d <removeall+0xf5>
        if (0 > chdir(dir)) {
                goto error;
        }

        ret = 1;
        while (ret != 0) {
 804c94c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c950:	75 82                	jne    804c8d4 <removeall+0x2c>
 804c952:	eb 01                	jmp    804c955 <removeall+0xad>
                if (0 > (ret = getdent(".", &dirent))) {
                        goto error;
                }
                if (0 == ret) {
                        break;
 804c954:	90                   	nop
                                goto error;
                        }
                }
        }

        if (0 > chdir("..")) {
 804c955:	c7 04 24 75 43 05 08 	movl   $0x8054375,(%esp)
 804c95c:	e8 73 10 00 00       	call   804d9d4 <chdir>
 804c961:	85 c0                	test   %eax,%eax
 804c963:	79 07                	jns    804c96c <removeall+0xc4>
                return errno;
 804c965:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
 804c96a:	eb 48                	jmp    804c9b4 <removeall+0x10c>
        }

        if (0 > rmdir(dir)) {
 804c96c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c96f:	89 04 24             	mov    %eax,(%esp)
 804c972:	e8 d5 0e 00 00       	call   804d84c <rmdir>
 804c977:	85 c0                	test   %eax,%eax
 804c979:	79 07                	jns    804c982 <removeall+0xda>
                return errno;
 804c97b:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
 804c980:	eb 32                	jmp    804c9b4 <removeall+0x10c>
        }

        close(fd);
 804c982:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c985:	89 04 24             	mov    %eax,(%esp)
 804c988:	e8 96 0d 00 00       	call   804d723 <close>
        return 0;
 804c98d:	b8 00 00 00 00       	mov    $0x0,%eax
 804c992:	eb 20                	jmp    804c9b4 <removeall+0x10c>
        int ret, fd = -1;
        dirent_t dirent;
        struct stat status;

        if (0 > chdir(dir)) {
                goto error;
 804c994:	90                   	nop
 804c995:	eb 07                	jmp    804c99e <removeall+0xf6>
        }

        ret = 1;
        while (ret != 0) {
                if (0 > (ret = getdent(".", &dirent))) {
                        goto error;
 804c997:	90                   	nop
 804c998:	eb 04                	jmp    804c99e <removeall+0xf6>
                if (0 == ret) {
                        break;
                }

                if (0 > stat(dirent.d_name, &status)) {
                        goto error;
 804c99a:	90                   	nop
 804c99b:	eb 01                	jmp    804c99e <removeall+0xf6>
                        if (0 > removeall(dirent.d_name)) {
                                goto error;
                        }
                } else {
                        if (0 > unlink(dirent.d_name)) {
                                goto error;
 804c99d:	90                   	nop

        close(fd);
        return 0;

error:
        if (0 <= fd) {
 804c99e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804c9a2:	78 0b                	js     804c9af <removeall+0x107>
                close(fd);
 804c9a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c9a7:	89 04 24             	mov    %eax,(%esp)
 804c9aa:	e8 74 0d 00 00       	call   804d723 <close>
        }

        return errno;
 804c9af:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
}
 804c9b4:	c9                   	leave  
 804c9b5:	c3                   	ret    

0804c9b6 <destroy_rootdir>:

/* Copied from vfstest. Linking stuff prevents use of the same file. */
static void
destroy_rootdir(void)
{
 804c9b6:	55                   	push   %ebp
 804c9b7:	89 e5                	mov    %esp,%ebp
 804c9b9:	83 ec 18             	sub    $0x18,%esp
        if (0 != removeall(root_dir)) {
 804c9bc:	c7 04 24 80 7a 05 08 	movl   $0x8057a80,(%esp)
 804c9c3:	e8 e0 fe ff ff       	call   804c8a8 <removeall>
 804c9c8:	85 c0                	test   %eax,%eax
 804c9ca:	74 3c                	je     804ca08 <destroy_rootdir+0x52>
                fprintf(stderr, "ERROR: could not remove testing root %s: %s\n", root_dir, strerror(errno));
 804c9cc:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
 804c9d1:	89 04 24             	mov    %eax,(%esp)
 804c9d4:	e8 7f 19 00 00       	call   804e358 <strerror>
 804c9d9:	89 c2                	mov    %eax,%edx
 804c9db:	a1 3c 79 05 08       	mov    0x805793c,%eax
 804c9e0:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c9e4:	c7 44 24 08 80 7a 05 	movl   $0x8057a80,0x8(%esp)
 804c9eb:	08 
 804c9ec:	c7 44 24 04 78 43 05 	movl   $0x8054378,0x4(%esp)
 804c9f3:	08 
 804c9f4:	89 04 24             	mov    %eax,(%esp)
 804c9f7:	e8 db 3e 00 00       	call   80508d7 <fprintf>
                exit(-1);
 804c9fc:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 804ca03:	e8 e6 08 00 00       	call   804d2ee <exit>
        }
        printf("Removed test root directory: ./%s\n", root_dir);
 804ca08:	c7 44 24 04 80 7a 05 	movl   $0x8057a80,0x4(%esp)
 804ca0f:	08 
 804ca10:	c7 04 24 a8 43 05 08 	movl   $0x80543a8,(%esp)
 804ca17:	e8 84 3e 00 00       	call   80508a0 <printf>

}
 804ca1c:	90                   	nop
 804ca1d:	c9                   	leave  
 804ca1e:	c3                   	ret    

0804ca1f <main>:

int main(int argc, char **argv)
{
 804ca1f:	55                   	push   %ebp
 804ca20:	89 e5                	mov    %esp,%ebp
 804ca22:	56                   	push   %esi
 804ca23:	53                   	push   %ebx
 804ca24:	83 e4 f0             	and    $0xfffffff0,%esp
 804ca27:	83 ec 50             	sub    $0x50,%esp
        if (argc != 1) {
 804ca2a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 804ca2e:	74 1f                	je     804ca4f <main+0x30>
                fprintf(stderr,
 804ca30:	a1 3c 79 05 08       	mov    0x805793c,%eax
 804ca35:	c7 44 24 04 cb 43 05 	movl   $0x80543cb,0x4(%esp)
 804ca3c:	08 
 804ca3d:	89 04 24             	mov    %eax,(%esp)
 804ca40:	e8 92 3e 00 00       	call   80508d7 <fprintf>
                        "USAGE: memtest\n");
                return 1;
 804ca45:	b8 01 00 00 00       	mov    $0x1,%eax
 804ca4a:	e9 69 06 00 00       	jmp    804d0b8 <main+0x699>
                test_assert(0 == status, "Test process returned error"); \
        } while (0)

        /* printf("Linker magic: start 0x%p, text end 0x%p, data end 0x%p, bss end 0x%p\n",
               text_start, text_end, data_end, bss_end); */
        test_init();
 804ca4f:	e8 4a 53 00 00       	call   8051d9e <test_init>
        make_rootdir();
 804ca54:	e8 25 fd ff ff       	call   804c77e <make_rootdir>
        syscall_success(chdir(root_dir));
 804ca59:	8b 35 c8 7b 05 08    	mov    0x8057bc8,%esi
 804ca5f:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
 804ca64:	89 04 24             	mov    %eax,(%esp)
 804ca67:	e8 1d 55 00 00       	call   8051f89 <test_errstr>
 804ca6c:	89 c3                	mov    %eax,%ebx
 804ca6e:	c7 04 24 80 7a 05 08 	movl   $0x8057a80,(%esp)
 804ca75:	e8 5a 0f 00 00       	call   804d9d4 <chdir>
 804ca7a:	f7 d0                	not    %eax
 804ca7c:	c1 e8 1f             	shr    $0x1f,%eax
 804ca7f:	0f b6 c0             	movzbl %al,%eax
 804ca82:	89 74 24 18          	mov    %esi,0x18(%esp)
 804ca86:	89 5c 24 14          	mov    %ebx,0x14(%esp)
 804ca8a:	c7 44 24 10 db 43 05 	movl   $0x80543db,0x10(%esp)
 804ca91:	08 
 804ca92:	c7 44 24 0c f6 43 05 	movl   $0x80543f6,0xc(%esp)
 804ca99:	08 
 804ca9a:	c7 44 24 08 dc 02 00 	movl   $0x2dc,0x8(%esp)
 804caa1:	00 
 804caa2:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804caa9:	08 
 804caaa:	89 04 24             	mov    %eax,(%esp)
 804caad:	e8 3e 57 00 00       	call   80521f0 <_test_assert>
        childtest(test_overflow);
 804cab2:	e8 7b 07 00 00       	call   804d232 <fork>
 804cab7:	89 44 24 4c          	mov    %eax,0x4c(%esp)
 804cabb:	83 7c 24 4c 00       	cmpl   $0x0,0x4c(%esp)
 804cac0:	75 0a                	jne    804cacc <main+0xad>
 804cac2:	e8 de b5 ff ff       	call   80480a5 <test_overflow>
 804cac7:	e9 ec 05 00 00       	jmp    804d0b8 <main+0x699>
 804cacc:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cad0:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cad4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cadb:	00 
 804cadc:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 804cae0:	89 04 24             	mov    %eax,(%esp)
 804cae3:	e8 e8 08 00 00       	call   804d3d0 <waitpid>
 804cae8:	8b 44 24 28          	mov    0x28(%esp),%eax
 804caec:	83 f8 0e             	cmp    $0xe,%eax
 804caef:	0f 95 c0             	setne  %al
 804caf2:	0f b6 c0             	movzbl %al,%eax
 804caf5:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cafc:	08 
 804cafd:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cb04:	08 
 804cb05:	c7 44 24 08 dd 02 00 	movl   $0x2dd,0x8(%esp)
 804cb0c:	00 
 804cb0d:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cb14:	08 
 804cb15:	89 04 24             	mov    %eax,(%esp)
 804cb18:	e8 d3 56 00 00       	call   80521f0 <_test_assert>
 804cb1d:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cb21:	85 c0                	test   %eax,%eax
 804cb23:	0f 94 c0             	sete   %al
 804cb26:	0f b6 c0             	movzbl %al,%eax
 804cb29:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cb30:	08 
 804cb31:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cb38:	08 
 804cb39:	c7 44 24 08 dd 02 00 	movl   $0x2dd,0x8(%esp)
 804cb40:	00 
 804cb41:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cb48:	08 
 804cb49:	89 04 24             	mov    %eax,(%esp)
 804cb4c:	e8 9f 56 00 00       	call   80521f0 <_test_assert>
        childtest(test_mmap_bounds);
 804cb51:	e8 dc 06 00 00       	call   804d232 <fork>
 804cb56:	89 44 24 48          	mov    %eax,0x48(%esp)
 804cb5a:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
 804cb5f:	75 0a                	jne    804cb6b <main+0x14c>
 804cb61:	e8 c0 b5 ff ff       	call   8048126 <test_mmap_bounds>
 804cb66:	e9 4d 05 00 00       	jmp    804d0b8 <main+0x699>
 804cb6b:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cb6f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cb73:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cb7a:	00 
 804cb7b:	8b 44 24 48          	mov    0x48(%esp),%eax
 804cb7f:	89 04 24             	mov    %eax,(%esp)
 804cb82:	e8 49 08 00 00       	call   804d3d0 <waitpid>
 804cb87:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cb8b:	83 f8 0e             	cmp    $0xe,%eax
 804cb8e:	0f 95 c0             	setne  %al
 804cb91:	0f b6 c0             	movzbl %al,%eax
 804cb94:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cb9b:	08 
 804cb9c:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cba3:	08 
 804cba4:	c7 44 24 08 de 02 00 	movl   $0x2de,0x8(%esp)
 804cbab:	00 
 804cbac:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cbb3:	08 
 804cbb4:	89 04 24             	mov    %eax,(%esp)
 804cbb7:	e8 34 56 00 00       	call   80521f0 <_test_assert>
 804cbbc:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cbc0:	85 c0                	test   %eax,%eax
 804cbc2:	0f 94 c0             	sete   %al
 804cbc5:	0f b6 c0             	movzbl %al,%eax
 804cbc8:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cbcf:	08 
 804cbd0:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cbd7:	08 
 804cbd8:	c7 44 24 08 de 02 00 	movl   $0x2de,0x8(%esp)
 804cbdf:	00 
 804cbe0:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cbe7:	08 
 804cbe8:	89 04 24             	mov    %eax,(%esp)
 804cbeb:	e8 00 56 00 00       	call   80521f0 <_test_assert>
        childtest(test_brk_bounds);
 804cbf0:	e8 3d 06 00 00       	call   804d232 <fork>
 804cbf5:	89 44 24 44          	mov    %eax,0x44(%esp)
 804cbf9:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
 804cbfe:	75 0a                	jne    804cc0a <main+0x1eb>
 804cc00:	e8 8b c2 ff ff       	call   8048e90 <test_brk_bounds>
 804cc05:	e9 ae 04 00 00       	jmp    804d0b8 <main+0x699>
 804cc0a:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cc0e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cc12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cc19:	00 
 804cc1a:	8b 44 24 44          	mov    0x44(%esp),%eax
 804cc1e:	89 04 24             	mov    %eax,(%esp)
 804cc21:	e8 aa 07 00 00       	call   804d3d0 <waitpid>
 804cc26:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cc2a:	83 f8 0e             	cmp    $0xe,%eax
 804cc2d:	0f 95 c0             	setne  %al
 804cc30:	0f b6 c0             	movzbl %al,%eax
 804cc33:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cc3a:	08 
 804cc3b:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cc42:	08 
 804cc43:	c7 44 24 08 df 02 00 	movl   $0x2df,0x8(%esp)
 804cc4a:	00 
 804cc4b:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cc52:	08 
 804cc53:	89 04 24             	mov    %eax,(%esp)
 804cc56:	e8 95 55 00 00       	call   80521f0 <_test_assert>
 804cc5b:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cc5f:	85 c0                	test   %eax,%eax
 804cc61:	0f 94 c0             	sete   %al
 804cc64:	0f b6 c0             	movzbl %al,%eax
 804cc67:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cc6e:	08 
 804cc6f:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cc76:	08 
 804cc77:	c7 44 24 08 df 02 00 	movl   $0x2df,0x8(%esp)
 804cc7e:	00 
 804cc7f:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cc86:	08 
 804cc87:	89 04 24             	mov    %eax,(%esp)
 804cc8a:	e8 61 55 00 00       	call   80521f0 <_test_assert>
        childtest(test_munmap);
 804cc8f:	e8 9e 05 00 00       	call   804d232 <fork>
 804cc94:	89 44 24 40          	mov    %eax,0x40(%esp)
 804cc98:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
 804cc9d:	75 0a                	jne    804cca9 <main+0x28a>
 804cc9f:	e8 f9 c9 ff ff       	call   804969d <test_munmap>
 804cca4:	e9 0f 04 00 00       	jmp    804d0b8 <main+0x699>
 804cca9:	8d 44 24 28          	lea    0x28(%esp),%eax
 804ccad:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ccb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804ccb8:	00 
 804ccb9:	8b 44 24 40          	mov    0x40(%esp),%eax
 804ccbd:	89 04 24             	mov    %eax,(%esp)
 804ccc0:	e8 0b 07 00 00       	call   804d3d0 <waitpid>
 804ccc5:	8b 44 24 28          	mov    0x28(%esp),%eax
 804ccc9:	83 f8 0e             	cmp    $0xe,%eax
 804cccc:	0f 95 c0             	setne  %al
 804cccf:	0f b6 c0             	movzbl %al,%eax
 804ccd2:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804ccd9:	08 
 804ccda:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cce1:	08 
 804cce2:	c7 44 24 08 e0 02 00 	movl   $0x2e0,0x8(%esp)
 804cce9:	00 
 804ccea:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ccf1:	08 
 804ccf2:	89 04 24             	mov    %eax,(%esp)
 804ccf5:	e8 f6 54 00 00       	call   80521f0 <_test_assert>
 804ccfa:	8b 44 24 28          	mov    0x28(%esp),%eax
 804ccfe:	85 c0                	test   %eax,%eax
 804cd00:	0f 94 c0             	sete   %al
 804cd03:	0f b6 c0             	movzbl %al,%eax
 804cd06:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cd0d:	08 
 804cd0e:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cd15:	08 
 804cd16:	c7 44 24 08 e0 02 00 	movl   $0x2e0,0x8(%esp)
 804cd1d:	00 
 804cd1e:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cd25:	08 
 804cd26:	89 04 24             	mov    %eax,(%esp)
 804cd29:	e8 c2 54 00 00       	call   80521f0 <_test_assert>
        childtest(test_start_brk);
 804cd2e:	e8 ff 04 00 00       	call   804d232 <fork>
 804cd33:	89 44 24 3c          	mov    %eax,0x3c(%esp)
 804cd37:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
 804cd3c:	75 0a                	jne    804cd48 <main+0x329>
 804cd3e:	e8 6a d4 ff ff       	call   804a1ad <test_start_brk>
 804cd43:	e9 70 03 00 00       	jmp    804d0b8 <main+0x699>
 804cd48:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cd4c:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cd50:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cd57:	00 
 804cd58:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 804cd5c:	89 04 24             	mov    %eax,(%esp)
 804cd5f:	e8 6c 06 00 00       	call   804d3d0 <waitpid>
 804cd64:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cd68:	83 f8 0e             	cmp    $0xe,%eax
 804cd6b:	0f 95 c0             	setne  %al
 804cd6e:	0f b6 c0             	movzbl %al,%eax
 804cd71:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cd78:	08 
 804cd79:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cd80:	08 
 804cd81:	c7 44 24 08 e1 02 00 	movl   $0x2e1,0x8(%esp)
 804cd88:	00 
 804cd89:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cd90:	08 
 804cd91:	89 04 24             	mov    %eax,(%esp)
 804cd94:	e8 57 54 00 00       	call   80521f0 <_test_assert>
 804cd99:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cd9d:	85 c0                	test   %eax,%eax
 804cd9f:	0f 94 c0             	sete   %al
 804cda2:	0f b6 c0             	movzbl %al,%eax
 804cda5:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cdac:	08 
 804cdad:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cdb4:	08 
 804cdb5:	c7 44 24 08 e1 02 00 	movl   $0x2e1,0x8(%esp)
 804cdbc:	00 
 804cdbd:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cdc4:	08 
 804cdc5:	89 04 24             	mov    %eax,(%esp)
 804cdc8:	e8 23 54 00 00       	call   80521f0 <_test_assert>
        childtest(test_brk_mmap);
 804cdcd:	e8 60 04 00 00       	call   804d232 <fork>
 804cdd2:	89 44 24 38          	mov    %eax,0x38(%esp)
 804cdd6:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
 804cddb:	75 0a                	jne    804cde7 <main+0x3c8>
 804cddd:	e8 d8 db ff ff       	call   804a9ba <test_brk_mmap>
 804cde2:	e9 d1 02 00 00       	jmp    804d0b8 <main+0x699>
 804cde7:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cdeb:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cdef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cdf6:	00 
 804cdf7:	8b 44 24 38          	mov    0x38(%esp),%eax
 804cdfb:	89 04 24             	mov    %eax,(%esp)
 804cdfe:	e8 cd 05 00 00       	call   804d3d0 <waitpid>
 804ce03:	8b 44 24 28          	mov    0x28(%esp),%eax
 804ce07:	83 f8 0e             	cmp    $0xe,%eax
 804ce0a:	0f 95 c0             	setne  %al
 804ce0d:	0f b6 c0             	movzbl %al,%eax
 804ce10:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804ce17:	08 
 804ce18:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804ce1f:	08 
 804ce20:	c7 44 24 08 e2 02 00 	movl   $0x2e2,0x8(%esp)
 804ce27:	00 
 804ce28:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ce2f:	08 
 804ce30:	89 04 24             	mov    %eax,(%esp)
 804ce33:	e8 b8 53 00 00       	call   80521f0 <_test_assert>
 804ce38:	8b 44 24 28          	mov    0x28(%esp),%eax
 804ce3c:	85 c0                	test   %eax,%eax
 804ce3e:	0f 94 c0             	sete   %al
 804ce41:	0f b6 c0             	movzbl %al,%eax
 804ce44:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804ce4b:	08 
 804ce4c:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804ce53:	08 
 804ce54:	c7 44 24 08 e2 02 00 	movl   $0x2e2,0x8(%esp)
 804ce5b:	00 
 804ce5c:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804ce63:	08 
 804ce64:	89 04 24             	mov    %eax,(%esp)
 804ce67:	e8 84 53 00 00       	call   80521f0 <_test_assert>
        childtest(test_mmap_fill);
 804ce6c:	e8 c1 03 00 00       	call   804d232 <fork>
 804ce71:	89 44 24 34          	mov    %eax,0x34(%esp)
 804ce75:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
 804ce7a:	75 0a                	jne    804ce86 <main+0x467>
 804ce7c:	e8 5f e1 ff ff       	call   804afe0 <test_mmap_fill>
 804ce81:	e9 32 02 00 00       	jmp    804d0b8 <main+0x699>
 804ce86:	8d 44 24 28          	lea    0x28(%esp),%eax
 804ce8a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ce8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804ce95:	00 
 804ce96:	8b 44 24 34          	mov    0x34(%esp),%eax
 804ce9a:	89 04 24             	mov    %eax,(%esp)
 804ce9d:	e8 2e 05 00 00       	call   804d3d0 <waitpid>
 804cea2:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cea6:	83 f8 0e             	cmp    $0xe,%eax
 804cea9:	0f 95 c0             	setne  %al
 804ceac:	0f b6 c0             	movzbl %al,%eax
 804ceaf:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804ceb6:	08 
 804ceb7:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cebe:	08 
 804cebf:	c7 44 24 08 e3 02 00 	movl   $0x2e3,0x8(%esp)
 804cec6:	00 
 804cec7:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cece:	08 
 804cecf:	89 04 24             	mov    %eax,(%esp)
 804ced2:	e8 19 53 00 00       	call   80521f0 <_test_assert>
 804ced7:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cedb:	85 c0                	test   %eax,%eax
 804cedd:	0f 94 c0             	sete   %al
 804cee0:	0f b6 c0             	movzbl %al,%eax
 804cee3:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804ceea:	08 
 804ceeb:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cef2:	08 
 804cef3:	c7 44 24 08 e3 02 00 	movl   $0x2e3,0x8(%esp)
 804cefa:	00 
 804cefb:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cf02:	08 
 804cf03:	89 04 24             	mov    %eax,(%esp)
 804cf06:	e8 e5 52 00 00       	call   80521f0 <_test_assert>
        childtest(test_mmap_repeat);
 804cf0b:	e8 22 03 00 00       	call   804d232 <fork>
 804cf10:	89 44 24 30          	mov    %eax,0x30(%esp)
 804cf14:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
 804cf19:	75 0a                	jne    804cf25 <main+0x506>
 804cf1b:	e8 65 ea ff ff       	call   804b985 <test_mmap_repeat>
 804cf20:	e9 93 01 00 00       	jmp    804d0b8 <main+0x699>
 804cf25:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cf29:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cf2d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cf34:	00 
 804cf35:	8b 44 24 30          	mov    0x30(%esp),%eax
 804cf39:	89 04 24             	mov    %eax,(%esp)
 804cf3c:	e8 8f 04 00 00       	call   804d3d0 <waitpid>
 804cf41:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cf45:	83 f8 0e             	cmp    $0xe,%eax
 804cf48:	0f 95 c0             	setne  %al
 804cf4b:	0f b6 c0             	movzbl %al,%eax
 804cf4e:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cf55:	08 
 804cf56:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cf5d:	08 
 804cf5e:	c7 44 24 08 e4 02 00 	movl   $0x2e4,0x8(%esp)
 804cf65:	00 
 804cf66:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cf6d:	08 
 804cf6e:	89 04 24             	mov    %eax,(%esp)
 804cf71:	e8 7a 52 00 00       	call   80521f0 <_test_assert>
 804cf76:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cf7a:	85 c0                	test   %eax,%eax
 804cf7c:	0f 94 c0             	sete   %al
 804cf7f:	0f b6 c0             	movzbl %al,%eax
 804cf82:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804cf89:	08 
 804cf8a:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804cf91:	08 
 804cf92:	c7 44 24 08 e4 02 00 	movl   $0x2e4,0x8(%esp)
 804cf99:	00 
 804cf9a:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804cfa1:	08 
 804cfa2:	89 04 24             	mov    %eax,(%esp)
 804cfa5:	e8 46 52 00 00       	call   80521f0 <_test_assert>
        childtest(test_mmap_beyond);
 804cfaa:	e8 83 02 00 00       	call   804d232 <fork>
 804cfaf:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 804cfb3:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
 804cfb8:	75 0a                	jne    804cfc4 <main+0x5a5>
 804cfba:	e8 b0 ed ff ff       	call   804bd6f <test_mmap_beyond>
 804cfbf:	e9 f4 00 00 00       	jmp    804d0b8 <main+0x699>
 804cfc4:	8d 44 24 28          	lea    0x28(%esp),%eax
 804cfc8:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cfcc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804cfd3:	00 
 804cfd4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804cfd8:	89 04 24             	mov    %eax,(%esp)
 804cfdb:	e8 f0 03 00 00       	call   804d3d0 <waitpid>
 804cfe0:	8b 44 24 28          	mov    0x28(%esp),%eax
 804cfe4:	83 f8 0e             	cmp    $0xe,%eax
 804cfe7:	0f 95 c0             	setne  %al
 804cfea:	0f b6 c0             	movzbl %al,%eax
 804cfed:	c7 44 24 10 10 44 05 	movl   $0x8054410,0x10(%esp)
 804cff4:	08 
 804cff5:	c7 44 24 0c 31 44 05 	movl   $0x8054431,0xc(%esp)
 804cffc:	08 
 804cffd:	c7 44 24 08 e5 02 00 	movl   $0x2e5,0x8(%esp)
 804d004:	00 
 804d005:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804d00c:	08 
 804d00d:	89 04 24             	mov    %eax,(%esp)
 804d010:	e8 db 51 00 00       	call   80521f0 <_test_assert>
 804d015:	8b 44 24 28          	mov    0x28(%esp),%eax
 804d019:	85 c0                	test   %eax,%eax
 804d01b:	0f 94 c0             	sete   %al
 804d01e:	0f b6 c0             	movzbl %al,%eax
 804d021:	c7 44 24 10 42 44 05 	movl   $0x8054442,0x10(%esp)
 804d028:	08 
 804d029:	c7 44 24 0c 5e 44 05 	movl   $0x805445e,0xc(%esp)
 804d030:	08 
 804d031:	c7 44 24 08 e5 02 00 	movl   $0x2e5,0x8(%esp)
 804d038:	00 
 804d039:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804d040:	08 
 804d041:	89 04 24             	mov    %eax,(%esp)
 804d044:	e8 a7 51 00 00       	call   80521f0 <_test_assert>
        syscall_success(chdir(".."));
 804d049:	8b 35 c8 7b 05 08    	mov    0x8057bc8,%esi
 804d04f:	a1 c8 7b 05 08       	mov    0x8057bc8,%eax
 804d054:	89 04 24             	mov    %eax,(%esp)
 804d057:	e8 2d 4f 00 00       	call   8051f89 <test_errstr>
 804d05c:	89 c3                	mov    %eax,%ebx
 804d05e:	c7 04 24 75 43 05 08 	movl   $0x8054375,(%esp)
 804d065:	e8 6a 09 00 00       	call   804d9d4 <chdir>
 804d06a:	f7 d0                	not    %eax
 804d06c:	c1 e8 1f             	shr    $0x1f,%eax
 804d06f:	0f b6 c0             	movzbl %al,%eax
 804d072:	89 74 24 18          	mov    %esi,0x18(%esp)
 804d076:	89 5c 24 14          	mov    %ebx,0x14(%esp)
 804d07a:	c7 44 24 10 db 43 05 	movl   $0x80543db,0x10(%esp)
 804d081:	08 
 804d082:	c7 44 24 0c 6a 44 05 	movl   $0x805446a,0xc(%esp)
 804d089:	08 
 804d08a:	c7 44 24 08 e6 02 00 	movl   $0x2e6,0x8(%esp)
 804d091:	00 
 804d092:	c7 44 24 04 ea 22 05 	movl   $0x80522ea,0x4(%esp)
 804d099:	08 
 804d09a:	89 04 24             	mov    %eax,(%esp)
 804d09d:	e8 4e 51 00 00       	call   80521f0 <_test_assert>
        destroy_rootdir();
 804d0a2:	e8 0f f9 ff ff       	call   804c9b6 <destroy_rootdir>
        test_fini(NULL);
 804d0a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804d0ae:	e8 28 4e 00 00       	call   8051edb <test_fini>

        return 0;
 804d0b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804d0b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804d0bb:	5b                   	pop    %ebx
 804d0bc:	5e                   	pop    %esi
 804d0bd:	5d                   	pop    %ebp
 804d0be:	c3                   	ret    

0804d0bf <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 804d0bf:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 804d0c2:	e8 58 f9 ff ff       	call   804ca1f <main>
	push %eax; /* Argument to exit is return value from main */
 804d0c7:	50                   	push   %eax
	call exit;
 804d0c8:	e8 21 02 00 00       	call   804d2ee <exit>

0804d0cd <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 804d0cd:	55                   	push   %ebp
 804d0ce:	89 e5                	mov    %esp,%ebp
 804d0d0:	83 ec 10             	sub    $0x10,%esp
 804d0d3:	e8 7d 0d 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d0d8:	81 c1 34 a8 00 00    	add    $0xa834,%ecx
        int ret;
        __asm__ volatile(
 804d0de:	8b 45 08             	mov    0x8(%ebp),%eax
 804d0e1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804d0e4:	cd 2e                	int    $0x2e
 804d0e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d0e9:	b8 27 00 00 00       	mov    $0x27,%eax
 804d0ee:	cd 2e                	int    $0x2e
 804d0f0:	89 c2                	mov    %eax,%edx
 804d0f2:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d0f8:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d0fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804d0fd:	c9                   	leave  
 804d0fe:	c3                   	ret    

0804d0ff <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 804d0ff:	55                   	push   %ebp
 804d100:	89 e5                	mov    %esp,%ebp
 804d102:	53                   	push   %ebx
 804d103:	83 ec 24             	sub    $0x24,%esp
 804d106:	e8 4a 0d 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d10b:	81 c1 01 a8 00 00    	add    $0xa801,%ecx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 804d111:	8b 81 b4 01 00 00    	mov    0x1b4(%ecx),%eax
 804d117:	85 c0                	test   %eax,%eax
 804d119:	75 44                	jne    804d15f <sbrk+0x60>
 804d11b:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 804d122:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d129:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d12c:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d12f:	cd 2e                	int    $0x2e
 804d131:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d134:	b8 27 00 00 00       	mov    $0x27,%eax
 804d139:	cd 2e                	int    $0x2e
 804d13b:	89 c2                	mov    %eax,%edx
 804d13d:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d143:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d145:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 804d148:	89 81 b4 01 00 00    	mov    %eax,0x1b4(%ecx)
 804d14e:	8b 81 b4 01 00 00    	mov    0x1b4(%ecx),%eax
 804d154:	85 c0                	test   %eax,%eax
 804d156:	79 07                	jns    804d15f <sbrk+0x60>
                        return (void *) -1;
 804d158:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d15d:	eb 63                	jmp    804d1c2 <sbrk+0xc3>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 804d15f:	8b 81 b4 01 00 00    	mov    0x1b4(%ecx),%eax
 804d165:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 804d168:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d16c:	79 2e                	jns    804d19c <sbrk+0x9d>
                if ((uintptr_t) - incr > oldbrk) {
 804d16e:	8b 45 08             	mov    0x8(%ebp),%eax
 804d171:	f7 d8                	neg    %eax
 804d173:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804d176:	76 07                	jbe    804d17f <sbrk+0x80>
                        return (void *) -1;
 804d178:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d17d:	eb 43                	jmp    804d1c2 <sbrk+0xc3>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 804d17f:	8b 55 08             	mov    0x8(%ebp),%edx
 804d182:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d185:	01 d0                	add    %edx,%eax
 804d187:	89 04 24             	mov    %eax,(%esp)
 804d18a:	89 cb                	mov    %ecx,%ebx
 804d18c:	e8 37 00 00 00       	call   804d1c8 <brk>
 804d191:	85 c0                	test   %eax,%eax
 804d193:	79 2a                	jns    804d1bf <sbrk+0xc0>
                        return (void *) -1;
 804d195:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d19a:	eb 26                	jmp    804d1c2 <sbrk+0xc3>
                }
        } else if (incr > 0) {
 804d19c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d1a0:	7e 1d                	jle    804d1bf <sbrk+0xc0>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 804d1a2:	8b 55 08             	mov    0x8(%ebp),%edx
 804d1a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d1a8:	01 d0                	add    %edx,%eax
 804d1aa:	89 04 24             	mov    %eax,(%esp)
 804d1ad:	89 cb                	mov    %ecx,%ebx
 804d1af:	e8 14 00 00 00       	call   804d1c8 <brk>
 804d1b4:	85 c0                	test   %eax,%eax
 804d1b6:	79 07                	jns    804d1bf <sbrk+0xc0>
                        return (void *) -1;
 804d1b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d1bd:	eb 03                	jmp    804d1c2 <sbrk+0xc3>
                }
        }
        return (void *) oldbrk;
 804d1bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d1c2:	83 c4 24             	add    $0x24,%esp
 804d1c5:	5b                   	pop    %ebx
 804d1c6:	5d                   	pop    %ebp
 804d1c7:	c3                   	ret    

0804d1c8 <brk>:

int brk(void *addr)
{
 804d1c8:	55                   	push   %ebp
 804d1c9:	89 e5                	mov    %esp,%ebp
 804d1cb:	83 ec 10             	sub    $0x10,%esp
 804d1ce:	e8 82 0c 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d1d3:	81 c1 39 a7 00 00    	add    $0xa739,%ecx
        if (NULL == addr)
 804d1d9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d1dd:	75 07                	jne    804d1e6 <brk+0x1e>
                return -1;
 804d1df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d1e4:	eb 4a                	jmp    804d230 <brk+0x68>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 804d1e6:	8b 45 08             	mov    0x8(%ebp),%eax
 804d1e9:	c7 45 f8 2c 00 00 00 	movl   $0x2c,-0x8(%ebp)
 804d1f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d1f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804d1f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d1f9:	cd 2e                	int    $0x2e
 804d1fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d1fe:	b8 27 00 00 00       	mov    $0x27,%eax
 804d203:	cd 2e                	int    $0x2e
 804d205:	89 c2                	mov    %eax,%edx
 804d207:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d20d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d212:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if (newbrk == (void *) -1)
 804d215:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
 804d219:	75 07                	jne    804d222 <brk+0x5a>
                return -1;
 804d21b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804d220:	eb 0e                	jmp    804d230 <brk+0x68>
        __curbrk = newbrk;
 804d222:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d225:	89 81 b4 01 00 00    	mov    %eax,0x1b4(%ecx)
        return 0;
 804d22b:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804d230:	c9                   	leave  
 804d231:	c3                   	ret    

0804d232 <fork>:

int fork(void)
{
 804d232:	55                   	push   %ebp
 804d233:	89 e5                	mov    %esp,%ebp
 804d235:	83 ec 10             	sub    $0x10,%esp
 804d238:	e8 18 0c 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d23d:	81 c1 cf a6 00 00    	add    $0xa6cf,%ecx
 804d243:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
 804d24a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d251:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d254:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d257:	cd 2e                	int    $0x2e
 804d259:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d25c:	b8 27 00 00 00       	mov    $0x27,%eax
 804d261:	cd 2e                	int    $0x2e
 804d263:	89 c2                	mov    %eax,%edx
 804d265:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d26b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d26d:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_fork, 0);
 804d270:	90                   	nop
}
 804d271:	c9                   	leave  
 804d272:	c3                   	ret    

0804d273 <atexit>:

int atexit(void (*func)(void))
{
 804d273:	55                   	push   %ebp
 804d274:	89 e5                	mov    %esp,%ebp
 804d276:	e8 d6 0b 00 00       	call   804de51 <__x86.get_pc_thunk.ax>
 804d27b:	05 91 a6 00 00       	add    $0xa691,%eax
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 804d280:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
 804d286:	83 fa 1f             	cmp    $0x1f,%edx
 804d289:	7f 20                	jg     804d2ab <atexit+0x38>
                atexit_func[atexit_handlers++] = func;
 804d28b:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
 804d291:	8d 4a 01             	lea    0x1(%edx),%ecx
 804d294:	89 88 54 02 00 00    	mov    %ecx,0x254(%eax)
 804d29a:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804d29d:	89 8c 90 d4 01 00 00 	mov    %ecx,0x1d4(%eax,%edx,4)
                return 0;
 804d2a4:	b8 00 00 00 00       	mov    $0x0,%eax
 804d2a9:	eb 05                	jmp    804d2b0 <atexit+0x3d>
        }

        return 1;
 804d2ab:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804d2b0:	5d                   	pop    %ebp
 804d2b1:	c3                   	ret    

0804d2b2 <_exit>:

void _exit(int status)
{
 804d2b2:	55                   	push   %ebp
 804d2b3:	89 e5                	mov    %esp,%ebp
 804d2b5:	83 ec 10             	sub    $0x10,%esp
 804d2b8:	e8 98 0b 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d2bd:	81 c1 4f a6 00 00    	add    $0xa64f,%ecx
        trap(SYS_exit, (uint32_t) status);
 804d2c3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d2c6:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
 804d2cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d2d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d2d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d2d6:	cd 2e                	int    $0x2e
 804d2d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d2db:	b8 27 00 00 00       	mov    $0x27,%eax
 804d2e0:	cd 2e                	int    $0x2e
 804d2e2:	89 c2                	mov    %eax,%edx
 804d2e4:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d2ea:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 804d2ec:	eb fe                	jmp    804d2ec <_exit+0x3a>

0804d2ee <exit>:
}

void exit(int status)
{
 804d2ee:	55                   	push   %ebp
 804d2ef:	89 e5                	mov    %esp,%ebp
 804d2f1:	53                   	push   %ebx
 804d2f2:	83 ec 14             	sub    $0x14,%esp
 804d2f5:	e8 5f 0b 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d2fa:	81 c3 12 a6 00 00    	add    $0xa612,%ebx
        while (atexit_handlers--) {
 804d300:	eb 0f                	jmp    804d311 <exit+0x23>
                atexit_func[atexit_handlers]();
 804d302:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804d308:	8b 84 83 d4 01 00 00 	mov    0x1d4(%ebx,%eax,4),%eax
 804d30f:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 804d311:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804d317:	8d 50 ff             	lea    -0x1(%eax),%edx
 804d31a:	89 93 54 02 00 00    	mov    %edx,0x254(%ebx)
 804d320:	85 c0                	test   %eax,%eax
 804d322:	75 de                	jne    804d302 <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 804d324:	8b 45 08             	mov    0x8(%ebp),%eax
 804d327:	89 04 24             	mov    %eax,(%esp)
 804d32a:	e8 83 ff ff ff       	call   804d2b2 <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 804d32f:	8b 45 08             	mov    0x8(%ebp),%eax
 804d332:	89 04 24             	mov    %eax,(%esp)
 804d335:	e8 b4 ff ff ff       	call   804d2ee <exit>
}
 804d33a:	90                   	nop
 804d33b:	83 c4 14             	add    $0x14,%esp
 804d33e:	5b                   	pop    %ebx
 804d33f:	5d                   	pop    %ebp
 804d340:	c3                   	ret    

0804d341 <yield>:

void yield(void)
{
 804d341:	55                   	push   %ebp
 804d342:	89 e5                	mov    %esp,%ebp
 804d344:	53                   	push   %ebx
 804d345:	83 ec 14             	sub    $0x14,%esp
 804d348:	e8 0c 0b 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d34d:	81 c3 bf a5 00 00    	add    $0xa5bf,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 804d353:	e8 da fe ff ff       	call   804d232 <fork>
 804d358:	85 c0                	test   %eax,%eax
 804d35a:	74 0e                	je     804d36a <yield+0x29>
 804d35c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804d363:	e8 15 00 00 00       	call   804d37d <wait>
}
 804d368:	eb 0c                	jmp    804d376 <yield+0x35>
void yield(void)
{
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 804d36a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804d371:	e8 78 ff ff ff       	call   804d2ee <exit>
}
 804d376:	90                   	nop
 804d377:	83 c4 14             	add    $0x14,%esp
 804d37a:	5b                   	pop    %ebx
 804d37b:	5d                   	pop    %ebp
 804d37c:	c3                   	ret    

0804d37d <wait>:

pid_t wait(int *status)
{
 804d37d:	55                   	push   %ebp
 804d37e:	89 e5                	mov    %esp,%ebp
 804d380:	83 ec 20             	sub    $0x20,%esp
 804d383:	e8 cd 0a 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d388:	81 c1 84 a5 00 00    	add    $0xa584,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 804d38e:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        args.wpa_options = 0;
 804d395:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        args.wpa_status = status;
 804d39c:	8b 45 08             	mov    0x8(%ebp),%eax
 804d39f:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 804d3a2:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804d3a5:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 804d3ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d3af:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d3b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d3b5:	cd 2e                	int    $0x2e
 804d3b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d3ba:	b8 27 00 00 00       	mov    $0x27,%eax
 804d3bf:	cd 2e                	int    $0x2e
 804d3c1:	89 c2                	mov    %eax,%edx
 804d3c3:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d3c9:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d3cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d3ce:	c9                   	leave  
 804d3cf:	c3                   	ret    

0804d3d0 <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 804d3d0:	55                   	push   %ebp
 804d3d1:	89 e5                	mov    %esp,%ebp
 804d3d3:	83 ec 20             	sub    $0x20,%esp
 804d3d6:	e8 7a 0a 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d3db:	81 c1 31 a5 00 00    	add    $0xa531,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 804d3e1:	8b 45 08             	mov    0x8(%ebp),%eax
 804d3e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_options = options;
 804d3e7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d3ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.wpa_status = status;
 804d3ed:	8b 45 10             	mov    0x10(%ebp),%eax
 804d3f0:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 804d3f3:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804d3f6:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 804d3fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d400:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d403:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d406:	cd 2e                	int    $0x2e
 804d408:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d40b:	b8 27 00 00 00       	mov    $0x27,%eax
 804d410:	cd 2e                	int    $0x2e
 804d412:	89 c2                	mov    %eax,%edx
 804d414:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d41a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d41c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d41f:	c9                   	leave  
 804d420:	c3                   	ret    

0804d421 <thr_exit>:

void thr_exit(int status)
{
 804d421:	55                   	push   %ebp
 804d422:	89 e5                	mov    %esp,%ebp
 804d424:	83 ec 10             	sub    $0x10,%esp
 804d427:	e8 29 0a 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d42c:	81 c1 e0 a4 00 00    	add    $0xa4e0,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 804d432:	8b 45 08             	mov    0x8(%ebp),%eax
 804d435:	c7 45 fc 1f 00 00 00 	movl   $0x1f,-0x4(%ebp)
 804d43c:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d43f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d442:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d445:	cd 2e                	int    $0x2e
 804d447:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d44a:	b8 27 00 00 00       	mov    $0x27,%eax
 804d44f:	cd 2e                	int    $0x2e
 804d451:	89 c2                	mov    %eax,%edx
 804d453:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d459:	89 10                	mov    %edx,(%eax)
}
 804d45b:	90                   	nop
 804d45c:	c9                   	leave  
 804d45d:	c3                   	ret    

0804d45e <getpid>:

pid_t getpid(void)
{
 804d45e:	55                   	push   %ebp
 804d45f:	89 e5                	mov    %esp,%ebp
 804d461:	83 ec 10             	sub    $0x10,%esp
 804d464:	e8 ec 09 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d469:	81 c1 a3 a4 00 00    	add    $0xa4a3,%ecx
 804d46f:	c7 45 fc 23 00 00 00 	movl   $0x23,-0x4(%ebp)
 804d476:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d47d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d480:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d483:	cd 2e                	int    $0x2e
 804d485:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d488:	b8 27 00 00 00       	mov    $0x27,%eax
 804d48d:	cd 2e                	int    $0x2e
 804d48f:	89 c2                	mov    %eax,%edx
 804d491:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d497:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d499:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_getpid, 0);
 804d49c:	90                   	nop
}
 804d49d:	c9                   	leave  
 804d49e:	c3                   	ret    

0804d49f <halt>:

int halt(void)
{
 804d49f:	55                   	push   %ebp
 804d4a0:	89 e5                	mov    %esp,%ebp
 804d4a2:	83 ec 10             	sub    $0x10,%esp
 804d4a5:	e8 ab 09 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d4aa:	81 c1 62 a4 00 00    	add    $0xa462,%ecx
 804d4b0:	c7 45 fc 28 00 00 00 	movl   $0x28,-0x4(%ebp)
 804d4b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d4be:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d4c1:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d4c4:	cd 2e                	int    $0x2e
 804d4c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d4c9:	b8 27 00 00 00       	mov    $0x27,%eax
 804d4ce:	cd 2e                	int    $0x2e
 804d4d0:	89 c2                	mov    %eax,%edx
 804d4d2:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d4d8:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d4da:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_halt, 0);
 804d4dd:	90                   	nop
}
 804d4de:	c9                   	leave  
 804d4df:	c3                   	ret    

0804d4e0 <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 804d4e0:	55                   	push   %ebp
 804d4e1:	89 e5                	mov    %esp,%ebp
 804d4e3:	83 ec 30             	sub    $0x30,%esp
 804d4e6:	e8 6a 09 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d4eb:	81 c1 21 a4 00 00    	add    $0xa421,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 804d4f1:	8b 45 08             	mov    0x8(%ebp),%eax
 804d4f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_len = len;
 804d4f7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d4fa:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_prot = prot;
 804d4fd:	8b 45 10             	mov    0x10(%ebp),%eax
 804d500:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_flags = flags;
 804d503:	8b 45 14             	mov    0x14(%ebp),%eax
 804d506:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_fd = fd;
 804d509:	8b 45 18             	mov    0x18(%ebp),%eax
 804d50c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.mma_off = off;
 804d50f:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804d512:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 804d515:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804d518:	c7 45 fc 18 00 00 00 	movl   $0x18,-0x4(%ebp)
 804d51f:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d522:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d525:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d528:	cd 2e                	int    $0x2e
 804d52a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d52d:	b8 27 00 00 00       	mov    $0x27,%eax
 804d532:	cd 2e                	int    $0x2e
 804d534:	89 c2                	mov    %eax,%edx
 804d536:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d53c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d53e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d541:	c9                   	leave  
 804d542:	c3                   	ret    

0804d543 <munmap>:

int munmap(void *addr, size_t len)
{
 804d543:	55                   	push   %ebp
 804d544:	89 e5                	mov    %esp,%ebp
 804d546:	83 ec 20             	sub    $0x20,%esp
 804d549:	e8 07 09 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d54e:	81 c1 be a3 00 00    	add    $0xa3be,%ecx
        munmap_args_t args;

        args.addr = addr;
 804d554:	8b 45 08             	mov    0x8(%ebp),%eax
 804d557:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.len = len;
 804d55a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d55d:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 804d560:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804d563:	c7 45 fc 1a 00 00 00 	movl   $0x1a,-0x4(%ebp)
 804d56a:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d56d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d570:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d573:	cd 2e                	int    $0x2e
 804d575:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d578:	b8 27 00 00 00       	mov    $0x27,%eax
 804d57d:	cd 2e                	int    $0x2e
 804d57f:	89 c2                	mov    %eax,%edx
 804d581:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d587:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d589:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d58c:	c9                   	leave  
 804d58d:	c3                   	ret    

0804d58e <sync>:

void sync(void)
{
 804d58e:	55                   	push   %ebp
 804d58f:	89 e5                	mov    %esp,%ebp
 804d591:	83 ec 10             	sub    $0x10,%esp
 804d594:	e8 bc 08 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d599:	81 c1 73 a3 00 00    	add    $0xa373,%ecx
 804d59f:	c7 45 fc 0f 00 00 00 	movl   $0xf,-0x4(%ebp)
 804d5a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d5ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d5b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d5b3:	cd 2e                	int    $0x2e
 804d5b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d5b8:	b8 27 00 00 00       	mov    $0x27,%eax
 804d5bd:	cd 2e                	int    $0x2e
 804d5bf:	89 c2                	mov    %eax,%edx
 804d5c1:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d5c7:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 804d5c9:	90                   	nop
 804d5ca:	c9                   	leave  
 804d5cb:	c3                   	ret    

0804d5cc <open>:

int open(const char *filename, int flags, int mode)
{
 804d5cc:	55                   	push   %ebp
 804d5cd:	89 e5                	mov    %esp,%ebp
 804d5cf:	53                   	push   %ebx
 804d5d0:	83 ec 34             	sub    $0x34,%esp
 804d5d3:	e8 81 08 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d5d8:	81 c3 34 a3 00 00    	add    $0xa334,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 804d5de:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5e1:	89 04 24             	mov    %eax,(%esp)
 804d5e4:	e8 e1 0a 00 00       	call   804e0ca <strlen>
 804d5e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 804d5ec:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 804d5f2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d5f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 804d5f8:	8b 45 10             	mov    0x10(%ebp),%eax
 804d5fb:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 804d5fe:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804d601:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 804d608:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d60b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d60e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d611:	cd 2e                	int    $0x2e
 804d613:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d616:	b8 27 00 00 00       	mov    $0x27,%eax
 804d61b:	cd 2e                	int    $0x2e
 804d61d:	89 c2                	mov    %eax,%edx
 804d61f:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d625:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d627:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d62a:	83 c4 34             	add    $0x34,%esp
 804d62d:	5b                   	pop    %ebx
 804d62e:	5d                   	pop    %ebp
 804d62f:	c3                   	ret    

0804d630 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 804d630:	55                   	push   %ebp
 804d631:	89 e5                	mov    %esp,%ebp
 804d633:	83 ec 20             	sub    $0x20,%esp
 804d636:	e8 1a 08 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d63b:	81 c1 d1 a2 00 00    	add    $0xa2d1,%ecx
        lseek_args_t args;

        args.fd = fd;
 804d641:	8b 45 08             	mov    0x8(%ebp),%eax
 804d644:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.offset = offset;
 804d647:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d64a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.whence = whence;
 804d64d:	8b 45 10             	mov    0x10(%ebp),%eax
 804d650:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 804d653:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804d656:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%ebp)
 804d65d:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d660:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d663:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d666:	cd 2e                	int    $0x2e
 804d668:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d66b:	b8 27 00 00 00       	mov    $0x27,%eax
 804d670:	cd 2e                	int    $0x2e
 804d672:	89 c2                	mov    %eax,%edx
 804d674:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d67a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d67c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d67f:	c9                   	leave  
 804d680:	c3                   	ret    

0804d681 <read>:


int read(int fd, void *buf, size_t nbytes)
{
 804d681:	55                   	push   %ebp
 804d682:	89 e5                	mov    %esp,%ebp
 804d684:	83 ec 20             	sub    $0x20,%esp
 804d687:	e8 c9 07 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d68c:	81 c1 80 a2 00 00    	add    $0xa280,%ecx
        read_args_t args;

        args.fd = fd;
 804d692:	8b 45 08             	mov    0x8(%ebp),%eax
 804d695:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = buf;
 804d698:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d69b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 804d69e:	8b 45 10             	mov    0x10(%ebp),%eax
 804d6a1:	89 45 f0             	mov    %eax,-0x10(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 804d6a4:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804d6a7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
 804d6ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d6b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d6b4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d6b7:	cd 2e                	int    $0x2e
 804d6b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d6bc:	b8 27 00 00 00       	mov    $0x27,%eax
 804d6c1:	cd 2e                	int    $0x2e
 804d6c3:	89 c2                	mov    %eax,%edx
 804d6c5:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d6cb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d6cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d6d0:	c9                   	leave  
 804d6d1:	c3                   	ret    

0804d6d2 <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 804d6d2:	55                   	push   %ebp
 804d6d3:	89 e5                	mov    %esp,%ebp
 804d6d5:	83 ec 20             	sub    $0x20,%esp
 804d6d8:	e8 78 07 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d6dd:	81 c1 2f a2 00 00    	add    $0xa22f,%ecx
        write_args_t args;

        args.fd = fd;
 804d6e3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d6e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = (void *) buf;
 804d6e9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d6ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 804d6ef:	8b 45 10             	mov    0x10(%ebp),%eax
 804d6f2:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 804d6f5:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804d6f8:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
 804d6ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d702:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d705:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d708:	cd 2e                	int    $0x2e
 804d70a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d70d:	b8 27 00 00 00       	mov    $0x27,%eax
 804d712:	cd 2e                	int    $0x2e
 804d714:	89 c2                	mov    %eax,%edx
 804d716:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d71c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d71e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d721:	c9                   	leave  
 804d722:	c3                   	ret    

0804d723 <close>:

int close(int fd)
{
 804d723:	55                   	push   %ebp
 804d724:	89 e5                	mov    %esp,%ebp
 804d726:	83 ec 10             	sub    $0x10,%esp
 804d729:	e8 27 07 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d72e:	81 c1 de a1 00 00    	add    $0xa1de,%ecx
        return trap(SYS_close, (uint32_t) fd);
 804d734:	8b 45 08             	mov    0x8(%ebp),%eax
 804d737:	c7 45 fc 06 00 00 00 	movl   $0x6,-0x4(%ebp)
 804d73e:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d741:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d744:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d747:	cd 2e                	int    $0x2e
 804d749:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d74c:	b8 27 00 00 00       	mov    $0x27,%eax
 804d751:	cd 2e                	int    $0x2e
 804d753:	89 c2                	mov    %eax,%edx
 804d755:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d75b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d75d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d760:	90                   	nop
}
 804d761:	c9                   	leave  
 804d762:	c3                   	ret    

0804d763 <dup>:

int dup(int fd)
{
 804d763:	55                   	push   %ebp
 804d764:	89 e5                	mov    %esp,%ebp
 804d766:	83 ec 10             	sub    $0x10,%esp
 804d769:	e8 e7 06 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d76e:	81 c1 9e a1 00 00    	add    $0xa19e,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 804d774:	8b 45 08             	mov    0x8(%ebp),%eax
 804d777:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
 804d77e:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d781:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d784:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d787:	cd 2e                	int    $0x2e
 804d789:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d78c:	b8 27 00 00 00       	mov    $0x27,%eax
 804d791:	cd 2e                	int    $0x2e
 804d793:	89 c2                	mov    %eax,%edx
 804d795:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d79b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d79d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d7a0:	90                   	nop
}
 804d7a1:	c9                   	leave  
 804d7a2:	c3                   	ret    

0804d7a3 <dup2>:

int dup2(int ofd, int nfd)
{
 804d7a3:	55                   	push   %ebp
 804d7a4:	89 e5                	mov    %esp,%ebp
 804d7a6:	83 ec 20             	sub    $0x20,%esp
 804d7a9:	e8 a7 06 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804d7ae:	81 c1 5e a1 00 00    	add    $0xa15e,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 804d7b4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d7b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nfd = nfd;
 804d7ba:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d7bd:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 804d7c0:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804d7c3:	c7 45 fc 2b 00 00 00 	movl   $0x2b,-0x4(%ebp)
 804d7ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d7cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d7d0:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804d7d3:	cd 2e                	int    $0x2e
 804d7d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d7d8:	b8 27 00 00 00       	mov    $0x27,%eax
 804d7dd:	cd 2e                	int    $0x2e
 804d7df:	89 c2                	mov    %eax,%edx
 804d7e1:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d7e7:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d7e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d7ec:	c9                   	leave  
 804d7ed:	c3                   	ret    

0804d7ee <mkdir>:

int mkdir(const char *path, int mode)
{
 804d7ee:	55                   	push   %ebp
 804d7ef:	89 e5                	mov    %esp,%ebp
 804d7f1:	53                   	push   %ebx
 804d7f2:	83 ec 34             	sub    $0x34,%esp
 804d7f5:	e8 5f 06 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d7fa:	81 c3 12 a1 00 00    	add    $0xa112,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 804d800:	8b 45 08             	mov    0x8(%ebp),%eax
 804d803:	89 04 24             	mov    %eax,(%esp)
 804d806:	e8 bf 08 00 00       	call   804e0ca <strlen>
 804d80b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 804d80e:	8b 45 08             	mov    0x8(%ebp),%eax
 804d811:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 804d814:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d817:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 804d81a:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804d81d:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 804d824:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d827:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d82a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d82d:	cd 2e                	int    $0x2e
 804d82f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d832:	b8 27 00 00 00       	mov    $0x27,%eax
 804d837:	cd 2e                	int    $0x2e
 804d839:	89 c2                	mov    %eax,%edx
 804d83b:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d841:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d843:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d846:	83 c4 34             	add    $0x34,%esp
 804d849:	5b                   	pop    %ebx
 804d84a:	5d                   	pop    %ebp
 804d84b:	c3                   	ret    

0804d84c <rmdir>:

int rmdir(const char *path)
{
 804d84c:	55                   	push   %ebp
 804d84d:	89 e5                	mov    %esp,%ebp
 804d84f:	53                   	push   %ebx
 804d850:	83 ec 34             	sub    $0x34,%esp
 804d853:	e8 01 06 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d858:	81 c3 b4 a0 00 00    	add    $0xa0b4,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 804d85e:	8b 45 08             	mov    0x8(%ebp),%eax
 804d861:	89 04 24             	mov    %eax,(%esp)
 804d864:	e8 61 08 00 00       	call   804e0ca <strlen>
 804d869:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 804d86c:	8b 45 08             	mov    0x8(%ebp),%eax
 804d86f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 804d872:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804d875:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 804d87c:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d87f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d882:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d885:	cd 2e                	int    $0x2e
 804d887:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d88a:	b8 27 00 00 00       	mov    $0x27,%eax
 804d88f:	cd 2e                	int    $0x2e
 804d891:	89 c2                	mov    %eax,%edx
 804d893:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d899:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d89b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d89e:	83 c4 34             	add    $0x34,%esp
 804d8a1:	5b                   	pop    %ebx
 804d8a2:	5d                   	pop    %ebp
 804d8a3:	c3                   	ret    

0804d8a4 <unlink>:

int unlink(const char *path)
{
 804d8a4:	55                   	push   %ebp
 804d8a5:	89 e5                	mov    %esp,%ebp
 804d8a7:	53                   	push   %ebx
 804d8a8:	83 ec 34             	sub    $0x34,%esp
 804d8ab:	e8 a9 05 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d8b0:	81 c3 5c a0 00 00    	add    $0xa05c,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 804d8b6:	8b 45 08             	mov    0x8(%ebp),%eax
 804d8b9:	89 04 24             	mov    %eax,(%esp)
 804d8bc:	e8 09 08 00 00       	call   804e0ca <strlen>
 804d8c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 804d8c4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d8c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 804d8ca:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804d8cd:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 804d8d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d8d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d8da:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d8dd:	cd 2e                	int    $0x2e
 804d8df:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d8e2:	b8 27 00 00 00       	mov    $0x27,%eax
 804d8e7:	cd 2e                	int    $0x2e
 804d8e9:	89 c2                	mov    %eax,%edx
 804d8eb:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d8f1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d8f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d8f6:	83 c4 34             	add    $0x34,%esp
 804d8f9:	5b                   	pop    %ebx
 804d8fa:	5d                   	pop    %ebp
 804d8fb:	c3                   	ret    

0804d8fc <link>:

int link(const char *from, const char *to)
{
 804d8fc:	55                   	push   %ebp
 804d8fd:	89 e5                	mov    %esp,%ebp
 804d8ff:	53                   	push   %ebx
 804d900:	83 ec 34             	sub    $0x34,%esp
 804d903:	e8 51 05 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d908:	81 c3 04 a0 00 00    	add    $0xa004,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 804d90e:	8b 45 08             	mov    0x8(%ebp),%eax
 804d911:	89 04 24             	mov    %eax,(%esp)
 804d914:	e8 b1 07 00 00       	call   804e0ca <strlen>
 804d919:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 804d91c:	8b 45 08             	mov    0x8(%ebp),%eax
 804d91f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 804d922:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d925:	89 04 24             	mov    %eax,(%esp)
 804d928:	e8 9d 07 00 00       	call   804e0ca <strlen>
 804d92d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 804d930:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d933:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 804d936:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804d939:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 804d940:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d943:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d946:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d949:	cd 2e                	int    $0x2e
 804d94b:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d94e:	b8 27 00 00 00       	mov    $0x27,%eax
 804d953:	cd 2e                	int    $0x2e
 804d955:	89 c2                	mov    %eax,%edx
 804d957:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d95d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d95f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d962:	83 c4 34             	add    $0x34,%esp
 804d965:	5b                   	pop    %ebx
 804d966:	5d                   	pop    %ebp
 804d967:	c3                   	ret    

0804d968 <rename>:

int rename(const char *oldname, const char *newname)
{
 804d968:	55                   	push   %ebp
 804d969:	89 e5                	mov    %esp,%ebp
 804d96b:	53                   	push   %ebx
 804d96c:	83 ec 34             	sub    $0x34,%esp
 804d96f:	e8 e5 04 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d974:	81 c3 98 9f 00 00    	add    $0x9f98,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 804d97a:	8b 45 08             	mov    0x8(%ebp),%eax
 804d97d:	89 04 24             	mov    %eax,(%esp)
 804d980:	e8 45 07 00 00       	call   804e0ca <strlen>
 804d985:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 804d988:	8b 45 08             	mov    0x8(%ebp),%eax
 804d98b:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 804d98e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d991:	89 04 24             	mov    %eax,(%esp)
 804d994:	e8 31 07 00 00       	call   804e0ca <strlen>
 804d999:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 804d99c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d99f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 804d9a2:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804d9a5:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 804d9ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804d9af:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d9b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d9b5:	cd 2e                	int    $0x2e
 804d9b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804d9ba:	b8 27 00 00 00       	mov    $0x27,%eax
 804d9bf:	cd 2e                	int    $0x2e
 804d9c1:	89 c2                	mov    %eax,%edx
 804d9c3:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804d9c9:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804d9cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804d9ce:	83 c4 34             	add    $0x34,%esp
 804d9d1:	5b                   	pop    %ebx
 804d9d2:	5d                   	pop    %ebp
 804d9d3:	c3                   	ret    

0804d9d4 <chdir>:

int chdir(const char *path)
{
 804d9d4:	55                   	push   %ebp
 804d9d5:	89 e5                	mov    %esp,%ebp
 804d9d7:	53                   	push   %ebx
 804d9d8:	83 ec 34             	sub    $0x34,%esp
 804d9db:	e8 79 04 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804d9e0:	81 c3 2c 9f 00 00    	add    $0x9f2c,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 804d9e6:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9e9:	89 04 24             	mov    %eax,(%esp)
 804d9ec:	e8 d9 06 00 00       	call   804e0ca <strlen>
 804d9f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 804d9f4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 804d9fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804d9fd:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 804da04:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804da07:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804da0a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804da0d:	cd 2e                	int    $0x2e
 804da0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804da12:	b8 27 00 00 00       	mov    $0x27,%eax
 804da17:	cd 2e                	int    $0x2e
 804da19:	89 c2                	mov    %eax,%edx
 804da1b:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804da21:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804da23:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804da26:	83 c4 34             	add    $0x34,%esp
 804da29:	5b                   	pop    %ebx
 804da2a:	5d                   	pop    %ebp
 804da2b:	c3                   	ret    

0804da2c <get_free_mem>:

size_t get_free_mem(void)
{
 804da2c:	55                   	push   %ebp
 804da2d:	89 e5                	mov    %esp,%ebp
 804da2f:	83 ec 10             	sub    $0x10,%esp
 804da32:	e8 1e 04 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804da37:	81 c1 d5 9e 00 00    	add    $0x9ed5,%ecx
 804da3d:	c7 45 fc 29 00 00 00 	movl   $0x29,-0x4(%ebp)
 804da44:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804da4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804da4e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804da51:	cd 2e                	int    $0x2e
 804da53:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804da56:	b8 27 00 00 00       	mov    $0x27,%eax
 804da5b:	cd 2e                	int    $0x2e
 804da5d:	89 c2                	mov    %eax,%edx
 804da5f:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804da65:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804da67:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 804da6a:	c9                   	leave  
 804da6b:	c3                   	ret    

0804da6c <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 804da6c:	55                   	push   %ebp
 804da6d:	89 e5                	mov    %esp,%ebp
 804da6f:	56                   	push   %esi
 804da70:	53                   	push   %ebx
 804da71:	83 ec 40             	sub    $0x40,%esp
 804da74:	e8 e0 03 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804da79:	81 c3 93 9e 00 00    	add    $0x9e93,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 804da7f:	8b 45 08             	mov    0x8(%ebp),%eax
 804da82:	89 04 24             	mov    %eax,(%esp)
 804da85:	e8 40 06 00 00       	call   804e0ca <strlen>
 804da8a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 804da8d:	8b 45 08             	mov    0x8(%ebp),%eax
 804da90:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 804da93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804da9a:	eb 03                	jmp    804da9f <execve+0x33>
 804da9c:	ff 45 f4             	incl   -0xc(%ebp)
 804da9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804daa2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804daa9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804daac:	01 d0                	add    %edx,%eax
 804daae:	8b 00                	mov    (%eax),%eax
 804dab0:	85 c0                	test   %eax,%eax
 804dab2:	75 e8                	jne    804da9c <execve+0x30>
                ;
        args.argv.av_len = i;
 804dab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dab7:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 804daba:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804dabd:	40                   	inc    %eax
 804dabe:	c1 e0 03             	shl    $0x3,%eax
 804dac1:	89 04 24             	mov    %eax,(%esp)
 804dac4:	e8 c5 2a 00 00       	call   805058e <malloc>
 804dac9:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 804dacc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804dad3:	eb 49                	jmp    804db1e <execve+0xb2>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 804dad5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804dad8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804dadb:	c1 e2 03             	shl    $0x3,%edx
 804dade:	8d 34 10             	lea    (%eax,%edx,1),%esi
 804dae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dae4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804daeb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804daee:	01 d0                	add    %edx,%eax
 804daf0:	8b 00                	mov    (%eax),%eax
 804daf2:	89 04 24             	mov    %eax,(%esp)
 804daf5:	e8 d0 05 00 00       	call   804e0ca <strlen>
 804dafa:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 804dafd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804db00:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804db03:	c1 e2 03             	shl    $0x3,%edx
 804db06:	01 c2                	add    %eax,%edx
 804db08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db0b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804db12:	8b 45 0c             	mov    0xc(%ebp),%eax
 804db15:	01 c8                	add    %ecx,%eax
 804db17:	8b 00                	mov    (%eax),%eax
 804db19:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 804db1b:	ff 45 f4             	incl   -0xc(%ebp)
 804db1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804db28:	8b 45 0c             	mov    0xc(%ebp),%eax
 804db2b:	01 d0                	add    %edx,%eax
 804db2d:	8b 00                	mov    (%eax),%eax
 804db2f:	85 c0                	test   %eax,%eax
 804db31:	75 a2                	jne    804dad5 <execve+0x69>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 804db33:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804db36:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804db39:	c1 e2 03             	shl    $0x3,%edx
 804db3c:	01 d0                	add    %edx,%eax
 804db3e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 804db45:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804db48:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804db4b:	c1 e2 03             	shl    $0x3,%edx
 804db4e:	01 d0                	add    %edx,%eax
 804db50:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 804db56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804db5d:	eb 03                	jmp    804db62 <execve+0xf6>
 804db5f:	ff 45 f4             	incl   -0xc(%ebp)
 804db62:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db65:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804db6c:	8b 45 10             	mov    0x10(%ebp),%eax
 804db6f:	01 d0                	add    %edx,%eax
 804db71:	8b 00                	mov    (%eax),%eax
 804db73:	85 c0                	test   %eax,%eax
 804db75:	75 e8                	jne    804db5f <execve+0xf3>
                ;
        args.envp.av_len = i;
 804db77:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db7a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 804db7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804db80:	40                   	inc    %eax
 804db81:	c1 e0 03             	shl    $0x3,%eax
 804db84:	89 04 24             	mov    %eax,(%esp)
 804db87:	e8 02 2a 00 00       	call   805058e <malloc>
 804db8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 804db8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804db96:	eb 49                	jmp    804dbe1 <execve+0x175>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 804db98:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804db9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804db9e:	c1 e2 03             	shl    $0x3,%edx
 804dba1:	8d 34 10             	lea    (%eax,%edx,1),%esi
 804dba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dba7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804dbae:	8b 45 10             	mov    0x10(%ebp),%eax
 804dbb1:	01 d0                	add    %edx,%eax
 804dbb3:	8b 00                	mov    (%eax),%eax
 804dbb5:	89 04 24             	mov    %eax,(%esp)
 804dbb8:	e8 0d 05 00 00       	call   804e0ca <strlen>
 804dbbd:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 804dbc0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804dbc3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804dbc6:	c1 e2 03             	shl    $0x3,%edx
 804dbc9:	01 c2                	add    %eax,%edx
 804dbcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dbce:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804dbd5:	8b 45 10             	mov    0x10(%ebp),%eax
 804dbd8:	01 c8                	add    %ecx,%eax
 804dbda:	8b 00                	mov    (%eax),%eax
 804dbdc:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 804dbde:	ff 45 f4             	incl   -0xc(%ebp)
 804dbe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dbe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804dbeb:	8b 45 10             	mov    0x10(%ebp),%eax
 804dbee:	01 d0                	add    %edx,%eax
 804dbf0:	8b 00                	mov    (%eax),%eax
 804dbf2:	85 c0                	test   %eax,%eax
 804dbf4:	75 a2                	jne    804db98 <execve+0x12c>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 804dbf6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804dbf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804dbfc:	c1 e2 03             	shl    $0x3,%edx
 804dbff:	01 d0                	add    %edx,%eax
 804dc01:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 804dc08:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804dc0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804dc0e:	c1 e2 03             	shl    $0x3,%edx
 804dc11:	01 d0                	add    %edx,%eax
 804dc13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 804dc19:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804dc1c:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 804dc23:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dc26:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804dc29:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804dc2c:	cd 2e                	int    $0x2e
 804dc2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dc31:	b8 27 00 00 00       	mov    $0x27,%eax
 804dc36:	cd 2e                	int    $0x2e
 804dc38:	89 c2                	mov    %eax,%edx
 804dc3a:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804dc40:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804dc42:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 804dc45:	83 c4 40             	add    $0x40,%esp
 804dc48:	5b                   	pop    %ebx
 804dc49:	5e                   	pop    %esi
 804dc4a:	5d                   	pop    %ebp
 804dc4b:	c3                   	ret    

0804dc4c <thr_set_errno>:

void thr_set_errno(int n)
{
 804dc4c:	55                   	push   %ebp
 804dc4d:	89 e5                	mov    %esp,%ebp
 804dc4f:	83 ec 10             	sub    $0x10,%esp
 804dc52:	e8 fe 01 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804dc57:	81 c1 b5 9c 00 00    	add    $0x9cb5,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 804dc5d:	8b 45 08             	mov    0x8(%ebp),%eax
 804dc60:	c7 45 fc 2a 00 00 00 	movl   $0x2a,-0x4(%ebp)
 804dc67:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dc6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804dc6d:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804dc70:	cd 2e                	int    $0x2e
 804dc72:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dc75:	b8 27 00 00 00       	mov    $0x27,%eax
 804dc7a:	cd 2e                	int    $0x2e
 804dc7c:	89 c2                	mov    %eax,%edx
 804dc7e:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804dc84:	89 10                	mov    %edx,(%eax)
}
 804dc86:	90                   	nop
 804dc87:	c9                   	leave  
 804dc88:	c3                   	ret    

0804dc89 <thr_errno>:

int thr_errno(void)
{
 804dc89:	55                   	push   %ebp
 804dc8a:	89 e5                	mov    %esp,%ebp
 804dc8c:	83 ec 10             	sub    $0x10,%esp
 804dc8f:	e8 c1 01 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804dc94:	81 c1 78 9c 00 00    	add    $0x9c78,%ecx
 804dc9a:	c7 45 fc 27 00 00 00 	movl   $0x27,-0x4(%ebp)
 804dca1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dca8:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804dcab:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804dcae:	cd 2e                	int    $0x2e
 804dcb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dcb3:	b8 27 00 00 00       	mov    $0x27,%eax
 804dcb8:	cd 2e                	int    $0x2e
 804dcba:	89 c2                	mov    %eax,%edx
 804dcbc:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804dcc2:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804dcc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_errno, 0);
 804dcc7:	90                   	nop
}
 804dcc8:	c9                   	leave  
 804dcc9:	c3                   	ret    

0804dcca <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 804dcca:	55                   	push   %ebp
 804dccb:	89 e5                	mov    %esp,%ebp
 804dccd:	83 ec 20             	sub    $0x20,%esp
 804dcd0:	e8 80 01 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804dcd5:	81 c1 37 9c 00 00    	add    $0x9c37,%ecx
        getdents_args_t args;

        args.fd = fd;
 804dcdb:	8b 45 08             	mov    0x8(%ebp),%eax
 804dcde:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.dirp = dir;
 804dce1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804dce4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.count = size;
 804dce7:	8b 45 10             	mov    0x10(%ebp),%eax
 804dcea:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 804dced:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804dcf0:	c7 45 fc 17 00 00 00 	movl   $0x17,-0x4(%ebp)
 804dcf7:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dcfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804dcfd:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804dd00:	cd 2e                	int    $0x2e
 804dd02:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dd05:	b8 27 00 00 00       	mov    $0x27,%eax
 804dd0a:	cd 2e                	int    $0x2e
 804dd0c:	89 c2                	mov    %eax,%edx
 804dd0e:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804dd14:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804dd16:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804dd19:	c9                   	leave  
 804dd1a:	c3                   	ret    

0804dd1b <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 804dd1b:	55                   	push   %ebp
 804dd1c:	89 e5                	mov    %esp,%ebp
 804dd1e:	53                   	push   %ebx
 804dd1f:	83 ec 34             	sub    $0x34,%esp
 804dd22:	e8 32 01 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804dd27:	81 c3 e5 9b 00 00    	add    $0x9be5,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 804dd2d:	8b 45 08             	mov    0x8(%ebp),%eax
 804dd30:	89 04 24             	mov    %eax,(%esp)
 804dd33:	e8 92 03 00 00       	call   804e0ca <strlen>
 804dd38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 804dd3b:	8b 45 08             	mov    0x8(%ebp),%eax
 804dd3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 804dd41:	8b 45 0c             	mov    0xc(%ebp),%eax
 804dd44:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 804dd47:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804dd4a:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 804dd51:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dd54:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dd57:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804dd5a:	cd 2e                	int    $0x2e
 804dd5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dd5f:	b8 27 00 00 00       	mov    $0x27,%eax
 804dd64:	cd 2e                	int    $0x2e
 804dd66:	89 c2                	mov    %eax,%edx
 804dd68:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804dd6e:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804dd70:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804dd73:	83 c4 34             	add    $0x34,%esp
 804dd76:	5b                   	pop    %ebx
 804dd77:	5d                   	pop    %ebp
 804dd78:	c3                   	ret    

0804dd79 <pipe>:

int
pipe(int pipefd[2])
{
 804dd79:	55                   	push   %ebp
 804dd7a:	89 e5                	mov    %esp,%ebp
 804dd7c:	83 ec 10             	sub    $0x10,%esp
 804dd7f:	e8 d1 00 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804dd84:	81 c1 88 9b 00 00    	add    $0x9b88,%ecx
        return trap(SYS_pipe, (uint32_t) pipefd);
 804dd8a:	8b 45 08             	mov    0x8(%ebp),%eax
 804dd8d:	c7 45 fc 12 00 00 00 	movl   $0x12,-0x4(%ebp)
 804dd94:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804dd97:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804dd9a:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804dd9d:	cd 2e                	int    $0x2e
 804dd9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dda2:	b8 27 00 00 00       	mov    $0x27,%eax
 804dda7:	cd 2e                	int    $0x2e
 804dda9:	89 c2                	mov    %eax,%edx
 804ddab:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804ddb1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804ddb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ddb6:	90                   	nop
}
 804ddb7:	c9                   	leave  
 804ddb8:	c3                   	ret    

0804ddb9 <uname>:

int
uname(struct utsname *buf)
{
 804ddb9:	55                   	push   %ebp
 804ddba:	89 e5                	mov    %esp,%ebp
 804ddbc:	83 ec 10             	sub    $0x10,%esp
 804ddbf:	e8 91 00 00 00       	call   804de55 <__x86.get_pc_thunk.cx>
 804ddc4:	81 c1 48 9b 00 00    	add    $0x9b48,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 804ddca:	8b 45 08             	mov    0x8(%ebp),%eax
 804ddcd:	c7 45 fc 1c 00 00 00 	movl   $0x1c,-0x4(%ebp)
 804ddd4:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804ddd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804ddda:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804dddd:	cd 2e                	int    $0x2e
 804dddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804dde2:	b8 27 00 00 00       	mov    $0x27,%eax
 804dde7:	cd 2e                	int    $0x2e
 804dde9:	89 c2                	mov    %eax,%edx
 804ddeb:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804ddf1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804ddf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ddf6:	90                   	nop
}
 804ddf7:	c9                   	leave  
 804ddf8:	c3                   	ret    

0804ddf9 <debug>:

int
debug(const char *str)
{
 804ddf9:	55                   	push   %ebp
 804ddfa:	89 e5                	mov    %esp,%ebp
 804ddfc:	53                   	push   %ebx
 804ddfd:	83 ec 34             	sub    $0x34,%esp
 804de00:	e8 54 00 00 00       	call   804de59 <__x86.get_pc_thunk.bx>
 804de05:	81 c3 07 9b 00 00    	add    $0x9b07,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 804de0b:	8b 45 08             	mov    0x8(%ebp),%eax
 804de0e:	89 04 24             	mov    %eax,(%esp)
 804de11:	e8 b4 02 00 00       	call   804e0ca <strlen>
 804de16:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 804de19:	8b 45 08             	mov    0x8(%ebp),%eax
 804de1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 804de1f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804de22:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 804de29:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804de2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804de2f:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804de32:	cd 2e                	int    $0x2e
 804de34:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804de37:	b8 27 00 00 00       	mov    $0x27,%eax
 804de3c:	cd 2e                	int    $0x2e
 804de3e:	89 c2                	mov    %eax,%edx
 804de40:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 804de46:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804de48:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804de4b:	83 c4 34             	add    $0x34,%esp
 804de4e:	5b                   	pop    %ebx
 804de4f:	5d                   	pop    %ebp
 804de50:	c3                   	ret    

0804de51 <__x86.get_pc_thunk.ax>:
 804de51:	8b 04 24             	mov    (%esp),%eax
 804de54:	c3                   	ret    

0804de55 <__x86.get_pc_thunk.cx>:
 804de55:	8b 0c 24             	mov    (%esp),%ecx
 804de58:	c3                   	ret    

0804de59 <__x86.get_pc_thunk.bx>:
 804de59:	8b 1c 24             	mov    (%esp),%ebx
 804de5c:	c3                   	ret    

0804de5d <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 804de5d:	55                   	push   %ebp
 804de5e:	89 e5                	mov    %esp,%ebp
 804de60:	83 ec 10             	sub    $0x10,%esp
 804de63:	e8 e9 ff ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804de68:	05 a4 9a 00 00       	add    $0x9aa4,%eax
        const unsigned char *su1, *su2;
        signed char res = 0;
 804de6d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804de71:	8b 45 08             	mov    0x8(%ebp),%eax
 804de74:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804de77:	8b 45 0c             	mov    0xc(%ebp),%eax
 804de7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804de7d:	eb 22                	jmp    804dea1 <memcmp+0x44>
                if ((res = *su1 - *su2) != 0)
 804de7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804de82:	0f b6 10             	movzbl (%eax),%edx
 804de85:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804de88:	0f b6 00             	movzbl (%eax),%eax
 804de8b:	28 c2                	sub    %al,%dl
 804de8d:	88 d0                	mov    %dl,%al
 804de8f:	88 45 f7             	mov    %al,-0x9(%ebp)
 804de92:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804de96:	75 11                	jne    804dea9 <memcmp+0x4c>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804de98:	ff 45 fc             	incl   -0x4(%ebp)
 804de9b:	ff 45 f8             	incl   -0x8(%ebp)
 804de9e:	ff 4d 10             	decl   0x10(%ebp)
 804dea1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804dea5:	75 d8                	jne    804de7f <memcmp+0x22>
 804dea7:	eb 01                	jmp    804deaa <memcmp+0x4d>
                if ((res = *su1 - *su2) != 0)
                        break;
 804dea9:	90                   	nop
        return res;
 804deaa:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 804deae:	c9                   	leave  
 804deaf:	c3                   	ret    

0804deb0 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 804deb0:	55                   	push   %ebp
 804deb1:	89 e5                	mov    %esp,%ebp
 804deb3:	83 ec 10             	sub    $0x10,%esp
 804deb6:	e8 96 ff ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804debb:	05 51 9a 00 00       	add    $0x9a51,%eax
        char *tmp = (char *) dest;
 804dec0:	8b 45 08             	mov    0x8(%ebp),%eax
 804dec3:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 804dec6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804dec9:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 804decc:	eb 17                	jmp    804dee5 <memcpy+0x35>
                *tmp++ = *s++;
 804dece:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804ded1:	8d 50 01             	lea    0x1(%eax),%edx
 804ded4:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804ded7:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804deda:	8d 4a 01             	lea    0x1(%edx),%ecx
 804dedd:	89 4d f8             	mov    %ecx,-0x8(%ebp)
 804dee0:	0f b6 12             	movzbl (%edx),%edx
 804dee3:	88 10                	mov    %dl,(%eax)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 804dee5:	8b 45 10             	mov    0x10(%ebp),%eax
 804dee8:	8d 50 ff             	lea    -0x1(%eax),%edx
 804deeb:	89 55 10             	mov    %edx,0x10(%ebp)
 804deee:	85 c0                	test   %eax,%eax
 804def0:	75 dc                	jne    804dece <memcpy+0x1e>
                *tmp++ = *s++;

        return dest;
 804def2:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804def5:	c9                   	leave  
 804def6:	c3                   	ret    

0804def7 <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 804def7:	55                   	push   %ebp
 804def8:	89 e5                	mov    %esp,%ebp
 804defa:	53                   	push   %ebx
 804defb:	e8 51 ff ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804df00:	05 0c 9a 00 00       	add    $0x9a0c,%eax
        register signed char __res = 0;
 804df05:	b3 00                	mov    $0x0,%bl

        while (count) {
 804df07:	eb 31                	jmp    804df3a <strncmp+0x43>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804df09:	8b 45 08             	mov    0x8(%ebp),%eax
 804df0c:	0f b6 00             	movzbl (%eax),%eax
 804df0f:	88 c1                	mov    %al,%cl
 804df11:	8b 45 0c             	mov    0xc(%ebp),%eax
 804df14:	8d 50 01             	lea    0x1(%eax),%edx
 804df17:	89 55 0c             	mov    %edx,0xc(%ebp)
 804df1a:	0f b6 00             	movzbl (%eax),%eax
 804df1d:	28 c1                	sub    %al,%cl
 804df1f:	88 c8                	mov    %cl,%al
 804df21:	88 c3                	mov    %al,%bl
 804df23:	84 db                	test   %bl,%bl
 804df25:	75 19                	jne    804df40 <strncmp+0x49>
 804df27:	8b 45 08             	mov    0x8(%ebp),%eax
 804df2a:	8d 50 01             	lea    0x1(%eax),%edx
 804df2d:	89 55 08             	mov    %edx,0x8(%ebp)
 804df30:	0f b6 00             	movzbl (%eax),%eax
 804df33:	84 c0                	test   %al,%al
 804df35:	74 09                	je     804df40 <strncmp+0x49>
                        break;
                count--;
 804df37:	ff 4d 10             	decl   0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 804df3a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804df3e:	75 c9                	jne    804df09 <strncmp+0x12>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 804df40:	0f be c3             	movsbl %bl,%eax
}
 804df43:	5b                   	pop    %ebx
 804df44:	5d                   	pop    %ebp
 804df45:	c3                   	ret    

0804df46 <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 804df46:	55                   	push   %ebp
 804df47:	89 e5                	mov    %esp,%ebp
 804df49:	53                   	push   %ebx
 804df4a:	e8 02 ff ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804df4f:	05 bd 99 00 00       	add    $0x99bd,%eax
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804df54:	8b 45 08             	mov    0x8(%ebp),%eax
 804df57:	0f b6 00             	movzbl (%eax),%eax
 804df5a:	88 c1                	mov    %al,%cl
 804df5c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804df5f:	8d 50 01             	lea    0x1(%eax),%edx
 804df62:	89 55 0c             	mov    %edx,0xc(%ebp)
 804df65:	0f b6 00             	movzbl (%eax),%eax
 804df68:	28 c1                	sub    %al,%cl
 804df6a:	88 c8                	mov    %cl,%al
 804df6c:	88 c3                	mov    %al,%bl
 804df6e:	84 db                	test   %bl,%bl
 804df70:	75 12                	jne    804df84 <strcmp+0x3e>
 804df72:	8b 45 08             	mov    0x8(%ebp),%eax
 804df75:	8d 50 01             	lea    0x1(%eax),%edx
 804df78:	89 55 08             	mov    %edx,0x8(%ebp)
 804df7b:	0f b6 00             	movzbl (%eax),%eax
 804df7e:	84 c0                	test   %al,%al
 804df80:	74 02                	je     804df84 <strcmp+0x3e>
                        break;
        }
 804df82:	eb d0                	jmp    804df54 <strcmp+0xe>

        return __res;
 804df84:	0f be c3             	movsbl %bl,%eax
}
 804df87:	5b                   	pop    %ebx
 804df88:	5d                   	pop    %ebp
 804df89:	c3                   	ret    

0804df8a <strcpy>:

char *strcpy(char *dest, const char *src)
{
 804df8a:	55                   	push   %ebp
 804df8b:	89 e5                	mov    %esp,%ebp
 804df8d:	83 ec 10             	sub    $0x10,%esp
 804df90:	e8 bc fe ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804df95:	05 77 99 00 00       	add    $0x9977,%eax
        char *tmp = dest;
 804df9a:	8b 45 08             	mov    0x8(%ebp),%eax
 804df9d:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 804dfa0:	90                   	nop
 804dfa1:	8b 45 08             	mov    0x8(%ebp),%eax
 804dfa4:	8d 50 01             	lea    0x1(%eax),%edx
 804dfa7:	89 55 08             	mov    %edx,0x8(%ebp)
 804dfaa:	8b 55 0c             	mov    0xc(%ebp),%edx
 804dfad:	8d 4a 01             	lea    0x1(%edx),%ecx
 804dfb0:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804dfb3:	0f b6 12             	movzbl (%edx),%edx
 804dfb6:	88 10                	mov    %dl,(%eax)
 804dfb8:	0f b6 00             	movzbl (%eax),%eax
 804dfbb:	84 c0                	test   %al,%al
 804dfbd:	75 e2                	jne    804dfa1 <strcpy+0x17>
                /* nothing */;
        return tmp;
 804dfbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804dfc2:	c9                   	leave  
 804dfc3:	c3                   	ret    

0804dfc4 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 804dfc4:	55                   	push   %ebp
 804dfc5:	89 e5                	mov    %esp,%ebp
 804dfc7:	83 ec 10             	sub    $0x10,%esp
 804dfca:	e8 82 fe ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804dfcf:	05 3d 99 00 00       	add    $0x993d,%eax
        char *tmp = dest;
 804dfd4:	8b 45 08             	mov    0x8(%ebp),%eax
 804dfd7:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804dfda:	90                   	nop
 804dfdb:	8b 45 10             	mov    0x10(%ebp),%eax
 804dfde:	8d 50 ff             	lea    -0x1(%eax),%edx
 804dfe1:	89 55 10             	mov    %edx,0x10(%ebp)
 804dfe4:	85 c0                	test   %eax,%eax
 804dfe6:	74 1e                	je     804e006 <strncpy+0x42>
 804dfe8:	8b 45 08             	mov    0x8(%ebp),%eax
 804dfeb:	8d 50 01             	lea    0x1(%eax),%edx
 804dfee:	89 55 08             	mov    %edx,0x8(%ebp)
 804dff1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804dff4:	8d 4a 01             	lea    0x1(%edx),%ecx
 804dff7:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804dffa:	0f b6 12             	movzbl (%edx),%edx
 804dffd:	88 10                	mov    %dl,(%eax)
 804dfff:	0f b6 00             	movzbl (%eax),%eax
 804e002:	84 c0                	test   %al,%al
 804e004:	75 d5                	jne    804dfdb <strncpy+0x17>
                /* nothing */;

        return tmp;
 804e006:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804e009:	c9                   	leave  
 804e00a:	c3                   	ret    

0804e00b <memset>:

void *memset(void *s, int c, size_t count)
{
 804e00b:	55                   	push   %ebp
 804e00c:	89 e5                	mov    %esp,%ebp
 804e00e:	83 ec 10             	sub    $0x10,%esp
 804e011:	e8 3b fe ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e016:	05 f6 98 00 00       	add    $0x98f6,%eax
        char *xs = (char *) s;
 804e01b:	8b 45 08             	mov    0x8(%ebp),%eax
 804e01e:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 804e021:	eb 0e                	jmp    804e031 <memset+0x26>
                *xs++ = c;
 804e023:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e026:	8d 50 01             	lea    0x1(%eax),%edx
 804e029:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804e02c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804e02f:	88 10                	mov    %dl,(%eax)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 804e031:	8b 45 10             	mov    0x10(%ebp),%eax
 804e034:	8d 50 ff             	lea    -0x1(%eax),%edx
 804e037:	89 55 10             	mov    %edx,0x10(%ebp)
 804e03a:	85 c0                	test   %eax,%eax
 804e03c:	75 e5                	jne    804e023 <memset+0x18>
                *xs++ = c;

        return s;
 804e03e:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804e041:	c9                   	leave  
 804e042:	c3                   	ret    

0804e043 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 804e043:	55                   	push   %ebp
 804e044:	89 e5                	mov    %esp,%ebp
 804e046:	83 ec 10             	sub    $0x10,%esp
 804e049:	e8 03 fe ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e04e:	05 be 98 00 00       	add    $0x98be,%eax
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 804e053:	8b 45 08             	mov    0x8(%ebp),%eax
 804e056:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804e059:	eb 03                	jmp    804e05e <strnlen+0x1b>
 804e05b:	ff 45 fc             	incl   -0x4(%ebp)
 804e05e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e061:	8d 50 ff             	lea    -0x1(%eax),%edx
 804e064:	89 55 0c             	mov    %edx,0xc(%ebp)
 804e067:	85 c0                	test   %eax,%eax
 804e069:	74 0a                	je     804e075 <strnlen+0x32>
 804e06b:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e06e:	0f b6 00             	movzbl (%eax),%eax
 804e071:	84 c0                	test   %al,%al
 804e073:	75 e6                	jne    804e05b <strnlen+0x18>
                /* nothing */;
        return sc - s;
 804e075:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804e078:	8b 45 08             	mov    0x8(%ebp),%eax
 804e07b:	29 c2                	sub    %eax,%edx
 804e07d:	89 d0                	mov    %edx,%eax
}
 804e07f:	c9                   	leave  
 804e080:	c3                   	ret    

0804e081 <strcat>:


char *strcat(char *dest, const char *src)
{
 804e081:	55                   	push   %ebp
 804e082:	89 e5                	mov    %esp,%ebp
 804e084:	83 ec 10             	sub    $0x10,%esp
 804e087:	e8 c5 fd ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e08c:	05 80 98 00 00       	add    $0x9880,%eax
        char *tmp = dest;
 804e091:	8b 45 08             	mov    0x8(%ebp),%eax
 804e094:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 804e097:	eb 03                	jmp    804e09c <strcat+0x1b>
                dest++;
 804e099:	ff 45 08             	incl   0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 804e09c:	8b 45 08             	mov    0x8(%ebp),%eax
 804e09f:	0f b6 00             	movzbl (%eax),%eax
 804e0a2:	84 c0                	test   %al,%al
 804e0a4:	75 f3                	jne    804e099 <strcat+0x18>
                dest++;

        while ((*dest++ = *src++) != '\0');
 804e0a6:	90                   	nop
 804e0a7:	8b 45 08             	mov    0x8(%ebp),%eax
 804e0aa:	8d 50 01             	lea    0x1(%eax),%edx
 804e0ad:	89 55 08             	mov    %edx,0x8(%ebp)
 804e0b0:	8b 55 0c             	mov    0xc(%ebp),%edx
 804e0b3:	8d 4a 01             	lea    0x1(%edx),%ecx
 804e0b6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804e0b9:	0f b6 12             	movzbl (%edx),%edx
 804e0bc:	88 10                	mov    %dl,(%eax)
 804e0be:	0f b6 00             	movzbl (%eax),%eax
 804e0c1:	84 c0                	test   %al,%al
 804e0c3:	75 e2                	jne    804e0a7 <strcat+0x26>

        return tmp;
 804e0c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804e0c8:	c9                   	leave  
 804e0c9:	c3                   	ret    

0804e0ca <strlen>:

size_t strlen(const char *s)
{
 804e0ca:	55                   	push   %ebp
 804e0cb:	89 e5                	mov    %esp,%ebp
 804e0cd:	83 ec 10             	sub    $0x10,%esp
 804e0d0:	e8 7c fd ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e0d5:	05 37 98 00 00       	add    $0x9837,%eax
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 804e0da:	8b 45 08             	mov    0x8(%ebp),%eax
 804e0dd:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804e0e0:	eb 03                	jmp    804e0e5 <strlen+0x1b>
 804e0e2:	ff 45 fc             	incl   -0x4(%ebp)
 804e0e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e0e8:	0f b6 00             	movzbl (%eax),%eax
 804e0eb:	84 c0                	test   %al,%al
 804e0ed:	75 f3                	jne    804e0e2 <strlen+0x18>
                /* nothing */;
        return sc - s;
 804e0ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804e0f2:	8b 45 08             	mov    0x8(%ebp),%eax
 804e0f5:	29 c2                	sub    %eax,%edx
 804e0f7:	89 d0                	mov    %edx,%eax
}
 804e0f9:	c9                   	leave  
 804e0fa:	c3                   	ret    

0804e0fb <strchr>:

char *strchr(const char *s, int c)
{
 804e0fb:	55                   	push   %ebp
 804e0fc:	89 e5                	mov    %esp,%ebp
 804e0fe:	e8 4e fd ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e103:	05 09 98 00 00       	add    $0x9809,%eax
        for (; *s != (char) c; ++s)
 804e108:	eb 14                	jmp    804e11e <strchr+0x23>
                if (*s == '\0')
 804e10a:	8b 45 08             	mov    0x8(%ebp),%eax
 804e10d:	0f b6 00             	movzbl (%eax),%eax
 804e110:	84 c0                	test   %al,%al
 804e112:	75 07                	jne    804e11b <strchr+0x20>
                        return NULL;
 804e114:	b8 00 00 00 00       	mov    $0x0,%eax
 804e119:	eb 13                	jmp    804e12e <strchr+0x33>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 804e11b:	ff 45 08             	incl   0x8(%ebp)
 804e11e:	8b 45 08             	mov    0x8(%ebp),%eax
 804e121:	0f b6 00             	movzbl (%eax),%eax
 804e124:	8b 55 0c             	mov    0xc(%ebp),%edx
 804e127:	38 d0                	cmp    %dl,%al
 804e129:	75 df                	jne    804e10a <strchr+0xf>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 804e12b:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804e12e:	5d                   	pop    %ebp
 804e12f:	c3                   	ret    

0804e130 <strrchr>:

char *strrchr(const char *s, int c)
{
 804e130:	55                   	push   %ebp
 804e131:	89 e5                	mov    %esp,%ebp
 804e133:	83 ec 10             	sub    $0x10,%esp
 804e136:	e8 16 fd ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e13b:	05 d1 97 00 00       	add    $0x97d1,%eax
        char *r = NULL;
 804e140:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 804e147:	eb 16                	jmp    804e15f <strrchr+0x2f>
                if (*s == (char)c)
 804e149:	8b 45 08             	mov    0x8(%ebp),%eax
 804e14c:	0f b6 00             	movzbl (%eax),%eax
 804e14f:	8b 55 0c             	mov    0xc(%ebp),%edx
 804e152:	38 d0                	cmp    %dl,%al
 804e154:	75 06                	jne    804e15c <strrchr+0x2c>
                        r = (char *)s;
 804e156:	8b 45 08             	mov    0x8(%ebp),%eax
 804e159:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 804e15c:	ff 45 08             	incl   0x8(%ebp)
 804e15f:	8b 45 08             	mov    0x8(%ebp),%eax
 804e162:	0f b6 00             	movzbl (%eax),%eax
 804e165:	84 c0                	test   %al,%al
 804e167:	75 e0                	jne    804e149 <strrchr+0x19>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 804e169:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804e16c:	c9                   	leave  
 804e16d:	c3                   	ret    

0804e16e <strstr>:

char *strstr(const char *s1, const char *s2)
{
 804e16e:	55                   	push   %ebp
 804e16f:	89 e5                	mov    %esp,%ebp
 804e171:	53                   	push   %ebx
 804e172:	83 ec 24             	sub    $0x24,%esp
 804e175:	e8 df fc ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804e17a:	81 c3 92 97 00 00    	add    $0x9792,%ebx
        int l1, l2;

        l2 = strlen(s2);
 804e180:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e183:	89 04 24             	mov    %eax,(%esp)
 804e186:	e8 3f ff ff ff       	call   804e0ca <strlen>
 804e18b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 804e18e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804e192:	75 05                	jne    804e199 <strstr+0x2b>
                return (char *) s1;
 804e194:	8b 45 08             	mov    0x8(%ebp),%eax
 804e197:	eb 45                	jmp    804e1de <strstr+0x70>
        l1 = strlen(s1);
 804e199:	8b 45 08             	mov    0x8(%ebp),%eax
 804e19c:	89 04 24             	mov    %eax,(%esp)
 804e19f:	e8 26 ff ff ff       	call   804e0ca <strlen>
 804e1a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 804e1a7:	eb 28                	jmp    804e1d1 <strstr+0x63>
                l1--;
 804e1a9:	ff 4d f4             	decl   -0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 804e1ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804e1af:	89 44 24 08          	mov    %eax,0x8(%esp)
 804e1b3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e1b6:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e1ba:	8b 45 08             	mov    0x8(%ebp),%eax
 804e1bd:	89 04 24             	mov    %eax,(%esp)
 804e1c0:	e8 98 fc ff ff       	call   804de5d <memcmp>
 804e1c5:	85 c0                	test   %eax,%eax
 804e1c7:	75 05                	jne    804e1ce <strstr+0x60>
                        return (char *) s1;
 804e1c9:	8b 45 08             	mov    0x8(%ebp),%eax
 804e1cc:	eb 10                	jmp    804e1de <strstr+0x70>
                s1++;
 804e1ce:	ff 45 08             	incl   0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 804e1d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e1d4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804e1d7:	7d d0                	jge    804e1a9 <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 804e1d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804e1de:	83 c4 24             	add    $0x24,%esp
 804e1e1:	5b                   	pop    %ebx
 804e1e2:	5d                   	pop    %ebp
 804e1e3:	c3                   	ret    

0804e1e4 <strdup>:

char *strdup(const char *s)
{
 804e1e4:	55                   	push   %ebp
 804e1e5:	89 e5                	mov    %esp,%ebp
 804e1e7:	e8 65 fc ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e1ec:	05 20 97 00 00       	add    $0x9720,%eax
        /* TODO - alvin */
        return NULL;
 804e1f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804e1f6:	5d                   	pop    %ebp
 804e1f7:	c3                   	ret    

0804e1f8 <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 804e1f8:	55                   	push   %ebp
 804e1f9:	89 e5                	mov    %esp,%ebp
 804e1fb:	83 ec 10             	sub    $0x10,%esp
 804e1fe:	e8 4e fc ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e203:	05 09 97 00 00       	add    $0x9709,%eax
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 804e208:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e20b:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804e20e:	eb 03                	jmp    804e213 <strpbrk+0x1b>
 804e210:	ff 45 fc             	incl   -0x4(%ebp)
 804e213:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e216:	0f b6 00             	movzbl (%eax),%eax
 804e219:	84 c0                	test   %al,%al
 804e21b:	74 10                	je     804e22d <strpbrk+0x35>
 804e21d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e220:	0f b6 10             	movzbl (%eax),%edx
 804e223:	8b 45 08             	mov    0x8(%ebp),%eax
 804e226:	0f b6 00             	movzbl (%eax),%eax
 804e229:	38 c2                	cmp    %al,%dl
 804e22b:	75 e3                	jne    804e210 <strpbrk+0x18>
                        ;
                if (*p != '\0')
 804e22d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e230:	0f b6 00             	movzbl (%eax),%eax
 804e233:	84 c0                	test   %al,%al
 804e235:	74 05                	je     804e23c <strpbrk+0x44>
                        return ((char *)string);
 804e237:	8b 45 08             	mov    0x8(%ebp),%eax
 804e23a:	eb 15                	jmp    804e251 <strpbrk+0x59>
        } while (*string++);
 804e23c:	8b 45 08             	mov    0x8(%ebp),%eax
 804e23f:	8d 50 01             	lea    0x1(%eax),%edx
 804e242:	89 55 08             	mov    %edx,0x8(%ebp)
 804e245:	0f b6 00             	movzbl (%eax),%eax
 804e248:	84 c0                	test   %al,%al
 804e24a:	75 bc                	jne    804e208 <strpbrk+0x10>

        return (NULL);
 804e24c:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804e251:	c9                   	leave  
 804e252:	c3                   	ret    

0804e253 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 804e253:	55                   	push   %ebp
 804e254:	89 e5                	mov    %esp,%ebp
 804e256:	83 ec 10             	sub    $0x10,%esp
 804e259:	e8 f3 fb ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e25e:	05 ae 96 00 00       	add    $0x96ae,%eax
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804e263:	8b 45 08             	mov    0x8(%ebp),%eax
 804e266:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804e269:	eb 32                	jmp    804e29d <strspn+0x4a>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 804e26b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e26e:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804e271:	eb 03                	jmp    804e276 <strspn+0x23>
 804e273:	ff 45 fc             	incl   -0x4(%ebp)
 804e276:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e279:	0f b6 00             	movzbl (%eax),%eax
 804e27c:	84 c0                	test   %al,%al
 804e27e:	74 10                	je     804e290 <strspn+0x3d>
 804e280:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e283:	0f b6 10             	movzbl (%eax),%edx
 804e286:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804e289:	0f b6 00             	movzbl (%eax),%eax
 804e28c:	38 c2                	cmp    %al,%dl
 804e28e:	75 e3                	jne    804e273 <strspn+0x20>
                        ;
                if (*p == '\0')
 804e290:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804e293:	0f b6 00             	movzbl (%eax),%eax
 804e296:	84 c0                	test   %al,%al
 804e298:	74 0f                	je     804e2a9 <strspn+0x56>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804e29a:	ff 45 f8             	incl   -0x8(%ebp)
 804e29d:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804e2a0:	0f b6 00             	movzbl (%eax),%eax
 804e2a3:	84 c0                	test   %al,%al
 804e2a5:	75 c4                	jne    804e26b <strspn+0x18>
 804e2a7:	eb 01                	jmp    804e2aa <strspn+0x57>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 804e2a9:	90                   	nop
        }

        return (q - string);
 804e2aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804e2ad:	8b 45 08             	mov    0x8(%ebp),%eax
 804e2b0:	29 c2                	sub    %eax,%edx
 804e2b2:	89 d0                	mov    %edx,%eax
}
 804e2b4:	c9                   	leave  
 804e2b5:	c3                   	ret    

0804e2b6 <strtok>:

char *
strtok(char *string, const char *sepset)
{
 804e2b6:	55                   	push   %ebp
 804e2b7:	89 e5                	mov    %esp,%ebp
 804e2b9:	53                   	push   %ebx
 804e2ba:	83 ec 24             	sub    $0x24,%esp
 804e2bd:	e8 97 fb ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804e2c2:	81 c3 4a 96 00 00    	add    $0x964a,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 804e2c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804e2cc:	75 08                	jne    804e2d6 <strtok+0x20>
 804e2ce:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804e2d4:	eb 03                	jmp    804e2d9 <strtok+0x23>
 804e2d6:	8b 45 08             	mov    0x8(%ebp),%eax
 804e2d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 804e2dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804e2e0:	75 07                	jne    804e2e9 <strtok+0x33>
                return (NULL);
 804e2e2:	b8 00 00 00 00       	mov    $0x0,%eax
 804e2e7:	eb 69                	jmp    804e352 <strtok+0x9c>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 804e2e9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e2ec:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e2f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e2f3:	89 04 24             	mov    %eax,(%esp)
 804e2f6:	e8 58 ff ff ff       	call   804e253 <strspn>
 804e2fb:	89 c2                	mov    %eax,%edx
 804e2fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e300:	01 d0                	add    %edx,%eax
 804e302:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 804e305:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804e308:	0f b6 00             	movzbl (%eax),%eax
 804e30b:	84 c0                	test   %al,%al
 804e30d:	75 07                	jne    804e316 <strtok+0x60>
                return (NULL);
 804e30f:	b8 00 00 00 00       	mov    $0x0,%eax
 804e314:	eb 3c                	jmp    804e352 <strtok+0x9c>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 804e316:	8b 45 0c             	mov    0xc(%ebp),%eax
 804e319:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e31d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804e320:	89 04 24             	mov    %eax,(%esp)
 804e323:	e8 d0 fe ff ff       	call   804e1f8 <strpbrk>
 804e328:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804e32b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804e32f:	75 0c                	jne    804e33d <strtok+0x87>
                savept = NULL;
 804e331:	c7 83 58 02 00 00 00 	movl   $0x0,0x258(%ebx)
 804e338:	00 00 00 
 804e33b:	eb 12                	jmp    804e34f <strtok+0x99>
        else {
                *r = '\0';
 804e33d:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804e340:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 804e343:	ff 45 ec             	incl   -0x14(%ebp)
 804e346:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804e349:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)
        }

        return (q);
 804e34f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 804e352:	83 c4 24             	add    $0x24,%esp
 804e355:	5b                   	pop    %ebx
 804e356:	5d                   	pop    %ebp
 804e357:	c3                   	ret    

0804e358 <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 804e358:	55                   	push   %ebp
 804e359:	89 e5                	mov    %esp,%ebp
 804e35b:	e8 f1 fa ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 804e360:	05 ac 95 00 00       	add    $0x95ac,%eax
        switch (errnum) {
 804e365:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 804e36c:	0f 87 e8 04 00 00    	ja     804e85a <.L90>
 804e372:	8b 55 08             	mov    0x8(%ebp),%edx
 804e375:	c1 e2 02             	shl    $0x2,%edx
 804e378:	8b 94 02 30 d6 ff ff 	mov    -0x29d0(%edx,%eax,1),%edx
 804e37f:	01 c2                	add    %eax,%edx
 804e381:	ff e2                	jmp    *%edx

0804e383 <.L91>:
                case EPERM: return "Not super-user";
 804e383:	8d 80 74 cb ff ff    	lea    -0x348c(%eax),%eax
 804e389:	e9 d1 04 00 00       	jmp    804e85f <.L90+0x5>

0804e38e <.L93>:
                case ENOENT: return "No such file or directory";
 804e38e:	8d 80 83 cb ff ff    	lea    -0x347d(%eax),%eax
 804e394:	e9 c6 04 00 00       	jmp    804e85f <.L90+0x5>

0804e399 <.L94>:
                case ESRCH: return "No such process";
 804e399:	8d 80 9d cb ff ff    	lea    -0x3463(%eax),%eax
 804e39f:	e9 bb 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3a4 <.L95>:
                case EINTR: return "interrupted system call";
 804e3a4:	8d 80 ad cb ff ff    	lea    -0x3453(%eax),%eax
 804e3aa:	e9 b0 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3af <.L96>:
                case EIO: return "I/O error";
 804e3af:	8d 80 c5 cb ff ff    	lea    -0x343b(%eax),%eax
 804e3b5:	e9 a5 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3ba <.L97>:
                case ENXIO: return "No such device or address";
 804e3ba:	8d 80 cf cb ff ff    	lea    -0x3431(%eax),%eax
 804e3c0:	e9 9a 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3c5 <.L98>:
                case E2BIG: return "Arg list too long";
 804e3c5:	8d 80 e9 cb ff ff    	lea    -0x3417(%eax),%eax
 804e3cb:	e9 8f 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3d0 <.L99>:
                case ENOEXEC: return "Exec format error";
 804e3d0:	8d 80 fb cb ff ff    	lea    -0x3405(%eax),%eax
 804e3d6:	e9 84 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3db <.L100>:
                case EBADF: return "Bad file number";
 804e3db:	8d 80 0d cc ff ff    	lea    -0x33f3(%eax),%eax
 804e3e1:	e9 79 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3e6 <.L101>:
                case ECHILD: return "No children";
 804e3e6:	8d 80 1d cc ff ff    	lea    -0x33e3(%eax),%eax
 804e3ec:	e9 6e 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3f1 <.L102>:
                case EAGAIN: return "Resource temporarily unavailable";
 804e3f1:	8d 80 2c cc ff ff    	lea    -0x33d4(%eax),%eax
 804e3f7:	e9 63 04 00 00       	jmp    804e85f <.L90+0x5>

0804e3fc <.L103>:
                case ENOMEM: return "Not enough core";
 804e3fc:	8d 80 4d cc ff ff    	lea    -0x33b3(%eax),%eax
 804e402:	e9 58 04 00 00       	jmp    804e85f <.L90+0x5>

0804e407 <.L104>:
                case EACCES: return "Permission denied";
 804e407:	8d 80 5d cc ff ff    	lea    -0x33a3(%eax),%eax
 804e40d:	e9 4d 04 00 00       	jmp    804e85f <.L90+0x5>

0804e412 <.L105>:
                case EFAULT: return "Bad address";
 804e412:	8d 80 6f cc ff ff    	lea    -0x3391(%eax),%eax
 804e418:	e9 42 04 00 00       	jmp    804e85f <.L90+0x5>

0804e41d <.L106>:
                case ENOTBLK: return "Block device required";
 804e41d:	8d 80 7b cc ff ff    	lea    -0x3385(%eax),%eax
 804e423:	e9 37 04 00 00       	jmp    804e85f <.L90+0x5>

0804e428 <.L107>:
                case EBUSY: return "Mount device busy";
 804e428:	8d 80 91 cc ff ff    	lea    -0x336f(%eax),%eax
 804e42e:	e9 2c 04 00 00       	jmp    804e85f <.L90+0x5>

0804e433 <.L108>:
                case EEXIST: return "File exists";
 804e433:	8d 80 a3 cc ff ff    	lea    -0x335d(%eax),%eax
 804e439:	e9 21 04 00 00       	jmp    804e85f <.L90+0x5>

0804e43e <.L109>:
                case EXDEV: return "Cross-device link";
 804e43e:	8d 80 af cc ff ff    	lea    -0x3351(%eax),%eax
 804e444:	e9 16 04 00 00       	jmp    804e85f <.L90+0x5>

0804e449 <.L110>:
                case ENODEV: return "No such device";
 804e449:	8d 80 c1 cc ff ff    	lea    -0x333f(%eax),%eax
 804e44f:	e9 0b 04 00 00       	jmp    804e85f <.L90+0x5>

0804e454 <.L111>:
                case ENOTDIR: return "Not a directory";
 804e454:	8d 80 d0 cc ff ff    	lea    -0x3330(%eax),%eax
 804e45a:	e9 00 04 00 00       	jmp    804e85f <.L90+0x5>

0804e45f <.L112>:
                case EISDIR: return "Is a directory";
 804e45f:	8d 80 e0 cc ff ff    	lea    -0x3320(%eax),%eax
 804e465:	e9 f5 03 00 00       	jmp    804e85f <.L90+0x5>

0804e46a <.L113>:
                case EINVAL: return "Invalid argument";
 804e46a:	8d 80 ef cc ff ff    	lea    -0x3311(%eax),%eax
 804e470:	e9 ea 03 00 00       	jmp    804e85f <.L90+0x5>

0804e475 <.L114>:
                case ENFILE: return "File table overflow";
 804e475:	8d 80 00 cd ff ff    	lea    -0x3300(%eax),%eax
 804e47b:	e9 df 03 00 00       	jmp    804e85f <.L90+0x5>

0804e480 <.L115>:
                case EMFILE: return "Too many open files";
 804e480:	8d 80 14 cd ff ff    	lea    -0x32ec(%eax),%eax
 804e486:	e9 d4 03 00 00       	jmp    804e85f <.L90+0x5>

0804e48b <.L116>:
                case ENOTTY: return "Inappropriate ioctl for device";
 804e48b:	8d 80 28 cd ff ff    	lea    -0x32d8(%eax),%eax
 804e491:	e9 c9 03 00 00       	jmp    804e85f <.L90+0x5>

0804e496 <.L117>:
                case ETXTBSY: return "Text file busy";
 804e496:	8d 80 47 cd ff ff    	lea    -0x32b9(%eax),%eax
 804e49c:	e9 be 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4a1 <.L118>:
                case EFBIG: return "File too large";
 804e4a1:	8d 80 56 cd ff ff    	lea    -0x32aa(%eax),%eax
 804e4a7:	e9 b3 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4ac <.L119>:
                case ENOSPC: return "No space left on device";
 804e4ac:	8d 80 65 cd ff ff    	lea    -0x329b(%eax),%eax
 804e4b2:	e9 a8 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4b7 <.L120>:
                case ESPIPE: return "Illegal seek";
 804e4b7:	8d 80 7d cd ff ff    	lea    -0x3283(%eax),%eax
 804e4bd:	e9 9d 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4c2 <.L121>:
                case EROFS: return "Read only file system";
 804e4c2:	8d 80 8a cd ff ff    	lea    -0x3276(%eax),%eax
 804e4c8:	e9 92 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4cd <.L122>:
                case EMLINK: return "Too many links";
 804e4cd:	8d 80 a0 cd ff ff    	lea    -0x3260(%eax),%eax
 804e4d3:	e9 87 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4d8 <.L123>:
                case EPIPE: return "Broken pipe";
 804e4d8:	8d 80 af cd ff ff    	lea    -0x3251(%eax),%eax
 804e4de:	e9 7c 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4e3 <.L124>:
                case EDOM: return "Math arg out of domain of func";
 804e4e3:	8d 80 bc cd ff ff    	lea    -0x3244(%eax),%eax
 804e4e9:	e9 71 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4ee <.L125>:
                case ERANGE: return "Math result not representable";
 804e4ee:	8d 80 db cd ff ff    	lea    -0x3225(%eax),%eax
 804e4f4:	e9 66 03 00 00       	jmp    804e85f <.L90+0x5>

0804e4f9 <.L132>:
                case ENOMSG: return "No message of desired type";
 804e4f9:	8d 80 f9 cd ff ff    	lea    -0x3207(%eax),%eax
 804e4ff:	e9 5b 03 00 00       	jmp    804e85f <.L90+0x5>

0804e504 <.L133>:
                case EIDRM: return "Identifier removed";
 804e504:	8d 80 14 ce ff ff    	lea    -0x31ec(%eax),%eax
 804e50a:	e9 50 03 00 00       	jmp    804e85f <.L90+0x5>

0804e50f <.L134>:
                case ECHRNG: return "Channel number out of range";
 804e50f:	8d 80 27 ce ff ff    	lea    -0x31d9(%eax),%eax
 804e515:	e9 45 03 00 00       	jmp    804e85f <.L90+0x5>

0804e51a <.L135>:
                case EL2NSYNC: return "Level 2 not synchronized";
 804e51a:	8d 80 43 ce ff ff    	lea    -0x31bd(%eax),%eax
 804e520:	e9 3a 03 00 00       	jmp    804e85f <.L90+0x5>

0804e525 <.L136>:
                case EL3HLT: return "Level 3 halted";
 804e525:	8d 80 5c ce ff ff    	lea    -0x31a4(%eax),%eax
 804e52b:	e9 2f 03 00 00       	jmp    804e85f <.L90+0x5>

0804e530 <.L137>:
                case EL3RST: return "Level 3 reset";
 804e530:	8d 80 6b ce ff ff    	lea    -0x3195(%eax),%eax
 804e536:	e9 24 03 00 00       	jmp    804e85f <.L90+0x5>

0804e53b <.L138>:
                case ELNRNG: return "Link number out of range";
 804e53b:	8d 80 79 ce ff ff    	lea    -0x3187(%eax),%eax
 804e541:	e9 19 03 00 00       	jmp    804e85f <.L90+0x5>

0804e546 <.L139>:
                case EUNATCH: return "Protocol driver not attached";
 804e546:	8d 80 92 ce ff ff    	lea    -0x316e(%eax),%eax
 804e54c:	e9 0e 03 00 00       	jmp    804e85f <.L90+0x5>

0804e551 <.L140>:
                case ENOCSI: return "No CSI structure available";
 804e551:	8d 80 af ce ff ff    	lea    -0x3151(%eax),%eax
 804e557:	e9 03 03 00 00       	jmp    804e85f <.L90+0x5>

0804e55c <.L141>:
                case EL2HLT: return "Level 2 halted";
 804e55c:	8d 80 ca ce ff ff    	lea    -0x3136(%eax),%eax
 804e562:	e9 f8 02 00 00       	jmp    804e85f <.L90+0x5>

0804e567 <.L126>:
                case EDEADLK: return "Deadlock condition.";
 804e567:	8d 80 d9 ce ff ff    	lea    -0x3127(%eax),%eax
 804e56d:	e9 ed 02 00 00       	jmp    804e85f <.L90+0x5>

0804e572 <.L128>:
                case ENOLCK: return "No record locks available.";
 804e572:	8d 80 ed ce ff ff    	lea    -0x3113(%eax),%eax
 804e578:	e9 e2 02 00 00       	jmp    804e85f <.L90+0x5>

0804e57d <.L206>:
                case ECANCELED: return "Operation canceled";
 804e57d:	8d 80 08 cf ff ff    	lea    -0x30f8(%eax),%eax
 804e583:	e9 d7 02 00 00       	jmp    804e85f <.L90+0x5>

0804e588 <.L183>:
                case ENOTSUP: return "Operation not supported";
 804e588:	8d 80 1b cf ff ff    	lea    -0x30e5(%eax),%eax
 804e58e:	e9 cc 02 00 00       	jmp    804e85f <.L90+0x5>

0804e593 <.L205>:
                case EDQUOT: return "Disc quota exceeded";
 804e593:	8d 80 33 cf ff ff    	lea    -0x30cd(%eax),%eax
 804e599:	e9 c1 02 00 00       	jmp    804e85f <.L90+0x5>

0804e59e <.L142>:
                case EBADE: return "invalid exchange";
 804e59e:	8d 80 47 cf ff ff    	lea    -0x30b9(%eax),%eax
 804e5a4:	e9 b6 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5a9 <.L143>:
                case EBADR: return "invalid request descriptor";
 804e5a9:	8d 80 58 cf ff ff    	lea    -0x30a8(%eax),%eax
 804e5af:	e9 ab 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5b4 <.L144>:
                case EXFULL: return "exchange full";
 804e5b4:	8d 80 73 cf ff ff    	lea    -0x308d(%eax),%eax
 804e5ba:	e9 a0 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5bf <.L145>:
                case ENOANO: return "no anode";
 804e5bf:	8d 80 81 cf ff ff    	lea    -0x307f(%eax),%eax
 804e5c5:	e9 95 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5ca <.L146>:
                case EBADRQC: return "invalid request code";
 804e5ca:	8d 80 8a cf ff ff    	lea    -0x3076(%eax),%eax
 804e5d0:	e9 8a 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5d5 <.L147>:
                case EBADSLT: return "invalid slot";
 804e5d5:	8d 80 9f cf ff ff    	lea    -0x3061(%eax),%eax
 804e5db:	e9 7f 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5e0 <.L148>:
                case EBFONT: return "bad font file fmt";
 804e5e0:	8d 80 ac cf ff ff    	lea    -0x3054(%eax),%eax
 804e5e6:	e9 74 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5eb <.L207>:
                case EOWNERDEAD: return "process died with the lock";
 804e5eb:	8d 80 be cf ff ff    	lea    -0x3042(%eax),%eax
 804e5f1:	e9 69 02 00 00       	jmp    804e85f <.L90+0x5>

0804e5f6 <.L208>:
                case ENOTRECOVERABLE: return "lock is not recoverable";
 804e5f6:	8d 80 d9 cf ff ff    	lea    -0x3027(%eax),%eax
 804e5fc:	e9 5e 02 00 00       	jmp    804e85f <.L90+0x5>

0804e601 <.L149>:
                case ENOSTR: return "Device not a stream";
 804e601:	8d 80 f1 cf ff ff    	lea    -0x300f(%eax),%eax
 804e607:	e9 53 02 00 00       	jmp    804e85f <.L90+0x5>

0804e60c <.L150>:
                case ENODATA: return "no data (for no delay io)";
 804e60c:	8d 80 05 d0 ff ff    	lea    -0x2ffb(%eax),%eax
 804e612:	e9 48 02 00 00       	jmp    804e85f <.L90+0x5>

0804e617 <.L151>:
                case ETIME: return "timer expired";
 804e617:	8d 80 1f d0 ff ff    	lea    -0x2fe1(%eax),%eax
 804e61d:	e9 3d 02 00 00       	jmp    804e85f <.L90+0x5>

0804e622 <.L152>:
                case ENOSR: return "out of streams resources";
 804e622:	8d 80 2d d0 ff ff    	lea    -0x2fd3(%eax),%eax
 804e628:	e9 32 02 00 00       	jmp    804e85f <.L90+0x5>

0804e62d <.L153>:
                case ENONET: return "Machine is not on the network";
 804e62d:	8d 80 46 d0 ff ff    	lea    -0x2fba(%eax),%eax
 804e633:	e9 27 02 00 00       	jmp    804e85f <.L90+0x5>

0804e638 <.L154>:
                case ENOPKG: return "Package not installed";
 804e638:	8d 80 64 d0 ff ff    	lea    -0x2f9c(%eax),%eax
 804e63e:	e9 1c 02 00 00       	jmp    804e85f <.L90+0x5>

0804e643 <.L155>:
                case EREMOTE: return "The object is remote";
 804e643:	8d 80 7a d0 ff ff    	lea    -0x2f86(%eax),%eax
 804e649:	e9 11 02 00 00       	jmp    804e85f <.L90+0x5>

0804e64e <.L156>:
                case ENOLINK: return "the link has been severed";
 804e64e:	8d 80 8f d0 ff ff    	lea    -0x2f71(%eax),%eax
 804e654:	e9 06 02 00 00       	jmp    804e85f <.L90+0x5>

0804e659 <.L157>:
                case EADV: return "advertise error";
 804e659:	8d 80 a9 d0 ff ff    	lea    -0x2f57(%eax),%eax
 804e65f:	e9 fb 01 00 00       	jmp    804e85f <.L90+0x5>

0804e664 <.L158>:
                case ESRMNT: return "srmount error";
 804e664:	8d 80 b9 d0 ff ff    	lea    -0x2f47(%eax),%eax
 804e66a:	e9 f0 01 00 00       	jmp    804e85f <.L90+0x5>

0804e66f <.L159>:
                case ECOMM: return "Communication error on send";
 804e66f:	8d 80 c7 d0 ff ff    	lea    -0x2f39(%eax),%eax
 804e675:	e9 e5 01 00 00       	jmp    804e85f <.L90+0x5>

0804e67a <.L160>:
                case EPROTO: return "Protocol error";
 804e67a:	8d 80 e3 d0 ff ff    	lea    -0x2f1d(%eax),%eax
 804e680:	e9 da 01 00 00       	jmp    804e85f <.L90+0x5>

0804e685 <.L161>:
                case EMULTIHOP: return "multihop attempted";
 804e685:	8d 80 f2 d0 ff ff    	lea    -0x2f0e(%eax),%eax
 804e68b:	e9 cf 01 00 00       	jmp    804e85f <.L90+0x5>

0804e690 <.L162>:
                case EBADMSG: return "trying to read unreadable message";
 804e690:	8d 80 08 d1 ff ff    	lea    -0x2ef8(%eax),%eax
 804e696:	e9 c4 01 00 00       	jmp    804e85f <.L90+0x5>

0804e69b <.L127>:
                case ENAMETOOLONG: return "path name is too long";
 804e69b:	8d 80 2a d1 ff ff    	lea    -0x2ed6(%eax),%eax
 804e6a1:	e9 b9 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6a6 <.L163>:
                case EOVERFLOW: return "value too large to be stored in data type";
 804e6a6:	8d 80 40 d1 ff ff    	lea    -0x2ec0(%eax),%eax
 804e6ac:	e9 ae 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6b1 <.L164>:
                case ENOTUNIQ: return "given log. name not unique";
 804e6b1:	8d 80 6a d1 ff ff    	lea    -0x2e96(%eax),%eax
 804e6b7:	e9 a3 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6bc <.L165>:
                case EBADFD: return "f.d. invalid for this operation";
 804e6bc:	8d 80 88 d1 ff ff    	lea    -0x2e78(%eax),%eax
 804e6c2:	e9 98 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6c7 <.L166>:
                case EREMCHG: return "Remote address changed";
 804e6c7:	8d 80 a8 d1 ff ff    	lea    -0x2e58(%eax),%eax
 804e6cd:	e9 8d 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6d2 <.L167>:
                case ELIBACC: return "Can't access a needed shared lib.";
 804e6d2:	8d 80 c0 d1 ff ff    	lea    -0x2e40(%eax),%eax
 804e6d8:	e9 82 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6dd <.L168>:
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 804e6dd:	8d 80 e4 d1 ff ff    	lea    -0x2e1c(%eax),%eax
 804e6e3:	e9 77 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6e8 <.L169>:
                case ELIBSCN: return ".lib section in a.out corrupted.";
 804e6e8:	8d 80 08 d2 ff ff    	lea    -0x2df8(%eax),%eax
 804e6ee:	e9 6c 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6f3 <.L170>:
                case ELIBMAX: return "Attempting to link in too many libs.";
 804e6f3:	8d 80 2c d2 ff ff    	lea    -0x2dd4(%eax),%eax
 804e6f9:	e9 61 01 00 00       	jmp    804e85f <.L90+0x5>

0804e6fe <.L171>:
                case ELIBEXEC: return "Attempting to exec a shared library.";
 804e6fe:	8d 80 54 d2 ff ff    	lea    -0x2dac(%eax),%eax
 804e704:	e9 56 01 00 00       	jmp    804e85f <.L90+0x5>

0804e709 <.L172>:
                case EILSEQ: return "Illegal byte sequence.";
 804e709:	8d 80 79 d2 ff ff    	lea    -0x2d87(%eax),%eax
 804e70f:	e9 4b 01 00 00       	jmp    804e85f <.L90+0x5>

0804e714 <.L129>:
                case ENOSYS: return "Unsupported file system operation";
 804e714:	8d 80 90 d2 ff ff    	lea    -0x2d70(%eax),%eax
 804e71a:	e9 40 01 00 00       	jmp    804e85f <.L90+0x5>

0804e71f <.L131>:
                case ELOOP: return "Symbolic link loop";
 804e71f:	8d 80 b2 d2 ff ff    	lea    -0x2d4e(%eax),%eax
 804e725:	e9 35 01 00 00       	jmp    804e85f <.L90+0x5>

0804e72a <.L173>:
                case ERESTART: return "Restartable system call";
 804e72a:	8d 80 c5 d2 ff ff    	lea    -0x2d3b(%eax),%eax
 804e730:	e9 2a 01 00 00       	jmp    804e85f <.L90+0x5>

0804e735 <.L174>:
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 804e735:	8d 80 e0 d2 ff ff    	lea    -0x2d20(%eax),%eax
 804e73b:	e9 1f 01 00 00       	jmp    804e85f <.L90+0x5>

0804e740 <.L130>:
                case ENOTEMPTY: return "directory not empty";
 804e740:	8d 80 09 d3 ff ff    	lea    -0x2cf7(%eax),%eax
 804e746:	e9 14 01 00 00       	jmp    804e85f <.L90+0x5>

0804e74b <.L175>:
                case EUSERS: return "Too many users (for UFS)";
 804e74b:	8d 80 1d d3 ff ff    	lea    -0x2ce3(%eax),%eax
 804e751:	e9 09 01 00 00       	jmp    804e85f <.L90+0x5>

0804e756 <.L176>:
                case ENOTSOCK: return "Socket operation on non-socket";
 804e756:	8d 80 38 d3 ff ff    	lea    -0x2cc8(%eax),%eax
 804e75c:	e9 fe 00 00 00       	jmp    804e85f <.L90+0x5>

0804e761 <.L177>:
                case EDESTADDRREQ: return "Destination address required";
 804e761:	8d 80 57 d3 ff ff    	lea    -0x2ca9(%eax),%eax
 804e767:	e9 f3 00 00 00       	jmp    804e85f <.L90+0x5>

0804e76c <.L178>:
                case EMSGSIZE: return "Message too long";
 804e76c:	8d 80 74 d3 ff ff    	lea    -0x2c8c(%eax),%eax
 804e772:	e9 e8 00 00 00       	jmp    804e85f <.L90+0x5>

0804e777 <.L179>:
                case EPROTOTYPE: return "Protocol wrong type for socket";
 804e777:	8d 80 88 d3 ff ff    	lea    -0x2c78(%eax),%eax
 804e77d:	e9 dd 00 00 00       	jmp    804e85f <.L90+0x5>

0804e782 <.L180>:
                case ENOPROTOOPT: return "Protocol not available";
 804e782:	8d 80 a7 d3 ff ff    	lea    -0x2c59(%eax),%eax
 804e788:	e9 d2 00 00 00       	jmp    804e85f <.L90+0x5>

0804e78d <.L181>:
                case EPROTONOSUPPORT: return "Protocol not supported";
 804e78d:	8d 80 be d3 ff ff    	lea    -0x2c42(%eax),%eax
 804e793:	e9 c7 00 00 00       	jmp    804e85f <.L90+0x5>

0804e798 <.L182>:
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 804e798:	8d 80 d5 d3 ff ff    	lea    -0x2c2b(%eax),%eax
 804e79e:	e9 bc 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7a3 <.L184>:
                case EPFNOSUPPORT: return "Protocol family not supported";
 804e7a3:	8d 80 ef d3 ff ff    	lea    -0x2c11(%eax),%eax
 804e7a9:	e9 b1 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7ae <.L185>:
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 804e7ae:	8d 80 10 d4 ff ff    	lea    -0x2bf0(%eax),%eax
 804e7b4:	e9 a6 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7b9 <.L186>:
                case EADDRINUSE: return "Address already in use";
 804e7b9:	8d 80 40 d4 ff ff    	lea    -0x2bc0(%eax),%eax
 804e7bf:	e9 9b 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7c4 <.L187>:
                case EADDRNOTAVAIL: return "Can't assign requested address";
 804e7c4:	8d 80 58 d4 ff ff    	lea    -0x2ba8(%eax),%eax
 804e7ca:	e9 90 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7cf <.L188>:
                case ENETDOWN: return "Network is down";
 804e7cf:	8d 80 77 d4 ff ff    	lea    -0x2b89(%eax),%eax
 804e7d5:	e9 85 00 00 00       	jmp    804e85f <.L90+0x5>

0804e7da <.L189>:
                case ENETUNREACH: return "Network is unreachable";
 804e7da:	8d 80 87 d4 ff ff    	lea    -0x2b79(%eax),%eax
 804e7e0:	eb 7d                	jmp    804e85f <.L90+0x5>

0804e7e2 <.L190>:
                case ENETRESET: return "Network dropped connection because of reset";
 804e7e2:	8d 80 a0 d4 ff ff    	lea    -0x2b60(%eax),%eax
 804e7e8:	eb 75                	jmp    804e85f <.L90+0x5>

0804e7ea <.L191>:
                case ECONNABORTED: return "Software caused connection abort";
 804e7ea:	8d 80 cc d4 ff ff    	lea    -0x2b34(%eax),%eax
 804e7f0:	eb 6d                	jmp    804e85f <.L90+0x5>

0804e7f2 <.L192>:
                case ECONNRESET: return "Connection reset by peer";
 804e7f2:	8d 80 ed d4 ff ff    	lea    -0x2b13(%eax),%eax
 804e7f8:	eb 65                	jmp    804e85f <.L90+0x5>

0804e7fa <.L193>:
                case ENOBUFS: return "No buffer space available";
 804e7fa:	8d 80 06 d5 ff ff    	lea    -0x2afa(%eax),%eax
 804e800:	eb 5d                	jmp    804e85f <.L90+0x5>

0804e802 <.L194>:
                case EISCONN: return "Socket is already connected";
 804e802:	8d 80 20 d5 ff ff    	lea    -0x2ae0(%eax),%eax
 804e808:	eb 55                	jmp    804e85f <.L90+0x5>

0804e80a <.L195>:
                case ENOTCONN: return "Socket is not connected";
 804e80a:	8d 80 3c d5 ff ff    	lea    -0x2ac4(%eax),%eax
 804e810:	eb 4d                	jmp    804e85f <.L90+0x5>

0804e812 <.L196>:
                case ESHUTDOWN: return "Can't send after socket shutdown";
 804e812:	8d 80 54 d5 ff ff    	lea    -0x2aac(%eax),%eax
 804e818:	eb 45                	jmp    804e85f <.L90+0x5>

0804e81a <.L197>:
                case ETOOMANYREFS: return "Too many references: can't splice";
 804e81a:	8d 80 78 d5 ff ff    	lea    -0x2a88(%eax),%eax
 804e820:	eb 3d                	jmp    804e85f <.L90+0x5>

0804e822 <.L198>:
                case ETIMEDOUT: return "Connection timed out";
 804e822:	8d 80 9a d5 ff ff    	lea    -0x2a66(%eax),%eax
 804e828:	eb 35                	jmp    804e85f <.L90+0x5>

0804e82a <.L199>:
                case ECONNREFUSED: return "Connection refused";
 804e82a:	8d 80 af d5 ff ff    	lea    -0x2a51(%eax),%eax
 804e830:	eb 2d                	jmp    804e85f <.L90+0x5>

0804e832 <.L200>:
                case EHOSTDOWN: return "Host is down";
 804e832:	8d 80 c2 d5 ff ff    	lea    -0x2a3e(%eax),%eax
 804e838:	eb 25                	jmp    804e85f <.L90+0x5>

0804e83a <.L201>:
                case EHOSTUNREACH: return "No route to host";
 804e83a:	8d 80 cf d5 ff ff    	lea    -0x2a31(%eax),%eax
 804e840:	eb 1d                	jmp    804e85f <.L90+0x5>

0804e842 <.L202>:
                case EALREADY: return "operation already in progress";
 804e842:	8d 80 e0 d5 ff ff    	lea    -0x2a20(%eax),%eax
 804e848:	eb 15                	jmp    804e85f <.L90+0x5>

0804e84a <.L203>:
                case EINPROGRESS: return "operation now in progress";
 804e84a:	8d 80 fe d5 ff ff    	lea    -0x2a02(%eax),%eax
 804e850:	eb 0d                	jmp    804e85f <.L90+0x5>

0804e852 <.L204>:
                case ESTALE: return "Stale NFS file handle";
 804e852:	8d 80 18 d6 ff ff    	lea    -0x29e8(%eax),%eax
 804e858:	eb 05                	jmp    804e85f <.L90+0x5>

0804e85a <.L90>:
                default: return 0;
 804e85a:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 804e85f:	5d                   	pop    %ebp
 804e860:	c3                   	ret    

0804e861 <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 804e861:	55                   	push   %ebp
 804e862:	89 e5                	mov    %esp,%ebp
 804e864:	53                   	push   %ebx
 804e865:	83 ec 24             	sub    $0x24,%esp
 804e868:	e8 ec f5 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804e86d:	81 c3 9f 90 00 00    	add    $0x909f,%ebx
        char *q = " error: ";
 804e873:	8d 83 41 d8 ff ff    	lea    -0x27bf(%ebx),%eax
 804e879:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804e87c:	8b 83 18 00 00 00    	mov    0x18(%ebx),%eax
 804e882:	89 04 24             	mov    %eax,(%esp)
 804e885:	e8 40 f8 ff ff       	call   804e0ca <strlen>
 804e88a:	89 c2                	mov    %eax,%edx
 804e88c:	8b 83 18 00 00 00    	mov    0x18(%ebx),%eax
 804e892:	89 54 24 08          	mov    %edx,0x8(%esp)
 804e896:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e89a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e8a1:	e8 2c ee ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804e8a6:	8b 83 b4 02 00 00    	mov    0x2b4(%ebx),%eax
 804e8ac:	89 04 24             	mov    %eax,(%esp)
 804e8af:	e8 16 f8 ff ff       	call   804e0ca <strlen>
 804e8b4:	89 c2                	mov    %eax,%edx
 804e8b6:	8b 83 b4 02 00 00    	mov    0x2b4(%ebx),%eax
 804e8bc:	89 54 24 08          	mov    %edx,0x8(%esp)
 804e8c0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e8c4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e8cb:	e8 02 ee ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, q, strlen(q));
 804e8d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e8d3:	89 04 24             	mov    %eax,(%esp)
 804e8d6:	e8 ef f7 ff ff       	call   804e0ca <strlen>
 804e8db:	89 44 24 08          	mov    %eax,0x8(%esp)
 804e8df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e8e2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e8e6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e8ed:	e8 e0 ed ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, p, strlen(p));
 804e8f2:	8b 45 08             	mov    0x8(%ebp),%eax
 804e8f5:	89 04 24             	mov    %eax,(%esp)
 804e8f8:	e8 cd f7 ff ff       	call   804e0ca <strlen>
 804e8fd:	89 44 24 08          	mov    %eax,0x8(%esp)
 804e901:	8b 45 08             	mov    0x8(%ebp),%eax
 804e904:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e908:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e90f:	e8 be ed ff ff       	call   804d6d2 <write>
        suicide = 1;
 804e914:	c7 83 90 02 00 00 01 	movl   $0x1,0x290(%ebx)
 804e91b:	00 00 00 
        abort();
 804e91e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804e925:	e8 c4 e9 ff ff       	call   804d2ee <exit>
}
 804e92a:	90                   	nop
 804e92b:	83 c4 24             	add    $0x24,%esp
 804e92e:	5b                   	pop    %ebx
 804e92f:	5d                   	pop    %ebp
 804e930:	c3                   	ret    

0804e931 <wrtwarning>:

static void
wrtwarning(char *p)
{
 804e931:	55                   	push   %ebp
 804e932:	89 e5                	mov    %esp,%ebp
 804e934:	53                   	push   %ebx
 804e935:	83 ec 24             	sub    $0x24,%esp
 804e938:	e8 1c f5 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804e93d:	81 c3 cf 8f 00 00    	add    $0x8fcf,%ebx
        char *q = " warning: ";
 804e943:	8d 83 4a d8 ff ff    	lea    -0x27b6(%ebx),%eax
 804e949:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 804e94c:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804e952:	85 c0                	test   %eax,%eax
 804e954:	74 0b                	je     804e961 <wrtwarning+0x30>
                wrterror(p);
 804e956:	8b 45 08             	mov    0x8(%ebp),%eax
 804e959:	89 04 24             	mov    %eax,(%esp)
 804e95c:	e8 00 ff ff ff       	call   804e861 <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 804e961:	8b 83 18 00 00 00    	mov    0x18(%ebx),%eax
 804e967:	89 04 24             	mov    %eax,(%esp)
 804e96a:	e8 5b f7 ff ff       	call   804e0ca <strlen>
 804e96f:	89 c2                	mov    %eax,%edx
 804e971:	8b 83 18 00 00 00    	mov    0x18(%ebx),%eax
 804e977:	89 54 24 08          	mov    %edx,0x8(%esp)
 804e97b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e97f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e986:	e8 47 ed ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 804e98b:	8b 83 b4 02 00 00    	mov    0x2b4(%ebx),%eax
 804e991:	89 04 24             	mov    %eax,(%esp)
 804e994:	e8 31 f7 ff ff       	call   804e0ca <strlen>
 804e999:	89 c2                	mov    %eax,%edx
 804e99b:	8b 83 b4 02 00 00    	mov    0x2b4(%ebx),%eax
 804e9a1:	89 54 24 08          	mov    %edx,0x8(%esp)
 804e9a5:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e9a9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e9b0:	e8 1d ed ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, q, strlen(q));
 804e9b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e9b8:	89 04 24             	mov    %eax,(%esp)
 804e9bb:	e8 0a f7 ff ff       	call   804e0ca <strlen>
 804e9c0:	89 44 24 08          	mov    %eax,0x8(%esp)
 804e9c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804e9c7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e9cb:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e9d2:	e8 fb ec ff ff       	call   804d6d2 <write>
        _write(STDERR_FILENO, p, strlen(p));
 804e9d7:	8b 45 08             	mov    0x8(%ebp),%eax
 804e9da:	89 04 24             	mov    %eax,(%esp)
 804e9dd:	e8 e8 f6 ff ff       	call   804e0ca <strlen>
 804e9e2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804e9e6:	8b 45 08             	mov    0x8(%ebp),%eax
 804e9e9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804e9ed:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 804e9f4:	e8 d9 ec ff ff       	call   804d6d2 <write>
}
 804e9f9:	90                   	nop
 804e9fa:	83 c4 24             	add    $0x24,%esp
 804e9fd:	5b                   	pop    %ebx
 804e9fe:	5d                   	pop    %ebp
 804e9ff:	c3                   	ret    

0804ea00 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 804ea00:	55                   	push   %ebp
 804ea01:	89 e5                	mov    %esp,%ebp
 804ea03:	53                   	push   %ebx
 804ea04:	83 ec 24             	sub    $0x24,%esp
 804ea07:	e8 4d f4 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804ea0c:	81 c3 00 8f 00 00    	add    $0x8f00,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 804ea12:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ea19:	e8 e1 e6 ff ff       	call   804d0ff <sbrk>
 804ea1e:	05 ff 0f 00 00       	add    $0xfff,%eax
 804ea23:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804ea28:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 804ea2b:	8b 45 08             	mov    0x8(%ebp),%eax
 804ea2e:	c1 e0 0c             	shl    $0xc,%eax
 804ea31:	89 c2                	mov    %eax,%edx
 804ea33:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ea36:	01 d0                	add    %edx,%eax
 804ea38:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 804ea3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ea3e:	89 04 24             	mov    %eax,(%esp)
 804ea41:	e8 82 e7 ff ff       	call   804d1c8 <brk>
 804ea46:	85 c0                	test   %eax,%eax
 804ea48:	74 07                	je     804ea51 <map_pages+0x51>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 804ea4a:	b8 00 00 00 00       	mov    $0x0,%eax
 804ea4f:	eb 51                	jmp    804eaa2 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 804ea51:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ea54:	c1 e8 0c             	shr    $0xc,%eax
 804ea57:	89 c2                	mov    %eax,%edx
 804ea59:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804ea5f:	29 c2                	sub    %eax,%edx
 804ea61:	89 d0                	mov    %edx,%eax
 804ea63:	48                   	dec    %eax
 804ea64:	89 83 6c 02 00 00    	mov    %eax,0x26c(%ebx)
        malloc_brk = tail;
 804ea6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ea6d:	89 83 ac 02 00 00    	mov    %eax,0x2ac(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 804ea73:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 804ea79:	8d 50 01             	lea    0x1(%eax),%edx
 804ea7c:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804ea82:	39 c2                	cmp    %eax,%edx
 804ea84:	72 19                	jb     804ea9f <map_pages+0x9f>
 804ea86:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 804ea8c:	89 04 24             	mov    %eax,(%esp)
 804ea8f:	e8 14 00 00 00       	call   804eaa8 <extend_pgdir>
 804ea94:	85 c0                	test   %eax,%eax
 804ea96:	75 07                	jne    804ea9f <map_pages+0x9f>
                return 0;;
 804ea98:	b8 00 00 00 00       	mov    $0x0,%eax
 804ea9d:	eb 03                	jmp    804eaa2 <map_pages+0xa2>

        return result;
 804ea9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804eaa2:	83 c4 24             	add    $0x24,%esp
 804eaa5:	5b                   	pop    %ebx
 804eaa6:	5d                   	pop    %ebp
 804eaa7:	c3                   	ret    

0804eaa8 <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 804eaa8:	55                   	push   %ebp
 804eaa9:	89 e5                	mov    %esp,%ebp
 804eaab:	53                   	push   %ebx
 804eaac:	83 ec 34             	sub    $0x34,%esp
 804eaaf:	e8 a5 f3 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804eab4:	81 c3 58 8e 00 00    	add    $0x8e58,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 804eaba:	8b 45 08             	mov    0x8(%ebp),%eax
 804eabd:	c1 e0 02             	shl    $0x2,%eax
 804eac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 804eac3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804eac6:	c1 e8 0c             	shr    $0xc,%eax
 804eac9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 804eacc:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 804ead0:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804ead6:	c1 e0 02             	shl    $0x2,%eax
 804ead9:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 804eadc:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804eae2:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804eae5:	c1 e2 0c             	shl    $0xc,%edx
 804eae8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804eaef:	00 
 804eaf0:	89 44 24 10          	mov    %eax,0x10(%esp)
 804eaf4:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804eafb:	00 
 804eafc:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804eb03:	00 
 804eb04:	89 54 24 04          	mov    %edx,0x4(%esp)
 804eb08:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804eb0f:	e8 cc e9 ff ff       	call   804d4e0 <mmap>
 804eb14:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 804eb17:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 804eb1b:	75 07                	jne    804eb24 <extend_pgdir+0x7c>
                return 0;
 804eb1d:	b8 00 00 00 00       	mov    $0x0,%eax
 804eb22:	eb 5e                	jmp    804eb82 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 804eb24:	8b 83 74 02 00 00    	mov    0x274(%ebx),%eax
 804eb2a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804eb31:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804eb37:	89 54 24 08          	mov    %edx,0x8(%esp)
 804eb3b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804eb3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804eb42:	89 04 24             	mov    %eax,(%esp)
 804eb45:	e8 66 f3 ff ff       	call   804deb0 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 804eb4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804eb4d:	c1 e0 0c             	shl    $0xc,%eax
 804eb50:	c1 e8 02             	shr    $0x2,%eax
 804eb53:	89 83 74 02 00 00    	mov    %eax,0x274(%ebx)

        /* swap the pointers */
        old = page_dir;
 804eb59:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804eb5f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 804eb62:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804eb65:	89 83 70 02 00 00    	mov    %eax,0x270(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 804eb6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804eb6e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804eb72:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eb75:	89 04 24             	mov    %eax,(%esp)
 804eb78:	e8 c6 e9 ff ff       	call   804d543 <munmap>
        return 1;
 804eb7d:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804eb82:	83 c4 34             	add    $0x34,%esp
 804eb85:	5b                   	pop    %ebx
 804eb86:	5d                   	pop    %ebp
 804eb87:	c3                   	ret    

0804eb88 <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 804eb88:	55                   	push   %ebp
 804eb89:	89 e5                	mov    %esp,%ebp
 804eb8b:	53                   	push   %ebx
 804eb8c:	83 ec 34             	sub    $0x34,%esp
 804eb8f:	e8 c5 f2 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804eb94:	81 c3 78 8d 00 00    	add    $0x8d78,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 804eb9a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804eba1:	00 
 804eba2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804eba9:	00 
 804ebaa:	8d 83 55 d8 ff ff    	lea    -0x27ab(%ebx),%eax
 804ebb0:	89 04 24             	mov    %eax,(%esp)
 804ebb3:	e8 14 ea ff ff       	call   804d5cc <open>
 804ebb8:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
 804ebbe:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ebc4:	83 f8 ff             	cmp    $0xffffffff,%eax
 804ebc7:	75 0e                	jne    804ebd7 <malloc_init+0x4f>
 804ebc9:	8d 83 5f d8 ff ff    	lea    -0x27a1(%ebx),%eax
 804ebcf:	89 04 24             	mov    %eax,(%esp)
 804ebd2:	e8 8a fc ff ff       	call   804e861 <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804ebd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804ebde:	e9 7c 01 00 00       	jmp    804ed5f <.L18+0x45>
                if (i == 0) {
 804ebe3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804ebe7:	75 0c                	jne    804ebf5 <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 804ebe9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804ebf0:	e9 53 01 00 00       	jmp    804ed48 <.L18+0x2e>
#endif
                } else if (i == 1) {
 804ebf5:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 804ebf9:	75 0c                	jne    804ec07 <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 804ebfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804ec02:	e9 41 01 00 00       	jmp    804ed48 <.L18+0x2e>
#endif
                } else {
                        p = malloc_options;
 804ec07:	8d 05 cc 7b 05 08    	lea    0x8057bcc,%eax
 804ec0d:	8b 00                	mov    (%eax),%eax
 804ec0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 804ec12:	e9 31 01 00 00       	jmp    804ed48 <.L18+0x2e>
                        switch (*p) {
 804ec17:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ec1a:	0f b6 00             	movzbl (%eax),%eax
 804ec1d:	0f be c0             	movsbl %al,%eax
 804ec20:	83 e8 3c             	sub    $0x3c,%eax
 804ec23:	83 f8 3e             	cmp    $0x3e,%eax
 804ec26:	0f 87 ee 00 00 00    	ja     804ed1a <.L18>
 804ec2c:	c1 e0 02             	shl    $0x2,%eax
 804ec2f:	8b 84 18 b4 d8 ff ff 	mov    -0x274c(%eax,%ebx,1),%eax
 804ec36:	01 d8                	add    %ebx,%eax
 804ec38:	ff e0                	jmp    *%eax

0804ec3a <.L21>:
                                case '>': malloc_cache   <<= 1; break;
 804ec3a:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804ec40:	01 c0                	add    %eax,%eax
 804ec42:	89 83 14 00 00 00    	mov    %eax,0x14(%ebx)
 804ec48:	e9 f8 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec4d <.L19>:
                                case '<': malloc_cache   >>= 1; break;
 804ec4d:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804ec53:	d1 e8                	shr    %eax
 804ec55:	89 83 14 00 00 00    	mov    %eax,0x14(%ebx)
 804ec5b:	e9 e5 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec60 <.L29>:
                                case 'a': malloc_abort   = 0; break;
 804ec60:	c7 83 8c 02 00 00 00 	movl   $0x0,0x28c(%ebx)
 804ec67:	00 00 00 
 804ec6a:	e9 d6 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec6f <.L22>:
                                case 'A': malloc_abort   = 1; break;
 804ec6f:	c7 83 8c 02 00 00 01 	movl   $0x1,0x28c(%ebx)
 804ec76:	00 00 00 
 804ec79:	e9 c7 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec7e <.L30>:
                                case 'h': malloc_hint    = 0; break;
 804ec7e:	c7 83 98 02 00 00 00 	movl   $0x0,0x298(%ebx)
 804ec85:	00 00 00 
 804ec88:	e9 b8 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec8d <.L23>:
                                case 'H': malloc_hint    = 1; break;
 804ec8d:	c7 83 98 02 00 00 01 	movl   $0x1,0x298(%ebx)
 804ec94:	00 00 00 
 804ec97:	e9 a9 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ec9c <.L32>:
                                case 'r': malloc_realloc = 0; break;
 804ec9c:	c7 83 94 02 00 00 00 	movl   $0x0,0x294(%ebx)
 804eca3:	00 00 00 
 804eca6:	e9 9a 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ecab <.L25>:
                                case 'R': malloc_realloc = 1; break;
 804ecab:	c7 83 94 02 00 00 01 	movl   $0x1,0x294(%ebx)
 804ecb2:	00 00 00 
 804ecb5:	e9 8b 00 00 00       	jmp    804ed45 <.L18+0x2b>

0804ecba <.L31>:
                                case 'j': malloc_junk    = 0; break;
 804ecba:	c7 83 a8 02 00 00 00 	movl   $0x0,0x2a8(%ebx)
 804ecc1:	00 00 00 
 804ecc4:	eb 7f                	jmp    804ed45 <.L18+0x2b>

0804ecc6 <.L24>:
                                case 'J': malloc_junk    = 1; break;
 804ecc6:	c7 83 a8 02 00 00 01 	movl   $0x1,0x2a8(%ebx)
 804eccd:	00 00 00 
 804ecd0:	eb 73                	jmp    804ed45 <.L18+0x2b>

0804ecd2 <.L33>:
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 804ecd2:	c7 83 a0 02 00 00 00 	movl   $0x0,0x2a0(%ebx)
 804ecd9:	00 00 00 
 804ecdc:	eb 67                	jmp    804ed45 <.L18+0x2b>

0804ecde <.L26>:
                                case 'V': malloc_sysv    = 1; break;
 804ecde:	c7 83 a0 02 00 00 01 	movl   $0x1,0x2a0(%ebx)
 804ece5:	00 00 00 
 804ece8:	eb 5b                	jmp    804ed45 <.L18+0x2b>

0804ecea <.L34>:
                                case 'x': malloc_xmalloc = 0; break;
 804ecea:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804ecf1:	00 00 00 
 804ecf4:	eb 4f                	jmp    804ed45 <.L18+0x2b>

0804ecf6 <.L27>:
                                case 'X': malloc_xmalloc = 1; break;
 804ecf6:	c7 83 9c 02 00 00 01 	movl   $0x1,0x29c(%ebx)
 804ecfd:	00 00 00 
 804ed00:	eb 43                	jmp    804ed45 <.L18+0x2b>

0804ed02 <.L35>:
                                case 'z': malloc_zero    = 0; break;
 804ed02:	c7 83 a4 02 00 00 00 	movl   $0x0,0x2a4(%ebx)
 804ed09:	00 00 00 
 804ed0c:	eb 37                	jmp    804ed45 <.L18+0x2b>

0804ed0e <.L28>:
                                case 'Z': malloc_zero    = 1; break;
 804ed0e:	c7 83 a4 02 00 00 01 	movl   $0x1,0x2a4(%ebx)
 804ed15:	00 00 00 
 804ed18:	eb 2b                	jmp    804ed45 <.L18+0x2b>

0804ed1a <.L18>:
                                default:
                                        j = malloc_abort;
 804ed1a:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804ed20:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 804ed23:	c7 83 8c 02 00 00 00 	movl   $0x0,0x28c(%ebx)
 804ed2a:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 804ed2d:	8d 83 74 d8 ff ff    	lea    -0x278c(%ebx),%eax
 804ed33:	89 04 24             	mov    %eax,(%esp)
 804ed36:	e8 f6 fb ff ff       	call   804e931 <wrtwarning>
                                        malloc_abort = j;
 804ed3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ed3e:	89 83 8c 02 00 00    	mov    %eax,0x28c(%ebx)
                                        break;
 804ed44:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 804ed45:	ff 45 f4             	incl   -0xc(%ebp)
 804ed48:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ed4c:	74 0e                	je     804ed5c <.L18+0x42>
 804ed4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ed51:	0f b6 00             	movzbl (%eax),%eax
 804ed54:	84 c0                	test   %al,%al
 804ed56:	0f 85 bb fe ff ff    	jne    804ec17 <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 804ed5c:	ff 45 f0             	incl   -0x10(%ebp)
 804ed5f:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 804ed63:	0f 8e 7a fe ff ff    	jle    804ebe3 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 804ed69:	8b 83 a4 02 00 00    	mov    0x2a4(%ebx),%eax
 804ed6f:	85 c0                	test   %eax,%eax
 804ed71:	74 0a                	je     804ed7d <.L18+0x63>
                malloc_junk = 1;
 804ed73:	c7 83 a8 02 00 00 01 	movl   $0x1,0x2a8(%ebx)
 804ed7a:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 804ed7d:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 804ed83:	85 c0                	test   %eax,%eax
 804ed85:	74 0a                	je     804ed91 <.L18+0x77>
                malloc_realloc = 1;
 804ed87:	c7 83 94 02 00 00 01 	movl   $0x1,0x294(%ebx)
 804ed8e:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 804ed91:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ed97:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804ed9e:	00 
 804ed9f:	89 44 24 10          	mov    %eax,0x10(%esp)
 804eda3:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804edaa:	00 
 804edab:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804edb2:	00 
 804edb3:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804edba:	00 
 804edbb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804edc2:	e8 19 e7 ff ff       	call   804d4e0 <mmap>
 804edc7:	89 83 70 02 00 00    	mov    %eax,0x270(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 804edcd:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804edd3:	83 f8 ff             	cmp    $0xffffffff,%eax
 804edd6:	75 0e                	jne    804ede6 <.L18+0xcc>
                wrterror("mmap(2) failed, check limits\n");
 804edd8:	8d 83 94 d8 ff ff    	lea    -0x276c(%ebx),%eax
 804edde:	89 04 24             	mov    %eax,(%esp)
 804ede1:	e8 7b fa ff ff       	call   804e861 <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 804ede6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804eded:	e8 0d e3 ff ff       	call   804d0ff <sbrk>
 804edf2:	05 ff 0f 00 00       	add    $0xfff,%eax
 804edf7:	c1 e8 0c             	shr    $0xc,%eax
 804edfa:	89 83 68 02 00 00    	mov    %eax,0x268(%ebx)
        malloc_origo -= malloc_pageshift;
 804ee00:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804ee06:	83 e8 0c             	sub    $0xc,%eax
 804ee09:	89 83 68 02 00 00    	mov    %eax,0x268(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 804ee0f:	c7 83 74 02 00 00 00 	movl   $0x400,0x274(%ebx)
 804ee16:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 804ee19:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804ee1f:	85 c0                	test   %eax,%eax
 804ee21:	75 0d                	jne    804ee30 <.L18+0x116>
                malloc_cache++;
 804ee23:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804ee29:	40                   	inc    %eax
 804ee2a:	89 83 14 00 00 00    	mov    %eax,0x14(%ebx)

        malloc_cache <<= malloc_pageshift;
 804ee30:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804ee36:	c1 e0 0c             	shl    $0xc,%eax
 804ee39:	89 83 14 00 00 00    	mov    %eax,0x14(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 804ee3f:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804ee46:	e8 5d 07 00 00       	call   804f5a8 <imalloc>
 804ee4b:	89 83 b0 02 00 00    	mov    %eax,0x2b0(%ebx)

        /* Been here, done that */
        malloc_started++;
 804ee51:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804ee57:	40                   	inc    %eax
 804ee58:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
}
 804ee5e:	90                   	nop
 804ee5f:	83 c4 34             	add    $0x34,%esp
 804ee62:	5b                   	pop    %ebx
 804ee63:	5d                   	pop    %ebp
 804ee64:	c3                   	ret    

0804ee65 <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 804ee65:	55                   	push   %ebp
 804ee66:	89 e5                	mov    %esp,%ebp
 804ee68:	53                   	push   %ebx
 804ee69:	83 ec 34             	sub    $0x34,%esp
 804ee6c:	e8 e8 ef ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804ee71:	81 c3 9b 8a 00 00    	add    $0x8a9b,%ebx
        void *p, *delay_free = 0;
 804ee77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 804ee7e:	8b 45 08             	mov    0x8(%ebp),%eax
 804ee81:	05 ff 0f 00 00       	add    $0xfff,%eax
 804ee86:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804ee8b:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 804ee8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804ee95:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804ee9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804ee9e:	e9 82 00 00 00       	jmp    804ef25 <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804eea3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eea6:	8b 40 10             	mov    0x10(%eax),%eax
 804eea9:	3b 45 08             	cmp    0x8(%ebp),%eax
 804eeac:	73 0a                	jae    804eeb8 <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804eeae:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eeb1:	8b 00                	mov    (%eax),%eax
 804eeb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804eeb6:	eb 6d                	jmp    804ef25 <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 804eeb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eebb:	8b 40 10             	mov    0x10(%eax),%eax
 804eebe:	3b 45 08             	cmp    0x8(%ebp),%eax
 804eec1:	75 35                	jne    804eef8 <malloc_pages+0x93>
                        p = pf->page;
 804eec3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eec6:	8b 40 08             	mov    0x8(%eax),%eax
 804eec9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 804eecc:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eecf:	8b 00                	mov    (%eax),%eax
 804eed1:	85 c0                	test   %eax,%eax
 804eed3:	74 0e                	je     804eee3 <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 804eed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eed8:	8b 00                	mov    (%eax),%eax
 804eeda:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804eedd:	8b 52 04             	mov    0x4(%edx),%edx
 804eee0:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 804eee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eee6:	8b 40 04             	mov    0x4(%eax),%eax
 804eee9:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804eeec:	8b 12                	mov    (%edx),%edx
 804eeee:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 804eef0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eef3:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 804eef6:	eb 37                	jmp    804ef2f <malloc_pages+0xca>
                }

                p = pf->page;
 804eef8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804eefb:	8b 40 08             	mov    0x8(%eax),%eax
 804eefe:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 804ef01:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ef04:	8b 50 08             	mov    0x8(%eax),%edx
 804ef07:	8b 45 08             	mov    0x8(%ebp),%eax
 804ef0a:	01 c2                	add    %eax,%edx
 804ef0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ef0f:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 804ef12:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ef15:	8b 40 10             	mov    0x10(%eax),%eax
 804ef18:	2b 45 08             	sub    0x8(%ebp),%eax
 804ef1b:	89 c2                	mov    %eax,%edx
 804ef1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ef20:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804ef23:	eb 0a                	jmp    804ef2f <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804ef25:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804ef29:	0f 85 74 ff ff ff    	jne    804eea3 <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 804ef2f:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804ef33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ef37:	75 0e                	jne    804ef47 <malloc_pages+0xe2>
                p = map_pages(size);
 804ef39:	8b 45 08             	mov    0x8(%ebp),%eax
 804ef3c:	89 04 24             	mov    %eax,(%esp)
 804ef3f:	e8 bc fa ff ff       	call   804ea00 <map_pages>
 804ef44:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804ef47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ef4b:	74 7d                	je     804efca <malloc_pages+0x165>

                index = ptr2index(p);
 804ef4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ef50:	c1 e8 0c             	shr    $0xc,%eax
 804ef53:	89 c2                	mov    %eax,%edx
 804ef55:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804ef5b:	29 c2                	sub    %eax,%edx
 804ef5d:	89 d0                	mov    %edx,%eax
 804ef5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804ef62:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804ef68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ef6b:	c1 e2 02             	shl    $0x2,%edx
 804ef6e:	01 d0                	add    %edx,%eax
 804ef70:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 804ef76:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804ef7d:	eb 1c                	jmp    804ef9b <malloc_pages+0x136>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804ef7f:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804ef85:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804ef88:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ef8b:	01 ca                	add    %ecx,%edx
 804ef8d:	c1 e2 02             	shl    $0x2,%edx
 804ef90:	01 d0                	add    %edx,%eax
 804ef92:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 804ef98:	ff 45 ec             	incl   -0x14(%ebp)
 804ef9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ef9e:	3b 45 08             	cmp    0x8(%ebp),%eax
 804efa1:	72 dc                	jb     804ef7f <malloc_pages+0x11a>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 804efa3:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 804efa9:	85 c0                	test   %eax,%eax
 804efab:	74 1d                	je     804efca <malloc_pages+0x165>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 804efad:	8b 45 08             	mov    0x8(%ebp),%eax
 804efb0:	c1 e0 0c             	shl    $0xc,%eax
 804efb3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804efb7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804efbe:	00 
 804efbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804efc2:	89 04 24             	mov    %eax,(%esp)
 804efc5:	e8 41 f0 ff ff       	call   804e00b <memset>
        }

        if (delay_free) {
 804efca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804efce:	74 20                	je     804eff0 <malloc_pages+0x18b>
                if (!px)
 804efd0:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804efd6:	85 c0                	test   %eax,%eax
 804efd8:	75 0b                	jne    804efe5 <malloc_pages+0x180>
                        px = delay_free;
 804efda:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804efdd:	89 83 b0 02 00 00    	mov    %eax,0x2b0(%ebx)
 804efe3:	eb 0b                	jmp    804eff0 <malloc_pages+0x18b>
                else
                        ifree(delay_free);
 804efe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804efe8:	89 04 24             	mov    %eax,(%esp)
 804efeb:	e8 d7 0e 00 00       	call   804fec7 <ifree>
        }

        return p;
 804eff0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804eff3:	83 c4 34             	add    $0x34,%esp
 804eff6:	5b                   	pop    %ebx
 804eff7:	5d                   	pop    %ebp
 804eff8:	c3                   	ret    

0804eff9 <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 804eff9:	55                   	push   %ebp
 804effa:	89 e5                	mov    %esp,%ebp
 804effc:	56                   	push   %esi
 804effd:	53                   	push   %ebx
 804effe:	83 ec 30             	sub    $0x30,%esp
 804f001:	e8 53 ee ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804f006:	81 c3 06 89 00 00    	add    $0x8906,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804f00c:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804f013:	e8 4d fe ff ff       	call   804ee65 <malloc_pages>
 804f018:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (!pp)
 804f01b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804f01f:	75 0a                	jne    804f02b <malloc_make_chunks+0x32>
                return 0;
 804f021:	b8 00 00 00 00       	mov    $0x0,%eax
 804f026:	e9 f4 01 00 00       	jmp    804f21f <malloc_make_chunks+0x226>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804f02b:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804f032:	8b 45 08             	mov    0x8(%ebp),%eax
 804f035:	ba 00 10 00 00       	mov    $0x1000,%edx
 804f03a:	88 c1                	mov    %al,%cl
 804f03c:	d3 ea                	shr    %cl,%edx
 804f03e:	89 d0                	mov    %edx,%eax
 804f040:	83 c0 1f             	add    $0x1f,%eax
 804f043:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804f046:	c1 e0 02             	shl    $0x2,%eax
 804f049:	01 45 ec             	add    %eax,-0x14(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804f04c:	8b 45 08             	mov    0x8(%ebp),%eax
 804f04f:	ba 01 00 00 00       	mov    $0x1,%edx
 804f054:	88 c1                	mov    %al,%cl
 804f056:	d3 e2                	shl    %cl,%edx
 804f058:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804f05b:	01 c0                	add    %eax,%eax
 804f05d:	39 c2                	cmp    %eax,%edx
 804f05f:	77 08                	ja     804f069 <malloc_make_chunks+0x70>
                bp = (struct  pginfo *)pp;
 804f061:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f064:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804f067:	eb 29                	jmp    804f092 <malloc_make_chunks+0x99>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804f069:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804f06c:	89 04 24             	mov    %eax,(%esp)
 804f06f:	e8 34 05 00 00       	call   804f5a8 <imalloc>
 804f074:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if (!bp) {
 804f077:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804f07b:	75 15                	jne    804f092 <malloc_make_chunks+0x99>
                        ifree(pp);
 804f07d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f080:	89 04 24             	mov    %eax,(%esp)
 804f083:	e8 3f 0e 00 00       	call   804fec7 <ifree>
                        return 0;
 804f088:	b8 00 00 00 00       	mov    $0x0,%eax
 804f08d:	e9 8d 01 00 00       	jmp    804f21f <malloc_make_chunks+0x226>
                }
        }

        bp->size = (1 << bits);
 804f092:	8b 45 08             	mov    0x8(%ebp),%eax
 804f095:	ba 01 00 00 00       	mov    $0x1,%edx
 804f09a:	88 c1                	mov    %al,%cl
 804f09c:	d3 e2                	shl    %cl,%edx
 804f09e:	89 d0                	mov    %edx,%eax
 804f0a0:	0f b7 d0             	movzwl %ax,%edx
 804f0a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0a6:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804f0aa:	8b 45 08             	mov    0x8(%ebp),%eax
 804f0ad:	0f b7 d0             	movzwl %ax,%edx
 804f0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0b3:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804f0b7:	8b 45 08             	mov    0x8(%ebp),%eax
 804f0ba:	ba 00 10 00 00       	mov    $0x1000,%edx
 804f0bf:	88 c1                	mov    %al,%cl
 804f0c1:	d3 ea                	shr    %cl,%edx
 804f0c3:	89 d0                	mov    %edx,%eax
 804f0c5:	0f b7 d0             	movzwl %ax,%edx
 804f0c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0cb:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804f0cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0d2:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804f0d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0d9:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804f0dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0e0:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804f0e3:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804f0e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f0e9:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804f0ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        i = 0;
 804f0f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804f0f7:	eb 19                	jmp    804f112 <malloc_make_chunks+0x119>
                bp->bits[i / MALLOC_BITS] = ~0;
 804f0f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f0fc:	c1 e8 05             	shr    $0x5,%eax
 804f0ff:	89 c2                	mov    %eax,%edx
 804f101:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f104:	83 c2 04             	add    $0x4,%edx
 804f107:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804f10e:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
 804f112:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f115:	2b 45 f0             	sub    -0x10(%ebp),%eax
 804f118:	83 f8 1f             	cmp    $0x1f,%eax
 804f11b:	77 dc                	ja     804f0f9 <malloc_make_chunks+0x100>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804f11d:	eb 2c                	jmp    804f14b <malloc_make_chunks+0x152>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804f11f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f122:	c1 e8 05             	shr    $0x5,%eax
 804f125:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f128:	8d 48 04             	lea    0x4(%eax),%ecx
 804f12b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804f12e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804f131:	83 e1 1f             	and    $0x1f,%ecx
 804f134:	be 01 00 00 00       	mov    $0x1,%esi
 804f139:	d3 e6                	shl    %cl,%esi
 804f13b:	89 f1                	mov    %esi,%ecx
 804f13d:	09 d1                	or     %edx,%ecx
 804f13f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f142:	83 c0 04             	add    $0x4,%eax
 804f145:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804f148:	ff 45 f0             	incl   -0x10(%ebp)
 804f14b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f14e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804f151:	72 cc                	jb     804f11f <malloc_make_chunks+0x126>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804f153:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f156:	8b 40 04             	mov    0x4(%eax),%eax
 804f159:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804f15c:	75 72                	jne    804f1d0 <malloc_make_chunks+0x1d7>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804f15e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804f165:	eb 63                	jmp    804f1ca <malloc_make_chunks+0x1d1>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804f167:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f16a:	c1 e8 05             	shr    $0x5,%eax
 804f16d:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f170:	8d 48 04             	lea    0x4(%eax),%ecx
 804f173:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804f176:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804f179:	83 e1 1f             	and    $0x1f,%ecx
 804f17c:	be 01 00 00 00       	mov    $0x1,%esi
 804f181:	d3 e6                	shl    %cl,%esi
 804f183:	89 f1                	mov    %esi,%ecx
 804f185:	f7 d1                	not    %ecx
 804f187:	21 d1                	and    %edx,%ecx
 804f189:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f18c:	83 c0 04             	add    $0x4,%eax
 804f18f:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804f192:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f195:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804f199:	48                   	dec    %eax
 804f19a:	0f b7 d0             	movzwl %ax,%edx
 804f19d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f1a0:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804f1a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f1a7:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804f1ab:	48                   	dec    %eax
 804f1ac:	0f b7 d0             	movzwl %ax,%edx
 804f1af:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f1b2:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804f1b6:	8b 45 08             	mov    0x8(%ebp),%eax
 804f1b9:	ba 01 00 00 00       	mov    $0x1,%edx
 804f1be:	88 c1                	mov    %al,%cl
 804f1c0:	d3 e2                	shl    %cl,%edx
 804f1c2:	89 d0                	mov    %edx,%eax
 804f1c4:	29 45 ec             	sub    %eax,-0x14(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804f1c7:	ff 45 f0             	incl   -0x10(%ebp)
 804f1ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804f1ce:	75 97                	jne    804f167 <malloc_make_chunks+0x16e>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804f1d0:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f1d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804f1d9:	89 d1                	mov    %edx,%ecx
 804f1db:	c1 e9 0c             	shr    $0xc,%ecx
 804f1de:	8b 93 68 02 00 00    	mov    0x268(%ebx),%edx
 804f1e4:	29 d1                	sub    %edx,%ecx
 804f1e6:	89 ca                	mov    %ecx,%edx
 804f1e8:	c1 e2 02             	shl    $0x2,%edx
 804f1eb:	01 c2                	add    %eax,%edx
 804f1ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f1f0:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804f1f2:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f1f8:	8b 55 08             	mov    0x8(%ebp),%edx
 804f1fb:	c1 e2 02             	shl    $0x2,%edx
 804f1fe:	01 d0                	add    %edx,%eax
 804f200:	8b 10                	mov    (%eax),%edx
 804f202:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f205:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804f207:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f20d:	8b 55 08             	mov    0x8(%ebp),%edx
 804f210:	c1 e2 02             	shl    $0x2,%edx
 804f213:	01 c2                	add    %eax,%edx
 804f215:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f218:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804f21a:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804f21f:	83 c4 30             	add    $0x30,%esp
 804f222:	5b                   	pop    %ebx
 804f223:	5e                   	pop    %esi
 804f224:	5d                   	pop    %ebp
 804f225:	c3                   	ret    

0804f226 <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 804f226:	55                   	push   %ebp
 804f227:	89 e5                	mov    %esp,%ebp
 804f229:	56                   	push   %esi
 804f22a:	53                   	push   %ebx
 804f22b:	83 ec 40             	sub    $0x40,%esp
 804f22e:	e8 26 ec ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804f233:	81 c3 d9 86 00 00    	add    $0x86d9,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 804f239:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 804f23d:	77 07                	ja     804f246 <malloc_bytes+0x20>
                size = malloc_minsize;
 804f23f:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 804f246:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
        i = size - 1;
 804f24d:	8b 45 08             	mov    0x8(%ebp),%eax
 804f250:	48                   	dec    %eax
 804f251:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (i >>= 1)
 804f254:	eb 03                	jmp    804f259 <malloc_bytes+0x33>
                j++;
 804f256:	ff 45 f0             	incl   -0x10(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 804f259:	d1 7d f4             	sarl   -0xc(%ebp)
 804f25c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804f260:	75 f4                	jne    804f256 <malloc_bytes+0x30>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804f262:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f268:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804f26b:	c1 e2 02             	shl    $0x2,%edx
 804f26e:	01 d0                	add    %edx,%eax
 804f270:	8b 00                	mov    (%eax),%eax
 804f272:	85 c0                	test   %eax,%eax
 804f274:	0f 85 27 02 00 00    	jne    804f4a1 <malloc_bytes+0x27b>
 804f27a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f27d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804f280:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804f287:	e8 d9 fb ff ff       	call   804ee65 <malloc_pages>
 804f28c:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804f28f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804f293:	75 0a                	jne    804f29f <malloc_bytes+0x79>
                return 0;
 804f295:	b8 00 00 00 00       	mov    $0x0,%eax
 804f29a:	e9 f4 01 00 00       	jmp    804f493 <malloc_bytes+0x26d>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804f29f:	c7 45 d4 10 00 00 00 	movl   $0x10,-0x2c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804f2a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f2a9:	ba 00 10 00 00       	mov    $0x1000,%edx
 804f2ae:	88 c1                	mov    %al,%cl
 804f2b0:	d3 ea                	shr    %cl,%edx
 804f2b2:	89 d0                	mov    %edx,%eax
 804f2b4:	83 c0 1f             	add    $0x1f,%eax
 804f2b7:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804f2ba:	c1 e0 02             	shl    $0x2,%eax
 804f2bd:	01 45 d4             	add    %eax,-0x2c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804f2c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f2c3:	ba 01 00 00 00       	mov    $0x1,%edx
 804f2c8:	88 c1                	mov    %al,%cl
 804f2ca:	d3 e2                	shl    %cl,%edx
 804f2cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804f2cf:	01 c0                	add    %eax,%eax
 804f2d1:	39 c2                	cmp    %eax,%edx
 804f2d3:	77 08                	ja     804f2dd <malloc_bytes+0xb7>
                bp = (struct  pginfo *)pp;
 804f2d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804f2d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804f2db:	eb 29                	jmp    804f306 <malloc_bytes+0xe0>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804f2dd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804f2e0:	89 04 24             	mov    %eax,(%esp)
 804f2e3:	e8 c0 02 00 00       	call   804f5a8 <imalloc>
 804f2e8:	89 45 d0             	mov    %eax,-0x30(%ebp)
                if (!bp) {
 804f2eb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804f2ef:	75 15                	jne    804f306 <malloc_bytes+0xe0>
                        ifree(pp);
 804f2f1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804f2f4:	89 04 24             	mov    %eax,(%esp)
 804f2f7:	e8 cb 0b 00 00       	call   804fec7 <ifree>
                        return 0;
 804f2fc:	b8 00 00 00 00       	mov    $0x0,%eax
 804f301:	e9 8d 01 00 00       	jmp    804f493 <malloc_bytes+0x26d>
                }
        }

        bp->size = (1 << bits);
 804f306:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f309:	ba 01 00 00 00       	mov    $0x1,%edx
 804f30e:	88 c1                	mov    %al,%cl
 804f310:	d3 e2                	shl    %cl,%edx
 804f312:	89 d0                	mov    %edx,%eax
 804f314:	0f b7 d0             	movzwl %ax,%edx
 804f317:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f31a:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804f31e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f321:	0f b7 d0             	movzwl %ax,%edx
 804f324:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f327:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804f32b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f32e:	ba 00 10 00 00       	mov    $0x1000,%edx
 804f333:	88 c1                	mov    %al,%cl
 804f335:	d3 ea                	shr    %cl,%edx
 804f337:	89 d0                	mov    %edx,%eax
 804f339:	0f b7 d0             	movzwl %ax,%edx
 804f33c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f33f:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804f343:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f346:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804f34a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f34d:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804f351:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f354:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804f357:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804f35a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f35d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804f361:	89 45 cc             	mov    %eax,-0x34(%ebp)
        i = 0;
 804f364:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804f36b:	eb 19                	jmp    804f386 <malloc_bytes+0x160>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 804f36d:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804f370:	c1 e8 05             	shr    $0x5,%eax
 804f373:	89 c2                	mov    %eax,%edx
 804f375:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f378:	83 c2 04             	add    $0x4,%edx
 804f37b:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804f382:	83 45 c8 20          	addl   $0x20,-0x38(%ebp)
 804f386:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804f389:	2b 45 c8             	sub    -0x38(%ebp),%eax
 804f38c:	83 f8 1f             	cmp    $0x1f,%eax
 804f38f:	77 dc                	ja     804f36d <malloc_bytes+0x147>
 804f391:	eb 2c                	jmp    804f3bf <malloc_bytes+0x199>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804f393:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804f396:	c1 e8 05             	shr    $0x5,%eax
 804f399:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804f39c:	8d 48 04             	lea    0x4(%eax),%ecx
 804f39f:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804f3a2:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804f3a5:	83 e1 1f             	and    $0x1f,%ecx
 804f3a8:	be 01 00 00 00       	mov    $0x1,%esi
 804f3ad:	d3 e6                	shl    %cl,%esi
 804f3af:	89 f1                	mov    %esi,%ecx
 804f3b1:	09 d1                	or     %edx,%ecx
 804f3b3:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804f3b6:	83 c0 04             	add    $0x4,%eax
 804f3b9:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804f3bc:	ff 45 c8             	incl   -0x38(%ebp)
 804f3bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804f3c2:	3b 45 c8             	cmp    -0x38(%ebp),%eax
 804f3c5:	77 cc                	ja     804f393 <malloc_bytes+0x16d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804f3c7:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f3ca:	8b 40 04             	mov    0x4(%eax),%eax
 804f3cd:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804f3d0:	75 72                	jne    804f444 <malloc_bytes+0x21e>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804f3d2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804f3d9:	eb 63                	jmp    804f43e <malloc_bytes+0x218>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804f3db:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804f3de:	c1 e8 05             	shr    $0x5,%eax
 804f3e1:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804f3e4:	8d 48 04             	lea    0x4(%eax),%ecx
 804f3e7:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804f3ea:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804f3ed:	83 e1 1f             	and    $0x1f,%ecx
 804f3f0:	be 01 00 00 00       	mov    $0x1,%esi
 804f3f5:	d3 e6                	shl    %cl,%esi
 804f3f7:	89 f1                	mov    %esi,%ecx
 804f3f9:	f7 d1                	not    %ecx
 804f3fb:	21 d1                	and    %edx,%ecx
 804f3fd:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804f400:	83 c0 04             	add    $0x4,%eax
 804f403:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804f406:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f409:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804f40d:	48                   	dec    %eax
 804f40e:	0f b7 d0             	movzwl %ax,%edx
 804f411:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f414:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804f418:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f41b:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804f41f:	48                   	dec    %eax
 804f420:	0f b7 d0             	movzwl %ax,%edx
 804f423:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f426:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804f42a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804f42d:	ba 01 00 00 00       	mov    $0x1,%edx
 804f432:	88 c1                	mov    %al,%cl
 804f434:	d3 e2                	shl    %cl,%edx
 804f436:	89 d0                	mov    %edx,%eax
 804f438:	29 45 d4             	sub    %eax,-0x2c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804f43b:	ff 45 c8             	incl   -0x38(%ebp)
 804f43e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804f442:	75 97                	jne    804f3db <malloc_bytes+0x1b5>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804f444:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f44a:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804f44d:	89 d1                	mov    %edx,%ecx
 804f44f:	c1 e9 0c             	shr    $0xc,%ecx
 804f452:	8b 93 68 02 00 00    	mov    0x268(%ebx),%edx
 804f458:	29 d1                	sub    %edx,%ecx
 804f45a:	89 ca                	mov    %ecx,%edx
 804f45c:	c1 e2 02             	shl    $0x2,%edx
 804f45f:	01 c2                	add    %eax,%edx
 804f461:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f464:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804f466:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f46c:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804f46f:	c1 e2 02             	shl    $0x2,%edx
 804f472:	01 d0                	add    %edx,%eax
 804f474:	8b 10                	mov    (%eax),%edx
 804f476:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f479:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804f47b:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f481:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804f484:	c1 e2 02             	shl    $0x2,%edx
 804f487:	01 c2                	add    %eax,%edx
 804f489:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804f48c:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804f48e:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804f493:	85 c0                	test   %eax,%eax
 804f495:	75 0a                	jne    804f4a1 <malloc_bytes+0x27b>
                return 0;
 804f497:	b8 00 00 00 00       	mov    $0x0,%eax
 804f49c:	e9 00 01 00 00       	jmp    804f5a1 <malloc_bytes+0x37b>

        bp = page_dir[j];
 804f4a1:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f4a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804f4aa:	c1 e2 02             	shl    $0x2,%edx
 804f4ad:	01 d0                	add    %edx,%eax
 804f4af:	8b 00                	mov    (%eax),%eax
 804f4b1:	89 45 e0             	mov    %eax,-0x20(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 804f4b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f4b7:	83 c0 10             	add    $0x10,%eax
 804f4ba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804f4bd:	eb 04                	jmp    804f4c3 <malloc_bytes+0x29d>
 804f4bf:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
 804f4c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f4c6:	8b 00                	mov    (%eax),%eax
 804f4c8:	85 c0                	test   %eax,%eax
 804f4ca:	74 f3                	je     804f4bf <malloc_bytes+0x299>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 804f4cc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        k = 0;
 804f4d3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        while (!(*lp & u)) {
 804f4da:	eb 0b                	jmp    804f4e7 <malloc_bytes+0x2c1>
                u += u;
 804f4dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804f4df:	01 c0                	add    %eax,%eax
 804f4e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
                k++;
 804f4e4:	ff 45 e8             	incl   -0x18(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 804f4e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f4ea:	8b 00                	mov    (%eax),%eax
 804f4ec:	23 45 ec             	and    -0x14(%ebp),%eax
 804f4ef:	85 c0                	test   %eax,%eax
 804f4f1:	74 e9                	je     804f4dc <malloc_bytes+0x2b6>
                u += u;
                k++;
        }
        *lp ^= u;
 804f4f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f4f6:	8b 00                	mov    (%eax),%eax
 804f4f8:	33 45 ec             	xor    -0x14(%ebp),%eax
 804f4fb:	89 c2                	mov    %eax,%edx
 804f4fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f500:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 804f502:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f505:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804f509:	48                   	dec    %eax
 804f50a:	0f b7 d0             	movzwl %ax,%edx
 804f50d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f510:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804f514:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f517:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804f51b:	85 c0                	test   %eax,%eax
 804f51d:	75 1e                	jne    804f53d <malloc_bytes+0x317>
                page_dir[j] = bp->next;
 804f51f:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f525:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804f528:	c1 e2 02             	shl    $0x2,%edx
 804f52b:	01 c2                	add    %eax,%edx
 804f52d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f530:	8b 00                	mov    (%eax),%eax
 804f532:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 804f534:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f537:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 804f53d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f540:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804f543:	83 c2 10             	add    $0x10,%edx
 804f546:	29 d0                	sub    %edx,%eax
 804f548:	c1 f8 02             	sar    $0x2,%eax
 804f54b:	c1 e0 05             	shl    $0x5,%eax
 804f54e:	89 c2                	mov    %eax,%edx
 804f550:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f553:	01 d0                	add    %edx,%eax
 804f555:	89 45 e8             	mov    %eax,-0x18(%ebp)
        k <<= bp->shift;
 804f558:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f55b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804f55f:	88 c1                	mov    %al,%cl
 804f561:	d3 65 e8             	shll   %cl,-0x18(%ebp)

        if (malloc_junk)
 804f564:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 804f56a:	85 c0                	test   %eax,%eax
 804f56c:	74 28                	je     804f596 <malloc_bytes+0x370>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 804f56e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f571:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804f575:	89 c2                	mov    %eax,%edx
 804f577:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f57a:	8b 48 04             	mov    0x4(%eax),%ecx
 804f57d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f580:	01 c8                	add    %ecx,%eax
 804f582:	89 54 24 08          	mov    %edx,0x8(%esp)
 804f586:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804f58d:	00 
 804f58e:	89 04 24             	mov    %eax,(%esp)
 804f591:	e8 75 ea ff ff       	call   804e00b <memset>

        return (u_char *)bp->page + k;
 804f596:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804f599:	8b 50 04             	mov    0x4(%eax),%edx
 804f59c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f59f:	01 d0                	add    %edx,%eax
}
 804f5a1:	83 c4 40             	add    $0x40,%esp
 804f5a4:	5b                   	pop    %ebx
 804f5a5:	5e                   	pop    %esi
 804f5a6:	5d                   	pop    %ebp
 804f5a7:	c3                   	ret    

0804f5a8 <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 804f5a8:	55                   	push   %ebp
 804f5a9:	89 e5                	mov    %esp,%ebp
 804f5ab:	53                   	push   %ebx
 804f5ac:	83 ec 24             	sub    $0x24,%esp
 804f5af:	e8 a5 e8 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804f5b4:	81 c3 58 83 00 00    	add    $0x8358,%ebx
        void *result;

        if (suicide)
 804f5ba:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804f5c0:	85 c0                	test   %eax,%eax
 804f5c2:	74 0c                	je     804f5d0 <imalloc+0x28>
                abort();
 804f5c4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804f5cb:	e8 1e dd ff ff       	call   804d2ee <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 804f5d0:	8b 45 08             	mov    0x8(%ebp),%eax
 804f5d3:	05 00 10 00 00       	add    $0x1000,%eax
 804f5d8:	3b 45 08             	cmp    0x8(%ebp),%eax
 804f5db:	73 09                	jae    804f5e6 <imalloc+0x3e>
                result = 0;
 804f5dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804f5e4:	eb 27                	jmp    804f60d <imalloc+0x65>
        else if (size <= malloc_maxsize)
 804f5e6:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 804f5ed:	77 10                	ja     804f5ff <imalloc+0x57>
                result =  malloc_bytes(size);
 804f5ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804f5f2:	89 04 24             	mov    %eax,(%esp)
 804f5f5:	e8 2c fc ff ff       	call   804f226 <malloc_bytes>
 804f5fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804f5fd:	eb 0e                	jmp    804f60d <imalloc+0x65>
        else
                result =  malloc_pages(size);
 804f5ff:	8b 45 08             	mov    0x8(%ebp),%eax
 804f602:	89 04 24             	mov    %eax,(%esp)
 804f605:	e8 5b f8 ff ff       	call   804ee65 <malloc_pages>
 804f60a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 804f60d:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804f613:	85 c0                	test   %eax,%eax
 804f615:	74 14                	je     804f62b <imalloc+0x83>
 804f617:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804f61b:	75 0e                	jne    804f62b <imalloc+0x83>
                wrterror("allocation failed.\n");
 804f61d:	8d 83 b0 d9 ff ff    	lea    -0x2650(%ebx),%eax
 804f623:	89 04 24             	mov    %eax,(%esp)
 804f626:	e8 36 f2 ff ff       	call   804e861 <wrterror>

        if (malloc_zero && result)
 804f62b:	8b 83 a4 02 00 00    	mov    0x2a4(%ebx),%eax
 804f631:	85 c0                	test   %eax,%eax
 804f633:	74 20                	je     804f655 <imalloc+0xad>
 804f635:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804f639:	74 1a                	je     804f655 <imalloc+0xad>
                memset(result, 0, size);
 804f63b:	8b 45 08             	mov    0x8(%ebp),%eax
 804f63e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804f642:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804f649:	00 
 804f64a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f64d:	89 04 24             	mov    %eax,(%esp)
 804f650:	e8 b6 e9 ff ff       	call   804e00b <memset>

        return result;
 804f655:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804f658:	83 c4 24             	add    $0x24,%esp
 804f65b:	5b                   	pop    %ebx
 804f65c:	5d                   	pop    %ebp
 804f65d:	c3                   	ret    

0804f65e <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 804f65e:	55                   	push   %ebp
 804f65f:	89 e5                	mov    %esp,%ebp
 804f661:	56                   	push   %esi
 804f662:	53                   	push   %ebx
 804f663:	83 ec 30             	sub    $0x30,%esp
 804f666:	e8 ee e7 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804f66b:	81 c3 a1 82 00 00    	add    $0x82a1,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 804f671:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804f677:	85 c0                	test   %eax,%eax
 804f679:	74 0c                	je     804f687 <irealloc+0x29>
                abort();
 804f67b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804f682:	e8 67 dc ff ff       	call   804d2ee <exit>

        index = ptr2index(ptr);
 804f687:	8b 45 08             	mov    0x8(%ebp),%eax
 804f68a:	c1 e8 0c             	shr    $0xc,%eax
 804f68d:	89 c2                	mov    %eax,%edx
 804f68f:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804f695:	29 c2                	sub    %eax,%edx
 804f697:	89 d0                	mov    %edx,%eax
 804f699:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (index < malloc_pageshift) {
 804f69c:	83 7d ec 0b          	cmpl   $0xb,-0x14(%ebp)
 804f6a0:	77 18                	ja     804f6ba <irealloc+0x5c>
                wrtwarning("junk pointer, too low to make sense.\n");
 804f6a2:	8d 83 c4 d9 ff ff    	lea    -0x263c(%ebx),%eax
 804f6a8:	89 04 24             	mov    %eax,(%esp)
 804f6ab:	e8 81 f2 ff ff       	call   804e931 <wrtwarning>
                return 0;
 804f6b0:	b8 00 00 00 00       	mov    $0x0,%eax
 804f6b5:	e9 fc 01 00 00       	jmp    804f8b6 <irealloc+0x258>
        }

        if (index > last_index) {
 804f6ba:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 804f6c0:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 804f6c3:	76 18                	jbe    804f6dd <irealloc+0x7f>
                wrtwarning("junk pointer, too high to make sense.\n");
 804f6c5:	8d 83 ec d9 ff ff    	lea    -0x2614(%ebx),%eax
 804f6cb:	89 04 24             	mov    %eax,(%esp)
 804f6ce:	e8 5e f2 ff ff       	call   804e931 <wrtwarning>
                return 0;
 804f6d3:	b8 00 00 00 00       	mov    $0x0,%eax
 804f6d8:	e9 d9 01 00 00       	jmp    804f8b6 <irealloc+0x258>
        }

        mp = &page_dir[index];
 804f6dd:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f6e3:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804f6e6:	c1 e2 02             	shl    $0x2,%edx
 804f6e9:	01 d0                	add    %edx,%eax
 804f6eb:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804f6ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f6f1:	8b 00                	mov    (%eax),%eax
 804f6f3:	83 f8 02             	cmp    $0x2,%eax
 804f6f6:	75 75                	jne    804f76d <irealloc+0x10f>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804f6f8:	8b 45 08             	mov    0x8(%ebp),%eax
 804f6fb:	25 ff 0f 00 00       	and    $0xfff,%eax
 804f700:	85 c0                	test   %eax,%eax
 804f702:	74 18                	je     804f71c <irealloc+0xbe>
                        wrtwarning("modified (page-) pointer.\n");
 804f704:	8d 83 13 da ff ff    	lea    -0x25ed(%ebx),%eax
 804f70a:	89 04 24             	mov    %eax,(%esp)
 804f70d:	e8 1f f2 ff ff       	call   804e931 <wrtwarning>
                        return 0;
 804f712:	b8 00 00 00 00       	mov    $0x0,%eax
 804f717:	e9 9a 01 00 00       	jmp    804f8b6 <irealloc+0x258>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804f71c:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
 804f723:	eb 07                	jmp    804f72c <irealloc+0xce>
                        osize += malloc_pagesize;
 804f725:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804f72c:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
 804f730:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f733:	8b 00                	mov    (%eax),%eax
 804f735:	83 f8 03             	cmp    $0x3,%eax
 804f738:	74 eb                	je     804f725 <irealloc+0xc7>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804f73a:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804f740:	85 c0                	test   %eax,%eax
 804f742:	0f 85 04 01 00 00    	jne    804f84c <irealloc+0x1ee>
 804f748:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f74b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804f74e:	0f 87 f8 00 00 00    	ja     804f84c <irealloc+0x1ee>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804f754:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f757:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804f75c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804f75f:	0f 83 e7 00 00 00    	jae    804f84c <irealloc+0x1ee>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804f765:	8b 45 08             	mov    0x8(%ebp),%eax
 804f768:	e9 49 01 00 00       	jmp    804f8b6 <irealloc+0x258>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804f76d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f770:	8b 00                	mov    (%eax),%eax
 804f772:	83 f8 03             	cmp    $0x3,%eax
 804f775:	0f 86 bc 00 00 00    	jbe    804f837 <irealloc+0x1d9>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804f77b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f77e:	8b 00                	mov    (%eax),%eax
 804f780:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804f784:	48                   	dec    %eax
 804f785:	89 c2                	mov    %eax,%edx
 804f787:	8b 45 08             	mov    0x8(%ebp),%eax
 804f78a:	21 d0                	and    %edx,%eax
 804f78c:	85 c0                	test   %eax,%eax
 804f78e:	74 18                	je     804f7a8 <irealloc+0x14a>
                        wrtwarning("modified (chunk-) pointer.\n");
 804f790:	8d 83 2e da ff ff    	lea    -0x25d2(%ebx),%eax
 804f796:	89 04 24             	mov    %eax,(%esp)
 804f799:	e8 93 f1 ff ff       	call   804e931 <wrtwarning>
                        return 0;
 804f79e:	b8 00 00 00 00       	mov    $0x0,%eax
 804f7a3:	e9 0e 01 00 00       	jmp    804f8b6 <irealloc+0x258>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804f7a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804f7ab:	25 ff 0f 00 00       	and    $0xfff,%eax
 804f7b0:	89 c2                	mov    %eax,%edx
 804f7b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f7b5:	8b 00                	mov    (%eax),%eax
 804f7b7:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804f7bb:	88 c1                	mov    %al,%cl
 804f7bd:	d3 ea                	shr    %cl,%edx
 804f7bf:	89 d0                	mov    %edx,%eax
 804f7c1:	89 45 e8             	mov    %eax,-0x18(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804f7c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f7c7:	8b 00                	mov    (%eax),%eax
 804f7c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804f7cc:	c1 ea 05             	shr    $0x5,%edx
 804f7cf:	83 c2 04             	add    $0x4,%edx
 804f7d2:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804f7d5:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804f7d8:	83 e2 1f             	and    $0x1f,%edx
 804f7db:	be 01 00 00 00       	mov    $0x1,%esi
 804f7e0:	88 d1                	mov    %dl,%cl
 804f7e2:	d3 e6                	shl    %cl,%esi
 804f7e4:	89 f2                	mov    %esi,%edx
 804f7e6:	21 d0                	and    %edx,%eax
 804f7e8:	85 c0                	test   %eax,%eax
 804f7ea:	74 18                	je     804f804 <irealloc+0x1a6>
                        wrtwarning("chunk is already free.\n");
 804f7ec:	8d 83 4a da ff ff    	lea    -0x25b6(%ebx),%eax
 804f7f2:	89 04 24             	mov    %eax,(%esp)
 804f7f5:	e8 37 f1 ff ff       	call   804e931 <wrtwarning>
                        return 0;
 804f7fa:	b8 00 00 00 00       	mov    $0x0,%eax
 804f7ff:	e9 b2 00 00 00       	jmp    804f8b6 <irealloc+0x258>
                }

                osize = (*mp)->size;
 804f804:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804f807:	8b 00                	mov    (%eax),%eax
 804f809:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804f80d:	89 45 f4             	mov    %eax,-0xc(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804f810:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804f816:	85 c0                	test   %eax,%eax
 804f818:	75 32                	jne    804f84c <irealloc+0x1ee>
 804f81a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f81d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804f820:	73 2a                	jae    804f84c <irealloc+0x1ee>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804f822:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f825:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804f827:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804f82a:	72 06                	jb     804f832 <irealloc+0x1d4>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804f82c:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
 804f830:	75 1a                	jne    804f84c <irealloc+0x1ee>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804f832:	8b 45 08             	mov    0x8(%ebp),%eax
 804f835:	eb 7f                	jmp    804f8b6 <irealloc+0x258>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804f837:	8d 83 62 da ff ff    	lea    -0x259e(%ebx),%eax
 804f83d:	89 04 24             	mov    %eax,(%esp)
 804f840:	e8 ec f0 ff ff       	call   804e931 <wrtwarning>
                return 0;
 804f845:	b8 00 00 00 00       	mov    $0x0,%eax
 804f84a:	eb 6a                	jmp    804f8b6 <irealloc+0x258>
        }

        p = imalloc(size);
 804f84c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f84f:	89 04 24             	mov    %eax,(%esp)
 804f852:	e8 51 fd ff ff       	call   804f5a8 <imalloc>
 804f857:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (p) {
 804f85a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804f85e:	74 53                	je     804f8b3 <irealloc+0x255>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804f860:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804f864:	74 42                	je     804f8a8 <irealloc+0x24a>
 804f866:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804f86a:	74 3c                	je     804f8a8 <irealloc+0x24a>
                        ;
                else if (osize < size)
 804f86c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f86f:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804f872:	73 1b                	jae    804f88f <irealloc+0x231>
                        memcpy(p, ptr, osize);
 804f874:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f877:	89 44 24 08          	mov    %eax,0x8(%esp)
 804f87b:	8b 45 08             	mov    0x8(%ebp),%eax
 804f87e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804f882:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f885:	89 04 24             	mov    %eax,(%esp)
 804f888:	e8 23 e6 ff ff       	call   804deb0 <memcpy>
 804f88d:	eb 19                	jmp    804f8a8 <irealloc+0x24a>
                else
                        memcpy(p, ptr, size);
 804f88f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804f892:	89 44 24 08          	mov    %eax,0x8(%esp)
 804f896:	8b 45 08             	mov    0x8(%ebp),%eax
 804f899:	89 44 24 04          	mov    %eax,0x4(%esp)
 804f89d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804f8a0:	89 04 24             	mov    %eax,(%esp)
 804f8a3:	e8 08 e6 ff ff       	call   804deb0 <memcpy>
                ifree(ptr);
 804f8a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804f8ab:	89 04 24             	mov    %eax,(%esp)
 804f8ae:	e8 14 06 00 00       	call   804fec7 <ifree>
        }
        return p;
 804f8b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
 804f8b6:	83 c4 30             	add    $0x30,%esp
 804f8b9:	5b                   	pop    %ebx
 804f8ba:	5e                   	pop    %esi
 804f8bb:	5d                   	pop    %ebp
 804f8bc:	c3                   	ret    

0804f8bd <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804f8bd:	55                   	push   %ebp
 804f8be:	89 e5                	mov    %esp,%ebp
 804f8c0:	53                   	push   %ebx
 804f8c1:	83 ec 34             	sub    $0x34,%esp
 804f8c4:	e8 90 e5 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804f8c9:	81 c3 43 80 00 00    	add    $0x8043,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804f8cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804f8d6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804f8da:	75 13                	jne    804f8ef <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804f8dc:	8d 83 7a da ff ff    	lea    -0x2586(%ebx),%eax
 804f8e2:	89 04 24             	mov    %eax,(%esp)
 804f8e5:	e8 47 f0 ff ff       	call   804e931 <wrtwarning>
                return;
 804f8ea:	e9 db 03 00 00       	jmp    804fcca <free_pages+0x40d>
        }

        if (info != MALLOC_FIRST) {
 804f8ef:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804f8f3:	74 13                	je     804f908 <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804f8f5:	8d 83 62 da ff ff    	lea    -0x259e(%ebx),%eax
 804f8fb:	89 04 24             	mov    %eax,(%esp)
 804f8fe:	e8 2e f0 ff ff       	call   804e931 <wrtwarning>
                return;
 804f903:	e9 c2 03 00 00       	jmp    804fcca <free_pages+0x40d>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804f908:	8b 45 08             	mov    0x8(%ebp),%eax
 804f90b:	25 ff 0f 00 00       	and    $0xfff,%eax
 804f910:	85 c0                	test   %eax,%eax
 804f912:	74 13                	je     804f927 <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804f914:	8d 83 13 da ff ff    	lea    -0x25ed(%ebx),%eax
 804f91a:	89 04 24             	mov    %eax,(%esp)
 804f91d:	e8 0f f0 ff ff       	call   804e931 <wrtwarning>
                return;
 804f922:	e9 a3 03 00 00       	jmp    804fcca <free_pages+0x40d>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804f927:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f92d:	8b 55 0c             	mov    0xc(%ebp),%edx
 804f930:	c1 e2 02             	shl    $0x2,%edx
 804f933:	01 d0                	add    %edx,%eax
 804f935:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804f93b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804f942:	eb 1c                	jmp    804f960 <free_pages+0xa3>
                page_dir[index + i] = MALLOC_FREE;
 804f944:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f94a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804f94d:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f950:	01 ca                	add    %ecx,%edx
 804f952:	c1 e2 02             	shl    $0x2,%edx
 804f955:	01 d0                	add    %edx,%eax
 804f957:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804f95d:	ff 45 f4             	incl   -0xc(%ebp)
 804f960:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804f966:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804f969:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804f96c:	01 ca                	add    %ecx,%edx
 804f96e:	c1 e2 02             	shl    $0x2,%edx
 804f971:	01 d0                	add    %edx,%eax
 804f973:	8b 00                	mov    (%eax),%eax
 804f975:	83 f8 03             	cmp    $0x3,%eax
 804f978:	74 ca                	je     804f944 <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804f97a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804f97d:	c1 e0 0c             	shl    $0xc,%eax
 804f980:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804f983:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 804f989:	85 c0                	test   %eax,%eax
 804f98b:	74 1a                	je     804f9a7 <free_pages+0xea>
                memset(ptr, SOME_JUNK, l);
 804f98d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f990:	89 44 24 08          	mov    %eax,0x8(%esp)
 804f994:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804f99b:	00 
 804f99c:	8b 45 08             	mov    0x8(%ebp),%eax
 804f99f:	89 04 24             	mov    %eax,(%esp)
 804f9a2:	e8 64 e6 ff ff       	call   804e00b <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804f9a7:	8b 55 08             	mov    0x8(%ebp),%edx
 804f9aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804f9ad:	01 d0                	add    %edx,%eax
 804f9af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804f9b2:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804f9b8:	85 c0                	test   %eax,%eax
 804f9ba:	75 12                	jne    804f9ce <free_pages+0x111>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804f9bc:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804f9c3:	e8 e0 fb ff ff       	call   804f5a8 <imalloc>
 804f9c8:	89 83 b0 02 00 00    	mov    %eax,0x2b0(%ebx)
        px->page = ptr;
 804f9ce:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804f9d4:	8b 55 08             	mov    0x8(%ebp),%edx
 804f9d7:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804f9da:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804f9e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804f9e3:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804f9e6:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804f9ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804f9ef:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804f9f2:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804f9f8:	85 c0                	test   %eax,%eax
 804f9fa:	75 41                	jne    804fa3d <free_pages+0x180>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804f9fc:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa02:	8b 93 78 02 00 00    	mov    0x278(%ebx),%edx
 804fa08:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804fa0a:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa10:	8d 93 78 02 00 00    	lea    0x278(%ebx),%edx
 804fa16:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804fa19:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa1f:	89 83 78 02 00 00    	mov    %eax,0x278(%ebx)
                pf = px;
 804fa25:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804fa2e:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 804fa35:	00 00 00 
 804fa38:	e9 a2 01 00 00       	jmp    804fbdf <free_pages+0x322>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804fa3d:	8b 55 08             	mov    0x8(%ebp),%edx
 804fa40:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804fa43:	01 d0                	add    %edx,%eax
 804fa45:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804fa48:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804fa4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804fa51:	eb 08                	jmp    804fa5b <free_pages+0x19e>
 804fa53:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fa56:	8b 00                	mov    (%eax),%eax
 804fa58:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804fa5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fa5e:	8b 40 0c             	mov    0xc(%eax),%eax
 804fa61:	3b 45 08             	cmp    0x8(%ebp),%eax
 804fa64:	73 09                	jae    804fa6f <free_pages+0x1b2>
 804fa66:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fa69:	8b 00                	mov    (%eax),%eax
 804fa6b:	85 c0                	test   %eax,%eax
 804fa6d:	75 e4                	jne    804fa53 <free_pages+0x196>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804fa6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fa72:	8b 40 08             	mov    0x8(%eax),%eax
 804fa75:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804fa78:	76 4f                	jbe    804fac9 <free_pages+0x20c>
                        /* Insert before entry */
                        px->next = pf;
 804fa7a:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa80:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804fa83:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804fa85:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fa8b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804fa8e:	8b 52 04             	mov    0x4(%edx),%edx
 804fa91:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804fa94:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 804fa9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fa9d:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804faa0:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804faa6:	8b 40 04             	mov    0x4(%eax),%eax
 804faa9:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 804faaf:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804fab1:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fab7:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804faba:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 804fac1:	00 00 00 
 804fac4:	e9 16 01 00 00       	jmp    804fbdf <free_pages+0x322>
                } else if (pf->end == ptr) {
 804fac9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804facc:	8b 40 0c             	mov    0xc(%eax),%eax
 804facf:	3b 45 08             	cmp    0x8(%ebp),%eax
 804fad2:	0f 85 91 00 00 00    	jne    804fb69 <free_pages+0x2ac>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804fad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fadb:	8b 50 0c             	mov    0xc(%eax),%edx
 804fade:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804fae1:	01 c2                	add    %eax,%edx
 804fae3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fae6:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804fae9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804faec:	8b 50 10             	mov    0x10(%eax),%edx
 804faef:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804faf2:	01 c2                	add    %eax,%edx
 804faf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804faf7:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804fafa:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fafd:	8b 00                	mov    (%eax),%eax
 804faff:	85 c0                	test   %eax,%eax
 804fb01:	0f 84 d8 00 00 00    	je     804fbdf <free_pages+0x322>
 804fb07:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb0a:	8b 50 0c             	mov    0xc(%eax),%edx
 804fb0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb10:	8b 00                	mov    (%eax),%eax
 804fb12:	8b 40 08             	mov    0x8(%eax),%eax
 804fb15:	39 c2                	cmp    %eax,%edx
 804fb17:	0f 85 c2 00 00 00    	jne    804fbdf <free_pages+0x322>
                                /* And collapse the next too. */
                                pt = pf->next;
 804fb1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb20:	8b 00                	mov    (%eax),%eax
 804fb22:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804fb25:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804fb28:	8b 50 0c             	mov    0xc(%eax),%edx
 804fb2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb2e:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804fb31:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb34:	8b 50 10             	mov    0x10(%eax),%edx
 804fb37:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804fb3a:	8b 40 10             	mov    0x10(%eax),%eax
 804fb3d:	01 c2                	add    %eax,%edx
 804fb3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb42:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804fb45:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804fb48:	8b 10                	mov    (%eax),%edx
 804fb4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb4d:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804fb4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb52:	8b 00                	mov    (%eax),%eax
 804fb54:	85 c0                	test   %eax,%eax
 804fb56:	0f 84 83 00 00 00    	je     804fbdf <free_pages+0x322>
                                        pf->next->prev = pf;
 804fb5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb5f:	8b 00                	mov    (%eax),%eax
 804fb61:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804fb64:	89 50 04             	mov    %edx,0x4(%eax)
 804fb67:	eb 76                	jmp    804fbdf <free_pages+0x322>
                        }
                } else if (pf->page == tail) {
 804fb69:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb6c:	8b 40 08             	mov    0x8(%eax),%eax
 804fb6f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804fb72:	75 1c                	jne    804fb90 <free_pages+0x2d3>
                        /* Prepend to entry */
                        pf->size += l;
 804fb74:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb77:	8b 50 10             	mov    0x10(%eax),%edx
 804fb7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804fb7d:	01 c2                	add    %eax,%edx
 804fb7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb82:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804fb85:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb88:	8b 55 08             	mov    0x8(%ebp),%edx
 804fb8b:	89 50 08             	mov    %edx,0x8(%eax)
 804fb8e:	eb 4f                	jmp    804fbdf <free_pages+0x322>
                } else if (!pf->next) {
 804fb90:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fb93:	8b 00                	mov    (%eax),%eax
 804fb95:	85 c0                	test   %eax,%eax
 804fb97:	75 38                	jne    804fbd1 <free_pages+0x314>
                        /* Append at tail of chain */
                        px->next = 0;
 804fb99:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fb9f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804fba5:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fbab:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804fbae:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804fbb1:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 804fbb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fbba:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804fbbc:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 804fbc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804fbc5:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 804fbcc:	00 00 00 
 804fbcf:	eb 0e                	jmp    804fbdf <free_pages+0x322>
                } else {
                        wrterror("freelist is destroyed.\n");
 804fbd1:	8d 83 91 da ff ff    	lea    -0x256f(%ebx),%eax
 804fbd7:	89 04 24             	mov    %eax,(%esp)
 804fbda:	e8 82 ec ff ff       	call   804e861 <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804fbdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fbe2:	8b 00                	mov    (%eax),%eax
 804fbe4:	85 c0                	test   %eax,%eax
 804fbe6:	0f 85 cd 00 00 00    	jne    804fcb9 <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804fbec:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fbef:	8b 50 10             	mov    0x10(%eax),%edx
 804fbf2:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804fbf8:	39 c2                	cmp    %eax,%edx
 804fbfa:	0f 86 b9 00 00 00    	jbe    804fcb9 <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804fc00:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc03:	8b 50 0c             	mov    0xc(%eax),%edx
 804fc06:	8b 83 ac 02 00 00    	mov    0x2ac(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804fc0c:	39 c2                	cmp    %eax,%edx
 804fc0e:	0f 85 a5 00 00 00    	jne    804fcb9 <free_pages+0x3fc>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804fc14:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804fc1b:	e8 df d4 ff ff       	call   804d0ff <sbrk>
 804fc20:	89 c2                	mov    %eax,%edx
 804fc22:	8b 83 ac 02 00 00    	mov    0x2ac(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804fc28:	39 c2                	cmp    %eax,%edx
 804fc2a:	0f 85 89 00 00 00    	jne    804fcb9 <free_pages+0x3fc>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804fc30:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc33:	8b 50 08             	mov    0x8(%eax),%edx
 804fc36:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 804fc3c:	01 c2                	add    %eax,%edx
 804fc3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc41:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804fc44:	8b 93 14 00 00 00    	mov    0x14(%ebx),%edx
 804fc4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc4d:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804fc50:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc53:	8b 40 0c             	mov    0xc(%eax),%eax
 804fc56:	89 04 24             	mov    %eax,(%esp)
 804fc59:	e8 6a d5 ff ff       	call   804d1c8 <brk>
                malloc_brk = pf->end;
 804fc5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc61:	8b 40 0c             	mov    0xc(%eax),%eax
 804fc64:	89 83 ac 02 00 00    	mov    %eax,0x2ac(%ebx)

                index = ptr2index(pf->end);
 804fc6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fc6d:	8b 40 0c             	mov    0xc(%eax),%eax
 804fc70:	c1 e8 0c             	shr    $0xc,%eax
 804fc73:	89 c2                	mov    %eax,%edx
 804fc75:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804fc7b:	29 c2                	sub    %eax,%edx
 804fc7d:	89 d0                	mov    %edx,%eax
 804fc7f:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804fc82:	8b 45 0c             	mov    0xc(%ebp),%eax
 804fc85:	48                   	dec    %eax
 804fc86:	89 83 6c 02 00 00    	mov    %eax,0x26c(%ebx)

                for (i = index; i <= last_index;)
 804fc8c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804fc8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804fc92:	eb 1a                	jmp    804fcae <free_pages+0x3f1>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804fc94:	8b 8b 70 02 00 00    	mov    0x270(%ebx),%ecx
 804fc9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fc9d:	8d 50 01             	lea    0x1(%eax),%edx
 804fca0:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804fca3:	c1 e0 02             	shl    $0x2,%eax
 804fca6:	01 c8                	add    %ecx,%eax
 804fca8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804fcae:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 804fcb4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804fcb7:	76 db                	jbe    804fc94 <free_pages+0x3d7>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804fcb9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804fcbd:	74 0b                	je     804fcca <free_pages+0x40d>
                ifree(pt);
 804fcbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804fcc2:	89 04 24             	mov    %eax,(%esp)
 804fcc5:	e8 fd 01 00 00       	call   804fec7 <ifree>
}
 804fcca:	83 c4 34             	add    $0x34,%esp
 804fccd:	5b                   	pop    %ebx
 804fcce:	5d                   	pop    %ebp
 804fccf:	c3                   	ret    

0804fcd0 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804fcd0:	55                   	push   %ebp
 804fcd1:	89 e5                	mov    %esp,%ebp
 804fcd3:	56                   	push   %esi
 804fcd4:	53                   	push   %ebx
 804fcd5:	83 ec 20             	sub    $0x20,%esp
 804fcd8:	e8 7c e1 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804fcdd:	81 c3 2f 7c 00 00    	add    $0x7c2f,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804fce3:	8b 45 08             	mov    0x8(%ebp),%eax
 804fce6:	25 ff 0f 00 00       	and    $0xfff,%eax
 804fceb:	89 c2                	mov    %eax,%edx
 804fced:	8b 45 10             	mov    0x10(%ebp),%eax
 804fcf0:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804fcf4:	88 c1                	mov    %al,%cl
 804fcf6:	d3 ea                	shr    %cl,%edx
 804fcf8:	89 d0                	mov    %edx,%eax
 804fcfa:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804fcfd:	8b 45 10             	mov    0x10(%ebp),%eax
 804fd00:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804fd04:	48                   	dec    %eax
 804fd05:	89 c2                	mov    %eax,%edx
 804fd07:	8b 45 08             	mov    0x8(%ebp),%eax
 804fd0a:	21 d0                	and    %edx,%eax
 804fd0c:	85 c0                	test   %eax,%eax
 804fd0e:	74 13                	je     804fd23 <free_bytes+0x53>
                wrtwarning("modified (chunk-) pointer.\n");
 804fd10:	8d 83 2e da ff ff    	lea    -0x25d2(%ebx),%eax
 804fd16:	89 04 24             	mov    %eax,(%esp)
 804fd19:	e8 13 ec ff ff       	call   804e931 <wrtwarning>
                return;
 804fd1e:	e9 9d 01 00 00       	jmp    804fec0 <free_bytes+0x1f0>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804fd23:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fd26:	c1 e8 05             	shr    $0x5,%eax
 804fd29:	89 c2                	mov    %eax,%edx
 804fd2b:	8b 45 10             	mov    0x10(%ebp),%eax
 804fd2e:	83 c2 04             	add    $0x4,%edx
 804fd31:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804fd34:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804fd37:	83 e2 1f             	and    $0x1f,%edx
 804fd3a:	be 01 00 00 00       	mov    $0x1,%esi
 804fd3f:	88 d1                	mov    %dl,%cl
 804fd41:	d3 e6                	shl    %cl,%esi
 804fd43:	89 f2                	mov    %esi,%edx
 804fd45:	21 d0                	and    %edx,%eax
 804fd47:	85 c0                	test   %eax,%eax
 804fd49:	74 13                	je     804fd5e <free_bytes+0x8e>
                wrtwarning("chunk is already free.\n");
 804fd4b:	8d 83 4a da ff ff    	lea    -0x25b6(%ebx),%eax
 804fd51:	89 04 24             	mov    %eax,(%esp)
 804fd54:	e8 d8 eb ff ff       	call   804e931 <wrtwarning>
                return;
 804fd59:	e9 62 01 00 00       	jmp    804fec0 <free_bytes+0x1f0>
        }

        if (malloc_junk)
 804fd5e:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 804fd64:	85 c0                	test   %eax,%eax
 804fd66:	74 1e                	je     804fd86 <free_bytes+0xb6>
                memset(ptr, SOME_JUNK, info->size);
 804fd68:	8b 45 10             	mov    0x10(%ebp),%eax
 804fd6b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804fd6f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804fd73:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804fd7a:	00 
 804fd7b:	8b 45 08             	mov    0x8(%ebp),%eax
 804fd7e:	89 04 24             	mov    %eax,(%esp)
 804fd81:	e8 85 e2 ff ff       	call   804e00b <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804fd86:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804fd89:	c1 e8 05             	shr    $0x5,%eax
 804fd8c:	8b 55 10             	mov    0x10(%ebp),%edx
 804fd8f:	8d 48 04             	lea    0x4(%eax),%ecx
 804fd92:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804fd95:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804fd98:	83 e1 1f             	and    $0x1f,%ecx
 804fd9b:	be 01 00 00 00       	mov    $0x1,%esi
 804fda0:	d3 e6                	shl    %cl,%esi
 804fda2:	89 f1                	mov    %esi,%ecx
 804fda4:	09 d1                	or     %edx,%ecx
 804fda6:	8b 55 10             	mov    0x10(%ebp),%edx
 804fda9:	83 c0 04             	add    $0x4,%eax
 804fdac:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804fdaf:	8b 45 10             	mov    0x10(%ebp),%eax
 804fdb2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804fdb6:	40                   	inc    %eax
 804fdb7:	0f b7 d0             	movzwl %ax,%edx
 804fdba:	8b 45 10             	mov    0x10(%ebp),%eax
 804fdbd:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804fdc1:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 804fdc7:	8b 45 10             	mov    0x10(%ebp),%eax
 804fdca:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804fdce:	c1 e0 02             	shl    $0x2,%eax
 804fdd1:	01 d0                	add    %edx,%eax
 804fdd3:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free == 1) {
 804fdd6:	8b 45 10             	mov    0x10(%ebp),%eax
 804fdd9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804fddd:	83 f8 01             	cmp    $0x1,%eax
 804fde0:	75 5e                	jne    804fe40 <free_bytes+0x170>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804fde2:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 804fde8:	8b 45 10             	mov    0x10(%ebp),%eax
 804fdeb:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804fdef:	c1 e0 02             	shl    $0x2,%eax
 804fdf2:	01 d0                	add    %edx,%eax
 804fdf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804fdf7:	eb 08                	jmp    804fe01 <free_bytes+0x131>
                        mp = &(*mp)->next;
 804fdf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fdfc:	8b 00                	mov    (%eax),%eax
 804fdfe:	89 45 f4             	mov    %eax,-0xc(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804fe01:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe04:	8b 00                	mov    (%eax),%eax
 804fe06:	85 c0                	test   %eax,%eax
 804fe08:	74 1f                	je     804fe29 <free_bytes+0x159>
 804fe0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe0d:	8b 00                	mov    (%eax),%eax
 804fe0f:	8b 00                	mov    (%eax),%eax
 804fe11:	85 c0                	test   %eax,%eax
 804fe13:	74 14                	je     804fe29 <free_bytes+0x159>
 804fe15:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe18:	8b 00                	mov    (%eax),%eax
 804fe1a:	8b 00                	mov    (%eax),%eax
 804fe1c:	8b 50 04             	mov    0x4(%eax),%edx
 804fe1f:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe22:	8b 40 04             	mov    0x4(%eax),%eax
 804fe25:	39 c2                	cmp    %eax,%edx
 804fe27:	72 d0                	jb     804fdf9 <free_bytes+0x129>
                        mp = &(*mp)->next;
                info->next = *mp;
 804fe29:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe2c:	8b 10                	mov    (%eax),%edx
 804fe2e:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe31:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804fe33:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe36:	8b 55 10             	mov    0x10(%ebp),%edx
 804fe39:	89 10                	mov    %edx,(%eax)
                return;
 804fe3b:	e9 80 00 00 00       	jmp    804fec0 <free_bytes+0x1f0>
        }

        if (info->free != info->total)
 804fe40:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe43:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804fe47:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe4a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804fe4e:	39 c2                	cmp    %eax,%edx
 804fe50:	75 6d                	jne    804febf <free_bytes+0x1ef>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804fe52:	eb 08                	jmp    804fe5c <free_bytes+0x18c>
                mp = &((*mp)->next);
 804fe54:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe57:	8b 00                	mov    (%eax),%eax
 804fe59:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804fe5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe5f:	8b 00                	mov    (%eax),%eax
 804fe61:	3b 45 10             	cmp    0x10(%ebp),%eax
 804fe64:	75 ee                	jne    804fe54 <free_bytes+0x184>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804fe66:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe69:	8b 10                	mov    (%eax),%edx
 804fe6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804fe6e:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804fe70:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 804fe76:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe79:	8b 40 04             	mov    0x4(%eax),%eax
 804fe7c:	c1 e8 0c             	shr    $0xc,%eax
 804fe7f:	89 c1                	mov    %eax,%ecx
 804fe81:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804fe87:	29 c1                	sub    %eax,%ecx
 804fe89:	89 c8                	mov    %ecx,%eax
 804fe8b:	c1 e0 02             	shl    $0x2,%eax
 804fe8e:	01 d0                	add    %edx,%eax
 804fe90:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804fe96:	8b 45 10             	mov    0x10(%ebp),%eax
 804fe99:	8b 40 04             	mov    0x4(%eax),%eax
 804fe9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (vp != (void *)info)
 804fe9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804fea2:	3b 45 10             	cmp    0x10(%ebp),%eax
 804fea5:	74 0b                	je     804feb2 <free_bytes+0x1e2>
                ifree(info);
 804fea7:	8b 45 10             	mov    0x10(%ebp),%eax
 804feaa:	89 04 24             	mov    %eax,(%esp)
 804fead:	e8 15 00 00 00       	call   804fec7 <ifree>
        ifree(vp);
 804feb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804feb5:	89 04 24             	mov    %eax,(%esp)
 804feb8:	e8 0a 00 00 00       	call   804fec7 <ifree>
 804febd:	eb 01                	jmp    804fec0 <free_bytes+0x1f0>
                *mp = info;
                return;
        }

        if (info->free != info->total)
                return;
 804febf:	90                   	nop
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
        vp = info->page;            /* Order is important ! */
        if (vp != (void *)info)
                ifree(info);
        ifree(vp);
}
 804fec0:	83 c4 20             	add    $0x20,%esp
 804fec3:	5b                   	pop    %ebx
 804fec4:	5e                   	pop    %esi
 804fec5:	5d                   	pop    %ebp
 804fec6:	c3                   	ret    

0804fec7 <ifree>:

static void
ifree(void *ptr)
{
 804fec7:	55                   	push   %ebp
 804fec8:	89 e5                	mov    %esp,%ebp
 804feca:	56                   	push   %esi
 804fecb:	53                   	push   %ebx
 804fecc:	83 ec 50             	sub    $0x50,%esp
 804fecf:	e8 85 df ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 804fed4:	81 c3 38 7a 00 00    	add    $0x7a38,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804feda:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804fede:	0f 84 9c 06 00 00    	je     8050580 <ifree+0x6b9>
                return;

        if (!malloc_started) {
 804fee4:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 804feea:	85 c0                	test   %eax,%eax
 804feec:	75 13                	jne    804ff01 <ifree+0x3a>
                wrtwarning("malloc() has never been called.\n");
 804feee:	8d 83 ac da ff ff    	lea    -0x2554(%ebx),%eax
 804fef4:	89 04 24             	mov    %eax,(%esp)
 804fef7:	e8 35 ea ff ff       	call   804e931 <wrtwarning>
                return;
 804fefc:	e9 86 06 00 00       	jmp    8050587 <ifree+0x6c0>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804ff01:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804ff07:	85 c0                	test   %eax,%eax
 804ff09:	0f 85 74 06 00 00    	jne    8050583 <ifree+0x6bc>
                return;

        index = ptr2index(ptr);
 804ff0f:	8b 45 08             	mov    0x8(%ebp),%eax
 804ff12:	c1 e8 0c             	shr    $0xc,%eax
 804ff15:	89 c2                	mov    %eax,%edx
 804ff17:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 804ff1d:	29 c2                	sub    %eax,%edx
 804ff1f:	89 d0                	mov    %edx,%eax
 804ff21:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (index < malloc_pageshift) {
 804ff24:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
 804ff28:	77 13                	ja     804ff3d <ifree+0x76>
                wrtwarning("junk pointer, too low to make sense.\n");
 804ff2a:	8d 83 c4 d9 ff ff    	lea    -0x263c(%ebx),%eax
 804ff30:	89 04 24             	mov    %eax,(%esp)
 804ff33:	e8 f9 e9 ff ff       	call   804e931 <wrtwarning>
                return;
 804ff38:	e9 4a 06 00 00       	jmp    8050587 <ifree+0x6c0>
        }

        if (index > last_index) {
 804ff3d:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 804ff43:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804ff46:	76 13                	jbe    804ff5b <ifree+0x94>
                wrtwarning("junk pointer, too high to make sense.\n");
 804ff48:	8d 83 ec d9 ff ff    	lea    -0x2614(%ebx),%eax
 804ff4e:	89 04 24             	mov    %eax,(%esp)
 804ff51:	e8 db e9 ff ff       	call   804e931 <wrtwarning>
                return;
 804ff56:	e9 2c 06 00 00       	jmp    8050587 <ifree+0x6c0>
        }

        info = page_dir[index];
 804ff5b:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804ff61:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ff64:	c1 e2 02             	shl    $0x2,%edx
 804ff67:	01 d0                	add    %edx,%eax
 804ff69:	8b 00                	mov    (%eax),%eax
 804ff6b:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (info < MALLOC_MAGIC)
 804ff6e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
 804ff72:	0f 87 19 04 00 00    	ja     8050391 <ifree+0x4ca>
                free_pages(ptr, index, info);
 804ff78:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ff7b:	8b 55 08             	mov    0x8(%ebp),%edx
 804ff7e:	89 55 e8             	mov    %edx,-0x18(%ebp)
 804ff81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804ff84:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ff87:	89 45 e0             	mov    %eax,-0x20(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804ff8a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804ff91:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
 804ff95:	75 13                	jne    804ffaa <ifree+0xe3>
                wrtwarning("page is already free.\n");
 804ff97:	8d 83 7a da ff ff    	lea    -0x2586(%ebx),%eax
 804ff9d:	89 04 24             	mov    %eax,(%esp)
 804ffa0:	e8 8c e9 ff ff       	call   804e931 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ffa5:	e9 dc 05 00 00       	jmp    8050586 <ifree+0x6bf>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804ffaa:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
 804ffae:	74 13                	je     804ffc3 <ifree+0xfc>
                wrtwarning("pointer to wrong page.\n");
 804ffb0:	8d 83 62 da ff ff    	lea    -0x259e(%ebx),%eax
 804ffb6:	89 04 24             	mov    %eax,(%esp)
 804ffb9:	e8 73 e9 ff ff       	call   804e931 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ffbe:	e9 c3 05 00 00       	jmp    8050586 <ifree+0x6bf>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804ffc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ffc6:	25 ff 0f 00 00       	and    $0xfff,%eax
 804ffcb:	85 c0                	test   %eax,%eax
 804ffcd:	74 13                	je     804ffe2 <ifree+0x11b>
                wrtwarning("modified (page-) pointer.\n");
 804ffcf:	8d 83 13 da ff ff    	lea    -0x25ed(%ebx),%eax
 804ffd5:	89 04 24             	mov    %eax,(%esp)
 804ffd8:	e8 54 e9 ff ff       	call   804e931 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804ffdd:	e9 a4 05 00 00       	jmp    8050586 <ifree+0x6bf>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804ffe2:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 804ffe8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ffeb:	c1 e2 02             	shl    $0x2,%edx
 804ffee:	01 d0                	add    %edx,%eax
 804fff0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804fff6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
 804fffd:	eb 1c                	jmp    805001b <ifree+0x154>
                page_dir[index + i] = MALLOC_FREE;
 804ffff:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 8050005:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 8050008:	8b 55 d8             	mov    -0x28(%ebp),%edx
 805000b:	01 ca                	add    %ecx,%edx
 805000d:	c1 e2 02             	shl    $0x2,%edx
 8050010:	01 d0                	add    %edx,%eax
 8050012:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 8050018:	ff 45 d8             	incl   -0x28(%ebp)
 805001b:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
 8050021:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 8050024:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8050027:	01 ca                	add    %ecx,%edx
 8050029:	c1 e2 02             	shl    $0x2,%edx
 805002c:	01 d0                	add    %edx,%eax
 805002e:	8b 00                	mov    (%eax),%eax
 8050030:	83 f8 03             	cmp    $0x3,%eax
 8050033:	74 ca                	je     804ffff <ifree+0x138>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 8050035:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8050038:	c1 e0 0c             	shl    $0xc,%eax
 805003b:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (malloc_junk)
 805003e:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 8050044:	85 c0                	test   %eax,%eax
 8050046:	74 1a                	je     8050062 <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 8050048:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 805004b:	89 44 24 08          	mov    %eax,0x8(%esp)
 805004f:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 8050056:	00 
 8050057:	8b 45 e8             	mov    -0x18(%ebp),%eax
 805005a:	89 04 24             	mov    %eax,(%esp)
 805005d:	e8 a9 df ff ff       	call   804e00b <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 8050062:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8050065:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050068:	01 d0                	add    %edx,%eax
 805006a:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* add to free-list */
        if (!px)
 805006d:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 8050073:	85 c0                	test   %eax,%eax
 8050075:	75 12                	jne    8050089 <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 8050077:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 805007e:	e8 25 f5 ff ff       	call   804f5a8 <imalloc>
 8050083:	89 83 b0 02 00 00    	mov    %eax,0x2b0(%ebx)
        px->page = ptr;
 8050089:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 805008f:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8050092:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 8050095:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 805009b:	8b 55 d0             	mov    -0x30(%ebp),%edx
 805009e:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 80500a1:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 80500a7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 80500aa:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 80500ad:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 80500b3:	85 c0                	test   %eax,%eax
 80500b5:	75 41                	jne    80500f8 <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 80500b7:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 80500bd:	8b 93 78 02 00 00    	mov    0x278(%ebx),%edx
 80500c3:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 80500c5:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 80500cb:	8d 93 78 02 00 00    	lea    0x278(%ebx),%edx
 80500d1:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 80500d4:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 80500da:	89 83 78 02 00 00    	mov    %eax,0x278(%ebx)
                pf = px;
 80500e0:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 80500e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
                px = 0;
 80500e9:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 80500f0:	00 00 00 
 80500f3:	e9 a5 01 00 00       	jmp    805029d <ifree+0x3d6>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 80500f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
 80500fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80500fe:	01 d0                	add    %edx,%eax
 8050100:	89 45 d0             	mov    %eax,-0x30(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 8050103:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 8050109:	89 45 cc             	mov    %eax,-0x34(%ebp)
 805010c:	eb 08                	jmp    8050116 <ifree+0x24f>
 805010e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050111:	8b 00                	mov    (%eax),%eax
 8050113:	89 45 cc             	mov    %eax,-0x34(%ebp)
 8050116:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050119:	8b 40 0c             	mov    0xc(%eax),%eax
 805011c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 805011f:	76 09                	jbe    805012a <ifree+0x263>
 8050121:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050124:	8b 00                	mov    (%eax),%eax
 8050126:	85 c0                	test   %eax,%eax
 8050128:	75 e4                	jne    805010e <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 805012a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805012d:	8b 40 08             	mov    0x8(%eax),%eax
 8050130:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 8050133:	73 4f                	jae    8050184 <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 8050135:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 805013b:	8b 55 cc             	mov    -0x34(%ebp),%edx
 805013e:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 8050140:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 8050146:	8b 55 cc             	mov    -0x34(%ebp),%edx
 8050149:	8b 52 04             	mov    0x4(%edx),%edx
 805014c:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 805014f:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 8050155:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050158:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 805015b:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 8050161:	8b 40 04             	mov    0x4(%eax),%eax
 8050164:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 805016a:	89 10                	mov    %edx,(%eax)
                        pf = px;
 805016c:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 8050172:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 8050175:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 805017c:	00 00 00 
 805017f:	e9 19 01 00 00       	jmp    805029d <ifree+0x3d6>
                } else if (pf->end == ptr) {
 8050184:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050187:	8b 40 0c             	mov    0xc(%eax),%eax
 805018a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 805018d:	0f 85 91 00 00 00    	jne    8050224 <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 8050193:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050196:	8b 50 0c             	mov    0xc(%eax),%edx
 8050199:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 805019c:	01 c2                	add    %eax,%edx
 805019e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501a1:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 80501a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501a7:	8b 50 10             	mov    0x10(%eax),%edx
 80501aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80501ad:	01 c2                	add    %eax,%edx
 80501af:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501b2:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 80501b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501b8:	8b 00                	mov    (%eax),%eax
 80501ba:	85 c0                	test   %eax,%eax
 80501bc:	0f 84 da 00 00 00    	je     805029c <ifree+0x3d5>
 80501c2:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501c5:	8b 50 0c             	mov    0xc(%eax),%edx
 80501c8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501cb:	8b 00                	mov    (%eax),%eax
 80501cd:	8b 40 08             	mov    0x8(%eax),%eax
 80501d0:	39 c2                	cmp    %eax,%edx
 80501d2:	0f 85 c4 00 00 00    	jne    805029c <ifree+0x3d5>
                                /* And collapse the next too. */
                                pt = pf->next;
 80501d8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501db:	8b 00                	mov    (%eax),%eax
 80501dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                pf->end = pt->end;
 80501e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
 80501e3:	8b 50 0c             	mov    0xc(%eax),%edx
 80501e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501e9:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 80501ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501ef:	8b 50 10             	mov    0x10(%eax),%edx
 80501f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
 80501f5:	8b 40 10             	mov    0x10(%eax),%eax
 80501f8:	01 c2                	add    %eax,%edx
 80501fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80501fd:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 8050200:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050203:	8b 10                	mov    (%eax),%edx
 8050205:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050208:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 805020a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805020d:	8b 00                	mov    (%eax),%eax
 805020f:	85 c0                	test   %eax,%eax
 8050211:	0f 84 85 00 00 00    	je     805029c <ifree+0x3d5>
                                        pf->next->prev = pf;
 8050217:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805021a:	8b 00                	mov    (%eax),%eax
 805021c:	8b 55 cc             	mov    -0x34(%ebp),%edx
 805021f:	89 50 04             	mov    %edx,0x4(%eax)
 8050222:	eb 79                	jmp    805029d <ifree+0x3d6>
                        }
                } else if (pf->page == tail) {
 8050224:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050227:	8b 40 08             	mov    0x8(%eax),%eax
 805022a:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 805022d:	75 1c                	jne    805024b <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 805022f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050232:	8b 50 10             	mov    0x10(%eax),%edx
 8050235:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050238:	01 c2                	add    %eax,%edx
 805023a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805023d:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 8050240:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050243:	8b 55 e8             	mov    -0x18(%ebp),%edx
 8050246:	89 50 08             	mov    %edx,0x8(%eax)
 8050249:	eb 52                	jmp    805029d <ifree+0x3d6>
                } else if (!pf->next) {
 805024b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805024e:	8b 00                	mov    (%eax),%eax
 8050250:	85 c0                	test   %eax,%eax
 8050252:	75 38                	jne    805028c <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 8050254:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 805025a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 8050260:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 8050266:	8b 55 cc             	mov    -0x34(%ebp),%edx
 8050269:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 805026c:	8b 93 b0 02 00 00    	mov    0x2b0(%ebx),%edx
 8050272:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050275:	89 10                	mov    %edx,(%eax)
                        pf = px;
 8050277:	8b 83 b0 02 00 00    	mov    0x2b0(%ebx),%eax
 805027d:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 8050280:	c7 83 b0 02 00 00 00 	movl   $0x0,0x2b0(%ebx)
 8050287:	00 00 00 
 805028a:	eb 11                	jmp    805029d <ifree+0x3d6>
                } else {
                        wrterror("freelist is destroyed.\n");
 805028c:	8d 83 91 da ff ff    	lea    -0x256f(%ebx),%eax
 8050292:	89 04 24             	mov    %eax,(%esp)
 8050295:	e8 c7 e5 ff ff       	call   804e861 <wrterror>
 805029a:	eb 01                	jmp    805029d <ifree+0x3d6>
                                pt = pf->next;
                                pf->end = pt->end;
                                pf->size += pt->size;
                                pf->next = pt->next;
                                if (pf->next)
                                        pf->next->prev = pf;
 805029c:	90                   	nop
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 805029d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80502a0:	8b 00                	mov    (%eax),%eax
 80502a2:	85 c0                	test   %eax,%eax
 80502a4:	0f 85 cd 00 00 00    	jne    8050377 <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 80502aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80502ad:	8b 50 10             	mov    0x10(%eax),%edx
 80502b0:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 80502b6:	39 c2                	cmp    %eax,%edx
 80502b8:	0f 86 b9 00 00 00    	jbe    8050377 <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 80502be:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80502c1:	8b 50 0c             	mov    0xc(%eax),%edx
 80502c4:	8b 83 ac 02 00 00    	mov    0x2ac(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 80502ca:	39 c2                	cmp    %eax,%edx
 80502cc:	0f 85 a5 00 00 00    	jne    8050377 <ifree+0x4b0>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 80502d2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80502d9:	e8 21 ce ff ff       	call   804d0ff <sbrk>
 80502de:	89 c2                	mov    %eax,%edx
 80502e0:	8b 83 ac 02 00 00    	mov    0x2ac(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 80502e6:	39 c2                	cmp    %eax,%edx
 80502e8:	0f 85 89 00 00 00    	jne    8050377 <ifree+0x4b0>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 80502ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80502f1:	8b 50 08             	mov    0x8(%eax),%edx
 80502f4:	8b 83 14 00 00 00    	mov    0x14(%ebx),%eax
 80502fa:	01 c2                	add    %eax,%edx
 80502fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
 80502ff:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 8050302:	8b 93 14 00 00 00    	mov    0x14(%ebx),%edx
 8050308:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805030b:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 805030e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050311:	8b 40 0c             	mov    0xc(%eax),%eax
 8050314:	89 04 24             	mov    %eax,(%esp)
 8050317:	e8 ac ce ff ff       	call   804d1c8 <brk>
                malloc_brk = pf->end;
 805031c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805031f:	8b 40 0c             	mov    0xc(%eax),%eax
 8050322:	89 83 ac 02 00 00    	mov    %eax,0x2ac(%ebx)

                index = ptr2index(pf->end);
 8050328:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805032b:	8b 40 0c             	mov    0xc(%eax),%eax
 805032e:	c1 e8 0c             	shr    $0xc,%eax
 8050331:	89 c2                	mov    %eax,%edx
 8050333:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 8050339:	29 c2                	sub    %eax,%edx
 805033b:	89 d0                	mov    %edx,%eax
 805033d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                last_index = index - 1;
 8050340:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8050343:	48                   	dec    %eax
 8050344:	89 83 6c 02 00 00    	mov    %eax,0x26c(%ebx)

                for (i = index; i <= last_index;)
 805034a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805034d:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8050350:	eb 1a                	jmp    805036c <ifree+0x4a5>
                        page_dir[i++] = MALLOC_NOT_MINE;
 8050352:	8b 8b 70 02 00 00    	mov    0x270(%ebx),%ecx
 8050358:	8b 45 d8             	mov    -0x28(%ebp),%eax
 805035b:	8d 50 01             	lea    0x1(%eax),%edx
 805035e:	89 55 d8             	mov    %edx,-0x28(%ebp)
 8050361:	c1 e0 02             	shl    $0x2,%eax
 8050364:	01 c8                	add    %ecx,%eax
 8050366:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 805036c:	8b 83 6c 02 00 00    	mov    0x26c(%ebx),%eax
 8050372:	39 45 d8             	cmp    %eax,-0x28(%ebp)
 8050375:	76 db                	jbe    8050352 <ifree+0x48b>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 8050377:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 805037b:	0f 84 05 02 00 00    	je     8050586 <ifree+0x6bf>
                ifree(pt);
 8050381:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050384:	89 04 24             	mov    %eax,(%esp)
 8050387:	e8 3b fb ff ff       	call   804fec7 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 805038c:	e9 f5 01 00 00       	jmp    8050586 <ifree+0x6bf>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 8050391:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8050394:	8b 55 08             	mov    0x8(%ebp),%edx
 8050397:	89 55 ec             	mov    %edx,-0x14(%ebp)
 805039a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 805039d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80503a0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 80503a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80503a6:	25 ff 0f 00 00       	and    $0xfff,%eax
 80503ab:	89 c2                	mov    %eax,%edx
 80503ad:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80503b0:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 80503b4:	88 c1                	mov    %al,%cl
 80503b6:	d3 ea                	shr    %cl,%edx
 80503b8:	89 d0                	mov    %edx,%eax
 80503ba:	89 45 c0             	mov    %eax,-0x40(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 80503bd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80503c0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 80503c4:	48                   	dec    %eax
 80503c5:	89 c2                	mov    %eax,%edx
 80503c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80503ca:	21 d0                	and    %edx,%eax
 80503cc:	85 c0                	test   %eax,%eax
 80503ce:	74 13                	je     80503e3 <ifree+0x51c>
                wrtwarning("modified (chunk-) pointer.\n");
 80503d0:	8d 83 2e da ff ff    	lea    -0x25d2(%ebx),%eax
 80503d6:	89 04 24             	mov    %eax,(%esp)
 80503d9:	e8 53 e5 ff ff       	call   804e931 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 80503de:	e9 a3 01 00 00       	jmp    8050586 <ifree+0x6bf>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 80503e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
 80503e6:	c1 e8 05             	shr    $0x5,%eax
 80503e9:	89 c2                	mov    %eax,%edx
 80503eb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80503ee:	83 c2 04             	add    $0x4,%edx
 80503f1:	8b 04 90             	mov    (%eax,%edx,4),%eax
 80503f4:	8b 55 c0             	mov    -0x40(%ebp),%edx
 80503f7:	83 e2 1f             	and    $0x1f,%edx
 80503fa:	be 01 00 00 00       	mov    $0x1,%esi
 80503ff:	88 d1                	mov    %dl,%cl
 8050401:	d3 e6                	shl    %cl,%esi
 8050403:	89 f2                	mov    %esi,%edx
 8050405:	21 d0                	and    %edx,%eax
 8050407:	85 c0                	test   %eax,%eax
 8050409:	74 13                	je     805041e <ifree+0x557>
                wrtwarning("chunk is already free.\n");
 805040b:	8d 83 4a da ff ff    	lea    -0x25b6(%ebx),%eax
 8050411:	89 04 24             	mov    %eax,(%esp)
 8050414:	e8 18 e5 ff ff       	call   804e931 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 8050419:	e9 68 01 00 00       	jmp    8050586 <ifree+0x6bf>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 805041e:	8b 83 a8 02 00 00    	mov    0x2a8(%ebx),%eax
 8050424:	85 c0                	test   %eax,%eax
 8050426:	74 1e                	je     8050446 <ifree+0x57f>
                memset(ptr, SOME_JUNK, info->size);
 8050428:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805042b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 805042f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8050433:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 805043a:	00 
 805043b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805043e:	89 04 24             	mov    %eax,(%esp)
 8050441:	e8 c5 db ff ff       	call   804e00b <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 8050446:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8050449:	c1 e8 05             	shr    $0x5,%eax
 805044c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 805044f:	8d 48 04             	lea    0x4(%eax),%ecx
 8050452:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 8050455:	8b 4d c0             	mov    -0x40(%ebp),%ecx
 8050458:	83 e1 1f             	and    $0x1f,%ecx
 805045b:	be 01 00 00 00       	mov    $0x1,%esi
 8050460:	d3 e6                	shl    %cl,%esi
 8050462:	89 f1                	mov    %esi,%ecx
 8050464:	09 d1                	or     %edx,%ecx
 8050466:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 8050469:	83 c0 04             	add    $0x4,%eax
 805046c:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 805046f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050472:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 8050476:	40                   	inc    %eax
 8050477:	0f b7 d0             	movzwl %ax,%edx
 805047a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805047d:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 8050481:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 8050487:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805048a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 805048e:	c1 e0 02             	shl    $0x2,%eax
 8050491:	01 d0                	add    %edx,%eax
 8050493:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free == 1) {
 8050496:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050499:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 805049d:	83 f8 01             	cmp    $0x1,%eax
 80504a0:	75 5e                	jne    8050500 <ifree+0x639>

                /* Page became non-full */

                mp = page_dir + info->shift;
 80504a2:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 80504a8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80504ab:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 80504af:	c1 e0 02             	shl    $0x2,%eax
 80504b2:	01 d0                	add    %edx,%eax
 80504b4:	89 45 bc             	mov    %eax,-0x44(%ebp)
 80504b7:	eb 08                	jmp    80504c1 <ifree+0x5fa>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 80504b9:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504bc:	8b 00                	mov    (%eax),%eax
 80504be:	89 45 bc             	mov    %eax,-0x44(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 80504c1:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504c4:	8b 00                	mov    (%eax),%eax
 80504c6:	85 c0                	test   %eax,%eax
 80504c8:	74 1f                	je     80504e9 <ifree+0x622>
 80504ca:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504cd:	8b 00                	mov    (%eax),%eax
 80504cf:	8b 00                	mov    (%eax),%eax
 80504d1:	85 c0                	test   %eax,%eax
 80504d3:	74 14                	je     80504e9 <ifree+0x622>
 80504d5:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504d8:	8b 00                	mov    (%eax),%eax
 80504da:	8b 00                	mov    (%eax),%eax
 80504dc:	8b 50 04             	mov    0x4(%eax),%edx
 80504df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80504e2:	8b 40 04             	mov    0x4(%eax),%eax
 80504e5:	39 c2                	cmp    %eax,%edx
 80504e7:	72 d0                	jb     80504b9 <ifree+0x5f2>
                        mp = &(*mp)->next;
                info->next = *mp;
 80504e9:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504ec:	8b 10                	mov    (%eax),%edx
 80504ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 80504f1:	89 10                	mov    %edx,(%eax)
                *mp = info;
 80504f3:	8b 45 bc             	mov    -0x44(%ebp),%eax
 80504f6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 80504f9:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 80504fb:	e9 86 00 00 00       	jmp    8050586 <ifree+0x6bf>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 8050500:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050503:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 8050507:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805050a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 805050e:	39 c2                	cmp    %eax,%edx
 8050510:	75 74                	jne    8050586 <ifree+0x6bf>
 8050512:	eb 08                	jmp    805051c <ifree+0x655>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 8050514:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050517:	8b 00                	mov    (%eax),%eax
 8050519:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 805051c:	8b 45 bc             	mov    -0x44(%ebp),%eax
 805051f:	8b 00                	mov    (%eax),%eax
 8050521:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 8050524:	75 ee                	jne    8050514 <ifree+0x64d>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 8050526:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050529:	8b 10                	mov    (%eax),%edx
 805052b:	8b 45 bc             	mov    -0x44(%ebp),%eax
 805052e:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 8050530:	8b 93 70 02 00 00    	mov    0x270(%ebx),%edx
 8050536:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050539:	8b 40 04             	mov    0x4(%eax),%eax
 805053c:	c1 e8 0c             	shr    $0xc,%eax
 805053f:	89 c1                	mov    %eax,%ecx
 8050541:	8b 83 68 02 00 00    	mov    0x268(%ebx),%eax
 8050547:	29 c1                	sub    %eax,%ecx
 8050549:	89 c8                	mov    %ecx,%eax
 805054b:	c1 e0 02             	shl    $0x2,%eax
 805054e:	01 d0                	add    %edx,%eax
 8050550:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 8050556:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050559:	8b 40 04             	mov    0x4(%eax),%eax
 805055c:	89 45 b8             	mov    %eax,-0x48(%ebp)
        if (vp != (void *)info)
 805055f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050562:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 8050565:	74 0b                	je     8050572 <ifree+0x6ab>
                ifree(info);
 8050567:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 805056a:	89 04 24             	mov    %eax,(%esp)
 805056d:	e8 55 f9 ff ff       	call   804fec7 <ifree>
        ifree(vp);
 8050572:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8050575:	89 04 24             	mov    %eax,(%esp)
 8050578:	e8 4a f9 ff ff       	call   804fec7 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 805057d:	90                   	nop
 805057e:	eb 06                	jmp    8050586 <ifree+0x6bf>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 8050580:	90                   	nop
 8050581:	eb 04                	jmp    8050587 <ifree+0x6c0>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 8050583:	90                   	nop
 8050584:	eb 01                	jmp    8050587 <ifree+0x6c0>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 8050586:	90                   	nop
}
 8050587:	83 c4 50             	add    $0x50,%esp
 805058a:	5b                   	pop    %ebx
 805058b:	5e                   	pop    %esi
 805058c:	5d                   	pop    %ebp
 805058d:	c3                   	ret    

0805058e <malloc>:
 */


void *
malloc(size_t size)
{
 805058e:	55                   	push   %ebp
 805058f:	89 e5                	mov    %esp,%ebp
 8050591:	56                   	push   %esi
 8050592:	53                   	push   %ebx
 8050593:	83 ec 10             	sub    $0x10,%esp
 8050596:	e8 be d8 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 805059b:	81 c3 71 73 00 00    	add    $0x7371,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 80505a1:	8d 83 cd da ff ff    	lea    -0x2533(%ebx),%eax
 80505a7:	89 83 b4 02 00 00    	mov    %eax,0x2b4(%ebx)
        if (malloc_active++) {
 80505ad:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 80505b3:	8d 50 01             	lea    0x1(%eax),%edx
 80505b6:	89 93 64 02 00 00    	mov    %edx,0x264(%ebx)
 80505bc:	85 c0                	test   %eax,%eax
 80505be:	74 22                	je     80505e2 <malloc+0x54>
                wrtwarning("recursive call.\n");
 80505c0:	8d 83 db da ff ff    	lea    -0x2525(%ebx),%eax
 80505c6:	89 04 24             	mov    %eax,(%esp)
 80505c9:	e8 63 e3 ff ff       	call   804e931 <wrtwarning>
                malloc_active--;
 80505ce:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 80505d4:	48                   	dec    %eax
 80505d5:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
                return (0);
 80505db:	b8 00 00 00 00       	mov    $0x0,%eax
 80505e0:	eb 5e                	jmp    8050640 <malloc+0xb2>
        }
        if (!malloc_started) {
 80505e2:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 80505e8:	85 c0                	test   %eax,%eax
 80505ea:	75 05                	jne    80505f1 <malloc+0x63>
                malloc_init();
 80505ec:	e8 97 e5 ff ff       	call   804eb88 <malloc_init>
        }
        if (malloc_sysv && !size)
 80505f1:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 80505f7:	85 c0                	test   %eax,%eax
 80505f9:	74 0d                	je     8050608 <malloc+0x7a>
 80505fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80505ff:	75 07                	jne    8050608 <malloc+0x7a>
                r = 0;
 8050601:	be 00 00 00 00       	mov    $0x0,%esi
 8050606:	eb 0d                	jmp    8050615 <malloc+0x87>
        else
                r = imalloc(size);
 8050608:	8b 45 08             	mov    0x8(%ebp),%eax
 805060b:	89 04 24             	mov    %eax,(%esp)
 805060e:	e8 95 ef ff ff       	call   804f5a8 <imalloc>
 8050613:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 8050615:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 805061b:	48                   	dec    %eax
 805061c:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 8050622:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 8050628:	85 c0                	test   %eax,%eax
 805062a:	74 12                	je     805063e <malloc+0xb0>
 805062c:	85 f6                	test   %esi,%esi
 805062e:	75 0e                	jne    805063e <malloc+0xb0>
                wrterror("out of memory.\n");
 8050630:	8d 83 ec da ff ff    	lea    -0x2514(%ebx),%eax
 8050636:	89 04 24             	mov    %eax,(%esp)
 8050639:	e8 23 e2 ff ff       	call   804e861 <wrterror>
        return (r);
 805063e:	89 f0                	mov    %esi,%eax
}
 8050640:	83 c4 10             	add    $0x10,%esp
 8050643:	5b                   	pop    %ebx
 8050644:	5e                   	pop    %esi
 8050645:	5d                   	pop    %ebp
 8050646:	c3                   	ret    

08050647 <free>:

void
free(void *ptr)
{
 8050647:	55                   	push   %ebp
 8050648:	89 e5                	mov    %esp,%ebp
 805064a:	53                   	push   %ebx
 805064b:	83 ec 14             	sub    $0x14,%esp
 805064e:	e8 06 d8 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 8050653:	81 c3 b9 72 00 00    	add    $0x72b9,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 8050659:	8d 83 fc da ff ff    	lea    -0x2504(%ebx),%eax
 805065f:	89 83 b4 02 00 00    	mov    %eax,0x2b4(%ebx)
        if (malloc_active++) {
 8050665:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 805066b:	8d 50 01             	lea    0x1(%eax),%edx
 805066e:	89 93 64 02 00 00    	mov    %edx,0x264(%ebx)
 8050674:	85 c0                	test   %eax,%eax
 8050676:	74 1d                	je     8050695 <free+0x4e>
                wrtwarning("recursive call.\n");
 8050678:	8d 83 db da ff ff    	lea    -0x2525(%ebx),%eax
 805067e:	89 04 24             	mov    %eax,(%esp)
 8050681:	e8 ab e2 ff ff       	call   804e931 <wrtwarning>
                malloc_active--;
 8050686:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 805068c:	48                   	dec    %eax
 805068d:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
                return;
 8050693:	eb 19                	jmp    80506ae <free+0x67>
        } else {
                ifree(ptr);
 8050695:	8b 45 08             	mov    0x8(%ebp),%eax
 8050698:	89 04 24             	mov    %eax,(%esp)
 805069b:	e8 27 f8 ff ff       	call   804fec7 <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 80506a0:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 80506a6:	48                   	dec    %eax
 80506a7:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
        THREAD_UNLOCK();
        return;
 80506ad:	90                   	nop
}
 80506ae:	83 c4 14             	add    $0x14,%esp
 80506b1:	5b                   	pop    %ebx
 80506b2:	5d                   	pop    %ebp
 80506b3:	c3                   	ret    

080506b4 <realloc>:

void *
realloc(void *ptr, size_t size)
{
 80506b4:	55                   	push   %ebp
 80506b5:	89 e5                	mov    %esp,%ebp
 80506b7:	56                   	push   %esi
 80506b8:	53                   	push   %ebx
 80506b9:	83 ec 10             	sub    $0x10,%esp
 80506bc:	e8 98 d7 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 80506c1:	81 c3 4b 72 00 00    	add    $0x724b,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 80506c7:	8d 83 08 db ff ff    	lea    -0x24f8(%ebx),%eax
 80506cd:	89 83 b4 02 00 00    	mov    %eax,0x2b4(%ebx)
        if (malloc_active++) {
 80506d3:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 80506d9:	8d 50 01             	lea    0x1(%eax),%edx
 80506dc:	89 93 64 02 00 00    	mov    %edx,0x264(%ebx)
 80506e2:	85 c0                	test   %eax,%eax
 80506e4:	74 25                	je     805070b <realloc+0x57>
                wrtwarning("recursive call.\n");
 80506e6:	8d 83 db da ff ff    	lea    -0x2525(%ebx),%eax
 80506ec:	89 04 24             	mov    %eax,(%esp)
 80506ef:	e8 3d e2 ff ff       	call   804e931 <wrtwarning>
                malloc_active--;
 80506f4:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 80506fa:	48                   	dec    %eax
 80506fb:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
                return (0);
 8050701:	b8 00 00 00 00       	mov    $0x0,%eax
 8050706:	e9 aa 00 00 00       	jmp    80507b5 <realloc+0x101>
        }
        if (ptr && !malloc_started) {
 805070b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 805070f:	74 1f                	je     8050730 <realloc+0x7c>
 8050711:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8050717:	85 c0                	test   %eax,%eax
 8050719:	75 15                	jne    8050730 <realloc+0x7c>
                wrtwarning("malloc() has never been called.\n");
 805071b:	8d 83 ac da ff ff    	lea    -0x2554(%ebx),%eax
 8050721:	89 04 24             	mov    %eax,(%esp)
 8050724:	e8 08 e2 ff ff       	call   804e931 <wrtwarning>
                ptr = 0;
 8050729:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 8050730:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8050736:	85 c0                	test   %eax,%eax
 8050738:	75 05                	jne    805073f <realloc+0x8b>
                malloc_init();
 805073a:	e8 49 e4 ff ff       	call   804eb88 <malloc_init>
        if (malloc_sysv && !size) {
 805073f:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 8050745:	85 c0                	test   %eax,%eax
 8050747:	74 18                	je     8050761 <realloc+0xad>
 8050749:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 805074d:	75 12                	jne    8050761 <realloc+0xad>
                ifree(ptr);
 805074f:	8b 45 08             	mov    0x8(%ebp),%eax
 8050752:	89 04 24             	mov    %eax,(%esp)
 8050755:	e8 6d f7 ff ff       	call   804fec7 <ifree>
                r = 0;
 805075a:	be 00 00 00 00       	mov    $0x0,%esi
 805075f:	eb 29                	jmp    805078a <realloc+0xd6>
        } else if (!ptr) {
 8050761:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8050765:	75 0f                	jne    8050776 <realloc+0xc2>
                r = imalloc(size);
 8050767:	8b 45 0c             	mov    0xc(%ebp),%eax
 805076a:	89 04 24             	mov    %eax,(%esp)
 805076d:	e8 36 ee ff ff       	call   804f5a8 <imalloc>
 8050772:	89 c6                	mov    %eax,%esi
 8050774:	eb 14                	jmp    805078a <realloc+0xd6>
        } else {
                r = irealloc(ptr, size);
 8050776:	8b 45 0c             	mov    0xc(%ebp),%eax
 8050779:	89 44 24 04          	mov    %eax,0x4(%esp)
 805077d:	8b 45 08             	mov    0x8(%ebp),%eax
 8050780:	89 04 24             	mov    %eax,(%esp)
 8050783:	e8 d6 ee ff ff       	call   804f65e <irealloc>
 8050788:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 805078a:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 8050790:	48                   	dec    %eax
 8050791:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 8050797:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 805079d:	85 c0                	test   %eax,%eax
 805079f:	74 12                	je     80507b3 <realloc+0xff>
 80507a1:	85 f6                	test   %esi,%esi
 80507a3:	75 0e                	jne    80507b3 <realloc+0xff>
                wrterror("out of memory.\n");
 80507a5:	8d 83 ec da ff ff    	lea    -0x2514(%ebx),%eax
 80507ab:	89 04 24             	mov    %eax,(%esp)
 80507ae:	e8 ae e0 ff ff       	call   804e861 <wrterror>
        return (r);
 80507b3:	89 f0                	mov    %esi,%eax
}
 80507b5:	83 c4 10             	add    $0x10,%esp
 80507b8:	5b                   	pop    %ebx
 80507b9:	5e                   	pop    %esi
 80507ba:	5d                   	pop    %ebp
 80507bb:	c3                   	ret    

080507bc <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 80507bc:	55                   	push   %ebp
 80507bd:	89 e5                	mov    %esp,%ebp
 80507bf:	53                   	push   %ebx
 80507c0:	83 ec 24             	sub    $0x24,%esp
 80507c3:	e8 91 d6 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 80507c8:	81 c3 44 71 00 00    	add    $0x7144,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 80507ce:	8b 45 08             	mov    0x8(%ebp),%eax
 80507d1:	0f af 45 0c          	imul   0xc(%ebp),%eax
 80507d5:	89 04 24             	mov    %eax,(%esp)
 80507d8:	e8 b1 fd ff ff       	call   805058e <malloc>
 80507dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80507e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 80507e4:	75 07                	jne    80507ed <calloc+0x31>
                return NULL;
 80507e6:	b8 00 00 00 00       	mov    $0x0,%eax
 80507eb:	eb 21                	jmp    805080e <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 80507ed:	8b 45 08             	mov    0x8(%ebp),%eax
 80507f0:	0f af 45 0c          	imul   0xc(%ebp),%eax
 80507f4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80507f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80507ff:	00 
 8050800:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8050803:	89 04 24             	mov    %eax,(%esp)
 8050806:	e8 00 d8 ff ff       	call   804e00b <memset>
                return tmp;
 805080b:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 805080e:	83 c4 24             	add    $0x24,%esp
 8050811:	5b                   	pop    %ebx
 8050812:	5d                   	pop    %ebp
 8050813:	c3                   	ret    

08050814 <rand>:
#define RANDOM(lo,hi) ((lo)+(((hi)-(lo)+1)*(randseed = (randseed*4096+150889)%714025))/714025)

static unsigned long long randseed = 123456L;

int rand(void)
{
 8050814:	55                   	push   %ebp
 8050815:	89 e5                	mov    %esp,%ebp
 8050817:	53                   	push   %ebx
 8050818:	83 ec 14             	sub    $0x14,%esp
 805081b:	e8 39 d6 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 8050820:	81 c3 ec 70 00 00    	add    $0x70ec,%ebx
        randseed = (randseed * 4096 + 150889) % RAND_MAX;
 8050826:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 805082c:	8b 93 38 00 00 00    	mov    0x38(%ebx),%edx
 8050832:	0f a4 c2 0c          	shld   $0xc,%eax,%edx
 8050836:	c1 e0 0c             	shl    $0xc,%eax
 8050839:	05 69 4d 02 00       	add    $0x24d69,%eax
 805083e:	83 d2 00             	adc    $0x0,%edx
 8050841:	c7 44 24 08 ff ff ff 	movl   $0x7fffffff,0x8(%esp)
 8050848:	7f 
 8050849:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 8050850:	00 
 8050851:	89 04 24             	mov    %eax,(%esp)
 8050854:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050858:	e8 69 0a 00 00       	call   80512c6 <__umoddi3>
 805085d:	89 83 34 00 00 00    	mov    %eax,0x34(%ebx)
 8050863:	89 93 38 00 00 00    	mov    %edx,0x38(%ebx)
        return randseed;
 8050869:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 805086f:	8b 93 38 00 00 00    	mov    0x38(%ebx),%edx
}
 8050875:	83 c4 14             	add    $0x14,%esp
 8050878:	5b                   	pop    %ebx
 8050879:	5d                   	pop    %ebp
 805087a:	c3                   	ret    

0805087b <srand>:

void srand(unsigned int seed)
{
 805087b:	55                   	push   %ebp
 805087c:	89 e5                	mov    %esp,%ebp
 805087e:	e8 d2 d5 ff ff       	call   804de55 <__x86.get_pc_thunk.cx>
 8050883:	81 c1 89 70 00 00    	add    $0x7089,%ecx
        randseed = seed;
 8050889:	8b 45 08             	mov    0x8(%ebp),%eax
 805088c:	ba 00 00 00 00       	mov    $0x0,%edx
 8050891:	89 81 34 00 00 00    	mov    %eax,0x34(%ecx)
 8050897:	89 91 38 00 00 00    	mov    %edx,0x38(%ecx)
}
 805089d:	90                   	nop
 805089e:	5d                   	pop    %ebp
 805089f:	c3                   	ret    

080508a0 <printf>:

#include "stdio.h"
#include "unistd.h"

int printf(const char *fmt, ...)
{
 80508a0:	55                   	push   %ebp
 80508a1:	89 e5                	mov    %esp,%ebp
 80508a3:	53                   	push   %ebx
 80508a4:	83 ec 24             	sub    $0x24,%esp
 80508a7:	e8 a5 d5 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 80508ac:	05 60 70 00 00       	add    $0x7060,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 80508b1:	8d 55 0c             	lea    0xc(%ebp),%edx
 80508b4:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vprintf(fmt, args);
 80508b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80508ba:	89 54 24 04          	mov    %edx,0x4(%esp)
 80508be:	8b 55 08             	mov    0x8(%ebp),%edx
 80508c1:	89 14 24             	mov    %edx,(%esp)
 80508c4:	89 c3                	mov    %eax,%ebx
 80508c6:	e8 cd 00 00 00       	call   8050998 <vprintf>
 80508cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 80508ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80508d1:	83 c4 24             	add    $0x24,%esp
 80508d4:	5b                   	pop    %ebx
 80508d5:	5d                   	pop    %ebp
 80508d6:	c3                   	ret    

080508d7 <fprintf>:

int fprintf(FILE *stream, const char *fmt, ...)
{
 80508d7:	55                   	push   %ebp
 80508d8:	89 e5                	mov    %esp,%ebp
 80508da:	53                   	push   %ebx
 80508db:	83 ec 24             	sub    $0x24,%esp
 80508de:	e8 6e d5 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 80508e3:	05 29 70 00 00       	add    $0x7029,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 80508e8:	8d 55 10             	lea    0x10(%ebp),%edx
 80508eb:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vfprintf(stream, fmt, args);
 80508ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80508f1:	89 54 24 08          	mov    %edx,0x8(%esp)
 80508f5:	8b 55 0c             	mov    0xc(%ebp),%edx
 80508f8:	89 54 24 04          	mov    %edx,0x4(%esp)
 80508fc:	8b 55 08             	mov    0x8(%ebp),%edx
 80508ff:	89 14 24             	mov    %edx,(%esp)
 8050902:	89 c3                	mov    %eax,%ebx
 8050904:	e8 c6 00 00 00       	call   80509cf <vfprintf>
 8050909:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 805090c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 805090f:	83 c4 24             	add    $0x24,%esp
 8050912:	5b                   	pop    %ebx
 8050913:	5d                   	pop    %ebp
 8050914:	c3                   	ret    

08050915 <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
 8050915:	55                   	push   %ebp
 8050916:	89 e5                	mov    %esp,%ebp
 8050918:	53                   	push   %ebx
 8050919:	83 ec 24             	sub    $0x24,%esp
 805091c:	e8 30 d5 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8050921:	05 eb 6f 00 00       	add    $0x6feb,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 8050926:	8d 55 10             	lea    0x10(%ebp),%edx
 8050929:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsprintf(buf, fmt, args);
 805092c:	8b 55 f0             	mov    -0x10(%ebp),%edx
 805092f:	89 54 24 08          	mov    %edx,0x8(%esp)
 8050933:	8b 55 0c             	mov    0xc(%ebp),%edx
 8050936:	89 54 24 04          	mov    %edx,0x4(%esp)
 805093a:	8b 55 08             	mov    0x8(%ebp),%edx
 805093d:	89 14 24             	mov    %edx,(%esp)
 8050940:	89 c3                	mov    %eax,%ebx
 8050942:	e8 f4 00 00 00       	call   8050a3b <vsprintf>
 8050947:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 805094a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 805094d:	83 c4 24             	add    $0x24,%esp
 8050950:	5b                   	pop    %ebx
 8050951:	5d                   	pop    %ebp
 8050952:	c3                   	ret    

08050953 <snprintf>:

int snprintf(char *buf, size_t size, const char *fmt, ...)
{
 8050953:	55                   	push   %ebp
 8050954:	89 e5                	mov    %esp,%ebp
 8050956:	53                   	push   %ebx
 8050957:	83 ec 24             	sub    $0x24,%esp
 805095a:	e8 f2 d4 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 805095f:	05 ad 6f 00 00       	add    $0x6fad,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 8050964:	8d 55 14             	lea    0x14(%ebp),%edx
 8050967:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsnprintf(buf, size, fmt, args);
 805096a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 805096d:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8050971:	8b 55 10             	mov    0x10(%ebp),%edx
 8050974:	89 54 24 08          	mov    %edx,0x8(%esp)
 8050978:	8b 55 0c             	mov    0xc(%ebp),%edx
 805097b:	89 54 24 04          	mov    %edx,0x4(%esp)
 805097f:	8b 55 08             	mov    0x8(%ebp),%edx
 8050982:	89 14 24             	mov    %edx,(%esp)
 8050985:	89 c3                	mov    %eax,%ebx
 8050987:	e8 27 0e 00 00       	call   80517b3 <vsnprintf>
 805098c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 805098f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8050992:	83 c4 24             	add    $0x24,%esp
 8050995:	5b                   	pop    %ebx
 8050996:	5d                   	pop    %ebp
 8050997:	c3                   	ret    

08050998 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
 8050998:	55                   	push   %ebp
 8050999:	89 e5                	mov    %esp,%ebp
 805099b:	53                   	push   %ebx
 805099c:	83 ec 14             	sub    $0x14,%esp
 805099f:	e8 ad d4 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 80509a4:	05 68 6f 00 00       	add    $0x6f68,%eax
        return vfprintf(stdout, fmt, args);
 80509a9:	8d 15 38 79 05 08    	lea    0x8057938,%edx
 80509af:	8b 12                	mov    (%edx),%edx
 80509b1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 80509b4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 80509b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
 80509bb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 80509bf:	89 14 24             	mov    %edx,(%esp)
 80509c2:	89 c3                	mov    %eax,%ebx
 80509c4:	e8 06 00 00 00       	call   80509cf <vfprintf>
}
 80509c9:	83 c4 14             	add    $0x14,%esp
 80509cc:	5b                   	pop    %ebx
 80509cd:	5d                   	pop    %ebp
 80509ce:	c3                   	ret    

080509cf <vfprintf>:

#define __LIBC_PRINTF_BUFSIZE 1024
int vfprintf(FILE *stream, const char *fmt, va_list args)
{
 80509cf:	55                   	push   %ebp
 80509d0:	89 e5                	mov    %esp,%ebp
 80509d2:	53                   	push   %ebx
 80509d3:	81 ec 24 04 00 00    	sub    $0x424,%esp
 80509d9:	e8 7b d4 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 80509de:	81 c3 2e 6f 00 00    	add    $0x6f2e,%ebx
        /* I'm really lazy */
        char buf[__LIBC_PRINTF_BUFSIZE];
        int ret = vsnprintf(buf, __LIBC_PRINTF_BUFSIZE, fmt, args);
 80509e4:	8b 45 10             	mov    0x10(%ebp),%eax
 80509e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80509eb:	8b 45 0c             	mov    0xc(%ebp),%eax
 80509ee:	89 44 24 08          	mov    %eax,0x8(%esp)
 80509f2:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 80509f9:	00 
 80509fa:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
 8050a00:	89 04 24             	mov    %eax,(%esp)
 8050a03:	e8 ab 0d 00 00       	call   80517b3 <vsnprintf>
 8050a08:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (ret > 0) {
 8050a0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8050a0f:	7e 1e                	jle    8050a2f <vfprintf+0x60>
                write(*stream, buf, ret);
 8050a11:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8050a14:	8b 45 08             	mov    0x8(%ebp),%eax
 8050a17:	8b 00                	mov    (%eax),%eax
 8050a19:	89 54 24 08          	mov    %edx,0x8(%esp)
 8050a1d:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
 8050a23:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050a27:	89 04 24             	mov    %eax,(%esp)
 8050a2a:	e8 a3 cc ff ff       	call   804d6d2 <write>
        }
        return ret;
 8050a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8050a32:	81 c4 24 04 00 00    	add    $0x424,%esp
 8050a38:	5b                   	pop    %ebx
 8050a39:	5d                   	pop    %ebp
 8050a3a:	c3                   	ret    

08050a3b <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
 8050a3b:	55                   	push   %ebp
 8050a3c:	89 e5                	mov    %esp,%ebp
 8050a3e:	53                   	push   %ebx
 8050a3f:	83 ec 14             	sub    $0x14,%esp
 8050a42:	e8 0a d4 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8050a47:	05 c5 6e 00 00       	add    $0x6ec5,%eax
        return vsnprintf(buf, 0xffffffffUL, fmt, args);
 8050a4c:	8b 55 10             	mov    0x10(%ebp),%edx
 8050a4f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8050a53:	8b 55 0c             	mov    0xc(%ebp),%edx
 8050a56:	89 54 24 08          	mov    %edx,0x8(%esp)
 8050a5a:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
 8050a61:	ff 
 8050a62:	8b 55 08             	mov    0x8(%ebp),%edx
 8050a65:	89 14 24             	mov    %edx,(%esp)
 8050a68:	89 c3                	mov    %eax,%ebx
 8050a6a:	e8 44 0d 00 00       	call   80517b3 <vsnprintf>
}
 8050a6f:	83 c4 14             	add    $0x14,%esp
 8050a72:	5b                   	pop    %ebx
 8050a73:	5d                   	pop    %ebp
 8050a74:	c3                   	ret    

08050a75 <fflush>:

int fflush(FILE *stream)
{
 8050a75:	55                   	push   %ebp
 8050a76:	89 e5                	mov    %esp,%ebp
 8050a78:	e8 d4 d3 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8050a7d:	05 8f 6e 00 00       	add    $0x6e8f,%eax
        /* no-op */
        return 0;
 8050a82:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8050a87:	5d                   	pop    %ebp
 8050a88:	c3                   	ret    

08050a89 <shl>:
 * `fall out' the left (there never will be any such anyway).
 * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
 */
static void
shl(register digit *p, register int len, register int sh)
{
 8050a89:	55                   	push   %ebp
 8050a8a:	89 e5                	mov    %esp,%ebp
 8050a8c:	57                   	push   %edi
 8050a8d:	56                   	push   %esi
 8050a8e:	53                   	push   %ebx
 8050a8f:	83 ec 04             	sub    $0x4,%esp
 8050a92:	e8 ba d3 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8050a97:	05 75 6e 00 00       	add    $0x6e75,%eax
 8050a9c:	8b 75 08             	mov    0x8(%ebp),%esi
        register int i;

        for (i = 0; i < len; i++)
 8050a9f:	bb 00 00 00 00       	mov    $0x0,%ebx
 8050aa4:	eb 41                	jmp    8050ae7 <shl+0x5e>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
 8050aa6:	89 d8                	mov    %ebx,%eax
 8050aa8:	c1 e0 02             	shl    $0x2,%eax
 8050aab:	8d 3c 06             	lea    (%esi,%eax,1),%edi
 8050aae:	89 d8                	mov    %ebx,%eax
 8050ab0:	c1 e0 02             	shl    $0x2,%eax
 8050ab3:	01 f0                	add    %esi,%eax
 8050ab5:	8b 00                	mov    (%eax),%eax
 8050ab7:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 8050abb:	d3 e0                	shl    %cl,%eax
 8050abd:	0f b7 c0             	movzwl %ax,%eax
 8050ac0:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8050ac3:	89 d8                	mov    %ebx,%eax
 8050ac5:	40                   	inc    %eax
 8050ac6:	c1 e0 02             	shl    $0x2,%eax
 8050ac9:	01 f0                	add    %esi,%eax
 8050acb:	8b 00                	mov    (%eax),%eax
 8050acd:	89 c1                	mov    %eax,%ecx
 8050acf:	8b 55 10             	mov    0x10(%ebp),%edx
 8050ad2:	b8 10 00 00 00       	mov    $0x10,%eax
 8050ad7:	29 d0                	sub    %edx,%eax
 8050ad9:	89 ca                	mov    %ecx,%edx
 8050adb:	88 c1                	mov    %al,%cl
 8050add:	d3 ea                	shr    %cl,%edx
 8050adf:	89 d0                	mov    %edx,%eax
 8050ae1:	0b 45 f0             	or     -0x10(%ebp),%eax
 8050ae4:	89 07                	mov    %eax,(%edi)
static void
shl(register digit *p, register int len, register int sh)
{
        register int i;

        for (i = 0; i < len; i++)
 8050ae6:	43                   	inc    %ebx
 8050ae7:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
 8050aea:	7c ba                	jl     8050aa6 <shl+0x1d>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
        p[i] = LHALF(p[i] << sh);
 8050aec:	89 d8                	mov    %ebx,%eax
 8050aee:	c1 e0 02             	shl    $0x2,%eax
 8050af1:	8d 14 06             	lea    (%esi,%eax,1),%edx
 8050af4:	89 d8                	mov    %ebx,%eax
 8050af6:	c1 e0 02             	shl    $0x2,%eax
 8050af9:	01 f0                	add    %esi,%eax
 8050afb:	8b 00                	mov    (%eax),%eax
 8050afd:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 8050b01:	d3 e0                	shl    %cl,%eax
 8050b03:	0f b7 c0             	movzwl %ax,%eax
 8050b06:	89 02                	mov    %eax,(%edx)
}
 8050b08:	90                   	nop
 8050b09:	83 c4 04             	add    $0x4,%esp
 8050b0c:	5b                   	pop    %ebx
 8050b0d:	5e                   	pop    %esi
 8050b0e:	5f                   	pop    %edi
 8050b0f:	5d                   	pop    %ebp
 8050b10:	c3                   	ret    

08050b11 <__qdivrem>:
 * divisor are 4 `digits' in this base (they are shorter if they have
 * leading zeros).
 */
unsigned long long
__qdivrem(unsigned long long uq, unsigned long long vq, unsigned long long *arq)
{
 8050b11:	55                   	push   %ebp
 8050b12:	89 e5                	mov    %esp,%ebp
 8050b14:	57                   	push   %edi
 8050b15:	56                   	push   %esi
 8050b16:	53                   	push   %ebx
 8050b17:	81 ec b8 00 00 00    	sub    $0xb8,%esp
 8050b1d:	e8 2f d3 ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8050b22:	05 ea 6d 00 00       	add    $0x6dea,%eax
 8050b27:	8b 55 08             	mov    0x8(%ebp),%edx
 8050b2a:	89 95 58 ff ff ff    	mov    %edx,-0xa8(%ebp)
 8050b30:	8b 55 0c             	mov    0xc(%ebp),%edx
 8050b33:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
 8050b39:	8b 55 10             	mov    0x10(%ebp),%edx
 8050b3c:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
 8050b42:	8b 55 14             	mov    0x14(%ebp),%edx
 8050b45:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
        digit uspace[5], vspace[5], qspace[5];

        /*
         * Take care of special cases: divide by zero, and u < v.
         */
        if (vq == 0) {
 8050b4b:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 8050b51:	0b 95 50 ff ff ff    	or     -0xb0(%ebp),%edx
 8050b57:	85 d2                	test   %edx,%edx
 8050b59:	75 40                	jne    8050b9b <__qdivrem+0x8a>
                /* divide by zero. */
                static volatile const unsigned int zero = 0;

                tmp.ul[H] = tmp.ul[L] = 1 / zero;
 8050b5b:	8b b8 3c 00 00 00    	mov    0x3c(%eax),%edi
 8050b61:	b8 01 00 00 00       	mov    $0x1,%eax
 8050b66:	ba 00 00 00 00       	mov    $0x0,%edx
 8050b6b:	f7 f7                	div    %edi
 8050b6d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 8050b70:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8050b73:	89 45 a8             	mov    %eax,-0x58(%ebp)
                if (arq)
 8050b76:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 8050b7a:	74 14                	je     8050b90 <__qdivrem+0x7f>
                        *arq = uq;
 8050b7c:	8b 4d 18             	mov    0x18(%ebp),%ecx
 8050b7f:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 8050b85:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 8050b8b:	89 01                	mov    %eax,(%ecx)
 8050b8d:	89 51 04             	mov    %edx,0x4(%ecx)
                return (tmp.q);
 8050b90:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8050b93:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8050b96:	e9 eb 05 00 00       	jmp    8051186 <__qdivrem+0x675>
        }
        if (uq < vq) {
 8050b9b:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 8050ba1:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 8050ba7:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 8050bad:	77 39                	ja     8050be8 <__qdivrem+0xd7>
 8050baf:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 8050bb5:	72 08                	jb     8050bbf <__qdivrem+0xae>
 8050bb7:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
 8050bbd:	73 29                	jae    8050be8 <__qdivrem+0xd7>
                if (arq)
 8050bbf:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 8050bc3:	74 14                	je     8050bd9 <__qdivrem+0xc8>
                        *arq = uq;
 8050bc5:	8b 4d 18             	mov    0x18(%ebp),%ecx
 8050bc8:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 8050bce:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 8050bd4:	89 01                	mov    %eax,(%ecx)
 8050bd6:	89 51 04             	mov    %edx,0x4(%ecx)
                return (0);
 8050bd9:	b8 00 00 00 00       	mov    $0x0,%eax
 8050bde:	ba 00 00 00 00       	mov    $0x0,%edx
 8050be3:	e9 9e 05 00 00       	jmp    8051186 <__qdivrem+0x675>
        }
        u = &uspace[0];
 8050be8:	8d 45 90             	lea    -0x70(%ebp),%eax
 8050beb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        v = &vspace[0];
 8050bee:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 8050bf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        q = &qspace[0];
 8050bf7:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 8050bfd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         *      m >= 0 (otherwise u < v, which we already checked)
         *      m + n = 4
         * and thus
         *      m = 4 - n <= 2
         */
        tmp.uq = uq;
 8050c00:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 8050c06:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 8050c0c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 8050c0f:	89 55 a8             	mov    %edx,-0x58(%ebp)
        u[0] = 0;
 8050c12:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050c15:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        u[1] = HHALF(tmp.ul[H]);
 8050c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050c1e:	83 c0 04             	add    $0x4,%eax
 8050c21:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8050c24:	c1 ea 10             	shr    $0x10,%edx
 8050c27:	89 10                	mov    %edx,(%eax)
        u[2] = LHALF(tmp.ul[H]);
 8050c29:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050c2c:	8d 50 08             	lea    0x8(%eax),%edx
 8050c2f:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8050c32:	0f b7 c0             	movzwl %ax,%eax
 8050c35:	89 02                	mov    %eax,(%edx)
        u[3] = HHALF(tmp.ul[L]);
 8050c37:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050c3a:	83 c0 0c             	add    $0xc,%eax
 8050c3d:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 8050c40:	c1 ea 10             	shr    $0x10,%edx
 8050c43:	89 10                	mov    %edx,(%eax)
        u[4] = LHALF(tmp.ul[L]);
 8050c45:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050c48:	8d 50 10             	lea    0x10(%eax),%edx
 8050c4b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8050c4e:	0f b7 c0             	movzwl %ax,%eax
 8050c51:	89 02                	mov    %eax,(%edx)
        tmp.uq = vq;
 8050c53:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 8050c59:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 8050c5f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 8050c62:	89 55 a8             	mov    %edx,-0x58(%ebp)
        v[1] = HHALF(tmp.ul[H]);
 8050c65:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050c68:	83 c0 04             	add    $0x4,%eax
 8050c6b:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8050c6e:	c1 ea 10             	shr    $0x10,%edx
 8050c71:	89 10                	mov    %edx,(%eax)
        v[2] = LHALF(tmp.ul[H]);
 8050c73:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050c76:	8d 50 08             	lea    0x8(%eax),%edx
 8050c79:	8b 45 a8             	mov    -0x58(%ebp),%eax
 8050c7c:	0f b7 c0             	movzwl %ax,%eax
 8050c7f:	89 02                	mov    %eax,(%edx)
        v[3] = HHALF(tmp.ul[L]);
 8050c81:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050c84:	83 c0 0c             	add    $0xc,%eax
 8050c87:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 8050c8a:	c1 ea 10             	shr    $0x10,%edx
 8050c8d:	89 10                	mov    %edx,(%eax)
        v[4] = LHALF(tmp.ul[L]);
 8050c8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050c92:	8d 50 10             	lea    0x10(%eax),%edx
 8050c95:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8050c98:	0f b7 c0             	movzwl %ax,%eax
 8050c9b:	89 02                	mov    %eax,(%edx)
        for (n = 4; v[1] == 0; v++) {
 8050c9d:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
 8050ca4:	e9 fc 00 00 00       	jmp    8050da5 <__qdivrem+0x294>
                if (--n == 1) {
 8050ca9:	ff 4d d4             	decl   -0x2c(%ebp)
 8050cac:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 8050cb0:	0f 85 eb 00 00 00    	jne    8050da1 <__qdivrem+0x290>
                         *      for j = 1..4:
                         *              q[j] = floor((r*B + u[j]) / v),
                         *              r = (r*B + u[j]) % v;
                         * We unroll this completely here.
                         */
                        t = v[2];       /* nonzero, by definition */
 8050cb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050cb9:	8b 40 08             	mov    0x8(%eax),%eax
 8050cbc:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        q1 = u[1] / t;
 8050cbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050cc2:	83 c0 04             	add    $0x4,%eax
 8050cc5:	8b 00                	mov    (%eax),%eax
 8050cc7:	ba 00 00 00 00       	mov    $0x0,%edx
 8050ccc:	f7 75 dc             	divl   -0x24(%ebp)
 8050ccf:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        rbj = COMBINE(u[1] % t, u[2]);
 8050cd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050cd5:	83 c0 04             	add    $0x4,%eax
 8050cd8:	8b 00                	mov    (%eax),%eax
 8050cda:	ba 00 00 00 00       	mov    $0x0,%edx
 8050cdf:	f7 75 dc             	divl   -0x24(%ebp)
 8050ce2:	89 d0                	mov    %edx,%eax
 8050ce4:	c1 e0 10             	shl    $0x10,%eax
 8050ce7:	89 c2                	mov    %eax,%edx
 8050ce9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050cec:	83 c0 08             	add    $0x8,%eax
 8050cef:	8b 00                	mov    (%eax),%eax
 8050cf1:	09 d0                	or     %edx,%eax
 8050cf3:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q2 = rbj / t;
 8050cf6:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050cf9:	ba 00 00 00 00       	mov    $0x0,%edx
 8050cfe:	f7 75 dc             	divl   -0x24(%ebp)
 8050d01:	89 45 b8             	mov    %eax,-0x48(%ebp)
                        rbj = COMBINE(rbj % t, u[3]);
 8050d04:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050d07:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d0c:	f7 75 dc             	divl   -0x24(%ebp)
 8050d0f:	89 d0                	mov    %edx,%eax
 8050d11:	c1 e0 10             	shl    $0x10,%eax
 8050d14:	89 c2                	mov    %eax,%edx
 8050d16:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050d19:	83 c0 0c             	add    $0xc,%eax
 8050d1c:	8b 00                	mov    (%eax),%eax
 8050d1e:	09 d0                	or     %edx,%eax
 8050d20:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q3 = rbj / t;
 8050d23:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050d26:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d2b:	f7 75 dc             	divl   -0x24(%ebp)
 8050d2e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                        rbj = COMBINE(rbj % t, u[4]);
 8050d31:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050d34:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d39:	f7 75 dc             	divl   -0x24(%ebp)
 8050d3c:	89 d0                	mov    %edx,%eax
 8050d3e:	c1 e0 10             	shl    $0x10,%eax
 8050d41:	89 c2                	mov    %eax,%edx
 8050d43:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050d46:	83 c0 10             	add    $0x10,%eax
 8050d49:	8b 00                	mov    (%eax),%eax
 8050d4b:	09 d0                	or     %edx,%eax
 8050d4d:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q4 = rbj / t;
 8050d50:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050d53:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d58:	f7 75 dc             	divl   -0x24(%ebp)
 8050d5b:	89 45 b0             	mov    %eax,-0x50(%ebp)
                        if (arq)
 8050d5e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 8050d62:	74 1a                	je     8050d7e <__qdivrem+0x26d>
                                *arq = rbj % t;
 8050d64:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8050d67:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d6c:	f7 75 dc             	divl   -0x24(%ebp)
 8050d6f:	89 d0                	mov    %edx,%eax
 8050d71:	ba 00 00 00 00       	mov    $0x0,%edx
 8050d76:	8b 4d 18             	mov    0x18(%ebp),%ecx
 8050d79:	89 01                	mov    %eax,(%ecx)
 8050d7b:	89 51 04             	mov    %edx,0x4(%ecx)
                        tmp.ul[H] = COMBINE(q1, q2);
 8050d7e:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8050d81:	c1 e0 10             	shl    $0x10,%eax
 8050d84:	0b 45 b8             	or     -0x48(%ebp),%eax
 8050d87:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        tmp.ul[L] = COMBINE(q3, q4);
 8050d8a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8050d8d:	c1 e0 10             	shl    $0x10,%eax
 8050d90:	0b 45 b0             	or     -0x50(%ebp),%eax
 8050d93:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        return (tmp.q);
 8050d96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8050d99:	8b 55 a8             	mov    -0x58(%ebp),%edx
 8050d9c:	e9 e5 03 00 00       	jmp    8051186 <__qdivrem+0x675>
        tmp.uq = vq;
        v[1] = HHALF(tmp.ul[H]);
        v[2] = LHALF(tmp.ul[H]);
        v[3] = HHALF(tmp.ul[L]);
        v[4] = LHALF(tmp.ul[L]);
        for (n = 4; v[1] == 0; v++) {
 8050da1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
 8050da5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050da8:	83 c0 04             	add    $0x4,%eax
 8050dab:	8b 00                	mov    (%eax),%eax
 8050dad:	85 c0                	test   %eax,%eax
 8050daf:	0f 84 f4 fe ff ff    	je     8050ca9 <__qdivrem+0x198>
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 8050db5:	b8 04 00 00 00       	mov    $0x4,%eax
 8050dba:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 8050dbd:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8050dc0:	eb 07                	jmp    8050dc9 <__qdivrem+0x2b8>
                m--;
 8050dc2:	ff 4d d8             	decl   -0x28(%ebp)
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 8050dc5:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
 8050dc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050dcc:	83 c0 04             	add    $0x4,%eax
 8050dcf:	8b 00                	mov    (%eax),%eax
 8050dd1:	85 c0                	test   %eax,%eax
 8050dd3:	74 ed                	je     8050dc2 <__qdivrem+0x2b1>
                m--;
        for (i = 4 - m; --i >= 0;)
 8050dd5:	b8 04 00 00 00       	mov    $0x4,%eax
 8050dda:	2b 45 d8             	sub    -0x28(%ebp),%eax
 8050ddd:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8050de0:	eb 15                	jmp    8050df7 <__qdivrem+0x2e6>
                q[i] = 0;
 8050de2:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8050de5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050dec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8050def:	01 d0                	add    %edx,%eax
 8050df1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
                m--;
        for (i = 4 - m; --i >= 0;)
 8050df7:	ff 4d c8             	decl   -0x38(%ebp)
 8050dfa:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 8050dfe:	79 e2                	jns    8050de2 <__qdivrem+0x2d1>
                q[i] = 0;
        q += 4 - m;
 8050e00:	b8 04 00 00 00       	mov    $0x4,%eax
 8050e05:	2b 45 d8             	sub    -0x28(%ebp),%eax
 8050e08:	c1 e0 02             	shl    $0x2,%eax
 8050e0b:	01 45 c4             	add    %eax,-0x3c(%ebp)
         * Here we run Program D, translated from MIX to C and acquiring
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
 8050e0e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        for (t = v[1]; t < B / 2; t <<= 1)
 8050e15:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050e18:	8b 40 04             	mov    0x4(%eax),%eax
 8050e1b:	89 45 dc             	mov    %eax,-0x24(%ebp)
 8050e1e:	eb 06                	jmp    8050e26 <__qdivrem+0x315>
                d++;
 8050e20:	ff 45 d0             	incl   -0x30(%ebp)
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
        for (t = v[1]; t < B / 2; t <<= 1)
 8050e23:	d1 65 dc             	shll   -0x24(%ebp)
 8050e26:	81 7d dc ff 7f 00 00 	cmpl   $0x7fff,-0x24(%ebp)
 8050e2d:	76 f1                	jbe    8050e20 <__qdivrem+0x30f>
                d++;
        if (d > 0) {
 8050e2f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8050e33:	7e 3d                	jle    8050e72 <__qdivrem+0x361>
                shl(&u[0], m + n, d);           /* u <<= d */
 8050e35:	8b 55 d8             	mov    -0x28(%ebp),%edx
 8050e38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050e3b:	01 c2                	add    %eax,%edx
 8050e3d:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8050e40:	89 44 24 08          	mov    %eax,0x8(%esp)
 8050e44:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050e48:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050e4b:	89 04 24             	mov    %eax,(%esp)
 8050e4e:	e8 36 fc ff ff       	call   8050a89 <shl>
                shl(&v[1], n - 1, d);           /* v <<= d */
 8050e53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050e56:	8d 48 ff             	lea    -0x1(%eax),%ecx
 8050e59:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050e5c:	8d 50 04             	lea    0x4(%eax),%edx
 8050e5f:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8050e62:	89 44 24 08          	mov    %eax,0x8(%esp)
 8050e66:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 8050e6a:	89 14 24             	mov    %edx,(%esp)
 8050e6d:	e8 17 fc ff ff       	call   8050a89 <shl>
        }
        /*
         * D2: j = 0.
         */
        j = 0;
 8050e72:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
        v1 = v[1];      /* for D3 -- note that v[1..n] are constant */
 8050e79:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050e7c:	8b 58 04             	mov    0x4(%eax),%ebx
        v2 = v[2];      /* for D3 */
 8050e7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050e82:	8b 40 08             	mov    0x8(%eax),%eax
 8050e85:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
                 * let rhat = (u[j]*B + u[j+1]) mod v[1].
                 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
                 * decrement qhat and increase rhat correspondingly.
                 * Note that if rhat >= B, v[2]*qhat < rhat*B.
                 */
                uj0 = u[j + 0]; /* for D3 only -- note that u[j+...] change */
 8050e8b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050e8e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050e95:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050e98:	01 d0                	add    %edx,%eax
 8050e9a:	8b 38                	mov    (%eax),%edi
                uj1 = u[j + 1]; /* for D3 only */
 8050e9c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050e9f:	40                   	inc    %eax
 8050ea0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050eaa:	01 d0                	add    %edx,%eax
 8050eac:	8b 30                	mov    (%eax),%esi
                uj2 = u[j + 2]; /* for D3 only */
 8050eae:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050eb1:	83 c0 02             	add    $0x2,%eax
 8050eb4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050ebe:	01 d0                	add    %edx,%eax
 8050ec0:	8b 00                	mov    (%eax),%eax
 8050ec2:	89 c1                	mov    %eax,%ecx
                if (uj0 == v1) {
 8050ec4:	39 df                	cmp    %ebx,%edi
 8050ec6:	75 0c                	jne    8050ed4 <__qdivrem+0x3c3>
                        qhat = B;
 8050ec8:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
                        rhat = uj1;
 8050ecf:	89 75 e0             	mov    %esi,-0x20(%ebp)
                        goto qhat_too_big;
 8050ed2:	eb 26                	jmp    8050efa <__qdivrem+0x3e9>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
 8050ed4:	89 f8                	mov    %edi,%eax
 8050ed6:	c1 e0 10             	shl    $0x10,%eax
 8050ed9:	09 f0                	or     %esi,%eax
 8050edb:	89 45 ac             	mov    %eax,-0x54(%ebp)
                        qhat = nn / v1;
 8050ede:	8b 45 ac             	mov    -0x54(%ebp),%eax
 8050ee1:	ba 00 00 00 00       	mov    $0x0,%edx
 8050ee6:	f7 f3                	div    %ebx
 8050ee8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        rhat = nn % v1;
 8050eeb:	8b 45 ac             	mov    -0x54(%ebp),%eax
 8050eee:	ba 00 00 00 00       	mov    $0x0,%edx
 8050ef3:	f7 f3                	div    %ebx
 8050ef5:	89 55 e0             	mov    %edx,-0x20(%ebp)
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 8050ef8:	eb 0f                	jmp    8050f09 <__qdivrem+0x3f8>
qhat_too_big:
                        qhat--;
 8050efa:	ff 4d e4             	decl   -0x1c(%ebp)
                        if ((rhat += v1) >= B)
 8050efd:	01 5d e0             	add    %ebx,-0x20(%ebp)
 8050f00:	81 7d e0 ff ff 00 00 	cmpl   $0xffff,-0x20(%ebp)
 8050f07:	77 1a                	ja     8050f23 <__qdivrem+0x412>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
                        qhat = nn / v1;
                        rhat = nn % v1;
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 8050f09:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 8050f0f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 8050f13:	8b 55 e0             	mov    -0x20(%ebp),%edx
 8050f16:	c1 e2 10             	shl    $0x10,%edx
 8050f19:	89 cf                	mov    %ecx,%edi
 8050f1b:	09 fa                	or     %edi,%edx
 8050f1d:	39 d0                	cmp    %edx,%eax
 8050f1f:	77 d9                	ja     8050efa <__qdivrem+0x3e9>
 8050f21:	eb 01                	jmp    8050f24 <__qdivrem+0x413>
qhat_too_big:
                        qhat--;
                        if ((rhat += v1) >= B)
                                break;
 8050f23:	90                   	nop
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 8050f24:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8050f2b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050f2e:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8050f31:	eb 64                	jmp    8050f97 <__qdivrem+0x486>
                        t = u[i + j] - v[i] * qhat - t;
 8050f33:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8050f36:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050f39:	01 d0                	add    %edx,%eax
 8050f3b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050f45:	01 d0                	add    %edx,%eax
 8050f47:	8b 10                	mov    (%eax),%edx
 8050f49:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8050f4c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8050f53:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8050f56:	01 c8                	add    %ecx,%eax
 8050f58:	8b 00                	mov    (%eax),%eax
 8050f5a:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 8050f5e:	29 c2                	sub    %eax,%edx
 8050f60:	89 d0                	mov    %edx,%eax
 8050f62:	2b 45 dc             	sub    -0x24(%ebp),%eax
 8050f65:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        u[i + j] = LHALF(t);
 8050f68:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8050f6b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050f6e:	01 d0                	add    %edx,%eax
 8050f70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050f77:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050f7a:	01 c2                	add    %eax,%edx
 8050f7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050f7f:	0f b7 c0             	movzwl %ax,%eax
 8050f82:	89 02                	mov    %eax,(%edx)
                        t = (B - HHALF(t)) & (B - 1);
 8050f84:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050f87:	c1 e8 10             	shr    $0x10,%eax
 8050f8a:	f7 d8                	neg    %eax
 8050f8c:	25 ff ff 00 00       	and    $0xffff,%eax
 8050f91:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 8050f94:	ff 4d c8             	decl   -0x38(%ebp)
 8050f97:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 8050f9b:	7f 96                	jg     8050f33 <__qdivrem+0x422>
                        t = u[i + j] - v[i] * qhat - t;
                        u[i + j] = LHALF(t);
                        t = (B - HHALF(t)) & (B - 1);
                }
                t = u[j] - t;
 8050f9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050fa0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050fa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050faa:	01 d0                	add    %edx,%eax
 8050fac:	8b 00                	mov    (%eax),%eax
 8050fae:	2b 45 dc             	sub    -0x24(%ebp),%eax
 8050fb1:	89 45 dc             	mov    %eax,-0x24(%ebp)
                u[j] = LHALF(t);
 8050fb4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050fb7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050fbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050fc1:	01 c2                	add    %eax,%edx
 8050fc3:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050fc6:	0f b7 c0             	movzwl %ax,%eax
 8050fc9:	89 02                	mov    %eax,(%edx)
                 * D5: test remainder.
                 * There is a borrow if and only if HHALF(t) is nonzero;
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
 8050fcb:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8050fce:	c1 e8 10             	shr    $0x10,%eax
 8050fd1:	85 c0                	test   %eax,%eax
 8050fd3:	0f 84 91 00 00 00    	je     805106a <__qdivrem+0x559>
                        qhat--;
 8050fd9:	ff 4d e4             	decl   -0x1c(%ebp)
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 8050fdc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 8050fe3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8050fe6:	89 45 c8             	mov    %eax,-0x38(%ebp)
 8050fe9:	eb 4f                	jmp    805103a <__qdivrem+0x529>
                                t += u[i + j] + v[i];
 8050feb:	8b 55 c8             	mov    -0x38(%ebp),%edx
 8050fee:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8050ff1:	01 d0                	add    %edx,%eax
 8050ff3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8050ffa:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8050ffd:	01 d0                	add    %edx,%eax
 8050fff:	8b 10                	mov    (%eax),%edx
 8051001:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8051004:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 805100b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 805100e:	01 c8                	add    %ecx,%eax
 8051010:	8b 00                	mov    (%eax),%eax
 8051012:	01 d0                	add    %edx,%eax
 8051014:	01 45 dc             	add    %eax,-0x24(%ebp)
                                u[i + j] = LHALF(t);
 8051017:	8b 55 c8             	mov    -0x38(%ebp),%edx
 805101a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805101d:	01 d0                	add    %edx,%eax
 805101f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8051026:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8051029:	01 c2                	add    %eax,%edx
 805102b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 805102e:	0f b7 c0             	movzwl %ax,%eax
 8051031:	89 02                	mov    %eax,(%edx)
                                t = HHALF(t);
 8051033:	c1 6d dc 10          	shrl   $0x10,-0x24(%ebp)
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
                        qhat--;
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 8051037:	ff 4d c8             	decl   -0x38(%ebp)
 805103a:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 805103e:	7f ab                	jg     8050feb <__qdivrem+0x4da>
                                t += u[i + j] + v[i];
                                u[i + j] = LHALF(t);
                                t = HHALF(t);
                        }
                        u[j] = LHALF(u[j] + t);
 8051040:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8051043:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805104a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805104d:	01 c2                	add    %eax,%edx
 805104f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8051052:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8051059:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805105c:	01 c8                	add    %ecx,%eax
 805105e:	8b 08                	mov    (%eax),%ecx
 8051060:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8051063:	01 c8                	add    %ecx,%eax
 8051065:	0f b7 c0             	movzwl %ax,%eax
 8051068:	89 02                	mov    %eax,(%edx)
                }
                q[j] = qhat;
 805106a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 805106d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8051074:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8051077:	01 c2                	add    %eax,%edx
 8051079:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805107c:	89 02                	mov    %eax,(%edx)
        } while (++j <= m);             /* D7: loop on j. */
 805107e:	ff 45 cc             	incl   -0x34(%ebp)
 8051081:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8051084:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 8051087:	0f 8e fe fd ff ff    	jle    8050e8b <__qdivrem+0x37a>
        /*
         * If caller wants the remainder, we have to calculate it as
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
 805108d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 8051091:	0f 84 bd 00 00 00    	je     8051154 <__qdivrem+0x643>
                if (d) {
 8051097:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 805109b:	0f 84 85 00 00 00    	je     8051126 <__qdivrem+0x615>
                        for (i = m + n; i > m; --i)
 80510a1:	8b 55 d8             	mov    -0x28(%ebp),%edx
 80510a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 80510a7:	01 d0                	add    %edx,%eax
 80510a9:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80510ac:	eb 5b                	jmp    8051109 <__qdivrem+0x5f8>
                                u[i] = (u[i] >> d) |
 80510ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80510b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 80510b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80510bb:	01 c2                	add    %eax,%edx
 80510bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80510c0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 80510c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80510ca:	01 c8                	add    %ecx,%eax
 80510cc:	8b 18                	mov    (%eax),%ebx
 80510ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
 80510d1:	89 de                	mov    %ebx,%esi
 80510d3:	88 c1                	mov    %al,%cl
 80510d5:	d3 ee                	shr    %cl,%esi
                                       LHALF(u[i - 1] << (HALF_BITS - d));
 80510d7:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80510da:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
 80510df:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 80510e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80510e9:	01 c8                	add    %ecx,%eax
 80510eb:	8b 18                	mov    (%eax),%ebx
 80510ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
 80510f0:	b9 10 00 00 00       	mov    $0x10,%ecx
 80510f5:	29 c1                	sub    %eax,%ecx
 80510f7:	89 c8                	mov    %ecx,%eax
 80510f9:	88 c1                	mov    %al,%cl
 80510fb:	d3 e3                	shl    %cl,%ebx
 80510fd:	89 d8                	mov    %ebx,%eax
 80510ff:	0f b7 c0             	movzwl %ax,%eax
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
                                u[i] = (u[i] >> d) |
 8051102:	09 f0                	or     %esi,%eax
 8051104:	89 02                	mov    %eax,(%edx)
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
 8051106:	ff 4d c8             	decl   -0x38(%ebp)
 8051109:	8b 45 c8             	mov    -0x38(%ebp),%eax
 805110c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 805110f:	7f 9d                	jg     80510ae <__qdivrem+0x59d>
                                u[i] = (u[i] >> d) |
                                       LHALF(u[i - 1] << (HALF_BITS - d));
                        u[i] = 0;
 8051111:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8051114:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805111b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 805111e:	01 d0                	add    %edx,%eax
 8051120:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                }
                tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
 8051126:	8b 45 94             	mov    -0x6c(%ebp),%eax
 8051129:	c1 e0 10             	shl    $0x10,%eax
 805112c:	89 c2                	mov    %eax,%edx
 805112e:	8b 45 98             	mov    -0x68(%ebp),%eax
 8051131:	09 d0                	or     %edx,%eax
 8051133:	89 45 a8             	mov    %eax,-0x58(%ebp)
                tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
 8051136:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8051139:	c1 e0 10             	shl    $0x10,%eax
 805113c:	89 c2                	mov    %eax,%edx
 805113e:	8b 45 a0             	mov    -0x60(%ebp),%eax
 8051141:	09 d0                	or     %edx,%eax
 8051143:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                *arq = tmp.q;
 8051146:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8051149:	8b 55 a8             	mov    -0x58(%ebp),%edx
 805114c:	8b 4d 18             	mov    0x18(%ebp),%ecx
 805114f:	89 01                	mov    %eax,(%ecx)
 8051151:	89 51 04             	mov    %edx,0x4(%ecx)
        }

        tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
 8051154:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 805115a:	c1 e0 10             	shl    $0x10,%eax
 805115d:	89 c2                	mov    %eax,%edx
 805115f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 8051165:	09 d0                	or     %edx,%eax
 8051167:	89 45 a8             	mov    %eax,-0x58(%ebp)
        tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
 805116a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 8051170:	c1 e0 10             	shl    $0x10,%eax
 8051173:	89 c2                	mov    %eax,%edx
 8051175:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 805117b:	09 d0                	or     %edx,%eax
 805117d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        return (tmp.q);
 8051180:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8051183:	8b 55 a8             	mov    -0x58(%ebp),%edx
}
 8051186:	81 c4 b8 00 00 00    	add    $0xb8,%esp
 805118c:	5b                   	pop    %ebx
 805118d:	5e                   	pop    %esi
 805118e:	5f                   	pop    %edi
 805118f:	5d                   	pop    %ebp
 8051190:	c3                   	ret    

08051191 <__divdi3>:
/*
 * Divide two signed quads.
 * ??? if -1/2 should produce -1 on this machine, this code is wrong
 */
long long __divdi3(long long a, long long b)
{
 8051191:	55                   	push   %ebp
 8051192:	89 e5                	mov    %esp,%ebp
 8051194:	53                   	push   %ebx
 8051195:	83 ec 54             	sub    $0x54,%esp
 8051198:	e8 b8 cc ff ff       	call   804de55 <__x86.get_pc_thunk.cx>
 805119d:	81 c1 6f 67 00 00    	add    $0x676f,%ecx
 80511a3:	8b 45 08             	mov    0x8(%ebp),%eax
 80511a6:	89 45 d0             	mov    %eax,-0x30(%ebp)
 80511a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 80511ac:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80511af:	8b 45 10             	mov    0x10(%ebp),%eax
 80511b2:	89 45 c8             	mov    %eax,-0x38(%ebp)
 80511b5:	8b 45 14             	mov    0x14(%ebp),%eax
 80511b8:	89 45 cc             	mov    %eax,-0x34(%ebp)
        unsigned long long ua, ub, uq;
        int neg;

        if (a < 0)
 80511bb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 80511bf:	79 1c                	jns    80511dd <__divdi3+0x4c>
                ua = -(unsigned long long)a, neg = 1;
 80511c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
 80511c4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 80511c7:	f7 d8                	neg    %eax
 80511c9:	83 d2 00             	adc    $0x0,%edx
 80511cc:	f7 da                	neg    %edx
 80511ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
 80511d1:	89 55 f4             	mov    %edx,-0xc(%ebp)
 80511d4:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
 80511db:	eb 13                	jmp    80511f0 <__divdi3+0x5f>
        else
                ua = a, neg = 0;
 80511dd:	8b 45 d0             	mov    -0x30(%ebp),%eax
 80511e0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 80511e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 80511e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
 80511e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if (b < 0)
 80511f0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 80511f4:	79 19                	jns    805120f <__divdi3+0x7e>
                ub = -(unsigned long long)b, neg ^= 1;
 80511f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
 80511f9:	8b 55 cc             	mov    -0x34(%ebp),%edx
 80511fc:	f7 d8                	neg    %eax
 80511fe:	83 d2 00             	adc    $0x0,%edx
 8051201:	f7 da                	neg    %edx
 8051203:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8051206:	89 55 ec             	mov    %edx,-0x14(%ebp)
 8051209:	83 75 e4 01          	xorl   $0x1,-0x1c(%ebp)
 805120d:	eb 0c                	jmp    805121b <__divdi3+0x8a>
        else
                ub = b;
 805120f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 8051212:	8b 55 cc             	mov    -0x34(%ebp),%edx
 8051215:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8051218:	89 55 ec             	mov    %edx,-0x14(%ebp)
        uq = __qdivrem(ua, ub, (unsigned long long *)0);
 805121b:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 8051222:	00 
 8051223:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8051226:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8051229:	89 44 24 08          	mov    %eax,0x8(%esp)
 805122d:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8051231:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8051234:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8051237:	89 04 24             	mov    %eax,(%esp)
 805123a:	89 54 24 04          	mov    %edx,0x4(%esp)
 805123e:	89 cb                	mov    %ecx,%ebx
 8051240:	e8 cc f8 ff ff       	call   8050b11 <__qdivrem>
 8051245:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8051248:	89 55 dc             	mov    %edx,-0x24(%ebp)
        return (neg ? -uq : uq);
 805124b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 805124f:	74 0f                	je     8051260 <__divdi3+0xcf>
 8051251:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051254:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8051257:	f7 d8                	neg    %eax
 8051259:	83 d2 00             	adc    $0x0,%edx
 805125c:	f7 da                	neg    %edx
 805125e:	eb 06                	jmp    8051266 <__divdi3+0xd5>
 8051260:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051263:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
 8051266:	83 c4 54             	add    $0x54,%esp
 8051269:	5b                   	pop    %ebx
 805126a:	5d                   	pop    %ebp
 805126b:	c3                   	ret    

0805126c <__udivdi3>:
/*
 * Divide two unsigned quads.
 */
unsigned long long
__udivdi3(unsigned long long a, unsigned long long b)
{
 805126c:	55                   	push   %ebp
 805126d:	89 e5                	mov    %esp,%ebp
 805126f:	53                   	push   %ebx
 8051270:	83 ec 34             	sub    $0x34,%esp
 8051273:	e8 dd cb ff ff       	call   804de55 <__x86.get_pc_thunk.cx>
 8051278:	81 c1 94 66 00 00    	add    $0x6694,%ecx
 805127e:	8b 45 08             	mov    0x8(%ebp),%eax
 8051281:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051284:	8b 45 0c             	mov    0xc(%ebp),%eax
 8051287:	89 45 f4             	mov    %eax,-0xc(%ebp)
 805128a:	8b 45 10             	mov    0x10(%ebp),%eax
 805128d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 8051290:	8b 45 14             	mov    0x14(%ebp),%eax
 8051293:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (__qdivrem(a, b, (unsigned long long *)0));
 8051296:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 805129d:	00 
 805129e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 80512a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80512a4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80512a8:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80512ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80512af:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80512b2:	89 04 24             	mov    %eax,(%esp)
 80512b5:	89 54 24 04          	mov    %edx,0x4(%esp)
 80512b9:	89 cb                	mov    %ecx,%ebx
 80512bb:	e8 51 f8 ff ff       	call   8050b11 <__qdivrem>
}
 80512c0:	83 c4 34             	add    $0x34,%esp
 80512c3:	5b                   	pop    %ebx
 80512c4:	5d                   	pop    %ebp
 80512c5:	c3                   	ret    

080512c6 <__umoddi3>:
/*
 * Return remainder after dividing two unsigned quads.
 */
unsigned long long
__umoddi3(unsigned long long a, unsigned long long b)
{
 80512c6:	55                   	push   %ebp
 80512c7:	89 e5                	mov    %esp,%ebp
 80512c9:	53                   	push   %ebx
 80512ca:	83 ec 44             	sub    $0x44,%esp
 80512cd:	e8 83 cb ff ff       	call   804de55 <__x86.get_pc_thunk.cx>
 80512d2:	81 c1 3a 66 00 00    	add    $0x663a,%ecx
 80512d8:	8b 45 08             	mov    0x8(%ebp),%eax
 80512db:	89 45 e0             	mov    %eax,-0x20(%ebp)
 80512de:	8b 45 0c             	mov    0xc(%ebp),%eax
 80512e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80512e4:	8b 45 10             	mov    0x10(%ebp),%eax
 80512e7:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80512ea:	8b 45 14             	mov    0x14(%ebp),%eax
 80512ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
        unsigned long long r;

        (void)__qdivrem(a, b, &r);
 80512f0:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80512f3:	89 44 24 10          	mov    %eax,0x10(%esp)
 80512f7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80512fa:	8b 55 dc             	mov    -0x24(%ebp),%edx
 80512fd:	89 44 24 08          	mov    %eax,0x8(%esp)
 8051301:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8051305:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8051308:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 805130b:	89 04 24             	mov    %eax,(%esp)
 805130e:	89 54 24 04          	mov    %edx,0x4(%esp)
 8051312:	89 cb                	mov    %ecx,%ebx
 8051314:	e8 f8 f7 ff ff       	call   8050b11 <__qdivrem>
        return (r);
 8051319:	8b 45 f0             	mov    -0x10(%ebp),%eax
 805131c:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
 805131f:	83 c4 44             	add    $0x44,%esp
 8051322:	5b                   	pop    %ebx
 8051323:	5d                   	pop    %ebp
 8051324:	c3                   	ret    

08051325 <__tolower>:

#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
 8051325:	55                   	push   %ebp
 8051326:	89 e5                	mov    %esp,%ebp
 8051328:	83 ec 04             	sub    $0x4,%esp
 805132b:	e8 66 0a 00 00       	call   8051d96 <__x86.get_pc_thunk.dx>
 8051330:	81 c2 dc 65 00 00    	add    $0x65dc,%edx
 8051336:	8b 45 08             	mov    0x8(%ebp),%eax
 8051339:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (isupper(c))
 805133c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 8051340:	0f b6 84 02 54 00 00 	movzbl 0x54(%edx,%eax,1),%eax
 8051347:	00 
 8051348:	0f b6 c0             	movzbl %al,%eax
 805134b:	83 e0 01             	and    $0x1,%eax
 805134e:	85 c0                	test   %eax,%eax
 8051350:	74 04                	je     8051356 <__tolower+0x31>
                c -= 'A' - 'a';
 8051352:	80 45 fc 20          	addb   $0x20,-0x4(%ebp)
        return c;
 8051356:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 805135a:	c9                   	leave  
 805135b:	c3                   	ret    

0805135c <__toupper>:

static inline unsigned char __toupper(unsigned char c)
{
 805135c:	55                   	push   %ebp
 805135d:	89 e5                	mov    %esp,%ebp
 805135f:	83 ec 04             	sub    $0x4,%esp
 8051362:	e8 2f 0a 00 00       	call   8051d96 <__x86.get_pc_thunk.dx>
 8051367:	81 c2 a5 65 00 00    	add    $0x65a5,%edx
 805136d:	8b 45 08             	mov    0x8(%ebp),%eax
 8051370:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (islower(c))
 8051373:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 8051377:	0f b6 84 02 54 00 00 	movzbl 0x54(%edx,%eax,1),%eax
 805137e:	00 
 805137f:	0f b6 c0             	movzbl %al,%eax
 8051382:	83 e0 02             	and    $0x2,%eax
 8051385:	85 c0                	test   %eax,%eax
 8051387:	74 04                	je     805138d <__toupper+0x31>
                c -= 'a' - 'A';
 8051389:	80 6d fc 20          	subb   $0x20,-0x4(%ebp)
        return c;
 805138d:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 8051391:	c9                   	leave  
 8051392:	c3                   	ret    

08051393 <skip_atoi>:
#include "stddef.h"
#include "stdio.h"
#include "string.h"

static int skip_atoi(const char **s)
{
 8051393:	55                   	push   %ebp
 8051394:	89 e5                	mov    %esp,%ebp
 8051396:	56                   	push   %esi
 8051397:	53                   	push   %ebx
 8051398:	83 ec 10             	sub    $0x10,%esp
 805139b:	e8 b5 ca ff ff       	call   804de55 <__x86.get_pc_thunk.cx>
 80513a0:	81 c1 6c 65 00 00    	add    $0x656c,%ecx
        int i = 0;
 80513a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        while (isdigit(**s))
 80513ad:	eb 29                	jmp    80513d8 <skip_atoi+0x45>
                i = i * 10 + *((*s)++) - '0';
 80513af:	8b 55 f4             	mov    -0xc(%ebp),%edx
 80513b2:	89 d0                	mov    %edx,%eax
 80513b4:	c1 e0 02             	shl    $0x2,%eax
 80513b7:	01 d0                	add    %edx,%eax
 80513b9:	01 c0                	add    %eax,%eax
 80513bb:	89 c6                	mov    %eax,%esi
 80513bd:	8b 45 08             	mov    0x8(%ebp),%eax
 80513c0:	8b 00                	mov    (%eax),%eax
 80513c2:	8d 58 01             	lea    0x1(%eax),%ebx
 80513c5:	8b 55 08             	mov    0x8(%ebp),%edx
 80513c8:	89 1a                	mov    %ebx,(%edx)
 80513ca:	0f b6 00             	movzbl (%eax),%eax
 80513cd:	0f be c0             	movsbl %al,%eax
 80513d0:	01 f0                	add    %esi,%eax
 80513d2:	83 e8 30             	sub    $0x30,%eax
 80513d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

static int skip_atoi(const char **s)
{
        int i = 0;

        while (isdigit(**s))
 80513d8:	8b 45 08             	mov    0x8(%ebp),%eax
 80513db:	8b 00                	mov    (%eax),%eax
 80513dd:	0f b6 00             	movzbl (%eax),%eax
 80513e0:	0f b6 c0             	movzbl %al,%eax
 80513e3:	0f b6 84 01 54 00 00 	movzbl 0x54(%ecx,%eax,1),%eax
 80513ea:	00 
 80513eb:	0f b6 c0             	movzbl %al,%eax
 80513ee:	83 e0 04             	and    $0x4,%eax
 80513f1:	85 c0                	test   %eax,%eax
 80513f3:	75 ba                	jne    80513af <skip_atoi+0x1c>
                i = i * 10 + *((*s)++) - '0';
        return i;
 80513f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80513f8:	83 c4 10             	add    $0x10,%esp
 80513fb:	5b                   	pop    %ebx
 80513fc:	5e                   	pop    %esi
 80513fd:	5d                   	pop    %ebp
 80513fe:	c3                   	ret    

080513ff <number>:
#define LEFT    16              /* left justified */
#define SPECIAL 32              /* 0x */
#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */

static char *number(char *buf, char *end, long long num, int base, int size, int precision, int type)
{
 80513ff:	55                   	push   %ebp
 8051400:	89 e5                	mov    %esp,%ebp
 8051402:	57                   	push   %edi
 8051403:	56                   	push   %esi
 8051404:	53                   	push   %ebx
 8051405:	81 ec dc 00 00 00    	sub    $0xdc,%esp
 805140b:	e8 8a 09 00 00       	call   8051d9a <__x86.get_pc_thunk.si>
 8051410:	81 c6 fc 64 00 00    	add    $0x64fc,%esi
 8051416:	8b 45 10             	mov    0x10(%ebp),%eax
 8051419:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
 805141f:	8b 45 14             	mov    0x14(%ebp),%eax
 8051422:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
        char c, sign, tmp[66];
        const char *digits;
        const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 8051428:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 805142e:	8d 96 18 db ff ff    	lea    -0x24e8(%esi),%edx
 8051434:	bb 25 00 00 00       	mov    $0x25,%ebx
 8051439:	89 c1                	mov    %eax,%ecx
 805143b:	83 e1 01             	and    $0x1,%ecx
 805143e:	85 c9                	test   %ecx,%ecx
 8051440:	74 0c                	je     805144e <number+0x4f>
 8051442:	0f b6 0a             	movzbl (%edx),%ecx
 8051445:	88 08                	mov    %cl,(%eax)
 8051447:	8d 40 01             	lea    0x1(%eax),%eax
 805144a:	8d 52 01             	lea    0x1(%edx),%edx
 805144d:	4b                   	dec    %ebx
 805144e:	89 c1                	mov    %eax,%ecx
 8051450:	83 e1 02             	and    $0x2,%ecx
 8051453:	85 c9                	test   %ecx,%ecx
 8051455:	74 0f                	je     8051466 <number+0x67>
 8051457:	0f b7 0a             	movzwl (%edx),%ecx
 805145a:	66 89 08             	mov    %cx,(%eax)
 805145d:	8d 40 02             	lea    0x2(%eax),%eax
 8051460:	8d 52 02             	lea    0x2(%edx),%edx
 8051463:	83 eb 02             	sub    $0x2,%ebx
 8051466:	89 df                	mov    %ebx,%edi
 8051468:	83 e7 fc             	and    $0xfffffffc,%edi
 805146b:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%ebp)
 8051471:	b9 00 00 00 00       	mov    $0x0,%ecx
 8051476:	8b 3c 0a             	mov    (%edx,%ecx,1),%edi
 8051479:	89 3c 08             	mov    %edi,(%eax,%ecx,1)
 805147c:	83 c1 04             	add    $0x4,%ecx
 805147f:	3b 8d 2c ff ff ff    	cmp    -0xd4(%ebp),%ecx
 8051485:	72 ef                	jb     8051476 <number+0x77>
 8051487:	01 c8                	add    %ecx,%eax
 8051489:	01 ca                	add    %ecx,%edx
 805148b:	b9 00 00 00 00       	mov    $0x0,%ecx
 8051490:	89 df                	mov    %ebx,%edi
 8051492:	83 e7 02             	and    $0x2,%edi
 8051495:	85 ff                	test   %edi,%edi
 8051497:	74 0b                	je     80514a4 <number+0xa5>
 8051499:	0f b7 3c 0a          	movzwl (%edx,%ecx,1),%edi
 805149d:	66 89 3c 08          	mov    %di,(%eax,%ecx,1)
 80514a1:	83 c1 02             	add    $0x2,%ecx
 80514a4:	83 e3 01             	and    $0x1,%ebx
 80514a7:	85 db                	test   %ebx,%ebx
 80514a9:	74 07                	je     80514b2 <number+0xb3>
 80514ab:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
 80514af:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 80514b2:	8d 8d 40 ff ff ff    	lea    -0xc0(%ebp),%ecx
 80514b8:	8d 96 40 db ff ff    	lea    -0x24c0(%esi),%edx
 80514be:	b8 25 00 00 00       	mov    $0x25,%eax
 80514c3:	83 e0 fc             	and    $0xfffffffc,%eax
 80514c6:	89 c7                	mov    %eax,%edi
 80514c8:	b8 00 00 00 00       	mov    $0x0,%eax
 80514cd:	8b 9c 06 40 db ff ff 	mov    -0x24c0(%esi,%eax,1),%ebx
 80514d4:	89 9c 05 40 ff ff ff 	mov    %ebx,-0xc0(%ebp,%eax,1)
 80514db:	83 c0 04             	add    $0x4,%eax
 80514de:	39 f8                	cmp    %edi,%eax
 80514e0:	72 eb                	jb     80514cd <number+0xce>
 80514e2:	01 c1                	add    %eax,%ecx
 80514e4:	01 c2                	add    %eax,%edx
 80514e6:	0f b6 02             	movzbl (%edx),%eax
 80514e9:	88 01                	mov    %al,(%ecx)
        int i;

        digits = (type & LARGE) ? large_digits : small_digits;
 80514eb:	8b 45 24             	mov    0x24(%ebp),%eax
 80514ee:	83 e0 40             	and    $0x40,%eax
 80514f1:	85 c0                	test   %eax,%eax
 80514f3:	74 08                	je     80514fd <number+0xfe>
 80514f5:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 80514fb:	eb 06                	jmp    8051503 <number+0x104>
 80514fd:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 8051503:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (type & LEFT)
 8051506:	8b 45 24             	mov    0x24(%ebp),%eax
 8051509:	83 e0 10             	and    $0x10,%eax
 805150c:	85 c0                	test   %eax,%eax
 805150e:	74 04                	je     8051514 <number+0x115>
                type &= ~ZEROPAD;
 8051510:	83 65 24 fe          	andl   $0xfffffffe,0x24(%ebp)
        if (base < 2 || base > 36)
 8051514:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
 8051518:	7e 06                	jle    8051520 <number+0x121>
 805151a:	83 7d 18 24          	cmpl   $0x24,0x18(%ebp)
 805151e:	7e 08                	jle    8051528 <number+0x129>
                return buf;
 8051520:	8b 45 08             	mov    0x8(%ebp),%eax
 8051523:	e9 80 02 00 00       	jmp    80517a8 <number+0x3a9>
        c = (type & ZEROPAD) ? '0' : ' ';
 8051528:	8b 45 24             	mov    0x24(%ebp),%eax
 805152b:	83 e0 01             	and    $0x1,%eax
 805152e:	85 c0                	test   %eax,%eax
 8051530:	74 04                	je     8051536 <number+0x137>
 8051532:	b0 30                	mov    $0x30,%al
 8051534:	eb 02                	jmp    8051538 <number+0x139>
 8051536:	b0 20                	mov    $0x20,%al
 8051538:	88 45 d3             	mov    %al,-0x2d(%ebp)
        sign = 0;
 805153b:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
        if (type & SIGN) {
 805153f:	8b 45 24             	mov    0x24(%ebp),%eax
 8051542:	83 e0 02             	and    $0x2,%eax
 8051545:	85 c0                	test   %eax,%eax
 8051547:	74 49                	je     8051592 <number+0x193>
                if (num < 0) {
 8051549:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
 8051550:	79 1c                	jns    805156e <number+0x16f>
                        sign = '-';
 8051552:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
                        num = -num;
 8051556:	f7 9d 30 ff ff ff    	negl   -0xd0(%ebp)
 805155c:	83 95 34 ff ff ff 00 	adcl   $0x0,-0xcc(%ebp)
 8051563:	f7 9d 34 ff ff ff    	negl   -0xcc(%ebp)
                        size--;
 8051569:	ff 4d 1c             	decl   0x1c(%ebp)
 805156c:	eb 24                	jmp    8051592 <number+0x193>
                } else if (type & PLUS) {
 805156e:	8b 45 24             	mov    0x24(%ebp),%eax
 8051571:	83 e0 04             	and    $0x4,%eax
 8051574:	85 c0                	test   %eax,%eax
 8051576:	74 09                	je     8051581 <number+0x182>
                        sign = '+';
 8051578:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
                        size--;
 805157c:	ff 4d 1c             	decl   0x1c(%ebp)
 805157f:	eb 11                	jmp    8051592 <number+0x193>
                } else if (type & SPACE) {
 8051581:	8b 45 24             	mov    0x24(%ebp),%eax
 8051584:	83 e0 08             	and    $0x8,%eax
 8051587:	85 c0                	test   %eax,%eax
 8051589:	74 07                	je     8051592 <number+0x193>
                        sign = ' ';
 805158b:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
                        size--;
 805158f:	ff 4d 1c             	decl   0x1c(%ebp)
                }
        }
        if (type & SPECIAL) {
 8051592:	8b 45 24             	mov    0x24(%ebp),%eax
 8051595:	83 e0 20             	and    $0x20,%eax
 8051598:	85 c0                	test   %eax,%eax
 805159a:	74 15                	je     80515b1 <number+0x1b2>
                if (base == 16)
 805159c:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 80515a0:	75 06                	jne    80515a8 <number+0x1a9>
                        size -= 2;
 80515a2:	83 6d 1c 02          	subl   $0x2,0x1c(%ebp)
 80515a6:	eb 09                	jmp    80515b1 <number+0x1b2>
                else if (base == 8)
 80515a8:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 80515ac:	75 03                	jne    80515b1 <number+0x1b2>
                        size--;
 80515ae:	ff 4d 1c             	decl   0x1c(%ebp)
        }
        i = 0;
 80515b1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        if (num == 0) {
 80515b8:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
 80515be:	0b 85 30 ff ff ff    	or     -0xd0(%ebp),%eax
 80515c4:	85 c0                	test   %eax,%eax
 80515c6:	75 13                	jne    80515db <number+0x1dc>
                tmp[i++] = '0';
 80515c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 80515cb:	8d 50 01             	lea    0x1(%eax),%edx
 80515ce:	89 55 e0             	mov    %edx,-0x20(%ebp)
 80515d1:	c6 44 05 8a 30       	movb   $0x30,-0x76(%ebp,%eax,1)
 80515d6:	e9 89 00 00 00       	jmp    8051664 <number+0x265>
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
 80515db:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 80515e1:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 80515e7:	89 45 d8             	mov    %eax,-0x28(%ebp)
 80515ea:	89 55 dc             	mov    %edx,-0x24(%ebp)
                unsigned int base2 = (unsigned int)base;
 80515ed:	8b 45 18             	mov    0x18(%ebp),%eax
 80515f0:	89 45 cc             	mov    %eax,-0x34(%ebp)
                while (num2 != 0) {
 80515f3:	eb 65                	jmp    805165a <number+0x25b>
                        tmp[i++] = digits[num2 % base2];
 80515f5:	8b 7d e0             	mov    -0x20(%ebp),%edi
 80515f8:	8d 47 01             	lea    0x1(%edi),%eax
 80515fb:	89 45 e0             	mov    %eax,-0x20(%ebp)
 80515fe:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 8051601:	bb 00 00 00 00       	mov    $0x0,%ebx
 8051606:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051609:	8b 55 dc             	mov    -0x24(%ebp),%edx
 805160c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8051610:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8051614:	89 04 24             	mov    %eax,(%esp)
 8051617:	89 54 24 04          	mov    %edx,0x4(%esp)
 805161b:	89 f3                	mov    %esi,%ebx
 805161d:	e8 a4 fc ff ff       	call   80512c6 <__umoddi3>
 8051622:	89 c2                	mov    %eax,%edx
 8051624:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8051627:	01 d0                	add    %edx,%eax
 8051629:	0f b6 00             	movzbl (%eax),%eax
 805162c:	88 44 3d 8a          	mov    %al,-0x76(%ebp,%edi,1)
                        num2 /= base2;
 8051630:	8b 45 cc             	mov    -0x34(%ebp),%eax
 8051633:	ba 00 00 00 00       	mov    $0x0,%edx
 8051638:	89 44 24 08          	mov    %eax,0x8(%esp)
 805163c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8051640:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051643:	8b 55 dc             	mov    -0x24(%ebp),%edx
 8051646:	89 04 24             	mov    %eax,(%esp)
 8051649:	89 54 24 04          	mov    %edx,0x4(%esp)
 805164d:	89 f3                	mov    %esi,%ebx
 805164f:	e8 18 fc ff ff       	call   805126c <__udivdi3>
 8051654:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8051657:	89 55 dc             	mov    %edx,-0x24(%ebp)
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
                unsigned int base2 = (unsigned int)base;
                while (num2 != 0) {
 805165a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 805165d:	0b 45 d8             	or     -0x28(%ebp),%eax
 8051660:	85 c0                	test   %eax,%eax
 8051662:	75 91                	jne    80515f5 <number+0x1f6>
                        tmp[i++] = digits[num2 % base2];
                        num2 /= base2;
                }
        }
        if (i > precision)
 8051664:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8051667:	3b 45 20             	cmp    0x20(%ebp),%eax
 805166a:	7e 06                	jle    8051672 <number+0x273>
                precision = i;
 805166c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805166f:	89 45 20             	mov    %eax,0x20(%ebp)
        size -= precision;
 8051672:	8b 45 20             	mov    0x20(%ebp),%eax
 8051675:	29 45 1c             	sub    %eax,0x1c(%ebp)
        if (!(type & (ZEROPAD + LEFT))) {
 8051678:	8b 45 24             	mov    0x24(%ebp),%eax
 805167b:	83 e0 11             	and    $0x11,%eax
 805167e:	85 c0                	test   %eax,%eax
 8051680:	75 20                	jne    80516a2 <number+0x2a3>
                while (size-- > 0) {
 8051682:	eb 11                	jmp    8051695 <number+0x296>
                        if (buf <= end)
 8051684:	8b 45 08             	mov    0x8(%ebp),%eax
 8051687:	3b 45 0c             	cmp    0xc(%ebp),%eax
 805168a:	77 06                	ja     8051692 <number+0x293>
                                *buf = ' ';
 805168c:	8b 45 08             	mov    0x8(%ebp),%eax
 805168f:	c6 00 20             	movb   $0x20,(%eax)
                        ++buf;
 8051692:	ff 45 08             	incl   0x8(%ebp)
        }
        if (i > precision)
                precision = i;
        size -= precision;
        if (!(type & (ZEROPAD + LEFT))) {
                while (size-- > 0) {
 8051695:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8051698:	8d 50 ff             	lea    -0x1(%eax),%edx
 805169b:	89 55 1c             	mov    %edx,0x1c(%ebp)
 805169e:	85 c0                	test   %eax,%eax
 80516a0:	7f e2                	jg     8051684 <number+0x285>
                        if (buf <= end)
                                *buf = ' ';
                        ++buf;
                }
        }
        if (sign) {
 80516a2:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 80516a6:	74 14                	je     80516bc <number+0x2bd>
                if (buf <= end)
 80516a8:	8b 45 08             	mov    0x8(%ebp),%eax
 80516ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80516ae:	77 09                	ja     80516b9 <number+0x2ba>
                        *buf = sign;
 80516b0:	8b 45 08             	mov    0x8(%ebp),%eax
 80516b3:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
 80516b7:	88 10                	mov    %dl,(%eax)
                ++buf;
 80516b9:	ff 45 08             	incl   0x8(%ebp)
        }
        if (type & SPECIAL) {
 80516bc:	8b 45 24             	mov    0x24(%ebp),%eax
 80516bf:	83 e0 20             	and    $0x20,%eax
 80516c2:	85 c0                	test   %eax,%eax
 80516c4:	74 47                	je     805170d <number+0x30e>
                if (base == 8) {
 80516c6:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 80516ca:	75 13                	jne    80516df <number+0x2e0>
                        if (buf <= end)
 80516cc:	8b 45 08             	mov    0x8(%ebp),%eax
 80516cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80516d2:	77 06                	ja     80516da <number+0x2db>
                                *buf = '0';
 80516d4:	8b 45 08             	mov    0x8(%ebp),%eax
 80516d7:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 80516da:	ff 45 08             	incl   0x8(%ebp)
 80516dd:	eb 2e                	jmp    805170d <number+0x30e>
                } else if (base == 16) {
 80516df:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 80516e3:	75 28                	jne    805170d <number+0x30e>
                        if (buf <= end)
 80516e5:	8b 45 08             	mov    0x8(%ebp),%eax
 80516e8:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80516eb:	77 06                	ja     80516f3 <number+0x2f4>
                                *buf = '0';
 80516ed:	8b 45 08             	mov    0x8(%ebp),%eax
 80516f0:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 80516f3:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
 80516f6:	8b 45 08             	mov    0x8(%ebp),%eax
 80516f9:	3b 45 0c             	cmp    0xc(%ebp),%eax
 80516fc:	77 0c                	ja     805170a <number+0x30b>
                                *buf = digits[33];
 80516fe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8051701:	0f b6 50 21          	movzbl 0x21(%eax),%edx
 8051705:	8b 45 08             	mov    0x8(%ebp),%eax
 8051708:	88 10                	mov    %dl,(%eax)
                        ++buf;
 805170a:	ff 45 08             	incl   0x8(%ebp)
                }
        }
        if (!(type & LEFT)) {
 805170d:	8b 45 24             	mov    0x24(%ebp),%eax
 8051710:	83 e0 10             	and    $0x10,%eax
 8051713:	85 c0                	test   %eax,%eax
 8051715:	75 36                	jne    805174d <number+0x34e>
                while (size-- > 0) {
 8051717:	eb 14                	jmp    805172d <number+0x32e>
                        if (buf <= end)
 8051719:	8b 45 08             	mov    0x8(%ebp),%eax
 805171c:	3b 45 0c             	cmp    0xc(%ebp),%eax
 805171f:	77 09                	ja     805172a <number+0x32b>
                                *buf = c;
 8051721:	8b 45 08             	mov    0x8(%ebp),%eax
 8051724:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 8051728:	88 10                	mov    %dl,(%eax)
                        ++buf;
 805172a:	ff 45 08             	incl   0x8(%ebp)
                                *buf = digits[33];
                        ++buf;
                }
        }
        if (!(type & LEFT)) {
                while (size-- > 0) {
 805172d:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8051730:	8d 50 ff             	lea    -0x1(%eax),%edx
 8051733:	89 55 1c             	mov    %edx,0x1c(%ebp)
 8051736:	85 c0                	test   %eax,%eax
 8051738:	7f df                	jg     8051719 <number+0x31a>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 805173a:	eb 11                	jmp    805174d <number+0x34e>
                if (buf <= end)
 805173c:	8b 45 08             	mov    0x8(%ebp),%eax
 805173f:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8051742:	77 06                	ja     805174a <number+0x34b>
                        *buf = '0';
 8051744:	8b 45 08             	mov    0x8(%ebp),%eax
 8051747:	c6 00 30             	movb   $0x30,(%eax)
                ++buf;
 805174a:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 805174d:	8b 45 20             	mov    0x20(%ebp),%eax
 8051750:	8d 50 ff             	lea    -0x1(%eax),%edx
 8051753:	89 55 20             	mov    %edx,0x20(%ebp)
 8051756:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051759:	7f e1                	jg     805173c <number+0x33d>
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 805175b:	eb 1b                	jmp    8051778 <number+0x379>
                if (buf <= end)
 805175d:	8b 45 08             	mov    0x8(%ebp),%eax
 8051760:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8051763:	77 10                	ja     8051775 <number+0x376>
                        *buf = tmp[i];
 8051765:	8d 55 8a             	lea    -0x76(%ebp),%edx
 8051768:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805176b:	01 d0                	add    %edx,%eax
 805176d:	0f b6 10             	movzbl (%eax),%edx
 8051770:	8b 45 08             	mov    0x8(%ebp),%eax
 8051773:	88 10                	mov    %dl,(%eax)
                ++buf;
 8051775:	ff 45 08             	incl   0x8(%ebp)
        while (i < precision--) {
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 8051778:	8b 45 e0             	mov    -0x20(%ebp),%eax
 805177b:	8d 50 ff             	lea    -0x1(%eax),%edx
 805177e:	89 55 e0             	mov    %edx,-0x20(%ebp)
 8051781:	85 c0                	test   %eax,%eax
 8051783:	7f d8                	jg     805175d <number+0x35e>
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 8051785:	eb 11                	jmp    8051798 <number+0x399>
                if (buf <= end)
 8051787:	8b 45 08             	mov    0x8(%ebp),%eax
 805178a:	3b 45 0c             	cmp    0xc(%ebp),%eax
 805178d:	77 06                	ja     8051795 <number+0x396>
                        *buf = ' ';
 805178f:	8b 45 08             	mov    0x8(%ebp),%eax
 8051792:	c6 00 20             	movb   $0x20,(%eax)
                ++buf;
 8051795:	ff 45 08             	incl   0x8(%ebp)
        while (i-- > 0) {
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 8051798:	8b 45 1c             	mov    0x1c(%ebp),%eax
 805179b:	8d 50 ff             	lea    -0x1(%eax),%edx
 805179e:	89 55 1c             	mov    %edx,0x1c(%ebp)
 80517a1:	85 c0                	test   %eax,%eax
 80517a3:	7f e2                	jg     8051787 <number+0x388>
                if (buf <= end)
                        *buf = ' ';
                ++buf;
        }
        return buf;
 80517a5:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80517a8:	81 c4 dc 00 00 00    	add    $0xdc,%esp
 80517ae:	5b                   	pop    %ebx
 80517af:	5e                   	pop    %esi
 80517b0:	5f                   	pop    %edi
 80517b1:	5d                   	pop    %ebp
 80517b2:	c3                   	ret    

080517b3 <vsnprintf>:
*
* Call this function if you are already dealing with a va_list.
* You probably want snprintf instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
 80517b3:	55                   	push   %ebp
 80517b4:	89 e5                	mov    %esp,%ebp
 80517b6:	53                   	push   %ebx
 80517b7:	83 ec 64             	sub    $0x64,%esp
 80517ba:	e8 9a c6 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 80517bf:	81 c3 4d 61 00 00    	add    $0x614d,%ebx
                                   number of chars for from string */
        int qualifier;              /* 'h', 'l', or 'L' for integer fields */
        /* 'z' support added 23/7/1999 S.H.    */
        /* 'z' changed to 'Z' --davidm 1/25/99 */

        str = buf;
 80517c5:	8b 45 08             	mov    0x8(%ebp),%eax
 80517c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        end = buf + size - 1;
 80517cb:	8b 45 0c             	mov    0xc(%ebp),%eax
 80517ce:	8d 50 ff             	lea    -0x1(%eax),%edx
 80517d1:	8b 45 08             	mov    0x8(%ebp),%eax
 80517d4:	01 d0                	add    %edx,%eax
 80517d6:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (end < buf - 1) {
 80517d9:	8b 45 08             	mov    0x8(%ebp),%eax
 80517dc:	48                   	dec    %eax
 80517dd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 80517e0:	0f 86 76 05 00 00    	jbe    8051d5c <.L138+0x116>
                end = ((void *) - 1);
 80517e6:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
                size = end - buf + 1;
 80517ed:	8b 55 e0             	mov    -0x20(%ebp),%edx
 80517f0:	8b 45 08             	mov    0x8(%ebp),%eax
 80517f3:	29 c2                	sub    %eax,%edx
 80517f5:	89 d0                	mov    %edx,%eax
 80517f7:	40                   	inc    %eax
 80517f8:	89 45 0c             	mov    %eax,0xc(%ebp)
        }

        for (; *fmt ; ++fmt) {
 80517fb:	e9 5c 05 00 00       	jmp    8051d5c <.L138+0x116>
                if (*fmt != '%') {
 8051800:	8b 45 10             	mov    0x10(%ebp),%eax
 8051803:	0f b6 00             	movzbl (%eax),%eax
 8051806:	3c 25                	cmp    $0x25,%al
 8051808:	74 1b                	je     8051825 <vsnprintf+0x72>
                        if (str <= end)
 805180a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805180d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051810:	77 0b                	ja     805181d <vsnprintf+0x6a>
                                *str = *fmt;
 8051812:	8b 45 10             	mov    0x10(%ebp),%eax
 8051815:	0f b6 10             	movzbl (%eax),%edx
 8051818:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 805181b:	88 10                	mov    %dl,(%eax)
                        ++str;
 805181d:	ff 45 e4             	incl   -0x1c(%ebp)
                        continue;
 8051820:	e9 30 05 00 00       	jmp    8051d55 <.L138+0x10f>
                }

                /* process flags */
                flags = 0;
 8051825:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
repeat:
                ++fmt;          /* this also skips first '%' */
 805182c:	8b 45 10             	mov    0x10(%ebp),%eax
 805182f:	40                   	inc    %eax
 8051830:	89 45 10             	mov    %eax,0x10(%ebp)
                switch (*fmt) {
 8051833:	8b 45 10             	mov    0x10(%ebp),%eax
 8051836:	0f b6 00             	movzbl (%eax),%eax
 8051839:	0f be c0             	movsbl %al,%eax
 805183c:	83 e8 20             	sub    $0x20,%eax
 805183f:	83 f8 10             	cmp    $0x10,%eax
 8051842:	77 2c                	ja     8051870 <.L70>
 8051844:	c1 e0 02             	shl    $0x2,%eax
 8051847:	8b 84 18 6c db ff ff 	mov    -0x2494(%eax,%ebx,1),%eax
 805184e:	01 d8                	add    %ebx,%eax
 8051850:	ff e0                	jmp    *%eax

08051852 <.L75>:
                        case '-': flags |= LEFT; goto repeat;
 8051852:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
 8051856:	eb d4                	jmp    805182c <vsnprintf+0x79>

08051858 <.L74>:
                        case '+': flags |= PLUS; goto repeat;
 8051858:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
 805185c:	eb ce                	jmp    805182c <vsnprintf+0x79>

0805185e <.L71>:
                        case ' ': flags |= SPACE; goto repeat;
 805185e:	83 4d d8 08          	orl    $0x8,-0x28(%ebp)
 8051862:	eb c8                	jmp    805182c <vsnprintf+0x79>

08051864 <.L73>:
                        case '#': flags |= SPECIAL; goto repeat;
 8051864:	83 4d d8 20          	orl    $0x20,-0x28(%ebp)
 8051868:	eb c2                	jmp    805182c <vsnprintf+0x79>

0805186a <.L76>:
                        case '0': flags |= ZEROPAD; goto repeat;
 805186a:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
 805186e:	eb bc                	jmp    805182c <vsnprintf+0x79>

08051870 <.L70>:
                }

                /* get field width */
                field_width = -1;
 8051870:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
                if (isdigit(*fmt))
 8051877:	8b 45 10             	mov    0x10(%ebp),%eax
 805187a:	0f b6 00             	movzbl (%eax),%eax
 805187d:	0f b6 c0             	movzbl %al,%eax
 8051880:	0f b6 84 03 54 00 00 	movzbl 0x54(%ebx,%eax,1),%eax
 8051887:	00 
 8051888:	0f b6 c0             	movzbl %al,%eax
 805188b:	83 e0 04             	and    $0x4,%eax
 805188e:	85 c0                	test   %eax,%eax
 8051890:	74 10                	je     80518a2 <.L70+0x32>
                        field_width = skip_atoi(&fmt);
 8051892:	8d 45 10             	lea    0x10(%ebp),%eax
 8051895:	89 04 24             	mov    %eax,(%esp)
 8051898:	e8 f6 fa ff ff       	call   8051393 <skip_atoi>
 805189d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 80518a0:	eb 2c                	jmp    80518ce <.L70+0x5e>
                else if (*fmt == '*') {
 80518a2:	8b 45 10             	mov    0x10(%ebp),%eax
 80518a5:	0f b6 00             	movzbl (%eax),%eax
 80518a8:	3c 2a                	cmp    $0x2a,%al
 80518aa:	75 22                	jne    80518ce <.L70+0x5e>
                        ++fmt;
 80518ac:	8b 45 10             	mov    0x10(%ebp),%eax
 80518af:	40                   	inc    %eax
 80518b0:	89 45 10             	mov    %eax,0x10(%ebp)
                        /* it's the next argument */
                        field_width = va_arg(args, int);
 80518b3:	8b 45 14             	mov    0x14(%ebp),%eax
 80518b6:	8d 50 04             	lea    0x4(%eax),%edx
 80518b9:	89 55 14             	mov    %edx,0x14(%ebp)
 80518bc:	8b 00                	mov    (%eax),%eax
 80518be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                        if (field_width < 0) {
 80518c1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 80518c5:	79 07                	jns    80518ce <.L70+0x5e>
                                field_width = -field_width;
 80518c7:	f7 5d d4             	negl   -0x2c(%ebp)
                                flags |= LEFT;
 80518ca:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
                        }
                }

                /* get the precision */
                precision = -1;
 80518ce:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
                if (*fmt == '.') {
 80518d5:	8b 45 10             	mov    0x10(%ebp),%eax
 80518d8:	0f b6 00             	movzbl (%eax),%eax
 80518db:	3c 2e                	cmp    $0x2e,%al
 80518dd:	75 5e                	jne    805193d <.L70+0xcd>
                        ++fmt;
 80518df:	8b 45 10             	mov    0x10(%ebp),%eax
 80518e2:	40                   	inc    %eax
 80518e3:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (isdigit(*fmt))
 80518e6:	8b 45 10             	mov    0x10(%ebp),%eax
 80518e9:	0f b6 00             	movzbl (%eax),%eax
 80518ec:	0f b6 c0             	movzbl %al,%eax
 80518ef:	0f b6 84 03 54 00 00 	movzbl 0x54(%ebx,%eax,1),%eax
 80518f6:	00 
 80518f7:	0f b6 c0             	movzbl %al,%eax
 80518fa:	83 e0 04             	and    $0x4,%eax
 80518fd:	85 c0                	test   %eax,%eax
 80518ff:	74 10                	je     8051911 <.L70+0xa1>
                                precision = skip_atoi(&fmt);
 8051901:	8d 45 10             	lea    0x10(%ebp),%eax
 8051904:	89 04 24             	mov    %eax,(%esp)
 8051907:	e8 87 fa ff ff       	call   8051393 <skip_atoi>
 805190c:	89 45 d0             	mov    %eax,-0x30(%ebp)
 805190f:	eb 1f                	jmp    8051930 <.L70+0xc0>
                        else if (*fmt == '*') {
 8051911:	8b 45 10             	mov    0x10(%ebp),%eax
 8051914:	0f b6 00             	movzbl (%eax),%eax
 8051917:	3c 2a                	cmp    $0x2a,%al
 8051919:	75 15                	jne    8051930 <.L70+0xc0>
                                ++fmt;
 805191b:	8b 45 10             	mov    0x10(%ebp),%eax
 805191e:	40                   	inc    %eax
 805191f:	89 45 10             	mov    %eax,0x10(%ebp)
                                /* it's the next argument */
                                precision = va_arg(args, int);
 8051922:	8b 45 14             	mov    0x14(%ebp),%eax
 8051925:	8d 50 04             	lea    0x4(%eax),%edx
 8051928:	89 55 14             	mov    %edx,0x14(%ebp)
 805192b:	8b 00                	mov    (%eax),%eax
 805192d:	89 45 d0             	mov    %eax,-0x30(%ebp)
                        }
                        if (precision < 0)
 8051930:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 8051934:	79 07                	jns    805193d <.L70+0xcd>
                                precision = 0;
 8051936:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
                }

                /* get the conversion qualifier */
                qualifier = -1;
 805193d:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
 8051944:	8b 45 10             	mov    0x10(%ebp),%eax
 8051947:	0f b6 00             	movzbl (%eax),%eax
 805194a:	3c 68                	cmp    $0x68,%al
 805194c:	74 1e                	je     805196c <.L70+0xfc>
 805194e:	8b 45 10             	mov    0x10(%ebp),%eax
 8051951:	0f b6 00             	movzbl (%eax),%eax
 8051954:	3c 6c                	cmp    $0x6c,%al
 8051956:	74 14                	je     805196c <.L70+0xfc>
 8051958:	8b 45 10             	mov    0x10(%ebp),%eax
 805195b:	0f b6 00             	movzbl (%eax),%eax
 805195e:	3c 4c                	cmp    $0x4c,%al
 8051960:	74 0a                	je     805196c <.L70+0xfc>
 8051962:	8b 45 10             	mov    0x10(%ebp),%eax
 8051965:	0f b6 00             	movzbl (%eax),%eax
 8051968:	3c 5a                	cmp    $0x5a,%al
 805196a:	75 31                	jne    805199d <.L70+0x12d>
                        qualifier = *fmt;
 805196c:	8b 45 10             	mov    0x10(%ebp),%eax
 805196f:	0f b6 00             	movzbl (%eax),%eax
 8051972:	0f be c0             	movsbl %al,%eax
 8051975:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        ++fmt;
 8051978:	8b 45 10             	mov    0x10(%ebp),%eax
 805197b:	40                   	inc    %eax
 805197c:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (qualifier == 'l' && *fmt == 'l') {
 805197f:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8051983:	75 18                	jne    805199d <.L70+0x12d>
 8051985:	8b 45 10             	mov    0x10(%ebp),%eax
 8051988:	0f b6 00             	movzbl (%eax),%eax
 805198b:	3c 6c                	cmp    $0x6c,%al
 805198d:	75 0e                	jne    805199d <.L70+0x12d>
                                qualifier = 'L';
 805198f:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                                ++fmt;
 8051996:	8b 45 10             	mov    0x10(%ebp),%eax
 8051999:	40                   	inc    %eax
 805199a:	89 45 10             	mov    %eax,0x10(%ebp)
                        }
                }
                if (*fmt == 'q') {
 805199d:	8b 45 10             	mov    0x10(%ebp),%eax
 80519a0:	0f b6 00             	movzbl (%eax),%eax
 80519a3:	3c 71                	cmp    $0x71,%al
 80519a5:	75 0e                	jne    80519b5 <.L70+0x145>
                        qualifier = 'L';
 80519a7:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                        ++fmt;
 80519ae:	8b 45 10             	mov    0x10(%ebp),%eax
 80519b1:	40                   	inc    %eax
 80519b2:	89 45 10             	mov    %eax,0x10(%ebp)
                }

                /* default base */
                base = 10;
 80519b5:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)

                switch (*fmt) {
 80519bc:	8b 45 10             	mov    0x10(%ebp),%eax
 80519bf:	0f b6 00             	movzbl (%eax),%eax
 80519c2:	0f be c0             	movsbl %al,%eax
 80519c5:	83 e8 25             	sub    $0x25,%eax
 80519c8:	83 f8 53             	cmp    $0x53,%eax
 80519cb:	0f 87 33 02 00 00    	ja     8051c04 <.L85>
 80519d1:	c1 e0 02             	shl    $0x2,%eax
 80519d4:	8b 84 18 b0 db ff ff 	mov    -0x2450(%eax,%ebx,1),%eax
 80519db:	01 d8                	add    %ebx,%eax
 80519dd:	ff e0                	jmp    *%eax

080519df <.L90>:
                        case 'c':
                                if (!(flags & LEFT)) {
 80519df:	8b 45 d8             	mov    -0x28(%ebp),%eax
 80519e2:	83 e0 10             	and    $0x10,%eax
 80519e5:	85 c0                	test   %eax,%eax
 80519e7:	75 1c                	jne    8051a05 <.L90+0x26>
                                        while (--field_width > 0) {
 80519e9:	eb 11                	jmp    80519fc <.L90+0x1d>
                                                if (str <= end)
 80519eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80519ee:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 80519f1:	77 06                	ja     80519f9 <.L90+0x1a>
                                                        *str = ' ';
 80519f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 80519f6:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 80519f9:	ff 45 e4             	incl   -0x1c(%ebp)
                base = 10;

                switch (*fmt) {
                        case 'c':
                                if (!(flags & LEFT)) {
                                        while (--field_width > 0) {
 80519fc:	ff 4d d4             	decl   -0x2c(%ebp)
 80519ff:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8051a03:	7f e6                	jg     80519eb <.L90+0xc>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                c = (unsigned char) va_arg(args, int);
 8051a05:	8b 45 14             	mov    0x14(%ebp),%eax
 8051a08:	8d 50 04             	lea    0x4(%eax),%edx
 8051a0b:	89 55 14             	mov    %edx,0x14(%ebp)
 8051a0e:	8b 00                	mov    (%eax),%eax
 8051a10:	88 45 cb             	mov    %al,-0x35(%ebp)
                                if (str <= end)
 8051a13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a16:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051a19:	77 09                	ja     8051a24 <.L90+0x45>
                                        *str = c;
 8051a1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a1e:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
 8051a22:	88 10                	mov    %dl,(%eax)
                                ++str;
 8051a24:	ff 45 e4             	incl   -0x1c(%ebp)
                                while (--field_width > 0) {
 8051a27:	eb 11                	jmp    8051a3a <.L90+0x5b>
                                        if (str <= end)
 8051a29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a2c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051a2f:	77 06                	ja     8051a37 <.L90+0x58>
                                                *str = ' ';
 8051a31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a34:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 8051a37:	ff 45 e4             	incl   -0x1c(%ebp)
                                }
                                c = (unsigned char) va_arg(args, int);
                                if (str <= end)
                                        *str = c;
                                ++str;
                                while (--field_width > 0) {
 8051a3a:	ff 4d d4             	decl   -0x2c(%ebp)
 8051a3d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 8051a41:	7f e6                	jg     8051a29 <.L90+0x4a>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 8051a43:	e9 0d 03 00 00       	jmp    8051d55 <.L138+0x10f>

08051a48 <.L95>:

                        case 's':
                                s = va_arg(args, char *);
 8051a48:	8b 45 14             	mov    0x14(%ebp),%eax
 8051a4b:	8d 50 04             	lea    0x4(%eax),%edx
 8051a4e:	89 55 14             	mov    %edx,0x14(%ebp)
 8051a51:	8b 00                	mov    (%eax),%eax
 8051a53:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                if (!s)
 8051a56:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 8051a5a:	75 09                	jne    8051a65 <.L95+0x1d>
                                        s = "<NULL>";
 8051a5c:	8d 83 65 db ff ff    	lea    -0x249b(%ebx),%eax
 8051a62:	89 45 dc             	mov    %eax,-0x24(%ebp)

                                len = strnlen(s, precision);
 8051a65:	8b 45 d0             	mov    -0x30(%ebp),%eax
 8051a68:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051a6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8051a6f:	89 04 24             	mov    %eax,(%esp)
 8051a72:	e8 cc c5 ff ff       	call   804e043 <strnlen>
 8051a77:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if (!(flags & LEFT)) {
 8051a7a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051a7d:	83 e0 10             	and    $0x10,%eax
 8051a80:	85 c0                	test   %eax,%eax
 8051a82:	75 21                	jne    8051aa5 <.L95+0x5d>
                                        while (len < field_width--) {
 8051a84:	eb 11                	jmp    8051a97 <.L95+0x4f>
                                                if (str <= end)
 8051a86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a89:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051a8c:	77 06                	ja     8051a94 <.L95+0x4c>
                                                        *str = ' ';
 8051a8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051a91:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 8051a94:	ff 45 e4             	incl   -0x1c(%ebp)
                                        s = "<NULL>";

                                len = strnlen(s, precision);

                                if (!(flags & LEFT)) {
                                        while (len < field_width--) {
 8051a97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8051a9a:	8d 50 ff             	lea    -0x1(%eax),%edx
 8051a9d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 8051aa0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8051aa3:	7f e1                	jg     8051a86 <.L95+0x3e>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 8051aa5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 8051aac:	eb 1c                	jmp    8051aca <.L95+0x82>
                                        if (str <= end)
 8051aae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051ab1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051ab4:	77 0b                	ja     8051ac1 <.L95+0x79>
                                                *str = *s;
 8051ab6:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8051ab9:	0f b6 10             	movzbl (%eax),%edx
 8051abc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051abf:	88 10                	mov    %dl,(%eax)
                                        ++str; ++s;
 8051ac1:	ff 45 e4             	incl   -0x1c(%ebp)
 8051ac4:	ff 45 dc             	incl   -0x24(%ebp)
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 8051ac7:	ff 45 ec             	incl   -0x14(%ebp)
 8051aca:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8051acd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8051ad0:	7c dc                	jl     8051aae <.L95+0x66>
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 8051ad2:	eb 11                	jmp    8051ae5 <.L95+0x9d>
                                        if (str <= end)
 8051ad4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051ad7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051ada:	77 06                	ja     8051ae2 <.L95+0x9a>
                                                *str = ' ';
 8051adc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051adf:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 8051ae2:	ff 45 e4             	incl   -0x1c(%ebp)
                                for (i = 0; i < len; ++i) {
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 8051ae5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 8051ae8:	8d 50 ff             	lea    -0x1(%eax),%edx
 8051aeb:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 8051aee:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 8051af1:	7f e1                	jg     8051ad4 <.L95+0x8c>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 8051af3:	e9 5d 02 00 00       	jmp    8051d55 <.L138+0x10f>

08051af8 <.L94>:

                        case 'p':
                                if (field_width == -1) {
 8051af8:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
 8051afc:	75 0b                	jne    8051b09 <.L94+0x11>
                                        field_width = 2 * sizeof(void *);
 8051afe:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                                        flags |= ZEROPAD;
 8051b05:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
                                }
                                str = number(str, end,
                                             (unsigned long) va_arg(args, void *),
 8051b09:	8b 45 14             	mov    0x14(%ebp),%eax
 8051b0c:	8d 50 04             	lea    0x4(%eax),%edx
 8051b0f:	89 55 14             	mov    %edx,0x14(%ebp)
 8051b12:	8b 00                	mov    (%eax),%eax
                        case 'p':
                                if (field_width == -1) {
                                        field_width = 2 * sizeof(void *);
                                        flags |= ZEROPAD;
                                }
                                str = number(str, end,
 8051b14:	ba 00 00 00 00       	mov    $0x0,%edx
 8051b19:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8051b1c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8051b20:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 8051b23:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8051b27:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8051b2a:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 8051b2e:	c7 44 24 10 10 00 00 	movl   $0x10,0x10(%esp)
 8051b35:	00 
 8051b36:	89 44 24 08          	mov    %eax,0x8(%esp)
 8051b3a:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8051b3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8051b41:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051b45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051b48:	89 04 24             	mov    %eax,(%esp)
 8051b4b:	e8 af f8 ff ff       	call   80513ff <number>
 8051b50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                                             (unsigned long) va_arg(args, void *),
                                             16, field_width, precision, flags);
                                continue;
 8051b53:	e9 fd 01 00 00       	jmp    8051d55 <.L138+0x10f>

08051b58 <.L92>:


                        case 'n':
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
 8051b58:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8051b5c:	75 20                	jne    8051b7e <.L92+0x26>
                                        long *ip = va_arg(args, long *);
 8051b5e:	8b 45 14             	mov    0x14(%ebp),%eax
 8051b61:	8d 50 04             	lea    0x4(%eax),%edx
 8051b64:	89 55 14             	mov    %edx,0x14(%ebp)
 8051b67:	8b 00                	mov    (%eax),%eax
 8051b69:	89 45 c0             	mov    %eax,-0x40(%ebp)
                                        *ip = (str - buf);
 8051b6c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051b6f:	8b 45 08             	mov    0x8(%ebp),%eax
 8051b72:	29 c2                	sub    %eax,%edx
 8051b74:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8051b77:	89 10                	mov    %edx,(%eax)
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 8051b79:	e9 d7 01 00 00       	jmp    8051d55 <.L138+0x10f>
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
                                        long *ip = va_arg(args, long *);
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
 8051b7e:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 8051b82:	75 24                	jne    8051ba8 <.L92+0x50>
                                        size_t *ip = va_arg(args, size_t *);
 8051b84:	8b 45 14             	mov    0x14(%ebp),%eax
 8051b87:	8d 50 04             	lea    0x4(%eax),%edx
 8051b8a:	89 55 14             	mov    %edx,0x14(%ebp)
 8051b8d:	8b 00                	mov    (%eax),%eax
 8051b8f:	89 45 bc             	mov    %eax,-0x44(%ebp)
                                        *ip = (str - buf);
 8051b92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051b95:	8b 45 08             	mov    0x8(%ebp),%eax
 8051b98:	29 c2                	sub    %eax,%edx
 8051b9a:	89 d0                	mov    %edx,%eax
 8051b9c:	89 c2                	mov    %eax,%edx
 8051b9e:	8b 45 bc             	mov    -0x44(%ebp),%eax
 8051ba1:	89 10                	mov    %edx,(%eax)
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 8051ba3:	e9 ad 01 00 00       	jmp    8051d55 <.L138+0x10f>
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
                                        size_t *ip = va_arg(args, size_t *);
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
 8051ba8:	8b 45 14             	mov    0x14(%ebp),%eax
 8051bab:	8d 50 04             	lea    0x4(%eax),%edx
 8051bae:	89 55 14             	mov    %edx,0x14(%ebp)
 8051bb1:	8b 00                	mov    (%eax),%eax
 8051bb3:	89 45 b8             	mov    %eax,-0x48(%ebp)
                                        *ip = (str - buf);
 8051bb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051bb9:	8b 45 08             	mov    0x8(%ebp),%eax
 8051bbc:	29 c2                	sub    %eax,%edx
 8051bbe:	8b 45 b8             	mov    -0x48(%ebp),%eax
 8051bc1:	89 10                	mov    %edx,(%eax)
                                }
                                continue;
 8051bc3:	e9 8d 01 00 00       	jmp    8051d55 <.L138+0x10f>

08051bc8 <.L86>:

                        case '%':
                                if (str <= end)
 8051bc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051bcb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051bce:	77 06                	ja     8051bd6 <.L86+0xe>
                                        *str = '%';
 8051bd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051bd3:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 8051bd6:	ff 45 e4             	incl   -0x1c(%ebp)
                                continue;
 8051bd9:	e9 77 01 00 00       	jmp    8051d55 <.L138+0x10f>

08051bde <.L93>:

                                /* integer number formats - set up the flags and "break" */
                        case 'o':
                                base = 8;
 8051bde:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
                                break;
 8051be5:	eb 60                	jmp    8051c47 <.L138+0x1>

08051be7 <.L89>:

                        case 'X':
                                flags |= LARGE;
 8051be7:	83 4d d8 40          	orl    $0x40,-0x28(%ebp)

08051beb <.L97>:
                        case 'x':
                                base = 16;
 8051beb:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)
                                break;
 8051bf2:	eb 53                	jmp    8051c47 <.L138+0x1>

08051bf4 <.L91>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
 8051bf4:	83 4d d8 02          	orl    $0x2,-0x28(%ebp)
                        case 'u':
                                break;
 8051bf8:	eb 4c                	jmp    8051c46 <.L138>

08051bfa <.L88>:
                                /* Added - TODO - alvin */
                        case 'f':
                        case 'F':
                        case 'g':
                        case 'G':
                                return -1;
 8051bfa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8051bff:	e9 8c 01 00 00       	jmp    8051d90 <.L138+0x14a>

08051c04 <.L85>:


                        default:
                                if (str <= end)
 8051c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051c07:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051c0a:	77 06                	ja     8051c12 <.L85+0xe>
                                        *str = '%';
 8051c0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051c0f:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 8051c12:	ff 45 e4             	incl   -0x1c(%ebp)
                                if (*fmt) {
 8051c15:	8b 45 10             	mov    0x10(%ebp),%eax
 8051c18:	0f b6 00             	movzbl (%eax),%eax
 8051c1b:	84 c0                	test   %al,%al
 8051c1d:	74 1b                	je     8051c3a <.L85+0x36>
                                        if (str <= end)
 8051c1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051c22:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051c25:	77 0b                	ja     8051c32 <.L85+0x2e>
                                                *str = *fmt;
 8051c27:	8b 45 10             	mov    0x10(%ebp),%eax
 8051c2a:	0f b6 10             	movzbl (%eax),%edx
 8051c2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051c30:	88 10                	mov    %dl,(%eax)
                                        ++str;
 8051c32:	ff 45 e4             	incl   -0x1c(%ebp)
                                } else {
                                        --fmt;
                                }
                                continue;
 8051c35:	e9 1b 01 00 00       	jmp    8051d55 <.L138+0x10f>
                                if (*fmt) {
                                        if (str <= end)
                                                *str = *fmt;
                                        ++str;
                                } else {
                                        --fmt;
 8051c3a:	8b 45 10             	mov    0x10(%ebp),%eax
 8051c3d:	48                   	dec    %eax
 8051c3e:	89 45 10             	mov    %eax,0x10(%ebp)
                                }
                                continue;
 8051c41:	e9 0f 01 00 00       	jmp    8051d55 <.L138+0x10f>

08051c46 <.L138>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
                        case 'u':
                                break;
 8051c46:	90                   	nop
                                } else {
                                        --fmt;
                                }
                                continue;
                }
                if (qualifier == 'L')
 8051c47:	83 7d cc 4c          	cmpl   $0x4c,-0x34(%ebp)
 8051c4b:	75 19                	jne    8051c66 <.L138+0x20>
                        num = va_arg(args, long long);
 8051c4d:	8b 45 14             	mov    0x14(%ebp),%eax
 8051c50:	8d 50 08             	lea    0x8(%eax),%edx
 8051c53:	89 55 14             	mov    %edx,0x14(%ebp)
 8051c56:	8b 50 04             	mov    0x4(%eax),%edx
 8051c59:	8b 00                	mov    (%eax),%eax
 8051c5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051c5e:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8051c61:	e9 b0 00 00 00       	jmp    8051d16 <.L138+0xd0>
                else if (qualifier == 'l') {
 8051c66:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 8051c6a:	75 2f                	jne    8051c9b <.L138+0x55>
                        num = va_arg(args, unsigned long);
 8051c6c:	8b 45 14             	mov    0x14(%ebp),%eax
 8051c6f:	8d 50 04             	lea    0x4(%eax),%edx
 8051c72:	89 55 14             	mov    %edx,0x14(%ebp)
 8051c75:	8b 00                	mov    (%eax),%eax
 8051c77:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051c7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8051c81:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051c84:	83 e0 02             	and    $0x2,%eax
 8051c87:	85 c0                	test   %eax,%eax
 8051c89:	0f 84 87 00 00 00    	je     8051d16 <.L138+0xd0>
                                num = (signed long) num;
 8051c8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8051c92:	99                   	cltd   
 8051c93:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051c96:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8051c99:	eb 7b                	jmp    8051d16 <.L138+0xd0>
                } else if (qualifier == 'Z') {
 8051c9b:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 8051c9f:	75 17                	jne    8051cb8 <.L138+0x72>
                        num = va_arg(args, size_t);
 8051ca1:	8b 45 14             	mov    0x14(%ebp),%eax
 8051ca4:	8d 50 04             	lea    0x4(%eax),%edx
 8051ca7:	89 55 14             	mov    %edx,0x14(%ebp)
 8051caa:	8b 00                	mov    (%eax),%eax
 8051cac:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051caf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8051cb6:	eb 5e                	jmp    8051d16 <.L138+0xd0>
                } else if (qualifier == 'h') {
 8051cb8:	83 7d cc 68          	cmpl   $0x68,-0x34(%ebp)
 8051cbc:	75 2f                	jne    8051ced <.L138+0xa7>
                        num = (unsigned short) va_arg(args, int);
 8051cbe:	8b 45 14             	mov    0x14(%ebp),%eax
 8051cc1:	8d 50 04             	lea    0x4(%eax),%edx
 8051cc4:	89 55 14             	mov    %edx,0x14(%ebp)
 8051cc7:	8b 00                	mov    (%eax),%eax
 8051cc9:	0f b7 c0             	movzwl %ax,%eax
 8051ccc:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051ccf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8051cd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051cd9:	83 e0 02             	and    $0x2,%eax
 8051cdc:	85 c0                	test   %eax,%eax
 8051cde:	74 36                	je     8051d16 <.L138+0xd0>
                                num = (signed short) num;
 8051ce0:	0f bf 45 f0          	movswl -0x10(%ebp),%eax
 8051ce4:	99                   	cltd   
 8051ce5:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051ce8:	89 55 f4             	mov    %edx,-0xc(%ebp)
 8051ceb:	eb 29                	jmp    8051d16 <.L138+0xd0>
                } else {
                        num = va_arg(args, unsigned int);
 8051ced:	8b 45 14             	mov    0x14(%ebp),%eax
 8051cf0:	8d 50 04             	lea    0x4(%eax),%edx
 8051cf3:	89 55 14             	mov    %edx,0x14(%ebp)
 8051cf6:	8b 00                	mov    (%eax),%eax
 8051cf8:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051cfb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 8051d02:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8051d05:	83 e0 02             	and    $0x2,%eax
 8051d08:	85 c0                	test   %eax,%eax
 8051d0a:	74 0a                	je     8051d16 <.L138+0xd0>
                                num = (signed int) num;
 8051d0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8051d0f:	99                   	cltd   
 8051d10:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8051d13:	89 55 f4             	mov    %edx,-0xc(%ebp)
                }

                str = number(str, end, num, base,
 8051d16:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8051d19:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8051d1c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 8051d1f:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8051d23:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 8051d26:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8051d2a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 8051d2d:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 8051d31:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 8051d34:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 8051d38:	89 44 24 08          	mov    %eax,0x8(%esp)
 8051d3c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8051d40:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8051d43:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051d47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051d4a:	89 04 24             	mov    %eax,(%esp)
 8051d4d:	e8 ad f6 ff ff       	call   80513ff <number>
 8051d52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (end < buf - 1) {
                end = ((void *) - 1);
                size = end - buf + 1;
        }

        for (; *fmt ; ++fmt) {
 8051d55:	8b 45 10             	mov    0x10(%ebp),%eax
 8051d58:	40                   	inc    %eax
 8051d59:	89 45 10             	mov    %eax,0x10(%ebp)
 8051d5c:	8b 45 10             	mov    0x10(%ebp),%eax
 8051d5f:	0f b6 00             	movzbl (%eax),%eax
 8051d62:	84 c0                	test   %al,%al
 8051d64:	0f 85 96 fa ff ff    	jne    8051800 <vsnprintf+0x4d>
                }

                str = number(str, end, num, base,
                             field_width, precision, flags);
        }
        if (str <= end)
 8051d6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051d6d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 8051d70:	77 08                	ja     8051d7a <.L138+0x134>
                *str = '\0';
 8051d72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8051d75:	c6 00 00             	movb   $0x0,(%eax)
 8051d78:	eb 0c                	jmp    8051d86 <.L138+0x140>
        else if (size > 0)
 8051d7a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8051d7e:	74 06                	je     8051d86 <.L138+0x140>
                /* don't write out a null byte if the buf size is zero */
                *end = '\0';
 8051d80:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8051d83:	c6 00 00             	movb   $0x0,(%eax)
        /* the trailing null byte doesn't count towards the total
         * ++str;
         */
        return str - buf;
 8051d86:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 8051d89:	8b 45 08             	mov    0x8(%ebp),%eax
 8051d8c:	29 c2                	sub    %eax,%edx
 8051d8e:	89 d0                	mov    %edx,%eax
}
 8051d90:	83 c4 64             	add    $0x64,%esp
 8051d93:	5b                   	pop    %ebx
 8051d94:	5d                   	pop    %ebp
 8051d95:	c3                   	ret    

08051d96 <__x86.get_pc_thunk.dx>:
 8051d96:	8b 14 24             	mov    (%esp),%edx
 8051d99:	c3                   	ret    

08051d9a <__x86.get_pc_thunk.si>:
 8051d9a:	8b 34 24             	mov    (%esp),%esi
 8051d9d:	c3                   	ret    

08051d9e <test_init>:
static test_pass_func_t _pass_func = _default_test_pass;
static test_fail_func_t _fail_func = _default_test_fail;

void
test_init(void)
{
 8051d9e:	55                   	push   %ebp
 8051d9f:	89 e5                	mov    %esp,%ebp
 8051da1:	53                   	push   %ebx
 8051da2:	83 ec 34             	sub    $0x34,%esp
 8051da5:	e8 af c0 ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 8051daa:	81 c3 62 5b 00 00    	add    $0x5b62,%ebx
        int zfd = -1;
 8051db0:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)

        if (0 > (zfd = open("/dev/zero", O_RDWR, 0))) {
 8051db7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8051dbe:	00 
 8051dbf:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 8051dc6:	00 
 8051dc7:	8d 83 00 dd ff ff    	lea    -0x2300(%ebx),%eax
 8051dcd:	89 04 24             	mov    %eax,(%esp)
 8051dd0:	e8 f7 b7 ff ff       	call   804d5cc <open>
 8051dd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
 8051dd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8051ddc:	79 27                	jns    8051e05 <test_init+0x67>
                printf("test_init: open(\"/dev/zero\"): %s\n", strerror(errno));
 8051dde:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 8051de4:	8b 00                	mov    (%eax),%eax
 8051de6:	89 04 24             	mov    %eax,(%esp)
 8051de9:	e8 6a c5 ff ff       	call   804e358 <strerror>
 8051dee:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051df2:	8d 83 0c dd ff ff    	lea    -0x22f4(%ebx),%eax
 8051df8:	89 04 24             	mov    %eax,(%esp)
 8051dfb:	e8 a0 ea ff ff       	call   80508a0 <printf>
                goto failed;
 8051e00:	e9 b6 00 00 00       	jmp    8051ebb <test_init+0x11d>
        }

        if (MAP_FAILED == (_test_data = mmap(NULL, sizeof(*_test_data), PROT_READ | PROT_WRITE, MAP_SHARED, zfd, 0))) {
 8051e05:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8051e0c:	00 
 8051e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8051e10:	89 44 24 10          	mov    %eax,0x10(%esp)
 8051e14:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 8051e1b:	00 
 8051e1c:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 8051e23:	00 
 8051e24:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
 8051e2b:	00 
 8051e2c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8051e33:	e8 a8 b6 ff ff       	call   804d4e0 <mmap>
 8051e38:	89 83 b8 02 00 00    	mov    %eax,0x2b8(%ebx)
 8051e3e:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051e44:	83 f8 ff             	cmp    $0xffffffff,%eax
 8051e47:	75 24                	jne    8051e6d <test_init+0xcf>
                printf("test_init: mmap(\"/dev/zero\"): %s\n", strerror(errno));
 8051e49:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 8051e4f:	8b 00                	mov    (%eax),%eax
 8051e51:	89 04 24             	mov    %eax,(%esp)
 8051e54:	e8 ff c4 ff ff       	call   804e358 <strerror>
 8051e59:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051e5d:	8d 83 30 dd ff ff    	lea    -0x22d0(%ebx),%eax
 8051e63:	89 04 24             	mov    %eax,(%esp)
 8051e66:	e8 35 ea ff ff       	call   80508a0 <printf>
                goto failed;
 8051e6b:	eb 4e                	jmp    8051ebb <test_init+0x11d>
        }

        if (0 > close(zfd)) {
 8051e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8051e70:	89 04 24             	mov    %eax,(%esp)
 8051e73:	e8 ab b8 ff ff       	call   804d723 <close>
 8051e78:	85 c0                	test   %eax,%eax
 8051e7a:	79 24                	jns    8051ea0 <test_init+0x102>
                printf("test_init: close(\"/dev/zero\"): %s\n", strerror(errno));
 8051e7c:	8d 05 c8 7b 05 08    	lea    0x8057bc8,%eax
 8051e82:	8b 00                	mov    (%eax),%eax
 8051e84:	89 04 24             	mov    %eax,(%esp)
 8051e87:	e8 cc c4 ff ff       	call   804e358 <strerror>
 8051e8c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051e90:	8d 83 54 dd ff ff    	lea    -0x22ac(%ebx),%eax
 8051e96:	89 04 24             	mov    %eax,(%esp)
 8051e99:	e8 02 ea ff ff       	call   80508a0 <printf>
                goto failed;
 8051e9e:	eb 1b                	jmp    8051ebb <test_init+0x11d>
        }

        _test_data->td_passed = 0;
 8051ea0:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051ea6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        _test_data->td_failed = 0;
 8051eac:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051eb2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        return;
 8051eb9:	eb 1a                	jmp    8051ed5 <test_init+0x137>

failed:
        printf("could not initialize testing library, exiting\n");
 8051ebb:	8d 83 78 dd ff ff    	lea    -0x2288(%ebx),%eax
 8051ec1:	89 04 24             	mov    %eax,(%esp)
 8051ec4:	e8 d7 e9 ff ff       	call   80508a0 <printf>
        exit(-1);
 8051ec9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 8051ed0:	e8 19 b4 ff ff       	call   804d2ee <exit>
}
 8051ed5:	83 c4 34             	add    $0x34,%esp
 8051ed8:	5b                   	pop    %ebx
 8051ed9:	5d                   	pop    %ebp
 8051eda:	c3                   	ret    

08051edb <test_fini>:

void
test_fini(const char *name)
{
 8051edb:	55                   	push   %ebp
 8051edc:	89 e5                	mov    %esp,%ebp
 8051ede:	53                   	push   %ebx
 8051edf:	83 ec 14             	sub    $0x14,%esp
 8051ee2:	e8 72 bf ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 8051ee7:	81 c3 25 5a 00 00    	add    $0x5a25,%ebx
        if (NULL == name) {
 8051eed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8051ef1:	75 45                	jne    8051f38 <test_fini+0x5d>
                printf("tests completed:\n");
 8051ef3:	8d 83 a7 dd ff ff    	lea    -0x2259(%ebx),%eax
 8051ef9:	89 04 24             	mov    %eax,(%esp)
 8051efc:	e8 9f e9 ff ff       	call   80508a0 <printf>
                printf("%d passed\n", _test_data->td_passed);
 8051f01:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051f07:	8b 00                	mov    (%eax),%eax
 8051f09:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051f0d:	8d 83 b9 dd ff ff    	lea    -0x2247(%ebx),%eax
 8051f13:	89 04 24             	mov    %eax,(%esp)
 8051f16:	e8 85 e9 ff ff       	call   80508a0 <printf>
                printf("%d failed\n", _test_data->td_failed);
 8051f1b:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051f21:	8b 40 04             	mov    0x4(%eax),%eax
 8051f24:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051f28:	8d 83 c4 dd ff ff    	lea    -0x223c(%ebx),%eax
 8051f2e:	89 04 24             	mov    %eax,(%esp)
 8051f31:	e8 6a e9 ff ff       	call   80508a0 <printf>
        } else {
                printf("%s subtests completed, ", name);
                printf("%d passed and ", _test_data->td_passed);
                printf("%d failed so far\n", _test_data->td_failed);
        }
}
 8051f36:	eb 4a                	jmp    8051f82 <test_fini+0xa7>
        if (NULL == name) {
                printf("tests completed:\n");
                printf("%d passed\n", _test_data->td_passed);
                printf("%d failed\n", _test_data->td_failed);
        } else {
                printf("%s subtests completed, ", name);
 8051f38:	8b 45 08             	mov    0x8(%ebp),%eax
 8051f3b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051f3f:	8d 83 cf dd ff ff    	lea    -0x2231(%ebx),%eax
 8051f45:	89 04 24             	mov    %eax,(%esp)
 8051f48:	e8 53 e9 ff ff       	call   80508a0 <printf>
                printf("%d passed and ", _test_data->td_passed);
 8051f4d:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051f53:	8b 00                	mov    (%eax),%eax
 8051f55:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051f59:	8d 83 e7 dd ff ff    	lea    -0x2219(%ebx),%eax
 8051f5f:	89 04 24             	mov    %eax,(%esp)
 8051f62:	e8 39 e9 ff ff       	call   80508a0 <printf>
                printf("%d failed so far\n", _test_data->td_failed);
 8051f67:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8051f6d:	8b 40 04             	mov    0x4(%eax),%eax
 8051f70:	89 44 24 04          	mov    %eax,0x4(%esp)
 8051f74:	8d 83 f6 dd ff ff    	lea    -0x220a(%ebx),%eax
 8051f7a:	89 04 24             	mov    %eax,(%esp)
 8051f7d:	e8 1e e9 ff ff       	call   80508a0 <printf>
        }
}
 8051f82:	90                   	nop
 8051f83:	83 c4 14             	add    $0x14,%esp
 8051f86:	5b                   	pop    %ebx
 8051f87:	5d                   	pop    %ebp
 8051f88:	c3                   	ret    

08051f89 <test_errstr>:

const char *
test_errstr(int err)
{
 8051f89:	55                   	push   %ebp
 8051f8a:	89 e5                	mov    %esp,%ebp
 8051f8c:	e8 c0 be ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 8051f91:	05 7b 59 00 00       	add    $0x597b,%eax
        switch (err) {
 8051f96:	83 7d 08 28          	cmpl   $0x28,0x8(%ebp)
 8051f9a:	0f 87 99 01 00 00    	ja     8052139 <.L12>
 8051fa0:	8b 55 08             	mov    0x8(%ebp),%edx
 8051fa3:	c1 e2 02             	shl    $0x2,%edx
 8051fa6:	8b 94 02 28 df ff ff 	mov    -0x20d8(%edx,%eax,1),%edx
 8051fad:	01 c2                	add    %eax,%edx
 8051faf:	ff e2                	jmp    *%edx

08051fb1 <.L13>:
                case 1:
                        return "EPERM";
 8051fb1:	8d 80 08 de ff ff    	lea    -0x21f8(%eax),%eax
 8051fb7:	e9 83 01 00 00       	jmp    805213f <.L12+0x6>

08051fbc <.L15>:
                case 2:
                        return "ENOENT";
 8051fbc:	8d 80 0e de ff ff    	lea    -0x21f2(%eax),%eax
 8051fc2:	e9 78 01 00 00       	jmp    805213f <.L12+0x6>

08051fc7 <.L16>:
                case 3:
                        return "ESRCH";
 8051fc7:	8d 80 15 de ff ff    	lea    -0x21eb(%eax),%eax
 8051fcd:	e9 6d 01 00 00       	jmp    805213f <.L12+0x6>

08051fd2 <.L17>:
                case 4:
                        return "EINTR";
 8051fd2:	8d 80 1b de ff ff    	lea    -0x21e5(%eax),%eax
 8051fd8:	e9 62 01 00 00       	jmp    805213f <.L12+0x6>

08051fdd <.L18>:
                case 5:
                        return "EIO";
 8051fdd:	8d 80 21 de ff ff    	lea    -0x21df(%eax),%eax
 8051fe3:	e9 57 01 00 00       	jmp    805213f <.L12+0x6>

08051fe8 <.L19>:
                case 6:
                        return "ENXIO";
 8051fe8:	8d 80 25 de ff ff    	lea    -0x21db(%eax),%eax
 8051fee:	e9 4c 01 00 00       	jmp    805213f <.L12+0x6>

08051ff3 <.L20>:
                case 7:
                        return "E2BIG";
 8051ff3:	8d 80 2b de ff ff    	lea    -0x21d5(%eax),%eax
 8051ff9:	e9 41 01 00 00       	jmp    805213f <.L12+0x6>

08051ffe <.L21>:
                case 8:
                        return "ENOEXEC";
 8051ffe:	8d 80 31 de ff ff    	lea    -0x21cf(%eax),%eax
 8052004:	e9 36 01 00 00       	jmp    805213f <.L12+0x6>

08052009 <.L22>:
                case 9:
                        return "EBADF";
 8052009:	8d 80 39 de ff ff    	lea    -0x21c7(%eax),%eax
 805200f:	e9 2b 01 00 00       	jmp    805213f <.L12+0x6>

08052014 <.L23>:
                case 10:
                        return "ECHILD";
 8052014:	8d 80 3f de ff ff    	lea    -0x21c1(%eax),%eax
 805201a:	e9 20 01 00 00       	jmp    805213f <.L12+0x6>

0805201f <.L24>:
                case 11:
                        return "EAGAIN";
 805201f:	8d 80 46 de ff ff    	lea    -0x21ba(%eax),%eax
 8052025:	e9 15 01 00 00       	jmp    805213f <.L12+0x6>

0805202a <.L25>:
                case 12:
                        return "ENOMEM";
 805202a:	8d 80 4d de ff ff    	lea    -0x21b3(%eax),%eax
 8052030:	e9 0a 01 00 00       	jmp    805213f <.L12+0x6>

08052035 <.L26>:
                case 13:
                        return "EACCES";
 8052035:	8d 80 54 de ff ff    	lea    -0x21ac(%eax),%eax
 805203b:	e9 ff 00 00 00       	jmp    805213f <.L12+0x6>

08052040 <.L27>:
                case 14:
                        return "EFAULT";
 8052040:	8d 80 5b de ff ff    	lea    -0x21a5(%eax),%eax
 8052046:	e9 f4 00 00 00       	jmp    805213f <.L12+0x6>

0805204b <.L28>:
                case 15:
                        return "ENOTBLK";
 805204b:	8d 80 62 de ff ff    	lea    -0x219e(%eax),%eax
 8052051:	e9 e9 00 00 00       	jmp    805213f <.L12+0x6>

08052056 <.L29>:
                case 16:
                        return "EBUSY";
 8052056:	8d 80 6a de ff ff    	lea    -0x2196(%eax),%eax
 805205c:	e9 de 00 00 00       	jmp    805213f <.L12+0x6>

08052061 <.L30>:
                case 17:
                        return "EEXIST";
 8052061:	8d 80 70 de ff ff    	lea    -0x2190(%eax),%eax
 8052067:	e9 d3 00 00 00       	jmp    805213f <.L12+0x6>

0805206c <.L31>:
                case 18:
                        return "EXDEV";
 805206c:	8d 80 77 de ff ff    	lea    -0x2189(%eax),%eax
 8052072:	e9 c8 00 00 00       	jmp    805213f <.L12+0x6>

08052077 <.L32>:
                case 19:
                        return "ENODEV";
 8052077:	8d 80 7d de ff ff    	lea    -0x2183(%eax),%eax
 805207d:	e9 bd 00 00 00       	jmp    805213f <.L12+0x6>

08052082 <.L33>:
                case 20:
                        return "ENOTDIR";
 8052082:	8d 80 84 de ff ff    	lea    -0x217c(%eax),%eax
 8052088:	e9 b2 00 00 00       	jmp    805213f <.L12+0x6>

0805208d <.L34>:
                case 21:
                        return "EISDIR";
 805208d:	8d 80 8c de ff ff    	lea    -0x2174(%eax),%eax
 8052093:	e9 a7 00 00 00       	jmp    805213f <.L12+0x6>

08052098 <.L35>:
                case 22:
                        return "EINVAL";
 8052098:	8d 80 93 de ff ff    	lea    -0x216d(%eax),%eax
 805209e:	e9 9c 00 00 00       	jmp    805213f <.L12+0x6>

080520a3 <.L36>:
                case 23:
                        return "ENFILE";
 80520a3:	8d 80 9a de ff ff    	lea    -0x2166(%eax),%eax
 80520a9:	e9 91 00 00 00       	jmp    805213f <.L12+0x6>

080520ae <.L37>:
                case 24:
                        return "EMFILE";
 80520ae:	8d 80 a1 de ff ff    	lea    -0x215f(%eax),%eax
 80520b4:	e9 86 00 00 00       	jmp    805213f <.L12+0x6>

080520b9 <.L38>:
                case 25:
                        return "ENOTTY";
 80520b9:	8d 80 a8 de ff ff    	lea    -0x2158(%eax),%eax
 80520bf:	eb 7e                	jmp    805213f <.L12+0x6>

080520c1 <.L39>:
                case 26:
                        return "ETXTBSY";
 80520c1:	8d 80 af de ff ff    	lea    -0x2151(%eax),%eax
 80520c7:	eb 76                	jmp    805213f <.L12+0x6>

080520c9 <.L40>:
                case 27:
                        return "EFBIG";
 80520c9:	8d 80 b7 de ff ff    	lea    -0x2149(%eax),%eax
 80520cf:	eb 6e                	jmp    805213f <.L12+0x6>

080520d1 <.L41>:
                case 28:
                        return "ENOSPC";
 80520d1:	8d 80 bd de ff ff    	lea    -0x2143(%eax),%eax
 80520d7:	eb 66                	jmp    805213f <.L12+0x6>

080520d9 <.L42>:
                case 29:
                        return "ESPIPE";
 80520d9:	8d 80 c4 de ff ff    	lea    -0x213c(%eax),%eax
 80520df:	eb 5e                	jmp    805213f <.L12+0x6>

080520e1 <.L43>:
                case 30:
                        return "EROFS";
 80520e1:	8d 80 cb de ff ff    	lea    -0x2135(%eax),%eax
 80520e7:	eb 56                	jmp    805213f <.L12+0x6>

080520e9 <.L44>:
                case 31:
                        return "EMLINK";
 80520e9:	8d 80 d1 de ff ff    	lea    -0x212f(%eax),%eax
 80520ef:	eb 4e                	jmp    805213f <.L12+0x6>

080520f1 <.L45>:
                case 32:
                        return "EPIPE";
 80520f1:	8d 80 d8 de ff ff    	lea    -0x2128(%eax),%eax
 80520f7:	eb 46                	jmp    805213f <.L12+0x6>

080520f9 <.L46>:
                case 33:
                        return "EDOM";
 80520f9:	8d 80 de de ff ff    	lea    -0x2122(%eax),%eax
 80520ff:	eb 3e                	jmp    805213f <.L12+0x6>

08052101 <.L47>:
                case 34:
                        return "ERANGE";
 8052101:	8d 80 e3 de ff ff    	lea    -0x211d(%eax),%eax
 8052107:	eb 36                	jmp    805213f <.L12+0x6>

08052109 <.L48>:
                case 35:
                        return "EDEADLK";
 8052109:	8d 80 ea de ff ff    	lea    -0x2116(%eax),%eax
 805210f:	eb 2e                	jmp    805213f <.L12+0x6>

08052111 <.L49>:
                case 36:
                        return "ENAMETOOLONG";
 8052111:	8d 80 f2 de ff ff    	lea    -0x210e(%eax),%eax
 8052117:	eb 26                	jmp    805213f <.L12+0x6>

08052119 <.L50>:
                case 37:
                        return "ENOLCK";
 8052119:	8d 80 ff de ff ff    	lea    -0x2101(%eax),%eax
 805211f:	eb 1e                	jmp    805213f <.L12+0x6>

08052121 <.L51>:
                case 38:
                        return "ENOSYS";
 8052121:	8d 80 06 df ff ff    	lea    -0x20fa(%eax),%eax
 8052127:	eb 16                	jmp    805213f <.L12+0x6>

08052129 <.L52>:
                case 39:
                        return "ENOTEMPTY";
 8052129:	8d 80 0d df ff ff    	lea    -0x20f3(%eax),%eax
 805212f:	eb 0e                	jmp    805213f <.L12+0x6>

08052131 <.L53>:
                case 40:
                        return "ELOOP";
 8052131:	8d 80 17 df ff ff    	lea    -0x20e9(%eax),%eax
 8052137:	eb 06                	jmp    805213f <.L12+0x6>

08052139 <.L12>:
                default:
                        return "UNKNOWN";
 8052139:	8d 80 1d df ff ff    	lea    -0x20e3(%eax),%eax
        }
}
 805213f:	5d                   	pop    %ebp
 8052140:	c3                   	ret    

08052141 <_default_test_fail>:

static void
_default_test_fail(const char *file, int line, const char *name, const char *fmt, va_list args)
{
 8052141:	55                   	push   %ebp
 8052142:	89 e5                	mov    %esp,%ebp
 8052144:	53                   	push   %ebx
 8052145:	83 ec 14             	sub    $0x14,%esp
 8052148:	e8 0c bd ff ff       	call   804de59 <__x86.get_pc_thunk.bx>
 805214d:	81 c3 bf 57 00 00    	add    $0x57bf,%ebx
        _test_data->td_failed++;
 8052153:	8b 83 b8 02 00 00    	mov    0x2b8(%ebx),%eax
 8052159:	8b 50 04             	mov    0x4(%eax),%edx
 805215c:	42                   	inc    %edx
 805215d:	89 50 04             	mov    %edx,0x4(%eax)
        if (NULL == fmt) {
 8052160:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
 8052164:	75 25                	jne    805218b <_default_test_fail+0x4a>
                printf("FAILED: %s(%d): %s\n", file, line, name);
 8052166:	8b 45 10             	mov    0x10(%ebp),%eax
 8052169:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805216d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8052170:	89 44 24 08          	mov    %eax,0x8(%esp)
 8052174:	8b 45 08             	mov    0x8(%ebp),%eax
 8052177:	89 44 24 04          	mov    %eax,0x4(%esp)
 805217b:	8d 83 cc df ff ff    	lea    -0x2034(%ebx),%eax
 8052181:	89 04 24             	mov    %eax,(%esp)
 8052184:	e8 17 e7 ff ff       	call   80508a0 <printf>
        } else {
                printf("FAILED: %s(%d): %s: ", file, line, name);
                vprintf(fmt, args);
                printf("\n");
        }
}
 8052189:	eb 43                	jmp    80521ce <_default_test_fail+0x8d>
{
        _test_data->td_failed++;
        if (NULL == fmt) {
                printf("FAILED: %s(%d): %s\n", file, line, name);
        } else {
                printf("FAILED: %s(%d): %s: ", file, line, name);
 805218b:	8b 45 10             	mov    0x10(%ebp),%eax
 805218e:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8052192:	8b 45 0c             	mov    0xc(%ebp),%eax
 8052195:	89 44 24 08          	mov    %eax,0x8(%esp)
 8052199:	8b 45 08             	mov    0x8(%ebp),%eax
 805219c:	89 44 24 04          	mov    %eax,0x4(%esp)
 80521a0:	8d 83 e0 df ff ff    	lea    -0x2020(%ebx),%eax
 80521a6:	89 04 24             	mov    %eax,(%esp)
 80521a9:	e8 f2 e6 ff ff       	call   80508a0 <printf>
                vprintf(fmt, args);
 80521ae:	8b 45 18             	mov    0x18(%ebp),%eax
 80521b1:	89 44 24 04          	mov    %eax,0x4(%esp)
 80521b5:	8b 45 14             	mov    0x14(%ebp),%eax
 80521b8:	89 04 24             	mov    %eax,(%esp)
 80521bb:	e8 d8 e7 ff ff       	call   8050998 <vprintf>
                printf("\n");
 80521c0:	8d 83 f5 df ff ff    	lea    -0x200b(%ebx),%eax
 80521c6:	89 04 24             	mov    %eax,(%esp)
 80521c9:	e8 d2 e6 ff ff       	call   80508a0 <printf>
        }
}
 80521ce:	90                   	nop
 80521cf:	83 c4 14             	add    $0x14,%esp
 80521d2:	5b                   	pop    %ebx
 80521d3:	5d                   	pop    %ebp
 80521d4:	c3                   	ret    

080521d5 <_default_test_pass>:

static void
_default_test_pass(int val, const char *file, int line, const char *name, const char *fmt, va_list args)
{
 80521d5:	55                   	push   %ebp
 80521d6:	89 e5                	mov    %esp,%ebp
 80521d8:	e8 74 bc ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 80521dd:	05 2f 57 00 00       	add    $0x572f,%eax
        _test_data->td_passed++;
 80521e2:	8b 80 b8 02 00 00    	mov    0x2b8(%eax),%eax
 80521e8:	8b 10                	mov    (%eax),%edx
 80521ea:	42                   	inc    %edx
 80521eb:	89 10                	mov    %edx,(%eax)
}
 80521ed:	90                   	nop
 80521ee:	5d                   	pop    %ebp
 80521ef:	c3                   	ret    

080521f0 <_test_assert>:

int
_test_assert(int val, const char *file, int line, const char *name, const char *fmt, ...)
{
 80521f0:	55                   	push   %ebp
 80521f1:	89 e5                	mov    %esp,%ebp
 80521f3:	83 ec 38             	sub    $0x38,%esp
 80521f6:	e8 56 bc ff ff       	call   804de51 <__x86.get_pc_thunk.ax>
 80521fb:	05 11 57 00 00       	add    $0x5711,%eax
        va_list args;
        va_start(args, fmt);
 8052200:	8d 55 1c             	lea    0x1c(%ebp),%edx
 8052203:	89 55 f4             	mov    %edx,-0xc(%ebp)

        if (0 == val) {
 8052206:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 805220a:	75 36                	jne    8052242 <_test_assert+0x52>
                if (NULL != _fail_func) {
 805220c:	8b 90 58 01 00 00    	mov    0x158(%eax),%edx
 8052212:	85 d2                	test   %edx,%edx
 8052214:	74 67                	je     805227d <_test_assert+0x8d>
                        _fail_func(file, line, name, fmt, args);
 8052216:	8b 80 58 01 00 00    	mov    0x158(%eax),%eax
 805221c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 805221f:	89 54 24 10          	mov    %edx,0x10(%esp)
 8052223:	8b 55 18             	mov    0x18(%ebp),%edx
 8052226:	89 54 24 0c          	mov    %edx,0xc(%esp)
 805222a:	8b 55 14             	mov    0x14(%ebp),%edx
 805222d:	89 54 24 08          	mov    %edx,0x8(%esp)
 8052231:	8b 55 10             	mov    0x10(%ebp),%edx
 8052234:	89 54 24 04          	mov    %edx,0x4(%esp)
 8052238:	8b 55 0c             	mov    0xc(%ebp),%edx
 805223b:	89 14 24             	mov    %edx,(%esp)
 805223e:	ff d0                	call   *%eax
 8052240:	eb 3b                	jmp    805227d <_test_assert+0x8d>
                }
        } else {
                if (NULL != _pass_func) {
 8052242:	8b 90 54 01 00 00    	mov    0x154(%eax),%edx
 8052248:	85 d2                	test   %edx,%edx
 805224a:	74 31                	je     805227d <_test_assert+0x8d>
                        _pass_func(val, file, line, name, fmt, args);
 805224c:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
 8052252:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8052255:	89 54 24 14          	mov    %edx,0x14(%esp)
 8052259:	8b 55 18             	mov    0x18(%ebp),%edx
 805225c:	89 54 24 10          	mov    %edx,0x10(%esp)
 8052260:	8b 55 14             	mov    0x14(%ebp),%edx
 8052263:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8052267:	8b 55 10             	mov    0x10(%ebp),%edx
 805226a:	89 54 24 08          	mov    %edx,0x8(%esp)
 805226e:	8b 55 0c             	mov    0xc(%ebp),%edx
 8052271:	89 54 24 04          	mov    %edx,0x4(%esp)
 8052275:	8b 55 08             	mov    0x8(%ebp),%edx
 8052278:	89 14 24             	mov    %edx,(%esp)
 805227b:	ff d0                	call   *%eax
                }
        }

        va_end(args);
        return val;
 805227d:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8052280:	c9                   	leave  
 8052281:	c3                   	ret    
