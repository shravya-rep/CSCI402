
user/usr/bin/forkbomb.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <main>:

/* TODO add options for different ways of forkbombing
   (kind of low priority but would be fun) */

int main(int argc, char **argv)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	83 e4 f0             	and    $0xfffffff0,%esp
 804809a:	83 ec 20             	sub    $0x20,%esp
        int n = 1;
 804809d:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
 80480a4:	00 
        pid_t pid;
        int limit = (-1);
 80480a5:	c7 44 24 18 ff ff ff 	movl   $0xffffffff,0x18(%esp)
 80480ac:	ff 

        if (argc > 0 && strcmp(argv[argc-1], "limit250") == 0) {
 80480ad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80480b1:	7e 34                	jle    80480e7 <main+0x53>
 80480b3:	8b 45 08             	mov    0x8(%ebp),%eax
 80480b6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
 80480bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 80480c2:	8b 45 0c             	mov    0xc(%ebp),%eax
 80480c5:	01 d0                	add    %edx,%eax
 80480c7:	8b 00                	mov    (%eax),%eax
 80480c9:	c7 44 24 04 88 ce 04 	movl   $0x804ce88,0x4(%esp)
 80480d0:	08 
 80480d1:	89 04 24             	mov    %eax,(%esp)
 80480d4:	e8 e1 0f 00 00       	call   80490ba <strcmp>
 80480d9:	85 c0                	test   %eax,%eax
 80480db:	75 0a                	jne    80480e7 <main+0x53>
                limit = 250;
 80480dd:	c7 44 24 18 fa 00 00 	movl   $0xfa,0x18(%esp)
 80480e4:	00 
 80480e5:	eb 38                	jmp    804811f <main+0x8b>
        } else if (argc > 0 && strcmp(argv[argc-1], "limit500") == 0) {
 80480e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80480eb:	7e 32                	jle    804811f <main+0x8b>
 80480ed:	8b 45 08             	mov    0x8(%ebp),%eax
 80480f0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
 80480f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 80480fc:	8b 45 0c             	mov    0xc(%ebp),%eax
 80480ff:	01 d0                	add    %edx,%eax
 8048101:	8b 00                	mov    (%eax),%eax
 8048103:	c7 44 24 04 91 ce 04 	movl   $0x804ce91,0x4(%esp)
 804810a:	08 
 804810b:	89 04 24             	mov    %eax,(%esp)
 804810e:	e8 a7 0f 00 00       	call   80490ba <strcmp>
 8048113:	85 c0                	test   %eax,%eax
 8048115:	75 08                	jne    804811f <main+0x8b>
                limit = 500;
 8048117:	c7 44 24 18 f4 01 00 	movl   $0x1f4,0x18(%esp)
 804811e:	00 
        }
        open("/dev/tty0", O_RDONLY, 0);
 804811f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8048126:	00 
 8048127:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804812e:	00 
 804812f:	c7 04 24 9a ce 04 08 	movl   $0x804ce9a,(%esp)
 8048136:	e8 05 06 00 00       	call   8048740 <open>
        open("/dev/tty0", O_WRONLY, 0);
 804813b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8048142:	00 
 8048143:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804814a:	00 
 804814b:	c7 04 24 9a ce 04 08 	movl   $0x804ce9a,(%esp)
 8048152:	e8 e9 05 00 00       	call   8048740 <open>
        printf("Forking up a storm!\n");
 8048157:	c7 04 24 a4 ce 04 08 	movl   $0x804cea4,(%esp)
 804815e:	e8 25 38 00 00       	call   804b988 <printf>
        printf("If this runs for 10 minutes without crashing, then you ");
 8048163:	c7 04 24 bc ce 04 08 	movl   $0x804cebc,(%esp)
 804816a:	e8 19 38 00 00       	call   804b988 <printf>
        printf("probably aren't \nleaking resources\n");
 804816f:	c7 04 24 f4 ce 04 08 	movl   $0x804cef4,(%esp)
 8048176:	e8 0d 38 00 00       	call   804b988 <printf>
        if (!fork()) {
 804817b:	e8 26 02 00 00       	call   80483a6 <fork>
 8048180:	85 c0                	test   %eax,%eax
 8048182:	0f 85 93 00 00 00    	jne    804821b <main+0x187>
                for (;;) {
                        printf("I am fork number %d\n", n);
 8048188:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804818c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048190:	c7 04 24 18 cf 04 08 	movl   $0x804cf18,(%esp)
 8048197:	e8 ec 37 00 00       	call   804b988 <printf>
                        if ((pid = fork())) {
 804819c:	e8 05 02 00 00       	call   80483a6 <fork>
 80481a1:	89 44 24 14          	mov    %eax,0x14(%esp)
 80481a5:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
 80481aa:	74 35                	je     80481e1 <main+0x14d>
                                /* parent */
                                /* pid should be > 2 or pid should be -1 if
                                 * the fork failed */
                                if (-1 != pid) {
 80481ac:	83 7c 24 14 ff       	cmpl   $0xffffffff,0x14(%esp)
 80481b1:	74 0e                	je     80481c1 <main+0x12d>
                                        exit(0);
 80481b3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80481ba:	e8 a3 02 00 00       	call   8048462 <exit>
 80481bf:	eb 20                	jmp    80481e1 <main+0x14d>
                                } else {
                                        printf("%d-th fork failed. "
 80481c1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80481c5:	89 44 24 04          	mov    %eax,0x4(%esp)
 80481c9:	c7 04 24 30 cf 04 08 	movl   $0x804cf30,(%esp)
 80481d0:	e8 b3 37 00 00       	call   804b988 <printf>
                                               "forkbomb stopping.", n);
                                        exit(1);
 80481d5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 80481dc:	e8 81 02 00 00       	call   8048462 <exit>
                                }
                        }
                        ++n;
 80481e1:	ff 44 24 1c          	incl   0x1c(%esp)
                        if (limit > 0 && n > limit) {
 80481e5:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
 80481ea:	7e 9c                	jle    8048188 <main+0xf4>
 80481ec:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80481f0:	3b 44 24 18          	cmp    0x18(%esp),%eax
 80481f4:	7e 92                	jle    8048188 <main+0xf4>
                                printf("Limit (specified in the commandline) of %1d reached.\n", limit);
 80481f6:	8b 44 24 18          	mov    0x18(%esp),%eax
 80481fa:	89 44 24 04          	mov    %eax,0x4(%esp)
 80481fe:	c7 04 24 58 cf 04 08 	movl   $0x804cf58,(%esp)
 8048205:	e8 7e 37 00 00       	call   804b988 <printf>
                                exit(0);
 804820a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8048211:	e8 4c 02 00 00       	call   8048462 <exit>
                        }
                }
 8048216:	e9 6d ff ff ff       	jmp    8048188 <main+0xf4>
        } else {
                int status;
                while (wait(&status) > 0)
 804821b:	90                   	nop
 804821c:	8d 44 24 10          	lea    0x10(%esp),%eax
 8048220:	89 04 24             	mov    %eax,(%esp)
 8048223:	e8 c9 02 00 00       	call   80484f1 <wait>
 8048228:	85 c0                	test   %eax,%eax
 804822a:	7f f0                	jg     804821c <main+0x188>
                        ;
        }
        return 0;
 804822c:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8048231:	c9                   	leave  
 8048232:	c3                   	ret    

08048233 <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 8048233:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 8048236:	e8 59 fe ff ff       	call   8048094 <main>
	push %eax; /* Argument to exit is return value from main */
 804823b:	50                   	push   %eax
	call exit;
 804823c:	e8 21 02 00 00       	call   8048462 <exit>

08048241 <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 8048241:	55                   	push   %ebp
 8048242:	89 e5                	mov    %esp,%ebp
 8048244:	83 ec 10             	sub    $0x10,%esp
 8048247:	e8 7d 0d 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804824c:	81 c1 b4 6d 00 00    	add    $0x6db4,%ecx
        int ret;
        __asm__ volatile(
 8048252:	8b 45 08             	mov    0x8(%ebp),%eax
 8048255:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048258:	cd 2e                	int    $0x2e
 804825a:	89 45 fc             	mov    %eax,-0x4(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804825d:	b8 27 00 00 00       	mov    $0x27,%eax
 8048262:	cd 2e                	int    $0x2e
 8048264:	89 c2                	mov    %eax,%edx
 8048266:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804826c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804826e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8048271:	c9                   	leave  
 8048272:	c3                   	ret    

08048273 <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 8048273:	55                   	push   %ebp
 8048274:	89 e5                	mov    %esp,%ebp
 8048276:	53                   	push   %ebx
 8048277:	83 ec 24             	sub    $0x24,%esp
 804827a:	e8 4a 0d 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804827f:	81 c1 81 6d 00 00    	add    $0x6d81,%ecx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 8048285:	8b 81 60 01 00 00    	mov    0x160(%ecx),%eax
 804828b:	85 c0                	test   %eax,%eax
 804828d:	75 44                	jne    80482d3 <sbrk+0x60>
 804828f:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 8048296:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804829d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80482a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
 80482a3:	cd 2e                	int    $0x2e
 80482a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80482a8:	b8 27 00 00 00       	mov    $0x27,%eax
 80482ad:	cd 2e                	int    $0x2e
 80482af:	89 c2                	mov    %eax,%edx
 80482b1:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80482b7:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80482b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 80482bc:	89 81 60 01 00 00    	mov    %eax,0x160(%ecx)
 80482c2:	8b 81 60 01 00 00    	mov    0x160(%ecx),%eax
 80482c8:	85 c0                	test   %eax,%eax
 80482ca:	79 07                	jns    80482d3 <sbrk+0x60>
                        return (void *) -1;
 80482cc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80482d1:	eb 63                	jmp    8048336 <sbrk+0xc3>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 80482d3:	8b 81 60 01 00 00    	mov    0x160(%ecx),%eax
 80482d9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 80482dc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80482e0:	79 2e                	jns    8048310 <sbrk+0x9d>
                if ((uintptr_t) - incr > oldbrk) {
 80482e2:	8b 45 08             	mov    0x8(%ebp),%eax
 80482e5:	f7 d8                	neg    %eax
 80482e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 80482ea:	76 07                	jbe    80482f3 <sbrk+0x80>
                        return (void *) -1;
 80482ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80482f1:	eb 43                	jmp    8048336 <sbrk+0xc3>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 80482f3:	8b 55 08             	mov    0x8(%ebp),%edx
 80482f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80482f9:	01 d0                	add    %edx,%eax
 80482fb:	89 04 24             	mov    %eax,(%esp)
 80482fe:	89 cb                	mov    %ecx,%ebx
 8048300:	e8 37 00 00 00       	call   804833c <brk>
 8048305:	85 c0                	test   %eax,%eax
 8048307:	79 2a                	jns    8048333 <sbrk+0xc0>
                        return (void *) -1;
 8048309:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804830e:	eb 26                	jmp    8048336 <sbrk+0xc3>
                }
        } else if (incr > 0) {
 8048310:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048314:	7e 1d                	jle    8048333 <sbrk+0xc0>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 8048316:	8b 55 08             	mov    0x8(%ebp),%edx
 8048319:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804831c:	01 d0                	add    %edx,%eax
 804831e:	89 04 24             	mov    %eax,(%esp)
 8048321:	89 cb                	mov    %ecx,%ebx
 8048323:	e8 14 00 00 00       	call   804833c <brk>
 8048328:	85 c0                	test   %eax,%eax
 804832a:	79 07                	jns    8048333 <sbrk+0xc0>
                        return (void *) -1;
 804832c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048331:	eb 03                	jmp    8048336 <sbrk+0xc3>
                }
        }
        return (void *) oldbrk;
 8048333:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048336:	83 c4 24             	add    $0x24,%esp
 8048339:	5b                   	pop    %ebx
 804833a:	5d                   	pop    %ebp
 804833b:	c3                   	ret    

0804833c <brk>:

int brk(void *addr)
{
 804833c:	55                   	push   %ebp
 804833d:	89 e5                	mov    %esp,%ebp
 804833f:	83 ec 10             	sub    $0x10,%esp
 8048342:	e8 82 0c 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048347:	81 c1 b9 6c 00 00    	add    $0x6cb9,%ecx
        if (NULL == addr)
 804834d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048351:	75 07                	jne    804835a <brk+0x1e>
                return -1;
 8048353:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048358:	eb 4a                	jmp    80483a4 <brk+0x68>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 804835a:	8b 45 08             	mov    0x8(%ebp),%eax
 804835d:	c7 45 f8 2c 00 00 00 	movl   $0x2c,-0x8(%ebp)
 8048364:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048367:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804836a:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804836d:	cd 2e                	int    $0x2e
 804836f:	89 45 f0             	mov    %eax,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048372:	b8 27 00 00 00       	mov    $0x27,%eax
 8048377:	cd 2e                	int    $0x2e
 8048379:	89 c2                	mov    %eax,%edx
 804837b:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048381:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048383:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048386:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if (newbrk == (void *) -1)
 8048389:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
 804838d:	75 07                	jne    8048396 <brk+0x5a>
                return -1;
 804838f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048394:	eb 0e                	jmp    80483a4 <brk+0x68>
        __curbrk = newbrk;
 8048396:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048399:	89 81 60 01 00 00    	mov    %eax,0x160(%ecx)
        return 0;
 804839f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80483a4:	c9                   	leave  
 80483a5:	c3                   	ret    

080483a6 <fork>:

int fork(void)
{
 80483a6:	55                   	push   %ebp
 80483a7:	89 e5                	mov    %esp,%ebp
 80483a9:	83 ec 10             	sub    $0x10,%esp
 80483ac:	e8 18 0c 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80483b1:	81 c1 4f 6c 00 00    	add    $0x6c4f,%ecx
 80483b7:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
 80483be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80483c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80483c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80483cb:	cd 2e                	int    $0x2e
 80483cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80483d0:	b8 27 00 00 00       	mov    $0x27,%eax
 80483d5:	cd 2e                	int    $0x2e
 80483d7:	89 c2                	mov    %eax,%edx
 80483d9:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80483df:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80483e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_fork, 0);
 80483e4:	90                   	nop
}
 80483e5:	c9                   	leave  
 80483e6:	c3                   	ret    

080483e7 <atexit>:

int atexit(void (*func)(void))
{
 80483e7:	55                   	push   %ebp
 80483e8:	89 e5                	mov    %esp,%ebp
 80483ea:	e8 d6 0b 00 00       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80483ef:	05 11 6c 00 00       	add    $0x6c11,%eax
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 80483f4:	8b 90 00 02 00 00    	mov    0x200(%eax),%edx
 80483fa:	83 fa 1f             	cmp    $0x1f,%edx
 80483fd:	7f 20                	jg     804841f <atexit+0x38>
                atexit_func[atexit_handlers++] = func;
 80483ff:	8b 90 00 02 00 00    	mov    0x200(%eax),%edx
 8048405:	8d 4a 01             	lea    0x1(%edx),%ecx
 8048408:	89 88 00 02 00 00    	mov    %ecx,0x200(%eax)
 804840e:	8b 4d 08             	mov    0x8(%ebp),%ecx
 8048411:	89 8c 90 80 01 00 00 	mov    %ecx,0x180(%eax,%edx,4)
                return 0;
 8048418:	b8 00 00 00 00       	mov    $0x0,%eax
 804841d:	eb 05                	jmp    8048424 <atexit+0x3d>
        }

        return 1;
 804841f:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8048424:	5d                   	pop    %ebp
 8048425:	c3                   	ret    

08048426 <_exit>:

void _exit(int status)
{
 8048426:	55                   	push   %ebp
 8048427:	89 e5                	mov    %esp,%ebp
 8048429:	83 ec 10             	sub    $0x10,%esp
 804842c:	e8 98 0b 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048431:	81 c1 cf 6b 00 00    	add    $0x6bcf,%ecx
        trap(SYS_exit, (uint32_t) status);
 8048437:	8b 45 08             	mov    0x8(%ebp),%eax
 804843a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
 8048441:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048444:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048447:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804844a:	cd 2e                	int    $0x2e
 804844c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804844f:	b8 27 00 00 00       	mov    $0x27,%eax
 8048454:	cd 2e                	int    $0x2e
 8048456:	89 c2                	mov    %eax,%edx
 8048458:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804845e:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 8048460:	eb fe                	jmp    8048460 <_exit+0x3a>

08048462 <exit>:
}

void exit(int status)
{
 8048462:	55                   	push   %ebp
 8048463:	89 e5                	mov    %esp,%ebp
 8048465:	53                   	push   %ebx
 8048466:	83 ec 14             	sub    $0x14,%esp
 8048469:	e8 5f 0b 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 804846e:	81 c3 92 6b 00 00    	add    $0x6b92,%ebx
        while (atexit_handlers--) {
 8048474:	eb 0f                	jmp    8048485 <exit+0x23>
                atexit_func[atexit_handlers]();
 8048476:	8b 83 00 02 00 00    	mov    0x200(%ebx),%eax
 804847c:	8b 84 83 80 01 00 00 	mov    0x180(%ebx,%eax,4),%eax
 8048483:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 8048485:	8b 83 00 02 00 00    	mov    0x200(%ebx),%eax
 804848b:	8d 50 ff             	lea    -0x1(%eax),%edx
 804848e:	89 93 00 02 00 00    	mov    %edx,0x200(%ebx)
 8048494:	85 c0                	test   %eax,%eax
 8048496:	75 de                	jne    8048476 <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 8048498:	8b 45 08             	mov    0x8(%ebp),%eax
 804849b:	89 04 24             	mov    %eax,(%esp)
 804849e:	e8 83 ff ff ff       	call   8048426 <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 80484a3:	8b 45 08             	mov    0x8(%ebp),%eax
 80484a6:	89 04 24             	mov    %eax,(%esp)
 80484a9:	e8 b4 ff ff ff       	call   8048462 <exit>
}
 80484ae:	90                   	nop
 80484af:	83 c4 14             	add    $0x14,%esp
 80484b2:	5b                   	pop    %ebx
 80484b3:	5d                   	pop    %ebp
 80484b4:	c3                   	ret    

080484b5 <yield>:

void yield(void)
{
 80484b5:	55                   	push   %ebp
 80484b6:	89 e5                	mov    %esp,%ebp
 80484b8:	53                   	push   %ebx
 80484b9:	83 ec 14             	sub    $0x14,%esp
 80484bc:	e8 0c 0b 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 80484c1:	81 c3 3f 6b 00 00    	add    $0x6b3f,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80484c7:	e8 da fe ff ff       	call   80483a6 <fork>
 80484cc:	85 c0                	test   %eax,%eax
 80484ce:	74 0e                	je     80484de <yield+0x29>
 80484d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80484d7:	e8 15 00 00 00       	call   80484f1 <wait>
}
 80484dc:	eb 0c                	jmp    80484ea <yield+0x35>
void yield(void)
{
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80484de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80484e5:	e8 78 ff ff ff       	call   8048462 <exit>
}
 80484ea:	90                   	nop
 80484eb:	83 c4 14             	add    $0x14,%esp
 80484ee:	5b                   	pop    %ebx
 80484ef:	5d                   	pop    %ebp
 80484f0:	c3                   	ret    

080484f1 <wait>:

pid_t wait(int *status)
{
 80484f1:	55                   	push   %ebp
 80484f2:	89 e5                	mov    %esp,%ebp
 80484f4:	83 ec 20             	sub    $0x20,%esp
 80484f7:	e8 cd 0a 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80484fc:	81 c1 04 6b 00 00    	add    $0x6b04,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 8048502:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        args.wpa_options = 0;
 8048509:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        args.wpa_status = status;
 8048510:	8b 45 08             	mov    0x8(%ebp),%eax
 8048513:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8048516:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048519:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 8048520:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048523:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048526:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048529:	cd 2e                	int    $0x2e
 804852b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804852e:	b8 27 00 00 00       	mov    $0x27,%eax
 8048533:	cd 2e                	int    $0x2e
 8048535:	89 c2                	mov    %eax,%edx
 8048537:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804853d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804853f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048542:	c9                   	leave  
 8048543:	c3                   	ret    

08048544 <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 8048544:	55                   	push   %ebp
 8048545:	89 e5                	mov    %esp,%ebp
 8048547:	83 ec 20             	sub    $0x20,%esp
 804854a:	e8 7a 0a 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804854f:	81 c1 b1 6a 00 00    	add    $0x6ab1,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 8048555:	8b 45 08             	mov    0x8(%ebp),%eax
 8048558:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_options = options;
 804855b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804855e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.wpa_status = status;
 8048561:	8b 45 10             	mov    0x10(%ebp),%eax
 8048564:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8048567:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804856a:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 8048571:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048574:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048577:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804857a:	cd 2e                	int    $0x2e
 804857c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804857f:	b8 27 00 00 00       	mov    $0x27,%eax
 8048584:	cd 2e                	int    $0x2e
 8048586:	89 c2                	mov    %eax,%edx
 8048588:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804858e:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048590:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048593:	c9                   	leave  
 8048594:	c3                   	ret    

08048595 <thr_exit>:

void thr_exit(int status)
{
 8048595:	55                   	push   %ebp
 8048596:	89 e5                	mov    %esp,%ebp
 8048598:	83 ec 10             	sub    $0x10,%esp
 804859b:	e8 29 0a 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80485a0:	81 c1 60 6a 00 00    	add    $0x6a60,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 80485a6:	8b 45 08             	mov    0x8(%ebp),%eax
 80485a9:	c7 45 fc 1f 00 00 00 	movl   $0x1f,-0x4(%ebp)
 80485b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80485b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80485b6:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80485b9:	cd 2e                	int    $0x2e
 80485bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80485be:	b8 27 00 00 00       	mov    $0x27,%eax
 80485c3:	cd 2e                	int    $0x2e
 80485c5:	89 c2                	mov    %eax,%edx
 80485c7:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80485cd:	89 10                	mov    %edx,(%eax)
}
 80485cf:	90                   	nop
 80485d0:	c9                   	leave  
 80485d1:	c3                   	ret    

080485d2 <getpid>:

pid_t getpid(void)
{
 80485d2:	55                   	push   %ebp
 80485d3:	89 e5                	mov    %esp,%ebp
 80485d5:	83 ec 10             	sub    $0x10,%esp
 80485d8:	e8 ec 09 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80485dd:	81 c1 23 6a 00 00    	add    $0x6a23,%ecx
 80485e3:	c7 45 fc 23 00 00 00 	movl   $0x23,-0x4(%ebp)
 80485ea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80485f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80485f4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80485f7:	cd 2e                	int    $0x2e
 80485f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80485fc:	b8 27 00 00 00       	mov    $0x27,%eax
 8048601:	cd 2e                	int    $0x2e
 8048603:	89 c2                	mov    %eax,%edx
 8048605:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804860b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804860d:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_getpid, 0);
 8048610:	90                   	nop
}
 8048611:	c9                   	leave  
 8048612:	c3                   	ret    

08048613 <halt>:

int halt(void)
{
 8048613:	55                   	push   %ebp
 8048614:	89 e5                	mov    %esp,%ebp
 8048616:	83 ec 10             	sub    $0x10,%esp
 8048619:	e8 ab 09 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804861e:	81 c1 e2 69 00 00    	add    $0x69e2,%ecx
 8048624:	c7 45 fc 28 00 00 00 	movl   $0x28,-0x4(%ebp)
 804862b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048632:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048635:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048638:	cd 2e                	int    $0x2e
 804863a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804863d:	b8 27 00 00 00       	mov    $0x27,%eax
 8048642:	cd 2e                	int    $0x2e
 8048644:	89 c2                	mov    %eax,%edx
 8048646:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804864c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804864e:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_halt, 0);
 8048651:	90                   	nop
}
 8048652:	c9                   	leave  
 8048653:	c3                   	ret    

08048654 <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 8048654:	55                   	push   %ebp
 8048655:	89 e5                	mov    %esp,%ebp
 8048657:	83 ec 30             	sub    $0x30,%esp
 804865a:	e8 6a 09 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804865f:	81 c1 a1 69 00 00    	add    $0x69a1,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 8048665:	8b 45 08             	mov    0x8(%ebp),%eax
 8048668:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_len = len;
 804866b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804866e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_prot = prot;
 8048671:	8b 45 10             	mov    0x10(%ebp),%eax
 8048674:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_flags = flags;
 8048677:	8b 45 14             	mov    0x14(%ebp),%eax
 804867a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_fd = fd;
 804867d:	8b 45 18             	mov    0x18(%ebp),%eax
 8048680:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.mma_off = off;
 8048683:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8048686:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 8048689:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804868c:	c7 45 fc 18 00 00 00 	movl   $0x18,-0x4(%ebp)
 8048693:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048696:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048699:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804869c:	cd 2e                	int    $0x2e
 804869e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486a1:	b8 27 00 00 00       	mov    $0x27,%eax
 80486a6:	cd 2e                	int    $0x2e
 80486a8:	89 c2                	mov    %eax,%edx
 80486aa:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80486b0:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80486b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80486b5:	c9                   	leave  
 80486b6:	c3                   	ret    

080486b7 <munmap>:

int munmap(void *addr, size_t len)
{
 80486b7:	55                   	push   %ebp
 80486b8:	89 e5                	mov    %esp,%ebp
 80486ba:	83 ec 20             	sub    $0x20,%esp
 80486bd:	e8 07 09 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80486c2:	81 c1 3e 69 00 00    	add    $0x693e,%ecx
        munmap_args_t args;

        args.addr = addr;
 80486c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80486cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.len = len;
 80486ce:	8b 45 0c             	mov    0xc(%ebp),%eax
 80486d1:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 80486d4:	8d 45 ec             	lea    -0x14(%ebp),%eax
 80486d7:	c7 45 fc 1a 00 00 00 	movl   $0x1a,-0x4(%ebp)
 80486de:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80486e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80486e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80486e7:	cd 2e                	int    $0x2e
 80486e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486ec:	b8 27 00 00 00       	mov    $0x27,%eax
 80486f1:	cd 2e                	int    $0x2e
 80486f3:	89 c2                	mov    %eax,%edx
 80486f5:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80486fb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80486fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048700:	c9                   	leave  
 8048701:	c3                   	ret    

08048702 <sync>:

void sync(void)
{
 8048702:	55                   	push   %ebp
 8048703:	89 e5                	mov    %esp,%ebp
 8048705:	83 ec 10             	sub    $0x10,%esp
 8048708:	e8 bc 08 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804870d:	81 c1 f3 68 00 00    	add    $0x68f3,%ecx
 8048713:	c7 45 fc 0f 00 00 00 	movl   $0xf,-0x4(%ebp)
 804871a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048721:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048724:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048727:	cd 2e                	int    $0x2e
 8048729:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804872c:	b8 27 00 00 00       	mov    $0x27,%eax
 8048731:	cd 2e                	int    $0x2e
 8048733:	89 c2                	mov    %eax,%edx
 8048735:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804873b:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 804873d:	90                   	nop
 804873e:	c9                   	leave  
 804873f:	c3                   	ret    

08048740 <open>:

int open(const char *filename, int flags, int mode)
{
 8048740:	55                   	push   %ebp
 8048741:	89 e5                	mov    %esp,%ebp
 8048743:	53                   	push   %ebx
 8048744:	83 ec 34             	sub    $0x34,%esp
 8048747:	e8 81 08 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 804874c:	81 c3 b4 68 00 00    	add    $0x68b4,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 8048752:	8b 45 08             	mov    0x8(%ebp),%eax
 8048755:	89 04 24             	mov    %eax,(%esp)
 8048758:	e8 e1 0a 00 00       	call   804923e <strlen>
 804875d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 8048760:	8b 45 08             	mov    0x8(%ebp),%eax
 8048763:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 8048766:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048769:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 804876c:	8b 45 10             	mov    0x10(%ebp),%eax
 804876f:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 8048772:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048775:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 804877c:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804877f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048782:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048785:	cd 2e                	int    $0x2e
 8048787:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804878a:	b8 27 00 00 00       	mov    $0x27,%eax
 804878f:	cd 2e                	int    $0x2e
 8048791:	89 c2                	mov    %eax,%edx
 8048793:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048799:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804879b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804879e:	83 c4 34             	add    $0x34,%esp
 80487a1:	5b                   	pop    %ebx
 80487a2:	5d                   	pop    %ebp
 80487a3:	c3                   	ret    

080487a4 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 80487a4:	55                   	push   %ebp
 80487a5:	89 e5                	mov    %esp,%ebp
 80487a7:	83 ec 20             	sub    $0x20,%esp
 80487aa:	e8 1a 08 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80487af:	81 c1 51 68 00 00    	add    $0x6851,%ecx
        lseek_args_t args;

        args.fd = fd;
 80487b5:	8b 45 08             	mov    0x8(%ebp),%eax
 80487b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.offset = offset;
 80487bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487be:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.whence = whence;
 80487c1:	8b 45 10             	mov    0x10(%ebp),%eax
 80487c4:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 80487c7:	8d 45 e8             	lea    -0x18(%ebp),%eax
 80487ca:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%ebp)
 80487d1:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80487d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80487d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80487da:	cd 2e                	int    $0x2e
 80487dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80487df:	b8 27 00 00 00       	mov    $0x27,%eax
 80487e4:	cd 2e                	int    $0x2e
 80487e6:	89 c2                	mov    %eax,%edx
 80487e8:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80487ee:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80487f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80487f3:	c9                   	leave  
 80487f4:	c3                   	ret    

080487f5 <read>:


int read(int fd, void *buf, size_t nbytes)
{
 80487f5:	55                   	push   %ebp
 80487f6:	89 e5                	mov    %esp,%ebp
 80487f8:	83 ec 20             	sub    $0x20,%esp
 80487fb:	e8 c9 07 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048800:	81 c1 00 68 00 00    	add    $0x6800,%ecx
        read_args_t args;

        args.fd = fd;
 8048806:	8b 45 08             	mov    0x8(%ebp),%eax
 8048809:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = buf;
 804880c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804880f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 8048812:	8b 45 10             	mov    0x10(%ebp),%eax
 8048815:	89 45 f0             	mov    %eax,-0x10(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 8048818:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804881b:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
 8048822:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048825:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048828:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804882b:	cd 2e                	int    $0x2e
 804882d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048830:	b8 27 00 00 00       	mov    $0x27,%eax
 8048835:	cd 2e                	int    $0x2e
 8048837:	89 c2                	mov    %eax,%edx
 8048839:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804883f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048841:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048844:	c9                   	leave  
 8048845:	c3                   	ret    

08048846 <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 8048846:	55                   	push   %ebp
 8048847:	89 e5                	mov    %esp,%ebp
 8048849:	83 ec 20             	sub    $0x20,%esp
 804884c:	e8 78 07 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048851:	81 c1 af 67 00 00    	add    $0x67af,%ecx
        write_args_t args;

        args.fd = fd;
 8048857:	8b 45 08             	mov    0x8(%ebp),%eax
 804885a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = (void *) buf;
 804885d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048860:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 8048863:	8b 45 10             	mov    0x10(%ebp),%eax
 8048866:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 8048869:	8d 45 e8             	lea    -0x18(%ebp),%eax
 804886c:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
 8048873:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048876:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048879:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804887c:	cd 2e                	int    $0x2e
 804887e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048881:	b8 27 00 00 00       	mov    $0x27,%eax
 8048886:	cd 2e                	int    $0x2e
 8048888:	89 c2                	mov    %eax,%edx
 804888a:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048890:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048892:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048895:	c9                   	leave  
 8048896:	c3                   	ret    

08048897 <close>:

int close(int fd)
{
 8048897:	55                   	push   %ebp
 8048898:	89 e5                	mov    %esp,%ebp
 804889a:	83 ec 10             	sub    $0x10,%esp
 804889d:	e8 27 07 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80488a2:	81 c1 5e 67 00 00    	add    $0x675e,%ecx
        return trap(SYS_close, (uint32_t) fd);
 80488a8:	8b 45 08             	mov    0x8(%ebp),%eax
 80488ab:	c7 45 fc 06 00 00 00 	movl   $0x6,-0x4(%ebp)
 80488b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488b8:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80488bb:	cd 2e                	int    $0x2e
 80488bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80488c0:	b8 27 00 00 00       	mov    $0x27,%eax
 80488c5:	cd 2e                	int    $0x2e
 80488c7:	89 c2                	mov    %eax,%edx
 80488c9:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80488cf:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80488d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80488d4:	90                   	nop
}
 80488d5:	c9                   	leave  
 80488d6:	c3                   	ret    

080488d7 <dup>:

int dup(int fd)
{
 80488d7:	55                   	push   %ebp
 80488d8:	89 e5                	mov    %esp,%ebp
 80488da:	83 ec 10             	sub    $0x10,%esp
 80488dd:	e8 e7 06 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 80488e2:	81 c1 1e 67 00 00    	add    $0x671e,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 80488e8:	8b 45 08             	mov    0x8(%ebp),%eax
 80488eb:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
 80488f2:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488f8:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80488fb:	cd 2e                	int    $0x2e
 80488fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048900:	b8 27 00 00 00       	mov    $0x27,%eax
 8048905:	cd 2e                	int    $0x2e
 8048907:	89 c2                	mov    %eax,%edx
 8048909:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804890f:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048911:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048914:	90                   	nop
}
 8048915:	c9                   	leave  
 8048916:	c3                   	ret    

08048917 <dup2>:

int dup2(int ofd, int nfd)
{
 8048917:	55                   	push   %ebp
 8048918:	89 e5                	mov    %esp,%ebp
 804891a:	83 ec 20             	sub    $0x20,%esp
 804891d:	e8 a7 06 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048922:	81 c1 de 66 00 00    	add    $0x66de,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 8048928:	8b 45 08             	mov    0x8(%ebp),%eax
 804892b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nfd = nfd;
 804892e:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048931:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 8048934:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048937:	c7 45 fc 2b 00 00 00 	movl   $0x2b,-0x4(%ebp)
 804893e:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048941:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048944:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048947:	cd 2e                	int    $0x2e
 8048949:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804894c:	b8 27 00 00 00       	mov    $0x27,%eax
 8048951:	cd 2e                	int    $0x2e
 8048953:	89 c2                	mov    %eax,%edx
 8048955:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 804895b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804895d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048960:	c9                   	leave  
 8048961:	c3                   	ret    

08048962 <mkdir>:

int mkdir(const char *path, int mode)
{
 8048962:	55                   	push   %ebp
 8048963:	89 e5                	mov    %esp,%ebp
 8048965:	53                   	push   %ebx
 8048966:	83 ec 34             	sub    $0x34,%esp
 8048969:	e8 5f 06 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 804896e:	81 c3 92 66 00 00    	add    $0x6692,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 8048974:	8b 45 08             	mov    0x8(%ebp),%eax
 8048977:	89 04 24             	mov    %eax,(%esp)
 804897a:	e8 bf 08 00 00       	call   804923e <strlen>
 804897f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048982:	8b 45 08             	mov    0x8(%ebp),%eax
 8048985:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 8048988:	8b 45 0c             	mov    0xc(%ebp),%eax
 804898b:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 804898e:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048991:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 8048998:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804899b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804899e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80489a1:	cd 2e                	int    $0x2e
 80489a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489a6:	b8 27 00 00 00       	mov    $0x27,%eax
 80489ab:	cd 2e                	int    $0x2e
 80489ad:	89 c2                	mov    %eax,%edx
 80489af:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 80489b5:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80489b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80489ba:	83 c4 34             	add    $0x34,%esp
 80489bd:	5b                   	pop    %ebx
 80489be:	5d                   	pop    %ebp
 80489bf:	c3                   	ret    

080489c0 <rmdir>:

int rmdir(const char *path)
{
 80489c0:	55                   	push   %ebp
 80489c1:	89 e5                	mov    %esp,%ebp
 80489c3:	53                   	push   %ebx
 80489c4:	83 ec 34             	sub    $0x34,%esp
 80489c7:	e8 01 06 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 80489cc:	81 c3 34 66 00 00    	add    $0x6634,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 80489d2:	8b 45 08             	mov    0x8(%ebp),%eax
 80489d5:	89 04 24             	mov    %eax,(%esp)
 80489d8:	e8 61 08 00 00       	call   804923e <strlen>
 80489dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 80489e0:	8b 45 08             	mov    0x8(%ebp),%eax
 80489e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 80489e6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 80489e9:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 80489f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80489f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80489f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80489f9:	cd 2e                	int    $0x2e
 80489fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489fe:	b8 27 00 00 00       	mov    $0x27,%eax
 8048a03:	cd 2e                	int    $0x2e
 8048a05:	89 c2                	mov    %eax,%edx
 8048a07:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048a0d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048a0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048a12:	83 c4 34             	add    $0x34,%esp
 8048a15:	5b                   	pop    %ebx
 8048a16:	5d                   	pop    %ebp
 8048a17:	c3                   	ret    

08048a18 <unlink>:

int unlink(const char *path)
{
 8048a18:	55                   	push   %ebp
 8048a19:	89 e5                	mov    %esp,%ebp
 8048a1b:	53                   	push   %ebx
 8048a1c:	83 ec 34             	sub    $0x34,%esp
 8048a1f:	e8 a9 05 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048a24:	81 c3 dc 65 00 00    	add    $0x65dc,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048a2a:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a2d:	89 04 24             	mov    %eax,(%esp)
 8048a30:	e8 09 08 00 00       	call   804923e <strlen>
 8048a35:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048a38:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 8048a3e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048a41:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 8048a48:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048a51:	cd 2e                	int    $0x2e
 8048a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a56:	b8 27 00 00 00       	mov    $0x27,%eax
 8048a5b:	cd 2e                	int    $0x2e
 8048a5d:	89 c2                	mov    %eax,%edx
 8048a5f:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048a65:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048a67:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048a6a:	83 c4 34             	add    $0x34,%esp
 8048a6d:	5b                   	pop    %ebx
 8048a6e:	5d                   	pop    %ebp
 8048a6f:	c3                   	ret    

08048a70 <link>:

int link(const char *from, const char *to)
{
 8048a70:	55                   	push   %ebp
 8048a71:	89 e5                	mov    %esp,%ebp
 8048a73:	53                   	push   %ebx
 8048a74:	83 ec 34             	sub    $0x34,%esp
 8048a77:	e8 51 05 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048a7c:	81 c3 84 65 00 00    	add    $0x6584,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 8048a82:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a85:	89 04 24             	mov    %eax,(%esp)
 8048a88:	e8 b1 07 00 00       	call   804923e <strlen>
 8048a8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 8048a90:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 8048a96:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a99:	89 04 24             	mov    %eax,(%esp)
 8048a9c:	e8 9d 07 00 00       	call   804923e <strlen>
 8048aa1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 8048aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048aa7:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 8048aaa:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048aad:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 8048ab4:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048aba:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048abd:	cd 2e                	int    $0x2e
 8048abf:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048ac2:	b8 27 00 00 00       	mov    $0x27,%eax
 8048ac7:	cd 2e                	int    $0x2e
 8048ac9:	89 c2                	mov    %eax,%edx
 8048acb:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048ad1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048ad3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ad6:	83 c4 34             	add    $0x34,%esp
 8048ad9:	5b                   	pop    %ebx
 8048ada:	5d                   	pop    %ebp
 8048adb:	c3                   	ret    

08048adc <rename>:

int rename(const char *oldname, const char *newname)
{
 8048adc:	55                   	push   %ebp
 8048add:	89 e5                	mov    %esp,%ebp
 8048adf:	53                   	push   %ebx
 8048ae0:	83 ec 34             	sub    $0x34,%esp
 8048ae3:	e8 e5 04 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048ae8:	81 c3 18 65 00 00    	add    $0x6518,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 8048aee:	8b 45 08             	mov    0x8(%ebp),%eax
 8048af1:	89 04 24             	mov    %eax,(%esp)
 8048af4:	e8 45 07 00 00       	call   804923e <strlen>
 8048af9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 8048afc:	8b 45 08             	mov    0x8(%ebp),%eax
 8048aff:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 8048b02:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b05:	89 04 24             	mov    %eax,(%esp)
 8048b08:	e8 31 07 00 00       	call   804923e <strlen>
 8048b0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 8048b10:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b13:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 8048b16:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048b19:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 8048b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b26:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048b29:	cd 2e                	int    $0x2e
 8048b2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b2e:	b8 27 00 00 00       	mov    $0x27,%eax
 8048b33:	cd 2e                	int    $0x2e
 8048b35:	89 c2                	mov    %eax,%edx
 8048b37:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048b3d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048b42:	83 c4 34             	add    $0x34,%esp
 8048b45:	5b                   	pop    %ebx
 8048b46:	5d                   	pop    %ebp
 8048b47:	c3                   	ret    

08048b48 <chdir>:

int chdir(const char *path)
{
 8048b48:	55                   	push   %ebp
 8048b49:	89 e5                	mov    %esp,%ebp
 8048b4b:	53                   	push   %ebx
 8048b4c:	83 ec 34             	sub    $0x34,%esp
 8048b4f:	e8 79 04 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048b54:	81 c3 ac 64 00 00    	add    $0x64ac,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048b5a:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b5d:	89 04 24             	mov    %eax,(%esp)
 8048b60:	e8 d9 06 00 00       	call   804923e <strlen>
 8048b65:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048b68:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 8048b6e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048b71:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 8048b78:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b7e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048b81:	cd 2e                	int    $0x2e
 8048b83:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b86:	b8 27 00 00 00       	mov    $0x27,%eax
 8048b8b:	cd 2e                	int    $0x2e
 8048b8d:	89 c2                	mov    %eax,%edx
 8048b8f:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048b95:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b97:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048b9a:	83 c4 34             	add    $0x34,%esp
 8048b9d:	5b                   	pop    %ebx
 8048b9e:	5d                   	pop    %ebp
 8048b9f:	c3                   	ret    

08048ba0 <get_free_mem>:

size_t get_free_mem(void)
{
 8048ba0:	55                   	push   %ebp
 8048ba1:	89 e5                	mov    %esp,%ebp
 8048ba3:	83 ec 10             	sub    $0x10,%esp
 8048ba6:	e8 1e 04 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048bab:	81 c1 55 64 00 00    	add    $0x6455,%ecx
 8048bb1:	c7 45 fc 29 00 00 00 	movl   $0x29,-0x4(%ebp)
 8048bb8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048bbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048bc2:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048bc5:	cd 2e                	int    $0x2e
 8048bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048bca:	b8 27 00 00 00       	mov    $0x27,%eax
 8048bcf:	cd 2e                	int    $0x2e
 8048bd1:	89 c2                	mov    %eax,%edx
 8048bd3:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048bd9:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 8048bde:	c9                   	leave  
 8048bdf:	c3                   	ret    

08048be0 <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 8048be0:	55                   	push   %ebp
 8048be1:	89 e5                	mov    %esp,%ebp
 8048be3:	56                   	push   %esi
 8048be4:	53                   	push   %ebx
 8048be5:	83 ec 40             	sub    $0x40,%esp
 8048be8:	e8 e0 03 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048bed:	81 c3 13 64 00 00    	add    $0x6413,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 8048bf3:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bf6:	89 04 24             	mov    %eax,(%esp)
 8048bf9:	e8 40 06 00 00       	call   804923e <strlen>
 8048bfe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 8048c01:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c04:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 8048c07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048c0e:	eb 03                	jmp    8048c13 <execve+0x33>
 8048c10:	ff 45 f4             	incl   -0xc(%ebp)
 8048c13:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c16:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c20:	01 d0                	add    %edx,%eax
 8048c22:	8b 00                	mov    (%eax),%eax
 8048c24:	85 c0                	test   %eax,%eax
 8048c26:	75 e8                	jne    8048c10 <execve+0x30>
                ;
        args.argv.av_len = i;
 8048c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c2b:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 8048c2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048c31:	40                   	inc    %eax
 8048c32:	c1 e0 03             	shl    $0x3,%eax
 8048c35:	89 04 24             	mov    %eax,(%esp)
 8048c38:	e8 c5 2a 00 00       	call   804b702 <malloc>
 8048c3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 8048c40:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048c47:	eb 49                	jmp    8048c92 <execve+0xb2>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 8048c49:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048c4c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048c4f:	c1 e2 03             	shl    $0x3,%edx
 8048c52:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048c55:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c58:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048c5f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c62:	01 d0                	add    %edx,%eax
 8048c64:	8b 00                	mov    (%eax),%eax
 8048c66:	89 04 24             	mov    %eax,(%esp)
 8048c69:	e8 d0 05 00 00       	call   804923e <strlen>
 8048c6e:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 8048c71:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048c74:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048c77:	c1 e2 03             	shl    $0x3,%edx
 8048c7a:	01 c2                	add    %eax,%edx
 8048c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c7f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8048c86:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c89:	01 c8                	add    %ecx,%eax
 8048c8b:	8b 00                	mov    (%eax),%eax
 8048c8d:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 8048c8f:	ff 45 f4             	incl   -0xc(%ebp)
 8048c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c95:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048c9c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c9f:	01 d0                	add    %edx,%eax
 8048ca1:	8b 00                	mov    (%eax),%eax
 8048ca3:	85 c0                	test   %eax,%eax
 8048ca5:	75 a2                	jne    8048c49 <execve+0x69>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 8048ca7:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048caa:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048cad:	c1 e2 03             	shl    $0x3,%edx
 8048cb0:	01 d0                	add    %edx,%eax
 8048cb2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 8048cb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048cbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048cbf:	c1 e2 03             	shl    $0x3,%edx
 8048cc2:	01 d0                	add    %edx,%eax
 8048cc4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 8048cca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048cd1:	eb 03                	jmp    8048cd6 <execve+0xf6>
 8048cd3:	ff 45 f4             	incl   -0xc(%ebp)
 8048cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cd9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048ce0:	8b 45 10             	mov    0x10(%ebp),%eax
 8048ce3:	01 d0                	add    %edx,%eax
 8048ce5:	8b 00                	mov    (%eax),%eax
 8048ce7:	85 c0                	test   %eax,%eax
 8048ce9:	75 e8                	jne    8048cd3 <execve+0xf3>
                ;
        args.envp.av_len = i;
 8048ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048cee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 8048cf1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048cf4:	40                   	inc    %eax
 8048cf5:	c1 e0 03             	shl    $0x3,%eax
 8048cf8:	89 04 24             	mov    %eax,(%esp)
 8048cfb:	e8 02 2a 00 00       	call   804b702 <malloc>
 8048d00:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 8048d03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048d0a:	eb 49                	jmp    8048d55 <execve+0x175>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 8048d0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048d0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d12:	c1 e2 03             	shl    $0x3,%edx
 8048d15:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048d18:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d1b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048d22:	8b 45 10             	mov    0x10(%ebp),%eax
 8048d25:	01 d0                	add    %edx,%eax
 8048d27:	8b 00                	mov    (%eax),%eax
 8048d29:	89 04 24             	mov    %eax,(%esp)
 8048d2c:	e8 0d 05 00 00       	call   804923e <strlen>
 8048d31:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 8048d34:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048d37:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d3a:	c1 e2 03             	shl    $0x3,%edx
 8048d3d:	01 c2                	add    %eax,%edx
 8048d3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d42:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8048d49:	8b 45 10             	mov    0x10(%ebp),%eax
 8048d4c:	01 c8                	add    %ecx,%eax
 8048d4e:	8b 00                	mov    (%eax),%eax
 8048d50:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 8048d52:	ff 45 f4             	incl   -0xc(%ebp)
 8048d55:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d58:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048d5f:	8b 45 10             	mov    0x10(%ebp),%eax
 8048d62:	01 d0                	add    %edx,%eax
 8048d64:	8b 00                	mov    (%eax),%eax
 8048d66:	85 c0                	test   %eax,%eax
 8048d68:	75 a2                	jne    8048d0c <execve+0x12c>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 8048d6a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048d6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d70:	c1 e2 03             	shl    $0x3,%edx
 8048d73:	01 d0                	add    %edx,%eax
 8048d75:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 8048d7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048d7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d82:	c1 e2 03             	shl    $0x3,%edx
 8048d85:	01 d0                	add    %edx,%eax
 8048d87:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 8048d8d:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8048d90:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 8048d97:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048d9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048d9d:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8048da0:	cd 2e                	int    $0x2e
 8048da2:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048da5:	b8 27 00 00 00       	mov    $0x27,%eax
 8048daa:	cd 2e                	int    $0x2e
 8048dac:	89 c2                	mov    %eax,%edx
 8048dae:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048db4:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048db6:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 8048db9:	83 c4 40             	add    $0x40,%esp
 8048dbc:	5b                   	pop    %ebx
 8048dbd:	5e                   	pop    %esi
 8048dbe:	5d                   	pop    %ebp
 8048dbf:	c3                   	ret    

08048dc0 <thr_set_errno>:

void thr_set_errno(int n)
{
 8048dc0:	55                   	push   %ebp
 8048dc1:	89 e5                	mov    %esp,%ebp
 8048dc3:	83 ec 10             	sub    $0x10,%esp
 8048dc6:	e8 fe 01 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048dcb:	81 c1 35 62 00 00    	add    $0x6235,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 8048dd1:	8b 45 08             	mov    0x8(%ebp),%eax
 8048dd4:	c7 45 fc 2a 00 00 00 	movl   $0x2a,-0x4(%ebp)
 8048ddb:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048dde:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048de1:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048de4:	cd 2e                	int    $0x2e
 8048de6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048de9:	b8 27 00 00 00       	mov    $0x27,%eax
 8048dee:	cd 2e                	int    $0x2e
 8048df0:	89 c2                	mov    %eax,%edx
 8048df2:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048df8:	89 10                	mov    %edx,(%eax)
}
 8048dfa:	90                   	nop
 8048dfb:	c9                   	leave  
 8048dfc:	c3                   	ret    

08048dfd <thr_errno>:

int thr_errno(void)
{
 8048dfd:	55                   	push   %ebp
 8048dfe:	89 e5                	mov    %esp,%ebp
 8048e00:	83 ec 10             	sub    $0x10,%esp
 8048e03:	e8 c1 01 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048e08:	81 c1 f8 61 00 00    	add    $0x61f8,%ecx
 8048e0e:	c7 45 fc 27 00 00 00 	movl   $0x27,-0x4(%ebp)
 8048e15:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048e1f:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048e22:	cd 2e                	int    $0x2e
 8048e24:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048e27:	b8 27 00 00 00       	mov    $0x27,%eax
 8048e2c:	cd 2e                	int    $0x2e
 8048e2e:	89 c2                	mov    %eax,%edx
 8048e30:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048e36:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_errno, 0);
 8048e3b:	90                   	nop
}
 8048e3c:	c9                   	leave  
 8048e3d:	c3                   	ret    

08048e3e <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 8048e3e:	55                   	push   %ebp
 8048e3f:	89 e5                	mov    %esp,%ebp
 8048e41:	83 ec 20             	sub    $0x20,%esp
 8048e44:	e8 80 01 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048e49:	81 c1 b7 61 00 00    	add    $0x61b7,%ecx
        getdents_args_t args;

        args.fd = fd;
 8048e4f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048e52:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.dirp = dir;
 8048e55:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048e58:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.count = size;
 8048e5b:	8b 45 10             	mov    0x10(%ebp),%eax
 8048e5e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 8048e61:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048e64:	c7 45 fc 17 00 00 00 	movl   $0x17,-0x4(%ebp)
 8048e6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048e71:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048e74:	cd 2e                	int    $0x2e
 8048e76:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048e79:	b8 27 00 00 00       	mov    $0x27,%eax
 8048e7e:	cd 2e                	int    $0x2e
 8048e80:	89 c2                	mov    %eax,%edx
 8048e82:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048e88:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048e8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048e8d:	c9                   	leave  
 8048e8e:	c3                   	ret    

08048e8f <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 8048e8f:	55                   	push   %ebp
 8048e90:	89 e5                	mov    %esp,%ebp
 8048e92:	53                   	push   %ebx
 8048e93:	83 ec 34             	sub    $0x34,%esp
 8048e96:	e8 32 01 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048e9b:	81 c3 65 61 00 00    	add    $0x6165,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 8048ea1:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ea4:	89 04 24             	mov    %eax,(%esp)
 8048ea7:	e8 92 03 00 00       	call   804923e <strlen>
 8048eac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048eaf:	8b 45 08             	mov    0x8(%ebp),%eax
 8048eb2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 8048eb5:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048eb8:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 8048ebb:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048ebe:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 8048ec5:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048ec8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048ecb:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048ece:	cd 2e                	int    $0x2e
 8048ed0:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048ed3:	b8 27 00 00 00       	mov    $0x27,%eax
 8048ed8:	cd 2e                	int    $0x2e
 8048eda:	89 c2                	mov    %eax,%edx
 8048edc:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048ee2:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ee7:	83 c4 34             	add    $0x34,%esp
 8048eea:	5b                   	pop    %ebx
 8048eeb:	5d                   	pop    %ebp
 8048eec:	c3                   	ret    

08048eed <pipe>:

int
pipe(int pipefd[2])
{
 8048eed:	55                   	push   %ebp
 8048eee:	89 e5                	mov    %esp,%ebp
 8048ef0:	83 ec 10             	sub    $0x10,%esp
 8048ef3:	e8 d1 00 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048ef8:	81 c1 08 61 00 00    	add    $0x6108,%ecx
        return trap(SYS_pipe, (uint32_t) pipefd);
 8048efe:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f01:	c7 45 fc 12 00 00 00 	movl   $0x12,-0x4(%ebp)
 8048f08:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048f0e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048f11:	cd 2e                	int    $0x2e
 8048f13:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f16:	b8 27 00 00 00       	mov    $0x27,%eax
 8048f1b:	cd 2e                	int    $0x2e
 8048f1d:	89 c2                	mov    %eax,%edx
 8048f1f:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048f25:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f27:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048f2a:	90                   	nop
}
 8048f2b:	c9                   	leave  
 8048f2c:	c3                   	ret    

08048f2d <uname>:

int
uname(struct utsname *buf)
{
 8048f2d:	55                   	push   %ebp
 8048f2e:	89 e5                	mov    %esp,%ebp
 8048f30:	83 ec 10             	sub    $0x10,%esp
 8048f33:	e8 91 00 00 00       	call   8048fc9 <__x86.get_pc_thunk.cx>
 8048f38:	81 c1 c8 60 00 00    	add    $0x60c8,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 8048f3e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f41:	c7 45 fc 1c 00 00 00 	movl   $0x1c,-0x4(%ebp)
 8048f48:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048f4e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048f51:	cd 2e                	int    $0x2e
 8048f53:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f56:	b8 27 00 00 00       	mov    $0x27,%eax
 8048f5b:	cd 2e                	int    $0x2e
 8048f5d:	89 c2                	mov    %eax,%edx
 8048f5f:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048f65:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048f6a:	90                   	nop
}
 8048f6b:	c9                   	leave  
 8048f6c:	c3                   	ret    

08048f6d <debug>:

int
debug(const char *str)
{
 8048f6d:	55                   	push   %ebp
 8048f6e:	89 e5                	mov    %esp,%ebp
 8048f70:	53                   	push   %ebx
 8048f71:	83 ec 34             	sub    $0x34,%esp
 8048f74:	e8 54 00 00 00       	call   8048fcd <__x86.get_pc_thunk.bx>
 8048f79:	81 c3 87 60 00 00    	add    $0x6087,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 8048f7f:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f82:	89 04 24             	mov    %eax,(%esp)
 8048f85:	e8 b4 02 00 00       	call   804923e <strlen>
 8048f8a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 8048f8d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 8048f93:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048f96:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 8048f9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048fa3:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048fa6:	cd 2e                	int    $0x2e
 8048fa8:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048fab:	b8 27 00 00 00       	mov    $0x27,%eax
 8048fb0:	cd 2e                	int    $0x2e
 8048fb2:	89 c2                	mov    %eax,%edx
 8048fb4:	8d 05 64 f2 04 08    	lea    0x804f264,%eax
 8048fba:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048fbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048fbf:	83 c4 34             	add    $0x34,%esp
 8048fc2:	5b                   	pop    %ebx
 8048fc3:	5d                   	pop    %ebp
 8048fc4:	c3                   	ret    

08048fc5 <__x86.get_pc_thunk.ax>:
 8048fc5:	8b 04 24             	mov    (%esp),%eax
 8048fc8:	c3                   	ret    

08048fc9 <__x86.get_pc_thunk.cx>:
 8048fc9:	8b 0c 24             	mov    (%esp),%ecx
 8048fcc:	c3                   	ret    

08048fcd <__x86.get_pc_thunk.bx>:
 8048fcd:	8b 1c 24             	mov    (%esp),%ebx
 8048fd0:	c3                   	ret    

08048fd1 <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 8048fd1:	55                   	push   %ebp
 8048fd2:	89 e5                	mov    %esp,%ebp
 8048fd4:	83 ec 10             	sub    $0x10,%esp
 8048fd7:	e8 e9 ff ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8048fdc:	05 24 60 00 00       	add    $0x6024,%eax
        const unsigned char *su1, *su2;
        signed char res = 0;
 8048fe1:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 8048fe5:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fe8:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048feb:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048fee:	89 45 f8             	mov    %eax,-0x8(%ebp)
 8048ff1:	eb 22                	jmp    8049015 <memcmp+0x44>
                if ((res = *su1 - *su2) != 0)
 8048ff3:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048ff6:	0f b6 10             	movzbl (%eax),%edx
 8048ff9:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048ffc:	0f b6 00             	movzbl (%eax),%eax
 8048fff:	28 c2                	sub    %al,%dl
 8049001:	88 d0                	mov    %dl,%al
 8049003:	88 45 f7             	mov    %al,-0x9(%ebp)
 8049006:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804900a:	75 11                	jne    804901d <memcmp+0x4c>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 804900c:	ff 45 fc             	incl   -0x4(%ebp)
 804900f:	ff 45 f8             	incl   -0x8(%ebp)
 8049012:	ff 4d 10             	decl   0x10(%ebp)
 8049015:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8049019:	75 d8                	jne    8048ff3 <memcmp+0x22>
 804901b:	eb 01                	jmp    804901e <memcmp+0x4d>
                if ((res = *su1 - *su2) != 0)
                        break;
 804901d:	90                   	nop
        return res;
 804901e:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 8049022:	c9                   	leave  
 8049023:	c3                   	ret    

08049024 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 8049024:	55                   	push   %ebp
 8049025:	89 e5                	mov    %esp,%ebp
 8049027:	83 ec 10             	sub    $0x10,%esp
 804902a:	e8 96 ff ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804902f:	05 d1 5f 00 00       	add    $0x5fd1,%eax
        char *tmp = (char *) dest;
 8049034:	8b 45 08             	mov    0x8(%ebp),%eax
 8049037:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 804903a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804903d:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 8049040:	eb 17                	jmp    8049059 <memcpy+0x35>
                *tmp++ = *s++;
 8049042:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049045:	8d 50 01             	lea    0x1(%eax),%edx
 8049048:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804904b:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804904e:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049051:	89 4d f8             	mov    %ecx,-0x8(%ebp)
 8049054:	0f b6 12             	movzbl (%edx),%edx
 8049057:	88 10                	mov    %dl,(%eax)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 8049059:	8b 45 10             	mov    0x10(%ebp),%eax
 804905c:	8d 50 ff             	lea    -0x1(%eax),%edx
 804905f:	89 55 10             	mov    %edx,0x10(%ebp)
 8049062:	85 c0                	test   %eax,%eax
 8049064:	75 dc                	jne    8049042 <memcpy+0x1e>
                *tmp++ = *s++;

        return dest;
 8049066:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049069:	c9                   	leave  
 804906a:	c3                   	ret    

0804906b <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 804906b:	55                   	push   %ebp
 804906c:	89 e5                	mov    %esp,%ebp
 804906e:	53                   	push   %ebx
 804906f:	e8 51 ff ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049074:	05 8c 5f 00 00       	add    $0x5f8c,%eax
        register signed char __res = 0;
 8049079:	b3 00                	mov    $0x0,%bl

        while (count) {
 804907b:	eb 31                	jmp    80490ae <strncmp+0x43>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 804907d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049080:	0f b6 00             	movzbl (%eax),%eax
 8049083:	88 c1                	mov    %al,%cl
 8049085:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049088:	8d 50 01             	lea    0x1(%eax),%edx
 804908b:	89 55 0c             	mov    %edx,0xc(%ebp)
 804908e:	0f b6 00             	movzbl (%eax),%eax
 8049091:	28 c1                	sub    %al,%cl
 8049093:	88 c8                	mov    %cl,%al
 8049095:	88 c3                	mov    %al,%bl
 8049097:	84 db                	test   %bl,%bl
 8049099:	75 19                	jne    80490b4 <strncmp+0x49>
 804909b:	8b 45 08             	mov    0x8(%ebp),%eax
 804909e:	8d 50 01             	lea    0x1(%eax),%edx
 80490a1:	89 55 08             	mov    %edx,0x8(%ebp)
 80490a4:	0f b6 00             	movzbl (%eax),%eax
 80490a7:	84 c0                	test   %al,%al
 80490a9:	74 09                	je     80490b4 <strncmp+0x49>
                        break;
                count--;
 80490ab:	ff 4d 10             	decl   0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 80490ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80490b2:	75 c9                	jne    804907d <strncmp+0x12>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 80490b4:	0f be c3             	movsbl %bl,%eax
}
 80490b7:	5b                   	pop    %ebx
 80490b8:	5d                   	pop    %ebp
 80490b9:	c3                   	ret    

080490ba <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 80490ba:	55                   	push   %ebp
 80490bb:	89 e5                	mov    %esp,%ebp
 80490bd:	53                   	push   %ebx
 80490be:	e8 02 ff ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80490c3:	05 3d 5f 00 00       	add    $0x5f3d,%eax
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 80490c8:	8b 45 08             	mov    0x8(%ebp),%eax
 80490cb:	0f b6 00             	movzbl (%eax),%eax
 80490ce:	88 c1                	mov    %al,%cl
 80490d0:	8b 45 0c             	mov    0xc(%ebp),%eax
 80490d3:	8d 50 01             	lea    0x1(%eax),%edx
 80490d6:	89 55 0c             	mov    %edx,0xc(%ebp)
 80490d9:	0f b6 00             	movzbl (%eax),%eax
 80490dc:	28 c1                	sub    %al,%cl
 80490de:	88 c8                	mov    %cl,%al
 80490e0:	88 c3                	mov    %al,%bl
 80490e2:	84 db                	test   %bl,%bl
 80490e4:	75 12                	jne    80490f8 <strcmp+0x3e>
 80490e6:	8b 45 08             	mov    0x8(%ebp),%eax
 80490e9:	8d 50 01             	lea    0x1(%eax),%edx
 80490ec:	89 55 08             	mov    %edx,0x8(%ebp)
 80490ef:	0f b6 00             	movzbl (%eax),%eax
 80490f2:	84 c0                	test   %al,%al
 80490f4:	74 02                	je     80490f8 <strcmp+0x3e>
                        break;
        }
 80490f6:	eb d0                	jmp    80490c8 <strcmp+0xe>

        return __res;
 80490f8:	0f be c3             	movsbl %bl,%eax
}
 80490fb:	5b                   	pop    %ebx
 80490fc:	5d                   	pop    %ebp
 80490fd:	c3                   	ret    

080490fe <strcpy>:

char *strcpy(char *dest, const char *src)
{
 80490fe:	55                   	push   %ebp
 80490ff:	89 e5                	mov    %esp,%ebp
 8049101:	83 ec 10             	sub    $0x10,%esp
 8049104:	e8 bc fe ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049109:	05 f7 5e 00 00       	add    $0x5ef7,%eax
        char *tmp = dest;
 804910e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049111:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 8049114:	90                   	nop
 8049115:	8b 45 08             	mov    0x8(%ebp),%eax
 8049118:	8d 50 01             	lea    0x1(%eax),%edx
 804911b:	89 55 08             	mov    %edx,0x8(%ebp)
 804911e:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049121:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049124:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 8049127:	0f b6 12             	movzbl (%edx),%edx
 804912a:	88 10                	mov    %dl,(%eax)
 804912c:	0f b6 00             	movzbl (%eax),%eax
 804912f:	84 c0                	test   %al,%al
 8049131:	75 e2                	jne    8049115 <strcpy+0x17>
                /* nothing */;
        return tmp;
 8049133:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049136:	c9                   	leave  
 8049137:	c3                   	ret    

08049138 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 8049138:	55                   	push   %ebp
 8049139:	89 e5                	mov    %esp,%ebp
 804913b:	83 ec 10             	sub    $0x10,%esp
 804913e:	e8 82 fe ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049143:	05 bd 5e 00 00       	add    $0x5ebd,%eax
        char *tmp = dest;
 8049148:	8b 45 08             	mov    0x8(%ebp),%eax
 804914b:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804914e:	90                   	nop
 804914f:	8b 45 10             	mov    0x10(%ebp),%eax
 8049152:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049155:	89 55 10             	mov    %edx,0x10(%ebp)
 8049158:	85 c0                	test   %eax,%eax
 804915a:	74 1e                	je     804917a <strncpy+0x42>
 804915c:	8b 45 08             	mov    0x8(%ebp),%eax
 804915f:	8d 50 01             	lea    0x1(%eax),%edx
 8049162:	89 55 08             	mov    %edx,0x8(%ebp)
 8049165:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049168:	8d 4a 01             	lea    0x1(%edx),%ecx
 804916b:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804916e:	0f b6 12             	movzbl (%edx),%edx
 8049171:	88 10                	mov    %dl,(%eax)
 8049173:	0f b6 00             	movzbl (%eax),%eax
 8049176:	84 c0                	test   %al,%al
 8049178:	75 d5                	jne    804914f <strncpy+0x17>
                /* nothing */;

        return tmp;
 804917a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804917d:	c9                   	leave  
 804917e:	c3                   	ret    

0804917f <memset>:

void *memset(void *s, int c, size_t count)
{
 804917f:	55                   	push   %ebp
 8049180:	89 e5                	mov    %esp,%ebp
 8049182:	83 ec 10             	sub    $0x10,%esp
 8049185:	e8 3b fe ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804918a:	05 76 5e 00 00       	add    $0x5e76,%eax
        char *xs = (char *) s;
 804918f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049192:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 8049195:	eb 0e                	jmp    80491a5 <memset+0x26>
                *xs++ = c;
 8049197:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804919a:	8d 50 01             	lea    0x1(%eax),%edx
 804919d:	89 55 fc             	mov    %edx,-0x4(%ebp)
 80491a0:	8b 55 0c             	mov    0xc(%ebp),%edx
 80491a3:	88 10                	mov    %dl,(%eax)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 80491a5:	8b 45 10             	mov    0x10(%ebp),%eax
 80491a8:	8d 50 ff             	lea    -0x1(%eax),%edx
 80491ab:	89 55 10             	mov    %edx,0x10(%ebp)
 80491ae:	85 c0                	test   %eax,%eax
 80491b0:	75 e5                	jne    8049197 <memset+0x18>
                *xs++ = c;

        return s;
 80491b2:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80491b5:	c9                   	leave  
 80491b6:	c3                   	ret    

080491b7 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 80491b7:	55                   	push   %ebp
 80491b8:	89 e5                	mov    %esp,%ebp
 80491ba:	83 ec 10             	sub    $0x10,%esp
 80491bd:	e8 03 fe ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80491c2:	05 3e 5e 00 00       	add    $0x5e3e,%eax
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 80491c7:	8b 45 08             	mov    0x8(%ebp),%eax
 80491ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80491cd:	eb 03                	jmp    80491d2 <strnlen+0x1b>
 80491cf:	ff 45 fc             	incl   -0x4(%ebp)
 80491d2:	8b 45 0c             	mov    0xc(%ebp),%eax
 80491d5:	8d 50 ff             	lea    -0x1(%eax),%edx
 80491d8:	89 55 0c             	mov    %edx,0xc(%ebp)
 80491db:	85 c0                	test   %eax,%eax
 80491dd:	74 0a                	je     80491e9 <strnlen+0x32>
 80491df:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80491e2:	0f b6 00             	movzbl (%eax),%eax
 80491e5:	84 c0                	test   %al,%al
 80491e7:	75 e6                	jne    80491cf <strnlen+0x18>
                /* nothing */;
        return sc - s;
 80491e9:	8b 55 fc             	mov    -0x4(%ebp),%edx
 80491ec:	8b 45 08             	mov    0x8(%ebp),%eax
 80491ef:	29 c2                	sub    %eax,%edx
 80491f1:	89 d0                	mov    %edx,%eax
}
 80491f3:	c9                   	leave  
 80491f4:	c3                   	ret    

080491f5 <strcat>:


char *strcat(char *dest, const char *src)
{
 80491f5:	55                   	push   %ebp
 80491f6:	89 e5                	mov    %esp,%ebp
 80491f8:	83 ec 10             	sub    $0x10,%esp
 80491fb:	e8 c5 fd ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049200:	05 00 5e 00 00       	add    $0x5e00,%eax
        char *tmp = dest;
 8049205:	8b 45 08             	mov    0x8(%ebp),%eax
 8049208:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 804920b:	eb 03                	jmp    8049210 <strcat+0x1b>
                dest++;
 804920d:	ff 45 08             	incl   0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 8049210:	8b 45 08             	mov    0x8(%ebp),%eax
 8049213:	0f b6 00             	movzbl (%eax),%eax
 8049216:	84 c0                	test   %al,%al
 8049218:	75 f3                	jne    804920d <strcat+0x18>
                dest++;

        while ((*dest++ = *src++) != '\0');
 804921a:	90                   	nop
 804921b:	8b 45 08             	mov    0x8(%ebp),%eax
 804921e:	8d 50 01             	lea    0x1(%eax),%edx
 8049221:	89 55 08             	mov    %edx,0x8(%ebp)
 8049224:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049227:	8d 4a 01             	lea    0x1(%edx),%ecx
 804922a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804922d:	0f b6 12             	movzbl (%edx),%edx
 8049230:	88 10                	mov    %dl,(%eax)
 8049232:	0f b6 00             	movzbl (%eax),%eax
 8049235:	84 c0                	test   %al,%al
 8049237:	75 e2                	jne    804921b <strcat+0x26>

        return tmp;
 8049239:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804923c:	c9                   	leave  
 804923d:	c3                   	ret    

0804923e <strlen>:

size_t strlen(const char *s)
{
 804923e:	55                   	push   %ebp
 804923f:	89 e5                	mov    %esp,%ebp
 8049241:	83 ec 10             	sub    $0x10,%esp
 8049244:	e8 7c fd ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049249:	05 b7 5d 00 00       	add    $0x5db7,%eax
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 804924e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049251:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8049254:	eb 03                	jmp    8049259 <strlen+0x1b>
 8049256:	ff 45 fc             	incl   -0x4(%ebp)
 8049259:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804925c:	0f b6 00             	movzbl (%eax),%eax
 804925f:	84 c0                	test   %al,%al
 8049261:	75 f3                	jne    8049256 <strlen+0x18>
                /* nothing */;
        return sc - s;
 8049263:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049266:	8b 45 08             	mov    0x8(%ebp),%eax
 8049269:	29 c2                	sub    %eax,%edx
 804926b:	89 d0                	mov    %edx,%eax
}
 804926d:	c9                   	leave  
 804926e:	c3                   	ret    

0804926f <strchr>:

char *strchr(const char *s, int c)
{
 804926f:	55                   	push   %ebp
 8049270:	89 e5                	mov    %esp,%ebp
 8049272:	e8 4e fd ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049277:	05 89 5d 00 00       	add    $0x5d89,%eax
        for (; *s != (char) c; ++s)
 804927c:	eb 14                	jmp    8049292 <strchr+0x23>
                if (*s == '\0')
 804927e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049281:	0f b6 00             	movzbl (%eax),%eax
 8049284:	84 c0                	test   %al,%al
 8049286:	75 07                	jne    804928f <strchr+0x20>
                        return NULL;
 8049288:	b8 00 00 00 00       	mov    $0x0,%eax
 804928d:	eb 13                	jmp    80492a2 <strchr+0x33>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 804928f:	ff 45 08             	incl   0x8(%ebp)
 8049292:	8b 45 08             	mov    0x8(%ebp),%eax
 8049295:	0f b6 00             	movzbl (%eax),%eax
 8049298:	8b 55 0c             	mov    0xc(%ebp),%edx
 804929b:	38 d0                	cmp    %dl,%al
 804929d:	75 df                	jne    804927e <strchr+0xf>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 804929f:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80492a2:	5d                   	pop    %ebp
 80492a3:	c3                   	ret    

080492a4 <strrchr>:

char *strrchr(const char *s, int c)
{
 80492a4:	55                   	push   %ebp
 80492a5:	89 e5                	mov    %esp,%ebp
 80492a7:	83 ec 10             	sub    $0x10,%esp
 80492aa:	e8 16 fd ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80492af:	05 51 5d 00 00       	add    $0x5d51,%eax
        char *r = NULL;
 80492b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 80492bb:	eb 16                	jmp    80492d3 <strrchr+0x2f>
                if (*s == (char)c)
 80492bd:	8b 45 08             	mov    0x8(%ebp),%eax
 80492c0:	0f b6 00             	movzbl (%eax),%eax
 80492c3:	8b 55 0c             	mov    0xc(%ebp),%edx
 80492c6:	38 d0                	cmp    %dl,%al
 80492c8:	75 06                	jne    80492d0 <strrchr+0x2c>
                        r = (char *)s;
 80492ca:	8b 45 08             	mov    0x8(%ebp),%eax
 80492cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 80492d0:	ff 45 08             	incl   0x8(%ebp)
 80492d3:	8b 45 08             	mov    0x8(%ebp),%eax
 80492d6:	0f b6 00             	movzbl (%eax),%eax
 80492d9:	84 c0                	test   %al,%al
 80492db:	75 e0                	jne    80492bd <strrchr+0x19>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 80492dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80492e0:	c9                   	leave  
 80492e1:	c3                   	ret    

080492e2 <strstr>:

char *strstr(const char *s1, const char *s2)
{
 80492e2:	55                   	push   %ebp
 80492e3:	89 e5                	mov    %esp,%ebp
 80492e5:	53                   	push   %ebx
 80492e6:	83 ec 24             	sub    $0x24,%esp
 80492e9:	e8 df fc ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 80492ee:	81 c3 12 5d 00 00    	add    $0x5d12,%ebx
        int l1, l2;

        l2 = strlen(s2);
 80492f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 80492f7:	89 04 24             	mov    %eax,(%esp)
 80492fa:	e8 3f ff ff ff       	call   804923e <strlen>
 80492ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 8049302:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049306:	75 05                	jne    804930d <strstr+0x2b>
                return (char *) s1;
 8049308:	8b 45 08             	mov    0x8(%ebp),%eax
 804930b:	eb 45                	jmp    8049352 <strstr+0x70>
        l1 = strlen(s1);
 804930d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049310:	89 04 24             	mov    %eax,(%esp)
 8049313:	e8 26 ff ff ff       	call   804923e <strlen>
 8049318:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 804931b:	eb 28                	jmp    8049345 <strstr+0x63>
                l1--;
 804931d:	ff 4d f4             	decl   -0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 8049320:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049323:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049327:	8b 45 0c             	mov    0xc(%ebp),%eax
 804932a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804932e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049331:	89 04 24             	mov    %eax,(%esp)
 8049334:	e8 98 fc ff ff       	call   8048fd1 <memcmp>
 8049339:	85 c0                	test   %eax,%eax
 804933b:	75 05                	jne    8049342 <strstr+0x60>
                        return (char *) s1;
 804933d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049340:	eb 10                	jmp    8049352 <strstr+0x70>
                s1++;
 8049342:	ff 45 08             	incl   0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 8049345:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049348:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804934b:	7d d0                	jge    804931d <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 804934d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049352:	83 c4 24             	add    $0x24,%esp
 8049355:	5b                   	pop    %ebx
 8049356:	5d                   	pop    %ebp
 8049357:	c3                   	ret    

08049358 <strdup>:

char *strdup(const char *s)
{
 8049358:	55                   	push   %ebp
 8049359:	89 e5                	mov    %esp,%ebp
 804935b:	e8 65 fc ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049360:	05 a0 5c 00 00       	add    $0x5ca0,%eax
        /* TODO - alvin */
        return NULL;
 8049365:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804936a:	5d                   	pop    %ebp
 804936b:	c3                   	ret    

0804936c <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 804936c:	55                   	push   %ebp
 804936d:	89 e5                	mov    %esp,%ebp
 804936f:	83 ec 10             	sub    $0x10,%esp
 8049372:	e8 4e fc ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 8049377:	05 89 5c 00 00       	add    $0x5c89,%eax
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 804937c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804937f:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8049382:	eb 03                	jmp    8049387 <strpbrk+0x1b>
 8049384:	ff 45 fc             	incl   -0x4(%ebp)
 8049387:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804938a:	0f b6 00             	movzbl (%eax),%eax
 804938d:	84 c0                	test   %al,%al
 804938f:	74 10                	je     80493a1 <strpbrk+0x35>
 8049391:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049394:	0f b6 10             	movzbl (%eax),%edx
 8049397:	8b 45 08             	mov    0x8(%ebp),%eax
 804939a:	0f b6 00             	movzbl (%eax),%eax
 804939d:	38 c2                	cmp    %al,%dl
 804939f:	75 e3                	jne    8049384 <strpbrk+0x18>
                        ;
                if (*p != '\0')
 80493a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80493a4:	0f b6 00             	movzbl (%eax),%eax
 80493a7:	84 c0                	test   %al,%al
 80493a9:	74 05                	je     80493b0 <strpbrk+0x44>
                        return ((char *)string);
 80493ab:	8b 45 08             	mov    0x8(%ebp),%eax
 80493ae:	eb 15                	jmp    80493c5 <strpbrk+0x59>
        } while (*string++);
 80493b0:	8b 45 08             	mov    0x8(%ebp),%eax
 80493b3:	8d 50 01             	lea    0x1(%eax),%edx
 80493b6:	89 55 08             	mov    %edx,0x8(%ebp)
 80493b9:	0f b6 00             	movzbl (%eax),%eax
 80493bc:	84 c0                	test   %al,%al
 80493be:	75 bc                	jne    804937c <strpbrk+0x10>

        return (NULL);
 80493c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80493c5:	c9                   	leave  
 80493c6:	c3                   	ret    

080493c7 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 80493c7:	55                   	push   %ebp
 80493c8:	89 e5                	mov    %esp,%ebp
 80493ca:	83 ec 10             	sub    $0x10,%esp
 80493cd:	e8 f3 fb ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80493d2:	05 2e 5c 00 00       	add    $0x5c2e,%eax
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 80493d7:	8b 45 08             	mov    0x8(%ebp),%eax
 80493da:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80493dd:	eb 32                	jmp    8049411 <strspn+0x4a>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 80493df:	8b 45 0c             	mov    0xc(%ebp),%eax
 80493e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80493e5:	eb 03                	jmp    80493ea <strspn+0x23>
 80493e7:	ff 45 fc             	incl   -0x4(%ebp)
 80493ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80493ed:	0f b6 00             	movzbl (%eax),%eax
 80493f0:	84 c0                	test   %al,%al
 80493f2:	74 10                	je     8049404 <strspn+0x3d>
 80493f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80493f7:	0f b6 10             	movzbl (%eax),%edx
 80493fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80493fd:	0f b6 00             	movzbl (%eax),%eax
 8049400:	38 c2                	cmp    %al,%dl
 8049402:	75 e3                	jne    80493e7 <strspn+0x20>
                        ;
                if (*p == '\0')
 8049404:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049407:	0f b6 00             	movzbl (%eax),%eax
 804940a:	84 c0                	test   %al,%al
 804940c:	74 0f                	je     804941d <strspn+0x56>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804940e:	ff 45 f8             	incl   -0x8(%ebp)
 8049411:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049414:	0f b6 00             	movzbl (%eax),%eax
 8049417:	84 c0                	test   %al,%al
 8049419:	75 c4                	jne    80493df <strspn+0x18>
 804941b:	eb 01                	jmp    804941e <strspn+0x57>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 804941d:	90                   	nop
        }

        return (q - string);
 804941e:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8049421:	8b 45 08             	mov    0x8(%ebp),%eax
 8049424:	29 c2                	sub    %eax,%edx
 8049426:	89 d0                	mov    %edx,%eax
}
 8049428:	c9                   	leave  
 8049429:	c3                   	ret    

0804942a <strtok>:

char *
strtok(char *string, const char *sepset)
{
 804942a:	55                   	push   %ebp
 804942b:	89 e5                	mov    %esp,%ebp
 804942d:	53                   	push   %ebx
 804942e:	83 ec 24             	sub    $0x24,%esp
 8049431:	e8 97 fb ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049436:	81 c3 ca 5b 00 00    	add    $0x5bca,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 804943c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049440:	75 08                	jne    804944a <strtok+0x20>
 8049442:	8b 83 04 02 00 00    	mov    0x204(%ebx),%eax
 8049448:	eb 03                	jmp    804944d <strtok+0x23>
 804944a:	8b 45 08             	mov    0x8(%ebp),%eax
 804944d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 8049450:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049454:	75 07                	jne    804945d <strtok+0x33>
                return (NULL);
 8049456:	b8 00 00 00 00       	mov    $0x0,%eax
 804945b:	eb 69                	jmp    80494c6 <strtok+0x9c>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 804945d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049460:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049464:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049467:	89 04 24             	mov    %eax,(%esp)
 804946a:	e8 58 ff ff ff       	call   80493c7 <strspn>
 804946f:	89 c2                	mov    %eax,%edx
 8049471:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049474:	01 d0                	add    %edx,%eax
 8049476:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 8049479:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804947c:	0f b6 00             	movzbl (%eax),%eax
 804947f:	84 c0                	test   %al,%al
 8049481:	75 07                	jne    804948a <strtok+0x60>
                return (NULL);
 8049483:	b8 00 00 00 00       	mov    $0x0,%eax
 8049488:	eb 3c                	jmp    80494c6 <strtok+0x9c>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 804948a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804948d:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049491:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049494:	89 04 24             	mov    %eax,(%esp)
 8049497:	e8 d0 fe ff ff       	call   804936c <strpbrk>
 804949c:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804949f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 80494a3:	75 0c                	jne    80494b1 <strtok+0x87>
                savept = NULL;
 80494a5:	c7 83 04 02 00 00 00 	movl   $0x0,0x204(%ebx)
 80494ac:	00 00 00 
 80494af:	eb 12                	jmp    80494c3 <strtok+0x99>
        else {
                *r = '\0';
 80494b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80494b4:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 80494b7:	ff 45 ec             	incl   -0x14(%ebp)
 80494ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80494bd:	89 83 04 02 00 00    	mov    %eax,0x204(%ebx)
        }

        return (q);
 80494c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80494c6:	83 c4 24             	add    $0x24,%esp
 80494c9:	5b                   	pop    %ebx
 80494ca:	5d                   	pop    %ebp
 80494cb:	c3                   	ret    

080494cc <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 80494cc:	55                   	push   %ebp
 80494cd:	89 e5                	mov    %esp,%ebp
 80494cf:	e8 f1 fa ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 80494d4:	05 2c 5b 00 00       	add    $0x5b2c,%eax
        switch (errnum) {
 80494d9:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 80494e0:	0f 87 e8 04 00 00    	ja     80499ce <.L90>
 80494e6:	8b 55 08             	mov    0x8(%ebp),%edx
 80494e9:	c1 e2 02             	shl    $0x2,%edx
 80494ec:	8b 94 02 4c ea ff ff 	mov    -0x15b4(%edx,%eax,1),%edx
 80494f3:	01 c2                	add    %eax,%edx
 80494f5:	ff e2                	jmp    *%edx

080494f7 <.L91>:
                case EPERM: return "Not super-user";
 80494f7:	8d 80 90 df ff ff    	lea    -0x2070(%eax),%eax
 80494fd:	e9 d1 04 00 00       	jmp    80499d3 <.L90+0x5>

08049502 <.L93>:
                case ENOENT: return "No such file or directory";
 8049502:	8d 80 9f df ff ff    	lea    -0x2061(%eax),%eax
 8049508:	e9 c6 04 00 00       	jmp    80499d3 <.L90+0x5>

0804950d <.L94>:
                case ESRCH: return "No such process";
 804950d:	8d 80 b9 df ff ff    	lea    -0x2047(%eax),%eax
 8049513:	e9 bb 04 00 00       	jmp    80499d3 <.L90+0x5>

08049518 <.L95>:
                case EINTR: return "interrupted system call";
 8049518:	8d 80 c9 df ff ff    	lea    -0x2037(%eax),%eax
 804951e:	e9 b0 04 00 00       	jmp    80499d3 <.L90+0x5>

08049523 <.L96>:
                case EIO: return "I/O error";
 8049523:	8d 80 e1 df ff ff    	lea    -0x201f(%eax),%eax
 8049529:	e9 a5 04 00 00       	jmp    80499d3 <.L90+0x5>

0804952e <.L97>:
                case ENXIO: return "No such device or address";
 804952e:	8d 80 eb df ff ff    	lea    -0x2015(%eax),%eax
 8049534:	e9 9a 04 00 00       	jmp    80499d3 <.L90+0x5>

08049539 <.L98>:
                case E2BIG: return "Arg list too long";
 8049539:	8d 80 05 e0 ff ff    	lea    -0x1ffb(%eax),%eax
 804953f:	e9 8f 04 00 00       	jmp    80499d3 <.L90+0x5>

08049544 <.L99>:
                case ENOEXEC: return "Exec format error";
 8049544:	8d 80 17 e0 ff ff    	lea    -0x1fe9(%eax),%eax
 804954a:	e9 84 04 00 00       	jmp    80499d3 <.L90+0x5>

0804954f <.L100>:
                case EBADF: return "Bad file number";
 804954f:	8d 80 29 e0 ff ff    	lea    -0x1fd7(%eax),%eax
 8049555:	e9 79 04 00 00       	jmp    80499d3 <.L90+0x5>

0804955a <.L101>:
                case ECHILD: return "No children";
 804955a:	8d 80 39 e0 ff ff    	lea    -0x1fc7(%eax),%eax
 8049560:	e9 6e 04 00 00       	jmp    80499d3 <.L90+0x5>

08049565 <.L102>:
                case EAGAIN: return "Resource temporarily unavailable";
 8049565:	8d 80 48 e0 ff ff    	lea    -0x1fb8(%eax),%eax
 804956b:	e9 63 04 00 00       	jmp    80499d3 <.L90+0x5>

08049570 <.L103>:
                case ENOMEM: return "Not enough core";
 8049570:	8d 80 69 e0 ff ff    	lea    -0x1f97(%eax),%eax
 8049576:	e9 58 04 00 00       	jmp    80499d3 <.L90+0x5>

0804957b <.L104>:
                case EACCES: return "Permission denied";
 804957b:	8d 80 79 e0 ff ff    	lea    -0x1f87(%eax),%eax
 8049581:	e9 4d 04 00 00       	jmp    80499d3 <.L90+0x5>

08049586 <.L105>:
                case EFAULT: return "Bad address";
 8049586:	8d 80 8b e0 ff ff    	lea    -0x1f75(%eax),%eax
 804958c:	e9 42 04 00 00       	jmp    80499d3 <.L90+0x5>

08049591 <.L106>:
                case ENOTBLK: return "Block device required";
 8049591:	8d 80 97 e0 ff ff    	lea    -0x1f69(%eax),%eax
 8049597:	e9 37 04 00 00       	jmp    80499d3 <.L90+0x5>

0804959c <.L107>:
                case EBUSY: return "Mount device busy";
 804959c:	8d 80 ad e0 ff ff    	lea    -0x1f53(%eax),%eax
 80495a2:	e9 2c 04 00 00       	jmp    80499d3 <.L90+0x5>

080495a7 <.L108>:
                case EEXIST: return "File exists";
 80495a7:	8d 80 bf e0 ff ff    	lea    -0x1f41(%eax),%eax
 80495ad:	e9 21 04 00 00       	jmp    80499d3 <.L90+0x5>

080495b2 <.L109>:
                case EXDEV: return "Cross-device link";
 80495b2:	8d 80 cb e0 ff ff    	lea    -0x1f35(%eax),%eax
 80495b8:	e9 16 04 00 00       	jmp    80499d3 <.L90+0x5>

080495bd <.L110>:
                case ENODEV: return "No such device";
 80495bd:	8d 80 dd e0 ff ff    	lea    -0x1f23(%eax),%eax
 80495c3:	e9 0b 04 00 00       	jmp    80499d3 <.L90+0x5>

080495c8 <.L111>:
                case ENOTDIR: return "Not a directory";
 80495c8:	8d 80 ec e0 ff ff    	lea    -0x1f14(%eax),%eax
 80495ce:	e9 00 04 00 00       	jmp    80499d3 <.L90+0x5>

080495d3 <.L112>:
                case EISDIR: return "Is a directory";
 80495d3:	8d 80 fc e0 ff ff    	lea    -0x1f04(%eax),%eax
 80495d9:	e9 f5 03 00 00       	jmp    80499d3 <.L90+0x5>

080495de <.L113>:
                case EINVAL: return "Invalid argument";
 80495de:	8d 80 0b e1 ff ff    	lea    -0x1ef5(%eax),%eax
 80495e4:	e9 ea 03 00 00       	jmp    80499d3 <.L90+0x5>

080495e9 <.L114>:
                case ENFILE: return "File table overflow";
 80495e9:	8d 80 1c e1 ff ff    	lea    -0x1ee4(%eax),%eax
 80495ef:	e9 df 03 00 00       	jmp    80499d3 <.L90+0x5>

080495f4 <.L115>:
                case EMFILE: return "Too many open files";
 80495f4:	8d 80 30 e1 ff ff    	lea    -0x1ed0(%eax),%eax
 80495fa:	e9 d4 03 00 00       	jmp    80499d3 <.L90+0x5>

080495ff <.L116>:
                case ENOTTY: return "Inappropriate ioctl for device";
 80495ff:	8d 80 44 e1 ff ff    	lea    -0x1ebc(%eax),%eax
 8049605:	e9 c9 03 00 00       	jmp    80499d3 <.L90+0x5>

0804960a <.L117>:
                case ETXTBSY: return "Text file busy";
 804960a:	8d 80 63 e1 ff ff    	lea    -0x1e9d(%eax),%eax
 8049610:	e9 be 03 00 00       	jmp    80499d3 <.L90+0x5>

08049615 <.L118>:
                case EFBIG: return "File too large";
 8049615:	8d 80 72 e1 ff ff    	lea    -0x1e8e(%eax),%eax
 804961b:	e9 b3 03 00 00       	jmp    80499d3 <.L90+0x5>

08049620 <.L119>:
                case ENOSPC: return "No space left on device";
 8049620:	8d 80 81 e1 ff ff    	lea    -0x1e7f(%eax),%eax
 8049626:	e9 a8 03 00 00       	jmp    80499d3 <.L90+0x5>

0804962b <.L120>:
                case ESPIPE: return "Illegal seek";
 804962b:	8d 80 99 e1 ff ff    	lea    -0x1e67(%eax),%eax
 8049631:	e9 9d 03 00 00       	jmp    80499d3 <.L90+0x5>

08049636 <.L121>:
                case EROFS: return "Read only file system";
 8049636:	8d 80 a6 e1 ff ff    	lea    -0x1e5a(%eax),%eax
 804963c:	e9 92 03 00 00       	jmp    80499d3 <.L90+0x5>

08049641 <.L122>:
                case EMLINK: return "Too many links";
 8049641:	8d 80 bc e1 ff ff    	lea    -0x1e44(%eax),%eax
 8049647:	e9 87 03 00 00       	jmp    80499d3 <.L90+0x5>

0804964c <.L123>:
                case EPIPE: return "Broken pipe";
 804964c:	8d 80 cb e1 ff ff    	lea    -0x1e35(%eax),%eax
 8049652:	e9 7c 03 00 00       	jmp    80499d3 <.L90+0x5>

08049657 <.L124>:
                case EDOM: return "Math arg out of domain of func";
 8049657:	8d 80 d8 e1 ff ff    	lea    -0x1e28(%eax),%eax
 804965d:	e9 71 03 00 00       	jmp    80499d3 <.L90+0x5>

08049662 <.L125>:
                case ERANGE: return "Math result not representable";
 8049662:	8d 80 f7 e1 ff ff    	lea    -0x1e09(%eax),%eax
 8049668:	e9 66 03 00 00       	jmp    80499d3 <.L90+0x5>

0804966d <.L132>:
                case ENOMSG: return "No message of desired type";
 804966d:	8d 80 15 e2 ff ff    	lea    -0x1deb(%eax),%eax
 8049673:	e9 5b 03 00 00       	jmp    80499d3 <.L90+0x5>

08049678 <.L133>:
                case EIDRM: return "Identifier removed";
 8049678:	8d 80 30 e2 ff ff    	lea    -0x1dd0(%eax),%eax
 804967e:	e9 50 03 00 00       	jmp    80499d3 <.L90+0x5>

08049683 <.L134>:
                case ECHRNG: return "Channel number out of range";
 8049683:	8d 80 43 e2 ff ff    	lea    -0x1dbd(%eax),%eax
 8049689:	e9 45 03 00 00       	jmp    80499d3 <.L90+0x5>

0804968e <.L135>:
                case EL2NSYNC: return "Level 2 not synchronized";
 804968e:	8d 80 5f e2 ff ff    	lea    -0x1da1(%eax),%eax
 8049694:	e9 3a 03 00 00       	jmp    80499d3 <.L90+0x5>

08049699 <.L136>:
                case EL3HLT: return "Level 3 halted";
 8049699:	8d 80 78 e2 ff ff    	lea    -0x1d88(%eax),%eax
 804969f:	e9 2f 03 00 00       	jmp    80499d3 <.L90+0x5>

080496a4 <.L137>:
                case EL3RST: return "Level 3 reset";
 80496a4:	8d 80 87 e2 ff ff    	lea    -0x1d79(%eax),%eax
 80496aa:	e9 24 03 00 00       	jmp    80499d3 <.L90+0x5>

080496af <.L138>:
                case ELNRNG: return "Link number out of range";
 80496af:	8d 80 95 e2 ff ff    	lea    -0x1d6b(%eax),%eax
 80496b5:	e9 19 03 00 00       	jmp    80499d3 <.L90+0x5>

080496ba <.L139>:
                case EUNATCH: return "Protocol driver not attached";
 80496ba:	8d 80 ae e2 ff ff    	lea    -0x1d52(%eax),%eax
 80496c0:	e9 0e 03 00 00       	jmp    80499d3 <.L90+0x5>

080496c5 <.L140>:
                case ENOCSI: return "No CSI structure available";
 80496c5:	8d 80 cb e2 ff ff    	lea    -0x1d35(%eax),%eax
 80496cb:	e9 03 03 00 00       	jmp    80499d3 <.L90+0x5>

080496d0 <.L141>:
                case EL2HLT: return "Level 2 halted";
 80496d0:	8d 80 e6 e2 ff ff    	lea    -0x1d1a(%eax),%eax
 80496d6:	e9 f8 02 00 00       	jmp    80499d3 <.L90+0x5>

080496db <.L126>:
                case EDEADLK: return "Deadlock condition.";
 80496db:	8d 80 f5 e2 ff ff    	lea    -0x1d0b(%eax),%eax
 80496e1:	e9 ed 02 00 00       	jmp    80499d3 <.L90+0x5>

080496e6 <.L128>:
                case ENOLCK: return "No record locks available.";
 80496e6:	8d 80 09 e3 ff ff    	lea    -0x1cf7(%eax),%eax
 80496ec:	e9 e2 02 00 00       	jmp    80499d3 <.L90+0x5>

080496f1 <.L206>:
                case ECANCELED: return "Operation canceled";
 80496f1:	8d 80 24 e3 ff ff    	lea    -0x1cdc(%eax),%eax
 80496f7:	e9 d7 02 00 00       	jmp    80499d3 <.L90+0x5>

080496fc <.L183>:
                case ENOTSUP: return "Operation not supported";
 80496fc:	8d 80 37 e3 ff ff    	lea    -0x1cc9(%eax),%eax
 8049702:	e9 cc 02 00 00       	jmp    80499d3 <.L90+0x5>

08049707 <.L205>:
                case EDQUOT: return "Disc quota exceeded";
 8049707:	8d 80 4f e3 ff ff    	lea    -0x1cb1(%eax),%eax
 804970d:	e9 c1 02 00 00       	jmp    80499d3 <.L90+0x5>

08049712 <.L142>:
                case EBADE: return "invalid exchange";
 8049712:	8d 80 63 e3 ff ff    	lea    -0x1c9d(%eax),%eax
 8049718:	e9 b6 02 00 00       	jmp    80499d3 <.L90+0x5>

0804971d <.L143>:
                case EBADR: return "invalid request descriptor";
 804971d:	8d 80 74 e3 ff ff    	lea    -0x1c8c(%eax),%eax
 8049723:	e9 ab 02 00 00       	jmp    80499d3 <.L90+0x5>

08049728 <.L144>:
                case EXFULL: return "exchange full";
 8049728:	8d 80 8f e3 ff ff    	lea    -0x1c71(%eax),%eax
 804972e:	e9 a0 02 00 00       	jmp    80499d3 <.L90+0x5>

08049733 <.L145>:
                case ENOANO: return "no anode";
 8049733:	8d 80 9d e3 ff ff    	lea    -0x1c63(%eax),%eax
 8049739:	e9 95 02 00 00       	jmp    80499d3 <.L90+0x5>

0804973e <.L146>:
                case EBADRQC: return "invalid request code";
 804973e:	8d 80 a6 e3 ff ff    	lea    -0x1c5a(%eax),%eax
 8049744:	e9 8a 02 00 00       	jmp    80499d3 <.L90+0x5>

08049749 <.L147>:
                case EBADSLT: return "invalid slot";
 8049749:	8d 80 bb e3 ff ff    	lea    -0x1c45(%eax),%eax
 804974f:	e9 7f 02 00 00       	jmp    80499d3 <.L90+0x5>

08049754 <.L148>:
                case EBFONT: return "bad font file fmt";
 8049754:	8d 80 c8 e3 ff ff    	lea    -0x1c38(%eax),%eax
 804975a:	e9 74 02 00 00       	jmp    80499d3 <.L90+0x5>

0804975f <.L207>:
                case EOWNERDEAD: return "process died with the lock";
 804975f:	8d 80 da e3 ff ff    	lea    -0x1c26(%eax),%eax
 8049765:	e9 69 02 00 00       	jmp    80499d3 <.L90+0x5>

0804976a <.L208>:
                case ENOTRECOVERABLE: return "lock is not recoverable";
 804976a:	8d 80 f5 e3 ff ff    	lea    -0x1c0b(%eax),%eax
 8049770:	e9 5e 02 00 00       	jmp    80499d3 <.L90+0x5>

08049775 <.L149>:
                case ENOSTR: return "Device not a stream";
 8049775:	8d 80 0d e4 ff ff    	lea    -0x1bf3(%eax),%eax
 804977b:	e9 53 02 00 00       	jmp    80499d3 <.L90+0x5>

08049780 <.L150>:
                case ENODATA: return "no data (for no delay io)";
 8049780:	8d 80 21 e4 ff ff    	lea    -0x1bdf(%eax),%eax
 8049786:	e9 48 02 00 00       	jmp    80499d3 <.L90+0x5>

0804978b <.L151>:
                case ETIME: return "timer expired";
 804978b:	8d 80 3b e4 ff ff    	lea    -0x1bc5(%eax),%eax
 8049791:	e9 3d 02 00 00       	jmp    80499d3 <.L90+0x5>

08049796 <.L152>:
                case ENOSR: return "out of streams resources";
 8049796:	8d 80 49 e4 ff ff    	lea    -0x1bb7(%eax),%eax
 804979c:	e9 32 02 00 00       	jmp    80499d3 <.L90+0x5>

080497a1 <.L153>:
                case ENONET: return "Machine is not on the network";
 80497a1:	8d 80 62 e4 ff ff    	lea    -0x1b9e(%eax),%eax
 80497a7:	e9 27 02 00 00       	jmp    80499d3 <.L90+0x5>

080497ac <.L154>:
                case ENOPKG: return "Package not installed";
 80497ac:	8d 80 80 e4 ff ff    	lea    -0x1b80(%eax),%eax
 80497b2:	e9 1c 02 00 00       	jmp    80499d3 <.L90+0x5>

080497b7 <.L155>:
                case EREMOTE: return "The object is remote";
 80497b7:	8d 80 96 e4 ff ff    	lea    -0x1b6a(%eax),%eax
 80497bd:	e9 11 02 00 00       	jmp    80499d3 <.L90+0x5>

080497c2 <.L156>:
                case ENOLINK: return "the link has been severed";
 80497c2:	8d 80 ab e4 ff ff    	lea    -0x1b55(%eax),%eax
 80497c8:	e9 06 02 00 00       	jmp    80499d3 <.L90+0x5>

080497cd <.L157>:
                case EADV: return "advertise error";
 80497cd:	8d 80 c5 e4 ff ff    	lea    -0x1b3b(%eax),%eax
 80497d3:	e9 fb 01 00 00       	jmp    80499d3 <.L90+0x5>

080497d8 <.L158>:
                case ESRMNT: return "srmount error";
 80497d8:	8d 80 d5 e4 ff ff    	lea    -0x1b2b(%eax),%eax
 80497de:	e9 f0 01 00 00       	jmp    80499d3 <.L90+0x5>

080497e3 <.L159>:
                case ECOMM: return "Communication error on send";
 80497e3:	8d 80 e3 e4 ff ff    	lea    -0x1b1d(%eax),%eax
 80497e9:	e9 e5 01 00 00       	jmp    80499d3 <.L90+0x5>

080497ee <.L160>:
                case EPROTO: return "Protocol error";
 80497ee:	8d 80 ff e4 ff ff    	lea    -0x1b01(%eax),%eax
 80497f4:	e9 da 01 00 00       	jmp    80499d3 <.L90+0x5>

080497f9 <.L161>:
                case EMULTIHOP: return "multihop attempted";
 80497f9:	8d 80 0e e5 ff ff    	lea    -0x1af2(%eax),%eax
 80497ff:	e9 cf 01 00 00       	jmp    80499d3 <.L90+0x5>

08049804 <.L162>:
                case EBADMSG: return "trying to read unreadable message";
 8049804:	8d 80 24 e5 ff ff    	lea    -0x1adc(%eax),%eax
 804980a:	e9 c4 01 00 00       	jmp    80499d3 <.L90+0x5>

0804980f <.L127>:
                case ENAMETOOLONG: return "path name is too long";
 804980f:	8d 80 46 e5 ff ff    	lea    -0x1aba(%eax),%eax
 8049815:	e9 b9 01 00 00       	jmp    80499d3 <.L90+0x5>

0804981a <.L163>:
                case EOVERFLOW: return "value too large to be stored in data type";
 804981a:	8d 80 5c e5 ff ff    	lea    -0x1aa4(%eax),%eax
 8049820:	e9 ae 01 00 00       	jmp    80499d3 <.L90+0x5>

08049825 <.L164>:
                case ENOTUNIQ: return "given log. name not unique";
 8049825:	8d 80 86 e5 ff ff    	lea    -0x1a7a(%eax),%eax
 804982b:	e9 a3 01 00 00       	jmp    80499d3 <.L90+0x5>

08049830 <.L165>:
                case EBADFD: return "f.d. invalid for this operation";
 8049830:	8d 80 a4 e5 ff ff    	lea    -0x1a5c(%eax),%eax
 8049836:	e9 98 01 00 00       	jmp    80499d3 <.L90+0x5>

0804983b <.L166>:
                case EREMCHG: return "Remote address changed";
 804983b:	8d 80 c4 e5 ff ff    	lea    -0x1a3c(%eax),%eax
 8049841:	e9 8d 01 00 00       	jmp    80499d3 <.L90+0x5>

08049846 <.L167>:
                case ELIBACC: return "Can't access a needed shared lib.";
 8049846:	8d 80 dc e5 ff ff    	lea    -0x1a24(%eax),%eax
 804984c:	e9 82 01 00 00       	jmp    80499d3 <.L90+0x5>

08049851 <.L168>:
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 8049851:	8d 80 00 e6 ff ff    	lea    -0x1a00(%eax),%eax
 8049857:	e9 77 01 00 00       	jmp    80499d3 <.L90+0x5>

0804985c <.L169>:
                case ELIBSCN: return ".lib section in a.out corrupted.";
 804985c:	8d 80 24 e6 ff ff    	lea    -0x19dc(%eax),%eax
 8049862:	e9 6c 01 00 00       	jmp    80499d3 <.L90+0x5>

08049867 <.L170>:
                case ELIBMAX: return "Attempting to link in too many libs.";
 8049867:	8d 80 48 e6 ff ff    	lea    -0x19b8(%eax),%eax
 804986d:	e9 61 01 00 00       	jmp    80499d3 <.L90+0x5>

08049872 <.L171>:
                case ELIBEXEC: return "Attempting to exec a shared library.";
 8049872:	8d 80 70 e6 ff ff    	lea    -0x1990(%eax),%eax
 8049878:	e9 56 01 00 00       	jmp    80499d3 <.L90+0x5>

0804987d <.L172>:
                case EILSEQ: return "Illegal byte sequence.";
 804987d:	8d 80 95 e6 ff ff    	lea    -0x196b(%eax),%eax
 8049883:	e9 4b 01 00 00       	jmp    80499d3 <.L90+0x5>

08049888 <.L129>:
                case ENOSYS: return "Unsupported file system operation";
 8049888:	8d 80 ac e6 ff ff    	lea    -0x1954(%eax),%eax
 804988e:	e9 40 01 00 00       	jmp    80499d3 <.L90+0x5>

08049893 <.L131>:
                case ELOOP: return "Symbolic link loop";
 8049893:	8d 80 ce e6 ff ff    	lea    -0x1932(%eax),%eax
 8049899:	e9 35 01 00 00       	jmp    80499d3 <.L90+0x5>

0804989e <.L173>:
                case ERESTART: return "Restartable system call";
 804989e:	8d 80 e1 e6 ff ff    	lea    -0x191f(%eax),%eax
 80498a4:	e9 2a 01 00 00       	jmp    80499d3 <.L90+0x5>

080498a9 <.L174>:
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 80498a9:	8d 80 fc e6 ff ff    	lea    -0x1904(%eax),%eax
 80498af:	e9 1f 01 00 00       	jmp    80499d3 <.L90+0x5>

080498b4 <.L130>:
                case ENOTEMPTY: return "directory not empty";
 80498b4:	8d 80 25 e7 ff ff    	lea    -0x18db(%eax),%eax
 80498ba:	e9 14 01 00 00       	jmp    80499d3 <.L90+0x5>

080498bf <.L175>:
                case EUSERS: return "Too many users (for UFS)";
 80498bf:	8d 80 39 e7 ff ff    	lea    -0x18c7(%eax),%eax
 80498c5:	e9 09 01 00 00       	jmp    80499d3 <.L90+0x5>

080498ca <.L176>:
                case ENOTSOCK: return "Socket operation on non-socket";
 80498ca:	8d 80 54 e7 ff ff    	lea    -0x18ac(%eax),%eax
 80498d0:	e9 fe 00 00 00       	jmp    80499d3 <.L90+0x5>

080498d5 <.L177>:
                case EDESTADDRREQ: return "Destination address required";
 80498d5:	8d 80 73 e7 ff ff    	lea    -0x188d(%eax),%eax
 80498db:	e9 f3 00 00 00       	jmp    80499d3 <.L90+0x5>

080498e0 <.L178>:
                case EMSGSIZE: return "Message too long";
 80498e0:	8d 80 90 e7 ff ff    	lea    -0x1870(%eax),%eax
 80498e6:	e9 e8 00 00 00       	jmp    80499d3 <.L90+0x5>

080498eb <.L179>:
                case EPROTOTYPE: return "Protocol wrong type for socket";
 80498eb:	8d 80 a4 e7 ff ff    	lea    -0x185c(%eax),%eax
 80498f1:	e9 dd 00 00 00       	jmp    80499d3 <.L90+0x5>

080498f6 <.L180>:
                case ENOPROTOOPT: return "Protocol not available";
 80498f6:	8d 80 c3 e7 ff ff    	lea    -0x183d(%eax),%eax
 80498fc:	e9 d2 00 00 00       	jmp    80499d3 <.L90+0x5>

08049901 <.L181>:
                case EPROTONOSUPPORT: return "Protocol not supported";
 8049901:	8d 80 da e7 ff ff    	lea    -0x1826(%eax),%eax
 8049907:	e9 c7 00 00 00       	jmp    80499d3 <.L90+0x5>

0804990c <.L182>:
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 804990c:	8d 80 f1 e7 ff ff    	lea    -0x180f(%eax),%eax
 8049912:	e9 bc 00 00 00       	jmp    80499d3 <.L90+0x5>

08049917 <.L184>:
                case EPFNOSUPPORT: return "Protocol family not supported";
 8049917:	8d 80 0b e8 ff ff    	lea    -0x17f5(%eax),%eax
 804991d:	e9 b1 00 00 00       	jmp    80499d3 <.L90+0x5>

08049922 <.L185>:
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 8049922:	8d 80 2c e8 ff ff    	lea    -0x17d4(%eax),%eax
 8049928:	e9 a6 00 00 00       	jmp    80499d3 <.L90+0x5>

0804992d <.L186>:
                case EADDRINUSE: return "Address already in use";
 804992d:	8d 80 5c e8 ff ff    	lea    -0x17a4(%eax),%eax
 8049933:	e9 9b 00 00 00       	jmp    80499d3 <.L90+0x5>

08049938 <.L187>:
                case EADDRNOTAVAIL: return "Can't assign requested address";
 8049938:	8d 80 74 e8 ff ff    	lea    -0x178c(%eax),%eax
 804993e:	e9 90 00 00 00       	jmp    80499d3 <.L90+0x5>

08049943 <.L188>:
                case ENETDOWN: return "Network is down";
 8049943:	8d 80 93 e8 ff ff    	lea    -0x176d(%eax),%eax
 8049949:	e9 85 00 00 00       	jmp    80499d3 <.L90+0x5>

0804994e <.L189>:
                case ENETUNREACH: return "Network is unreachable";
 804994e:	8d 80 a3 e8 ff ff    	lea    -0x175d(%eax),%eax
 8049954:	eb 7d                	jmp    80499d3 <.L90+0x5>

08049956 <.L190>:
                case ENETRESET: return "Network dropped connection because of reset";
 8049956:	8d 80 bc e8 ff ff    	lea    -0x1744(%eax),%eax
 804995c:	eb 75                	jmp    80499d3 <.L90+0x5>

0804995e <.L191>:
                case ECONNABORTED: return "Software caused connection abort";
 804995e:	8d 80 e8 e8 ff ff    	lea    -0x1718(%eax),%eax
 8049964:	eb 6d                	jmp    80499d3 <.L90+0x5>

08049966 <.L192>:
                case ECONNRESET: return "Connection reset by peer";
 8049966:	8d 80 09 e9 ff ff    	lea    -0x16f7(%eax),%eax
 804996c:	eb 65                	jmp    80499d3 <.L90+0x5>

0804996e <.L193>:
                case ENOBUFS: return "No buffer space available";
 804996e:	8d 80 22 e9 ff ff    	lea    -0x16de(%eax),%eax
 8049974:	eb 5d                	jmp    80499d3 <.L90+0x5>

08049976 <.L194>:
                case EISCONN: return "Socket is already connected";
 8049976:	8d 80 3c e9 ff ff    	lea    -0x16c4(%eax),%eax
 804997c:	eb 55                	jmp    80499d3 <.L90+0x5>

0804997e <.L195>:
                case ENOTCONN: return "Socket is not connected";
 804997e:	8d 80 58 e9 ff ff    	lea    -0x16a8(%eax),%eax
 8049984:	eb 4d                	jmp    80499d3 <.L90+0x5>

08049986 <.L196>:
                case ESHUTDOWN: return "Can't send after socket shutdown";
 8049986:	8d 80 70 e9 ff ff    	lea    -0x1690(%eax),%eax
 804998c:	eb 45                	jmp    80499d3 <.L90+0x5>

0804998e <.L197>:
                case ETOOMANYREFS: return "Too many references: can't splice";
 804998e:	8d 80 94 e9 ff ff    	lea    -0x166c(%eax),%eax
 8049994:	eb 3d                	jmp    80499d3 <.L90+0x5>

08049996 <.L198>:
                case ETIMEDOUT: return "Connection timed out";
 8049996:	8d 80 b6 e9 ff ff    	lea    -0x164a(%eax),%eax
 804999c:	eb 35                	jmp    80499d3 <.L90+0x5>

0804999e <.L199>:
                case ECONNREFUSED: return "Connection refused";
 804999e:	8d 80 cb e9 ff ff    	lea    -0x1635(%eax),%eax
 80499a4:	eb 2d                	jmp    80499d3 <.L90+0x5>

080499a6 <.L200>:
                case EHOSTDOWN: return "Host is down";
 80499a6:	8d 80 de e9 ff ff    	lea    -0x1622(%eax),%eax
 80499ac:	eb 25                	jmp    80499d3 <.L90+0x5>

080499ae <.L201>:
                case EHOSTUNREACH: return "No route to host";
 80499ae:	8d 80 eb e9 ff ff    	lea    -0x1615(%eax),%eax
 80499b4:	eb 1d                	jmp    80499d3 <.L90+0x5>

080499b6 <.L202>:
                case EALREADY: return "operation already in progress";
 80499b6:	8d 80 fc e9 ff ff    	lea    -0x1604(%eax),%eax
 80499bc:	eb 15                	jmp    80499d3 <.L90+0x5>

080499be <.L203>:
                case EINPROGRESS: return "operation now in progress";
 80499be:	8d 80 1a ea ff ff    	lea    -0x15e6(%eax),%eax
 80499c4:	eb 0d                	jmp    80499d3 <.L90+0x5>

080499c6 <.L204>:
                case ESTALE: return "Stale NFS file handle";
 80499c6:	8d 80 34 ea ff ff    	lea    -0x15cc(%eax),%eax
 80499cc:	eb 05                	jmp    80499d3 <.L90+0x5>

080499ce <.L90>:
                default: return 0;
 80499ce:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 80499d3:	5d                   	pop    %ebp
 80499d4:	c3                   	ret    

080499d5 <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 80499d5:	55                   	push   %ebp
 80499d6:	89 e5                	mov    %esp,%ebp
 80499d8:	53                   	push   %ebx
 80499d9:	83 ec 24             	sub    $0x24,%esp
 80499dc:	e8 ec f5 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 80499e1:	81 c3 1f 56 00 00    	add    $0x561f,%ebx
        char *q = " error: ";
 80499e7:	8d 83 5d ec ff ff    	lea    -0x13a3(%ebx),%eax
 80499ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 80499f0:	8b 83 24 00 00 00    	mov    0x24(%ebx),%eax
 80499f6:	89 04 24             	mov    %eax,(%esp)
 80499f9:	e8 40 f8 ff ff       	call   804923e <strlen>
 80499fe:	89 c2                	mov    %eax,%edx
 8049a00:	8b 83 24 00 00 00    	mov    0x24(%ebx),%eax
 8049a06:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049a0a:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049a0e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049a15:	e8 2c ee ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 8049a1a:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049a20:	89 04 24             	mov    %eax,(%esp)
 8049a23:	e8 16 f8 ff ff       	call   804923e <strlen>
 8049a28:	89 c2                	mov    %eax,%edx
 8049a2a:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049a30:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049a34:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049a38:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049a3f:	e8 02 ee ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, q, strlen(q));
 8049a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a47:	89 04 24             	mov    %eax,(%esp)
 8049a4a:	e8 ef f7 ff ff       	call   804923e <strlen>
 8049a4f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a56:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049a5a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049a61:	e8 e0 ed ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, p, strlen(p));
 8049a66:	8b 45 08             	mov    0x8(%ebp),%eax
 8049a69:	89 04 24             	mov    %eax,(%esp)
 8049a6c:	e8 cd f7 ff ff       	call   804923e <strlen>
 8049a71:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049a75:	8b 45 08             	mov    0x8(%ebp),%eax
 8049a78:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049a7c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049a83:	e8 be ed ff ff       	call   8048846 <write>
        suicide = 1;
 8049a88:	c7 83 3c 02 00 00 01 	movl   $0x1,0x23c(%ebx)
 8049a8f:	00 00 00 
        abort();
 8049a92:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049a99:	e8 c4 e9 ff ff       	call   8048462 <exit>
}
 8049a9e:	90                   	nop
 8049a9f:	83 c4 24             	add    $0x24,%esp
 8049aa2:	5b                   	pop    %ebx
 8049aa3:	5d                   	pop    %ebp
 8049aa4:	c3                   	ret    

08049aa5 <wrtwarning>:

static void
wrtwarning(char *p)
{
 8049aa5:	55                   	push   %ebp
 8049aa6:	89 e5                	mov    %esp,%ebp
 8049aa8:	53                   	push   %ebx
 8049aa9:	83 ec 24             	sub    $0x24,%esp
 8049aac:	e8 1c f5 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049ab1:	81 c3 4f 55 00 00    	add    $0x554f,%ebx
        char *q = " warning: ";
 8049ab7:	8d 83 66 ec ff ff    	lea    -0x139a(%ebx),%eax
 8049abd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 8049ac0:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
 8049ac6:	85 c0                	test   %eax,%eax
 8049ac8:	74 0b                	je     8049ad5 <wrtwarning+0x30>
                wrterror(p);
 8049aca:	8b 45 08             	mov    0x8(%ebp),%eax
 8049acd:	89 04 24             	mov    %eax,(%esp)
 8049ad0:	e8 00 ff ff ff       	call   80499d5 <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 8049ad5:	8b 83 24 00 00 00    	mov    0x24(%ebx),%eax
 8049adb:	89 04 24             	mov    %eax,(%esp)
 8049ade:	e8 5b f7 ff ff       	call   804923e <strlen>
 8049ae3:	89 c2                	mov    %eax,%edx
 8049ae5:	8b 83 24 00 00 00    	mov    0x24(%ebx),%eax
 8049aeb:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049aef:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049af3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049afa:	e8 47 ed ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 8049aff:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049b05:	89 04 24             	mov    %eax,(%esp)
 8049b08:	e8 31 f7 ff ff       	call   804923e <strlen>
 8049b0d:	89 c2                	mov    %eax,%edx
 8049b0f:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049b15:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049b19:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b1d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b24:	e8 1d ed ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, q, strlen(q));
 8049b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b2c:	89 04 24             	mov    %eax,(%esp)
 8049b2f:	e8 0a f7 ff ff       	call   804923e <strlen>
 8049b34:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b3b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b3f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b46:	e8 fb ec ff ff       	call   8048846 <write>
        _write(STDERR_FILENO, p, strlen(p));
 8049b4b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b4e:	89 04 24             	mov    %eax,(%esp)
 8049b51:	e8 e8 f6 ff ff       	call   804923e <strlen>
 8049b56:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b5a:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b5d:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b61:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b68:	e8 d9 ec ff ff       	call   8048846 <write>
}
 8049b6d:	90                   	nop
 8049b6e:	83 c4 24             	add    $0x24,%esp
 8049b71:	5b                   	pop    %ebx
 8049b72:	5d                   	pop    %ebp
 8049b73:	c3                   	ret    

08049b74 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 8049b74:	55                   	push   %ebp
 8049b75:	89 e5                	mov    %esp,%ebp
 8049b77:	53                   	push   %ebx
 8049b78:	83 ec 24             	sub    $0x24,%esp
 8049b7b:	e8 4d f4 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049b80:	81 c3 80 54 00 00    	add    $0x5480,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 8049b86:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049b8d:	e8 e1 e6 ff ff       	call   8048273 <sbrk>
 8049b92:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049b97:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8049b9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 8049b9f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ba2:	c1 e0 0c             	shl    $0xc,%eax
 8049ba5:	89 c2                	mov    %eax,%edx
 8049ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049baa:	01 d0                	add    %edx,%eax
 8049bac:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 8049baf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049bb2:	89 04 24             	mov    %eax,(%esp)
 8049bb5:	e8 82 e7 ff ff       	call   804833c <brk>
 8049bba:	85 c0                	test   %eax,%eax
 8049bbc:	74 07                	je     8049bc5 <map_pages+0x51>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 8049bbe:	b8 00 00 00 00       	mov    $0x0,%eax
 8049bc3:	eb 51                	jmp    8049c16 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 8049bc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049bc8:	c1 e8 0c             	shr    $0xc,%eax
 8049bcb:	89 c2                	mov    %eax,%edx
 8049bcd:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 8049bd3:	29 c2                	sub    %eax,%edx
 8049bd5:	89 d0                	mov    %edx,%eax
 8049bd7:	48                   	dec    %eax
 8049bd8:	89 83 18 02 00 00    	mov    %eax,0x218(%ebx)
        malloc_brk = tail;
 8049bde:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049be1:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 8049be7:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 8049bed:	8d 50 01             	lea    0x1(%eax),%edx
 8049bf0:	8b 83 20 02 00 00    	mov    0x220(%ebx),%eax
 8049bf6:	39 c2                	cmp    %eax,%edx
 8049bf8:	72 19                	jb     8049c13 <map_pages+0x9f>
 8049bfa:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 8049c00:	89 04 24             	mov    %eax,(%esp)
 8049c03:	e8 14 00 00 00       	call   8049c1c <extend_pgdir>
 8049c08:	85 c0                	test   %eax,%eax
 8049c0a:	75 07                	jne    8049c13 <map_pages+0x9f>
                return 0;;
 8049c0c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c11:	eb 03                	jmp    8049c16 <map_pages+0xa2>

        return result;
 8049c13:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049c16:	83 c4 24             	add    $0x24,%esp
 8049c19:	5b                   	pop    %ebx
 8049c1a:	5d                   	pop    %ebp
 8049c1b:	c3                   	ret    

08049c1c <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 8049c1c:	55                   	push   %ebp
 8049c1d:	89 e5                	mov    %esp,%ebp
 8049c1f:	53                   	push   %ebx
 8049c20:	83 ec 34             	sub    $0x34,%esp
 8049c23:	e8 a5 f3 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049c28:	81 c3 d8 53 00 00    	add    $0x53d8,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 8049c2e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c31:	c1 e0 02             	shl    $0x2,%eax
 8049c34:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 8049c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c3a:	c1 e8 0c             	shr    $0xc,%eax
 8049c3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 8049c40:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 8049c44:	8b 83 20 02 00 00    	mov    0x220(%ebx),%eax
 8049c4a:	c1 e0 02             	shl    $0x2,%eax
 8049c4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 8049c50:	8b 83 08 02 00 00    	mov    0x208(%ebx),%eax
 8049c56:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049c59:	c1 e2 0c             	shl    $0xc,%edx
 8049c5c:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8049c63:	00 
 8049c64:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049c68:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 8049c6f:	00 
 8049c70:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 8049c77:	00 
 8049c78:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049c7c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049c83:	e8 cc e9 ff ff       	call   8048654 <mmap>
 8049c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 8049c8b:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049c8f:	75 07                	jne    8049c98 <extend_pgdir+0x7c>
                return 0;
 8049c91:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c96:	eb 5e                	jmp    8049cf6 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 8049c98:	8b 83 20 02 00 00    	mov    0x220(%ebx),%eax
 8049c9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8049ca5:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 8049cab:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049caf:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049cb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049cb6:	89 04 24             	mov    %eax,(%esp)
 8049cb9:	e8 66 f3 ff ff       	call   8049024 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 8049cbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049cc1:	c1 e0 0c             	shl    $0xc,%eax
 8049cc4:	c1 e8 02             	shr    $0x2,%eax
 8049cc7:	89 83 20 02 00 00    	mov    %eax,0x220(%ebx)

        /* swap the pointers */
        old = page_dir;
 8049ccd:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 8049cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 8049cd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049cd9:	89 83 1c 02 00 00    	mov    %eax,0x21c(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 8049cdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049ce2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ce6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049ce9:	89 04 24             	mov    %eax,(%esp)
 8049cec:	e8 c6 e9 ff ff       	call   80486b7 <munmap>
        return 1;
 8049cf1:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049cf6:	83 c4 34             	add    $0x34,%esp
 8049cf9:	5b                   	pop    %ebx
 8049cfa:	5d                   	pop    %ebp
 8049cfb:	c3                   	ret    

08049cfc <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 8049cfc:	55                   	push   %ebp
 8049cfd:	89 e5                	mov    %esp,%ebp
 8049cff:	53                   	push   %ebx
 8049d00:	83 ec 34             	sub    $0x34,%esp
 8049d03:	e8 c5 f2 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049d08:	81 c3 f8 52 00 00    	add    $0x52f8,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 8049d0e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049d15:	00 
 8049d16:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 8049d1d:	00 
 8049d1e:	8d 83 71 ec ff ff    	lea    -0x138f(%ebx),%eax
 8049d24:	89 04 24             	mov    %eax,(%esp)
 8049d27:	e8 14 ea ff ff       	call   8048740 <open>
 8049d2c:	89 83 08 02 00 00    	mov    %eax,0x208(%ebx)
 8049d32:	8b 83 08 02 00 00    	mov    0x208(%ebx),%eax
 8049d38:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049d3b:	75 0e                	jne    8049d4b <malloc_init+0x4f>
 8049d3d:	8d 83 7b ec ff ff    	lea    -0x1385(%ebx),%eax
 8049d43:	89 04 24             	mov    %eax,(%esp)
 8049d46:	e8 8a fc ff ff       	call   80499d5 <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 8049d4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049d52:	e9 7c 01 00 00       	jmp    8049ed3 <.L18+0x45>
                if (i == 0) {
 8049d57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049d5b:	75 0c                	jne    8049d69 <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 8049d5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049d64:	e9 53 01 00 00       	jmp    8049ebc <.L18+0x2e>
#endif
                } else if (i == 1) {
 8049d69:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 8049d6d:	75 0c                	jne    8049d7b <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 8049d6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049d76:	e9 41 01 00 00       	jmp    8049ebc <.L18+0x2e>
#endif
                } else {
                        p = malloc_options;
 8049d7b:	8d 05 68 f2 04 08    	lea    0x804f268,%eax
 8049d81:	8b 00                	mov    (%eax),%eax
 8049d83:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 8049d86:	e9 31 01 00 00       	jmp    8049ebc <.L18+0x2e>
                        switch (*p) {
 8049d8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d8e:	0f b6 00             	movzbl (%eax),%eax
 8049d91:	0f be c0             	movsbl %al,%eax
 8049d94:	83 e8 3c             	sub    $0x3c,%eax
 8049d97:	83 f8 3e             	cmp    $0x3e,%eax
 8049d9a:	0f 87 ee 00 00 00    	ja     8049e8e <.L18>
 8049da0:	c1 e0 02             	shl    $0x2,%eax
 8049da3:	8b 84 18 d0 ec ff ff 	mov    -0x1330(%eax,%ebx,1),%eax
 8049daa:	01 d8                	add    %ebx,%eax
 8049dac:	ff e0                	jmp    *%eax

08049dae <.L21>:
                                case '>': malloc_cache   <<= 1; break;
 8049dae:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 8049db4:	01 c0                	add    %eax,%eax
 8049db6:	89 83 20 00 00 00    	mov    %eax,0x20(%ebx)
 8049dbc:	e9 f8 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049dc1 <.L19>:
                                case '<': malloc_cache   >>= 1; break;
 8049dc1:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 8049dc7:	d1 e8                	shr    %eax
 8049dc9:	89 83 20 00 00 00    	mov    %eax,0x20(%ebx)
 8049dcf:	e9 e5 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049dd4 <.L29>:
                                case 'a': malloc_abort   = 0; break;
 8049dd4:	c7 83 38 02 00 00 00 	movl   $0x0,0x238(%ebx)
 8049ddb:	00 00 00 
 8049dde:	e9 d6 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049de3 <.L22>:
                                case 'A': malloc_abort   = 1; break;
 8049de3:	c7 83 38 02 00 00 01 	movl   $0x1,0x238(%ebx)
 8049dea:	00 00 00 
 8049ded:	e9 c7 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049df2 <.L30>:
                                case 'h': malloc_hint    = 0; break;
 8049df2:	c7 83 44 02 00 00 00 	movl   $0x0,0x244(%ebx)
 8049df9:	00 00 00 
 8049dfc:	e9 b8 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049e01 <.L23>:
                                case 'H': malloc_hint    = 1; break;
 8049e01:	c7 83 44 02 00 00 01 	movl   $0x1,0x244(%ebx)
 8049e08:	00 00 00 
 8049e0b:	e9 a9 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049e10 <.L32>:
                                case 'r': malloc_realloc = 0; break;
 8049e10:	c7 83 40 02 00 00 00 	movl   $0x0,0x240(%ebx)
 8049e17:	00 00 00 
 8049e1a:	e9 9a 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049e1f <.L25>:
                                case 'R': malloc_realloc = 1; break;
 8049e1f:	c7 83 40 02 00 00 01 	movl   $0x1,0x240(%ebx)
 8049e26:	00 00 00 
 8049e29:	e9 8b 00 00 00       	jmp    8049eb9 <.L18+0x2b>

08049e2e <.L31>:
                                case 'j': malloc_junk    = 0; break;
 8049e2e:	c7 83 54 02 00 00 00 	movl   $0x0,0x254(%ebx)
 8049e35:	00 00 00 
 8049e38:	eb 7f                	jmp    8049eb9 <.L18+0x2b>

08049e3a <.L24>:
                                case 'J': malloc_junk    = 1; break;
 8049e3a:	c7 83 54 02 00 00 01 	movl   $0x1,0x254(%ebx)
 8049e41:	00 00 00 
 8049e44:	eb 73                	jmp    8049eb9 <.L18+0x2b>

08049e46 <.L33>:
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 8049e46:	c7 83 4c 02 00 00 00 	movl   $0x0,0x24c(%ebx)
 8049e4d:	00 00 00 
 8049e50:	eb 67                	jmp    8049eb9 <.L18+0x2b>

08049e52 <.L26>:
                                case 'V': malloc_sysv    = 1; break;
 8049e52:	c7 83 4c 02 00 00 01 	movl   $0x1,0x24c(%ebx)
 8049e59:	00 00 00 
 8049e5c:	eb 5b                	jmp    8049eb9 <.L18+0x2b>

08049e5e <.L34>:
                                case 'x': malloc_xmalloc = 0; break;
 8049e5e:	c7 83 48 02 00 00 00 	movl   $0x0,0x248(%ebx)
 8049e65:	00 00 00 
 8049e68:	eb 4f                	jmp    8049eb9 <.L18+0x2b>

08049e6a <.L27>:
                                case 'X': malloc_xmalloc = 1; break;
 8049e6a:	c7 83 48 02 00 00 01 	movl   $0x1,0x248(%ebx)
 8049e71:	00 00 00 
 8049e74:	eb 43                	jmp    8049eb9 <.L18+0x2b>

08049e76 <.L35>:
                                case 'z': malloc_zero    = 0; break;
 8049e76:	c7 83 50 02 00 00 00 	movl   $0x0,0x250(%ebx)
 8049e7d:	00 00 00 
 8049e80:	eb 37                	jmp    8049eb9 <.L18+0x2b>

08049e82 <.L28>:
                                case 'Z': malloc_zero    = 1; break;
 8049e82:	c7 83 50 02 00 00 01 	movl   $0x1,0x250(%ebx)
 8049e89:	00 00 00 
 8049e8c:	eb 2b                	jmp    8049eb9 <.L18+0x2b>

08049e8e <.L18>:
                                default:
                                        j = malloc_abort;
 8049e8e:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
 8049e94:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 8049e97:	c7 83 38 02 00 00 00 	movl   $0x0,0x238(%ebx)
 8049e9e:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 8049ea1:	8d 83 90 ec ff ff    	lea    -0x1370(%ebx),%eax
 8049ea7:	89 04 24             	mov    %eax,(%esp)
 8049eaa:	e8 f6 fb ff ff       	call   8049aa5 <wrtwarning>
                                        malloc_abort = j;
 8049eaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049eb2:	89 83 38 02 00 00    	mov    %eax,0x238(%ebx)
                                        break;
 8049eb8:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 8049eb9:	ff 45 f4             	incl   -0xc(%ebp)
 8049ebc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049ec0:	74 0e                	je     8049ed0 <.L18+0x42>
 8049ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ec5:	0f b6 00             	movzbl (%eax),%eax
 8049ec8:	84 c0                	test   %al,%al
 8049eca:	0f 85 bb fe ff ff    	jne    8049d8b <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 8049ed0:	ff 45 f0             	incl   -0x10(%ebp)
 8049ed3:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 8049ed7:	0f 8e 7a fe ff ff    	jle    8049d57 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 8049edd:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 8049ee3:	85 c0                	test   %eax,%eax
 8049ee5:	74 0a                	je     8049ef1 <.L18+0x63>
                malloc_junk = 1;
 8049ee7:	c7 83 54 02 00 00 01 	movl   $0x1,0x254(%ebx)
 8049eee:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 8049ef1:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 8049ef7:	85 c0                	test   %eax,%eax
 8049ef9:	74 0a                	je     8049f05 <.L18+0x77>
                malloc_realloc = 1;
 8049efb:	c7 83 40 02 00 00 01 	movl   $0x1,0x240(%ebx)
 8049f02:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 8049f05:	8b 83 08 02 00 00    	mov    0x208(%ebx),%eax
 8049f0b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8049f12:	00 
 8049f13:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049f17:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 8049f1e:	00 
 8049f1f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 8049f26:	00 
 8049f27:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 8049f2e:	00 
 8049f2f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049f36:	e8 19 e7 ff ff       	call   8048654 <mmap>
 8049f3b:	89 83 1c 02 00 00    	mov    %eax,0x21c(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 8049f41:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 8049f47:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049f4a:	75 0e                	jne    8049f5a <.L18+0xcc>
                wrterror("mmap(2) failed, check limits\n");
 8049f4c:	8d 83 b0 ec ff ff    	lea    -0x1350(%ebx),%eax
 8049f52:	89 04 24             	mov    %eax,(%esp)
 8049f55:	e8 7b fa ff ff       	call   80499d5 <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 8049f5a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049f61:	e8 0d e3 ff ff       	call   8048273 <sbrk>
 8049f66:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049f6b:	c1 e8 0c             	shr    $0xc,%eax
 8049f6e:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)
        malloc_origo -= malloc_pageshift;
 8049f74:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 8049f7a:	83 e8 0c             	sub    $0xc,%eax
 8049f7d:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 8049f83:	c7 83 20 02 00 00 00 	movl   $0x400,0x220(%ebx)
 8049f8a:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 8049f8d:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 8049f93:	85 c0                	test   %eax,%eax
 8049f95:	75 0d                	jne    8049fa4 <.L18+0x116>
                malloc_cache++;
 8049f97:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 8049f9d:	40                   	inc    %eax
 8049f9e:	89 83 20 00 00 00    	mov    %eax,0x20(%ebx)

        malloc_cache <<= malloc_pageshift;
 8049fa4:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 8049faa:	c1 e0 0c             	shl    $0xc,%eax
 8049fad:	89 83 20 00 00 00    	mov    %eax,0x20(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 8049fb3:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 8049fba:	e8 5d 07 00 00       	call   804a71c <imalloc>
 8049fbf:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)

        /* Been here, done that */
        malloc_started++;
 8049fc5:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 8049fcb:	40                   	inc    %eax
 8049fcc:	89 83 0c 02 00 00    	mov    %eax,0x20c(%ebx)
}
 8049fd2:	90                   	nop
 8049fd3:	83 c4 34             	add    $0x34,%esp
 8049fd6:	5b                   	pop    %ebx
 8049fd7:	5d                   	pop    %ebp
 8049fd8:	c3                   	ret    

08049fd9 <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 8049fd9:	55                   	push   %ebp
 8049fda:	89 e5                	mov    %esp,%ebp
 8049fdc:	53                   	push   %ebx
 8049fdd:	83 ec 34             	sub    $0x34,%esp
 8049fe0:	e8 e8 ef ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 8049fe5:	81 c3 1b 50 00 00    	add    $0x501b,%ebx
        void *p, *delay_free = 0;
 8049feb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 8049ff2:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ff5:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049ffa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8049fff:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 804a002:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a009:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
 804a00f:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a012:	e9 82 00 00 00       	jmp    804a099 <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804a017:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a01a:	8b 40 10             	mov    0x10(%eax),%eax
 804a01d:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a020:	73 0a                	jae    804a02c <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a022:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a025:	8b 00                	mov    (%eax),%eax
 804a027:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a02a:	eb 6d                	jmp    804a099 <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 804a02c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a02f:	8b 40 10             	mov    0x10(%eax),%eax
 804a032:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a035:	75 35                	jne    804a06c <malloc_pages+0x93>
                        p = pf->page;
 804a037:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a03a:	8b 40 08             	mov    0x8(%eax),%eax
 804a03d:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 804a040:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a043:	8b 00                	mov    (%eax),%eax
 804a045:	85 c0                	test   %eax,%eax
 804a047:	74 0e                	je     804a057 <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 804a049:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a04c:	8b 00                	mov    (%eax),%eax
 804a04e:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a051:	8b 52 04             	mov    0x4(%edx),%edx
 804a054:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 804a057:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a05a:	8b 40 04             	mov    0x4(%eax),%eax
 804a05d:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a060:	8b 12                	mov    (%edx),%edx
 804a062:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 804a064:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a067:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 804a06a:	eb 37                	jmp    804a0a3 <malloc_pages+0xca>
                }

                p = pf->page;
 804a06c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a06f:	8b 40 08             	mov    0x8(%eax),%eax
 804a072:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 804a075:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a078:	8b 50 08             	mov    0x8(%eax),%edx
 804a07b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a07e:	01 c2                	add    %eax,%edx
 804a080:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a083:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 804a086:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a089:	8b 40 10             	mov    0x10(%eax),%eax
 804a08c:	2b 45 08             	sub    0x8(%ebp),%eax
 804a08f:	89 c2                	mov    %eax,%edx
 804a091:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a094:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804a097:	eb 0a                	jmp    804a0a3 <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a099:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a09d:	0f 85 74 ff ff ff    	jne    804a017 <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 804a0a3:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804a0a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a0ab:	75 0e                	jne    804a0bb <malloc_pages+0xe2>
                p = map_pages(size);
 804a0ad:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0b0:	89 04 24             	mov    %eax,(%esp)
 804a0b3:	e8 bc fa ff ff       	call   8049b74 <map_pages>
 804a0b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804a0bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a0bf:	74 7d                	je     804a13e <malloc_pages+0x165>

                index = ptr2index(p);
 804a0c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a0c4:	c1 e8 0c             	shr    $0xc,%eax
 804a0c7:	89 c2                	mov    %eax,%edx
 804a0c9:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804a0cf:	29 c2                	sub    %eax,%edx
 804a0d1:	89 d0                	mov    %edx,%eax
 804a0d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804a0d6:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a0dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a0df:	c1 e2 02             	shl    $0x2,%edx
 804a0e2:	01 d0                	add    %edx,%eax
 804a0e4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 804a0ea:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804a0f1:	eb 1c                	jmp    804a10f <malloc_pages+0x136>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804a0f3:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a0f9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804a0fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a0ff:	01 ca                	add    %ecx,%edx
 804a101:	c1 e2 02             	shl    $0x2,%edx
 804a104:	01 d0                	add    %edx,%eax
 804a106:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 804a10c:	ff 45 ec             	incl   -0x14(%ebp)
 804a10f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a112:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a115:	72 dc                	jb     804a0f3 <malloc_pages+0x11a>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 804a117:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804a11d:	85 c0                	test   %eax,%eax
 804a11f:	74 1d                	je     804a13e <malloc_pages+0x165>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 804a121:	8b 45 08             	mov    0x8(%ebp),%eax
 804a124:	c1 e0 0c             	shl    $0xc,%eax
 804a127:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a12b:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a132:	00 
 804a133:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a136:	89 04 24             	mov    %eax,(%esp)
 804a139:	e8 41 f0 ff ff       	call   804917f <memset>
        }

        if (delay_free) {
 804a13e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a142:	74 20                	je     804a164 <malloc_pages+0x18b>
                if (!px)
 804a144:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a14a:	85 c0                	test   %eax,%eax
 804a14c:	75 0b                	jne    804a159 <malloc_pages+0x180>
                        px = delay_free;
 804a14e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a151:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
 804a157:	eb 0b                	jmp    804a164 <malloc_pages+0x18b>
                else
                        ifree(delay_free);
 804a159:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a15c:	89 04 24             	mov    %eax,(%esp)
 804a15f:	e8 d7 0e 00 00       	call   804b03b <ifree>
        }

        return p;
 804a164:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a167:	83 c4 34             	add    $0x34,%esp
 804a16a:	5b                   	pop    %ebx
 804a16b:	5d                   	pop    %ebp
 804a16c:	c3                   	ret    

0804a16d <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 804a16d:	55                   	push   %ebp
 804a16e:	89 e5                	mov    %esp,%ebp
 804a170:	56                   	push   %esi
 804a171:	53                   	push   %ebx
 804a172:	83 ec 30             	sub    $0x30,%esp
 804a175:	e8 53 ee ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804a17a:	81 c3 86 4e 00 00    	add    $0x4e86,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804a180:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a187:	e8 4d fe ff ff       	call   8049fd9 <malloc_pages>
 804a18c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (!pp)
 804a18f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a193:	75 0a                	jne    804a19f <malloc_make_chunks+0x32>
                return 0;
 804a195:	b8 00 00 00 00       	mov    $0x0,%eax
 804a19a:	e9 f4 01 00 00       	jmp    804a393 <malloc_make_chunks+0x226>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804a19f:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804a1a6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1a9:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a1ae:	88 c1                	mov    %al,%cl
 804a1b0:	d3 ea                	shr    %cl,%edx
 804a1b2:	89 d0                	mov    %edx,%eax
 804a1b4:	83 c0 1f             	add    $0x1f,%eax
 804a1b7:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804a1ba:	c1 e0 02             	shl    $0x2,%eax
 804a1bd:	01 45 ec             	add    %eax,-0x14(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804a1c0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1c3:	ba 01 00 00 00       	mov    $0x1,%edx
 804a1c8:	88 c1                	mov    %al,%cl
 804a1ca:	d3 e2                	shl    %cl,%edx
 804a1cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a1cf:	01 c0                	add    %eax,%eax
 804a1d1:	39 c2                	cmp    %eax,%edx
 804a1d3:	77 08                	ja     804a1dd <malloc_make_chunks+0x70>
                bp = (struct  pginfo *)pp;
 804a1d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a1d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a1db:	eb 29                	jmp    804a206 <malloc_make_chunks+0x99>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804a1dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a1e0:	89 04 24             	mov    %eax,(%esp)
 804a1e3:	e8 34 05 00 00       	call   804a71c <imalloc>
 804a1e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if (!bp) {
 804a1eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a1ef:	75 15                	jne    804a206 <malloc_make_chunks+0x99>
                        ifree(pp);
 804a1f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a1f4:	89 04 24             	mov    %eax,(%esp)
 804a1f7:	e8 3f 0e 00 00       	call   804b03b <ifree>
                        return 0;
 804a1fc:	b8 00 00 00 00       	mov    $0x0,%eax
 804a201:	e9 8d 01 00 00       	jmp    804a393 <malloc_make_chunks+0x226>
                }
        }

        bp->size = (1 << bits);
 804a206:	8b 45 08             	mov    0x8(%ebp),%eax
 804a209:	ba 01 00 00 00       	mov    $0x1,%edx
 804a20e:	88 c1                	mov    %al,%cl
 804a210:	d3 e2                	shl    %cl,%edx
 804a212:	89 d0                	mov    %edx,%eax
 804a214:	0f b7 d0             	movzwl %ax,%edx
 804a217:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a21a:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804a21e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a221:	0f b7 d0             	movzwl %ax,%edx
 804a224:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a227:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804a22b:	8b 45 08             	mov    0x8(%ebp),%eax
 804a22e:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a233:	88 c1                	mov    %al,%cl
 804a235:	d3 ea                	shr    %cl,%edx
 804a237:	89 d0                	mov    %edx,%eax
 804a239:	0f b7 d0             	movzwl %ax,%edx
 804a23c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a23f:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a243:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a246:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a24a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a24d:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804a251:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a254:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a257:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804a25a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a25d:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a261:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        i = 0;
 804a264:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a26b:	eb 19                	jmp    804a286 <malloc_make_chunks+0x119>
                bp->bits[i / MALLOC_BITS] = ~0;
 804a26d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a270:	c1 e8 05             	shr    $0x5,%eax
 804a273:	89 c2                	mov    %eax,%edx
 804a275:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a278:	83 c2 04             	add    $0x4,%edx
 804a27b:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a282:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
 804a286:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a289:	2b 45 f0             	sub    -0x10(%ebp),%eax
 804a28c:	83 f8 1f             	cmp    $0x1f,%eax
 804a28f:	77 dc                	ja     804a26d <malloc_make_chunks+0x100>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a291:	eb 2c                	jmp    804a2bf <malloc_make_chunks+0x152>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a293:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a296:	c1 e8 05             	shr    $0x5,%eax
 804a299:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a29c:	8d 48 04             	lea    0x4(%eax),%ecx
 804a29f:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a2a2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804a2a5:	83 e1 1f             	and    $0x1f,%ecx
 804a2a8:	be 01 00 00 00       	mov    $0x1,%esi
 804a2ad:	d3 e6                	shl    %cl,%esi
 804a2af:	89 f1                	mov    %esi,%ecx
 804a2b1:	09 d1                	or     %edx,%ecx
 804a2b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a2b6:	83 c0 04             	add    $0x4,%eax
 804a2b9:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a2bc:	ff 45 f0             	incl   -0x10(%ebp)
 804a2bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a2c2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a2c5:	72 cc                	jb     804a293 <malloc_make_chunks+0x126>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804a2c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a2ca:	8b 40 04             	mov    0x4(%eax),%eax
 804a2cd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804a2d0:	75 72                	jne    804a344 <malloc_make_chunks+0x1d7>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a2d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804a2d9:	eb 63                	jmp    804a33e <malloc_make_chunks+0x1d1>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804a2db:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a2de:	c1 e8 05             	shr    $0x5,%eax
 804a2e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a2e4:	8d 48 04             	lea    0x4(%eax),%ecx
 804a2e7:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a2ea:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804a2ed:	83 e1 1f             	and    $0x1f,%ecx
 804a2f0:	be 01 00 00 00       	mov    $0x1,%esi
 804a2f5:	d3 e6                	shl    %cl,%esi
 804a2f7:	89 f1                	mov    %esi,%ecx
 804a2f9:	f7 d1                	not    %ecx
 804a2fb:	21 d1                	and    %edx,%ecx
 804a2fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a300:	83 c0 04             	add    $0x4,%eax
 804a303:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804a306:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a309:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a30d:	48                   	dec    %eax
 804a30e:	0f b7 d0             	movzwl %ax,%edx
 804a311:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a314:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804a318:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a31b:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a31f:	48                   	dec    %eax
 804a320:	0f b7 d0             	movzwl %ax,%edx
 804a323:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a326:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804a32a:	8b 45 08             	mov    0x8(%ebp),%eax
 804a32d:	ba 01 00 00 00       	mov    $0x1,%edx
 804a332:	88 c1                	mov    %al,%cl
 804a334:	d3 e2                	shl    %cl,%edx
 804a336:	89 d0                	mov    %edx,%eax
 804a338:	29 45 ec             	sub    %eax,-0x14(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a33b:	ff 45 f0             	incl   -0x10(%ebp)
 804a33e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804a342:	75 97                	jne    804a2db <malloc_make_chunks+0x16e>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804a344:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a34a:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a34d:	89 d1                	mov    %edx,%ecx
 804a34f:	c1 e9 0c             	shr    $0xc,%ecx
 804a352:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
 804a358:	29 d1                	sub    %edx,%ecx
 804a35a:	89 ca                	mov    %ecx,%edx
 804a35c:	c1 e2 02             	shl    $0x2,%edx
 804a35f:	01 c2                	add    %eax,%edx
 804a361:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a364:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804a366:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a36c:	8b 55 08             	mov    0x8(%ebp),%edx
 804a36f:	c1 e2 02             	shl    $0x2,%edx
 804a372:	01 d0                	add    %edx,%eax
 804a374:	8b 10                	mov    (%eax),%edx
 804a376:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a379:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804a37b:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a381:	8b 55 08             	mov    0x8(%ebp),%edx
 804a384:	c1 e2 02             	shl    $0x2,%edx
 804a387:	01 c2                	add    %eax,%edx
 804a389:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a38c:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804a38e:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804a393:	83 c4 30             	add    $0x30,%esp
 804a396:	5b                   	pop    %ebx
 804a397:	5e                   	pop    %esi
 804a398:	5d                   	pop    %ebp
 804a399:	c3                   	ret    

0804a39a <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 804a39a:	55                   	push   %ebp
 804a39b:	89 e5                	mov    %esp,%ebp
 804a39d:	56                   	push   %esi
 804a39e:	53                   	push   %ebx
 804a39f:	83 ec 40             	sub    $0x40,%esp
 804a3a2:	e8 26 ec ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804a3a7:	81 c3 59 4c 00 00    	add    $0x4c59,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 804a3ad:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 804a3b1:	77 07                	ja     804a3ba <malloc_bytes+0x20>
                size = malloc_minsize;
 804a3b3:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 804a3ba:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
        i = size - 1;
 804a3c1:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3c4:	48                   	dec    %eax
 804a3c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (i >>= 1)
 804a3c8:	eb 03                	jmp    804a3cd <malloc_bytes+0x33>
                j++;
 804a3ca:	ff 45 f0             	incl   -0x10(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 804a3cd:	d1 7d f4             	sarl   -0xc(%ebp)
 804a3d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a3d4:	75 f4                	jne    804a3ca <malloc_bytes+0x30>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804a3d6:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a3dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a3df:	c1 e2 02             	shl    $0x2,%edx
 804a3e2:	01 d0                	add    %edx,%eax
 804a3e4:	8b 00                	mov    (%eax),%eax
 804a3e6:	85 c0                	test   %eax,%eax
 804a3e8:	0f 85 27 02 00 00    	jne    804a615 <malloc_bytes+0x27b>
 804a3ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804a3f4:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a3fb:	e8 d9 fb ff ff       	call   8049fd9 <malloc_pages>
 804a400:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804a403:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804a407:	75 0a                	jne    804a413 <malloc_bytes+0x79>
                return 0;
 804a409:	b8 00 00 00 00       	mov    $0x0,%eax
 804a40e:	e9 f4 01 00 00       	jmp    804a607 <malloc_bytes+0x26d>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804a413:	c7 45 d4 10 00 00 00 	movl   $0x10,-0x2c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804a41a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a41d:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a422:	88 c1                	mov    %al,%cl
 804a424:	d3 ea                	shr    %cl,%edx
 804a426:	89 d0                	mov    %edx,%eax
 804a428:	83 c0 1f             	add    $0x1f,%eax
 804a42b:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804a42e:	c1 e0 02             	shl    $0x2,%eax
 804a431:	01 45 d4             	add    %eax,-0x2c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804a434:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a437:	ba 01 00 00 00       	mov    $0x1,%edx
 804a43c:	88 c1                	mov    %al,%cl
 804a43e:	d3 e2                	shl    %cl,%edx
 804a440:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a443:	01 c0                	add    %eax,%eax
 804a445:	39 c2                	cmp    %eax,%edx
 804a447:	77 08                	ja     804a451 <malloc_bytes+0xb7>
                bp = (struct  pginfo *)pp;
 804a449:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a44c:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804a44f:	eb 29                	jmp    804a47a <malloc_bytes+0xe0>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804a451:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a454:	89 04 24             	mov    %eax,(%esp)
 804a457:	e8 c0 02 00 00       	call   804a71c <imalloc>
 804a45c:	89 45 d0             	mov    %eax,-0x30(%ebp)
                if (!bp) {
 804a45f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804a463:	75 15                	jne    804a47a <malloc_bytes+0xe0>
                        ifree(pp);
 804a465:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a468:	89 04 24             	mov    %eax,(%esp)
 804a46b:	e8 cb 0b 00 00       	call   804b03b <ifree>
                        return 0;
 804a470:	b8 00 00 00 00       	mov    $0x0,%eax
 804a475:	e9 8d 01 00 00       	jmp    804a607 <malloc_bytes+0x26d>
                }
        }

        bp->size = (1 << bits);
 804a47a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a47d:	ba 01 00 00 00       	mov    $0x1,%edx
 804a482:	88 c1                	mov    %al,%cl
 804a484:	d3 e2                	shl    %cl,%edx
 804a486:	89 d0                	mov    %edx,%eax
 804a488:	0f b7 d0             	movzwl %ax,%edx
 804a48b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a48e:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804a492:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a495:	0f b7 d0             	movzwl %ax,%edx
 804a498:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a49b:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804a49f:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a4a2:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a4a7:	88 c1                	mov    %al,%cl
 804a4a9:	d3 ea                	shr    %cl,%edx
 804a4ab:	89 d0                	mov    %edx,%eax
 804a4ad:	0f b7 d0             	movzwl %ax,%edx
 804a4b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4b3:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a4b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4ba:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a4be:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4c1:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804a4c5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4c8:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a4cb:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804a4ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4d1:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a4d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
        i = 0;
 804a4d8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804a4df:	eb 19                	jmp    804a4fa <malloc_bytes+0x160>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 804a4e1:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a4e4:	c1 e8 05             	shr    $0x5,%eax
 804a4e7:	89 c2                	mov    %eax,%edx
 804a4e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a4ec:	83 c2 04             	add    $0x4,%edx
 804a4ef:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a4f6:	83 45 c8 20          	addl   $0x20,-0x38(%ebp)
 804a4fa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a4fd:	2b 45 c8             	sub    -0x38(%ebp),%eax
 804a500:	83 f8 1f             	cmp    $0x1f,%eax
 804a503:	77 dc                	ja     804a4e1 <malloc_bytes+0x147>
 804a505:	eb 2c                	jmp    804a533 <malloc_bytes+0x199>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a507:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a50a:	c1 e8 05             	shr    $0x5,%eax
 804a50d:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a510:	8d 48 04             	lea    0x4(%eax),%ecx
 804a513:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a516:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804a519:	83 e1 1f             	and    $0x1f,%ecx
 804a51c:	be 01 00 00 00       	mov    $0x1,%esi
 804a521:	d3 e6                	shl    %cl,%esi
 804a523:	89 f1                	mov    %esi,%ecx
 804a525:	09 d1                	or     %edx,%ecx
 804a527:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a52a:	83 c0 04             	add    $0x4,%eax
 804a52d:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a530:	ff 45 c8             	incl   -0x38(%ebp)
 804a533:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a536:	3b 45 c8             	cmp    -0x38(%ebp),%eax
 804a539:	77 cc                	ja     804a507 <malloc_bytes+0x16d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804a53b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a53e:	8b 40 04             	mov    0x4(%eax),%eax
 804a541:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804a544:	75 72                	jne    804a5b8 <malloc_bytes+0x21e>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a546:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804a54d:	eb 63                	jmp    804a5b2 <malloc_bytes+0x218>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804a54f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a552:	c1 e8 05             	shr    $0x5,%eax
 804a555:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a558:	8d 48 04             	lea    0x4(%eax),%ecx
 804a55b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a55e:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804a561:	83 e1 1f             	and    $0x1f,%ecx
 804a564:	be 01 00 00 00       	mov    $0x1,%esi
 804a569:	d3 e6                	shl    %cl,%esi
 804a56b:	89 f1                	mov    %esi,%ecx
 804a56d:	f7 d1                	not    %ecx
 804a56f:	21 d1                	and    %edx,%ecx
 804a571:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a574:	83 c0 04             	add    $0x4,%eax
 804a577:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804a57a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a57d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a581:	48                   	dec    %eax
 804a582:	0f b7 d0             	movzwl %ax,%edx
 804a585:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a588:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804a58c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a58f:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a593:	48                   	dec    %eax
 804a594:	0f b7 d0             	movzwl %ax,%edx
 804a597:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a59a:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804a59e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a5a1:	ba 01 00 00 00       	mov    $0x1,%edx
 804a5a6:	88 c1                	mov    %al,%cl
 804a5a8:	d3 e2                	shl    %cl,%edx
 804a5aa:	89 d0                	mov    %edx,%eax
 804a5ac:	29 45 d4             	sub    %eax,-0x2c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a5af:	ff 45 c8             	incl   -0x38(%ebp)
 804a5b2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a5b6:	75 97                	jne    804a54f <malloc_bytes+0x1b5>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804a5b8:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a5be:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a5c1:	89 d1                	mov    %edx,%ecx
 804a5c3:	c1 e9 0c             	shr    $0xc,%ecx
 804a5c6:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
 804a5cc:	29 d1                	sub    %edx,%ecx
 804a5ce:	89 ca                	mov    %ecx,%edx
 804a5d0:	c1 e2 02             	shl    $0x2,%edx
 804a5d3:	01 c2                	add    %eax,%edx
 804a5d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5d8:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804a5da:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a5e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a5e3:	c1 e2 02             	shl    $0x2,%edx
 804a5e6:	01 d0                	add    %edx,%eax
 804a5e8:	8b 10                	mov    (%eax),%edx
 804a5ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5ed:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804a5ef:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a5f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a5f8:	c1 e2 02             	shl    $0x2,%edx
 804a5fb:	01 c2                	add    %eax,%edx
 804a5fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a600:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804a602:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804a607:	85 c0                	test   %eax,%eax
 804a609:	75 0a                	jne    804a615 <malloc_bytes+0x27b>
                return 0;
 804a60b:	b8 00 00 00 00       	mov    $0x0,%eax
 804a610:	e9 00 01 00 00       	jmp    804a715 <malloc_bytes+0x37b>

        bp = page_dir[j];
 804a615:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a61b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a61e:	c1 e2 02             	shl    $0x2,%edx
 804a621:	01 d0                	add    %edx,%eax
 804a623:	8b 00                	mov    (%eax),%eax
 804a625:	89 45 e0             	mov    %eax,-0x20(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 804a628:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a62b:	83 c0 10             	add    $0x10,%eax
 804a62e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a631:	eb 04                	jmp    804a637 <malloc_bytes+0x29d>
 804a633:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
 804a637:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a63a:	8b 00                	mov    (%eax),%eax
 804a63c:	85 c0                	test   %eax,%eax
 804a63e:	74 f3                	je     804a633 <malloc_bytes+0x299>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 804a640:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        k = 0;
 804a647:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        while (!(*lp & u)) {
 804a64e:	eb 0b                	jmp    804a65b <malloc_bytes+0x2c1>
                u += u;
 804a650:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a653:	01 c0                	add    %eax,%eax
 804a655:	89 45 ec             	mov    %eax,-0x14(%ebp)
                k++;
 804a658:	ff 45 e8             	incl   -0x18(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 804a65b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a65e:	8b 00                	mov    (%eax),%eax
 804a660:	23 45 ec             	and    -0x14(%ebp),%eax
 804a663:	85 c0                	test   %eax,%eax
 804a665:	74 e9                	je     804a650 <malloc_bytes+0x2b6>
                u += u;
                k++;
        }
        *lp ^= u;
 804a667:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a66a:	8b 00                	mov    (%eax),%eax
 804a66c:	33 45 ec             	xor    -0x14(%ebp),%eax
 804a66f:	89 c2                	mov    %eax,%edx
 804a671:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a674:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 804a676:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a679:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a67d:	48                   	dec    %eax
 804a67e:	0f b7 d0             	movzwl %ax,%edx
 804a681:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a684:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a688:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a68b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a68f:	85 c0                	test   %eax,%eax
 804a691:	75 1e                	jne    804a6b1 <malloc_bytes+0x317>
                page_dir[j] = bp->next;
 804a693:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a699:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a69c:	c1 e2 02             	shl    $0x2,%edx
 804a69f:	01 c2                	add    %eax,%edx
 804a6a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6a4:	8b 00                	mov    (%eax),%eax
 804a6a6:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 804a6a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 804a6b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a6b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a6b7:	83 c2 10             	add    $0x10,%edx
 804a6ba:	29 d0                	sub    %edx,%eax
 804a6bc:	c1 f8 02             	sar    $0x2,%eax
 804a6bf:	c1 e0 05             	shl    $0x5,%eax
 804a6c2:	89 c2                	mov    %eax,%edx
 804a6c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a6c7:	01 d0                	add    %edx,%eax
 804a6c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        k <<= bp->shift;
 804a6cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6cf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a6d3:	88 c1                	mov    %al,%cl
 804a6d5:	d3 65 e8             	shll   %cl,-0x18(%ebp)

        if (malloc_junk)
 804a6d8:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804a6de:	85 c0                	test   %eax,%eax
 804a6e0:	74 28                	je     804a70a <malloc_bytes+0x370>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 804a6e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6e5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a6e9:	89 c2                	mov    %eax,%edx
 804a6eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a6ee:	8b 48 04             	mov    0x4(%eax),%ecx
 804a6f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a6f4:	01 c8                	add    %ecx,%eax
 804a6f6:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a6fa:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a701:	00 
 804a702:	89 04 24             	mov    %eax,(%esp)
 804a705:	e8 75 ea ff ff       	call   804917f <memset>

        return (u_char *)bp->page + k;
 804a70a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a70d:	8b 50 04             	mov    0x4(%eax),%edx
 804a710:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a713:	01 d0                	add    %edx,%eax
}
 804a715:	83 c4 40             	add    $0x40,%esp
 804a718:	5b                   	pop    %ebx
 804a719:	5e                   	pop    %esi
 804a71a:	5d                   	pop    %ebp
 804a71b:	c3                   	ret    

0804a71c <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 804a71c:	55                   	push   %ebp
 804a71d:	89 e5                	mov    %esp,%ebp
 804a71f:	53                   	push   %ebx
 804a720:	83 ec 24             	sub    $0x24,%esp
 804a723:	e8 a5 e8 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804a728:	81 c3 d8 48 00 00    	add    $0x48d8,%ebx
        void *result;

        if (suicide)
 804a72e:	8b 83 3c 02 00 00    	mov    0x23c(%ebx),%eax
 804a734:	85 c0                	test   %eax,%eax
 804a736:	74 0c                	je     804a744 <imalloc+0x28>
                abort();
 804a738:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a73f:	e8 1e dd ff ff       	call   8048462 <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 804a744:	8b 45 08             	mov    0x8(%ebp),%eax
 804a747:	05 00 10 00 00       	add    $0x1000,%eax
 804a74c:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a74f:	73 09                	jae    804a75a <imalloc+0x3e>
                result = 0;
 804a751:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804a758:	eb 27                	jmp    804a781 <imalloc+0x65>
        else if (size <= malloc_maxsize)
 804a75a:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 804a761:	77 10                	ja     804a773 <imalloc+0x57>
                result =  malloc_bytes(size);
 804a763:	8b 45 08             	mov    0x8(%ebp),%eax
 804a766:	89 04 24             	mov    %eax,(%esp)
 804a769:	e8 2c fc ff ff       	call   804a39a <malloc_bytes>
 804a76e:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a771:	eb 0e                	jmp    804a781 <imalloc+0x65>
        else
                result =  malloc_pages(size);
 804a773:	8b 45 08             	mov    0x8(%ebp),%eax
 804a776:	89 04 24             	mov    %eax,(%esp)
 804a779:	e8 5b f8 ff ff       	call   8049fd9 <malloc_pages>
 804a77e:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 804a781:	8b 83 38 02 00 00    	mov    0x238(%ebx),%eax
 804a787:	85 c0                	test   %eax,%eax
 804a789:	74 14                	je     804a79f <imalloc+0x83>
 804a78b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a78f:	75 0e                	jne    804a79f <imalloc+0x83>
                wrterror("allocation failed.\n");
 804a791:	8d 83 cc ed ff ff    	lea    -0x1234(%ebx),%eax
 804a797:	89 04 24             	mov    %eax,(%esp)
 804a79a:	e8 36 f2 ff ff       	call   80499d5 <wrterror>

        if (malloc_zero && result)
 804a79f:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804a7a5:	85 c0                	test   %eax,%eax
 804a7a7:	74 20                	je     804a7c9 <imalloc+0xad>
 804a7a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a7ad:	74 1a                	je     804a7c9 <imalloc+0xad>
                memset(result, 0, size);
 804a7af:	8b 45 08             	mov    0x8(%ebp),%eax
 804a7b2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a7b6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a7bd:	00 
 804a7be:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a7c1:	89 04 24             	mov    %eax,(%esp)
 804a7c4:	e8 b6 e9 ff ff       	call   804917f <memset>

        return result;
 804a7c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a7cc:	83 c4 24             	add    $0x24,%esp
 804a7cf:	5b                   	pop    %ebx
 804a7d0:	5d                   	pop    %ebp
 804a7d1:	c3                   	ret    

0804a7d2 <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 804a7d2:	55                   	push   %ebp
 804a7d3:	89 e5                	mov    %esp,%ebp
 804a7d5:	56                   	push   %esi
 804a7d6:	53                   	push   %ebx
 804a7d7:	83 ec 30             	sub    $0x30,%esp
 804a7da:	e8 ee e7 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804a7df:	81 c3 21 48 00 00    	add    $0x4821,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 804a7e5:	8b 83 3c 02 00 00    	mov    0x23c(%ebx),%eax
 804a7eb:	85 c0                	test   %eax,%eax
 804a7ed:	74 0c                	je     804a7fb <irealloc+0x29>
                abort();
 804a7ef:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a7f6:	e8 67 dc ff ff       	call   8048462 <exit>

        index = ptr2index(ptr);
 804a7fb:	8b 45 08             	mov    0x8(%ebp),%eax
 804a7fe:	c1 e8 0c             	shr    $0xc,%eax
 804a801:	89 c2                	mov    %eax,%edx
 804a803:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804a809:	29 c2                	sub    %eax,%edx
 804a80b:	89 d0                	mov    %edx,%eax
 804a80d:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (index < malloc_pageshift) {
 804a810:	83 7d ec 0b          	cmpl   $0xb,-0x14(%ebp)
 804a814:	77 18                	ja     804a82e <irealloc+0x5c>
                wrtwarning("junk pointer, too low to make sense.\n");
 804a816:	8d 83 e0 ed ff ff    	lea    -0x1220(%ebx),%eax
 804a81c:	89 04 24             	mov    %eax,(%esp)
 804a81f:	e8 81 f2 ff ff       	call   8049aa5 <wrtwarning>
                return 0;
 804a824:	b8 00 00 00 00       	mov    $0x0,%eax
 804a829:	e9 fc 01 00 00       	jmp    804aa2a <irealloc+0x258>
        }

        if (index > last_index) {
 804a82e:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 804a834:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 804a837:	76 18                	jbe    804a851 <irealloc+0x7f>
                wrtwarning("junk pointer, too high to make sense.\n");
 804a839:	8d 83 08 ee ff ff    	lea    -0x11f8(%ebx),%eax
 804a83f:	89 04 24             	mov    %eax,(%esp)
 804a842:	e8 5e f2 ff ff       	call   8049aa5 <wrtwarning>
                return 0;
 804a847:	b8 00 00 00 00       	mov    $0x0,%eax
 804a84c:	e9 d9 01 00 00       	jmp    804aa2a <irealloc+0x258>
        }

        mp = &page_dir[index];
 804a851:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804a857:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a85a:	c1 e2 02             	shl    $0x2,%edx
 804a85d:	01 d0                	add    %edx,%eax
 804a85f:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804a862:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a865:	8b 00                	mov    (%eax),%eax
 804a867:	83 f8 02             	cmp    $0x2,%eax
 804a86a:	75 75                	jne    804a8e1 <irealloc+0x10f>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804a86c:	8b 45 08             	mov    0x8(%ebp),%eax
 804a86f:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a874:	85 c0                	test   %eax,%eax
 804a876:	74 18                	je     804a890 <irealloc+0xbe>
                        wrtwarning("modified (page-) pointer.\n");
 804a878:	8d 83 2f ee ff ff    	lea    -0x11d1(%ebx),%eax
 804a87e:	89 04 24             	mov    %eax,(%esp)
 804a881:	e8 1f f2 ff ff       	call   8049aa5 <wrtwarning>
                        return 0;
 804a886:	b8 00 00 00 00       	mov    $0x0,%eax
 804a88b:	e9 9a 01 00 00       	jmp    804aa2a <irealloc+0x258>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a890:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
 804a897:	eb 07                	jmp    804a8a0 <irealloc+0xce>
                        osize += malloc_pagesize;
 804a899:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a8a0:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
 804a8a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a8a7:	8b 00                	mov    (%eax),%eax
 804a8a9:	83 f8 03             	cmp    $0x3,%eax
 804a8ac:	74 eb                	je     804a899 <irealloc+0xc7>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804a8ae:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 804a8b4:	85 c0                	test   %eax,%eax
 804a8b6:	0f 85 04 01 00 00    	jne    804a9c0 <irealloc+0x1ee>
 804a8bc:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a8bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804a8c2:	0f 87 f8 00 00 00    	ja     804a9c0 <irealloc+0x1ee>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804a8c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a8cb:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804a8d0:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a8d3:	0f 83 e7 00 00 00    	jae    804a9c0 <irealloc+0x1ee>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804a8d9:	8b 45 08             	mov    0x8(%ebp),%eax
 804a8dc:	e9 49 01 00 00       	jmp    804aa2a <irealloc+0x258>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804a8e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a8e4:	8b 00                	mov    (%eax),%eax
 804a8e6:	83 f8 03             	cmp    $0x3,%eax
 804a8e9:	0f 86 bc 00 00 00    	jbe    804a9ab <irealloc+0x1d9>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804a8ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a8f2:	8b 00                	mov    (%eax),%eax
 804a8f4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a8f8:	48                   	dec    %eax
 804a8f9:	89 c2                	mov    %eax,%edx
 804a8fb:	8b 45 08             	mov    0x8(%ebp),%eax
 804a8fe:	21 d0                	and    %edx,%eax
 804a900:	85 c0                	test   %eax,%eax
 804a902:	74 18                	je     804a91c <irealloc+0x14a>
                        wrtwarning("modified (chunk-) pointer.\n");
 804a904:	8d 83 4a ee ff ff    	lea    -0x11b6(%ebx),%eax
 804a90a:	89 04 24             	mov    %eax,(%esp)
 804a90d:	e8 93 f1 ff ff       	call   8049aa5 <wrtwarning>
                        return 0;
 804a912:	b8 00 00 00 00       	mov    $0x0,%eax
 804a917:	e9 0e 01 00 00       	jmp    804aa2a <irealloc+0x258>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804a91c:	8b 45 08             	mov    0x8(%ebp),%eax
 804a91f:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a924:	89 c2                	mov    %eax,%edx
 804a926:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a929:	8b 00                	mov    (%eax),%eax
 804a92b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a92f:	88 c1                	mov    %al,%cl
 804a931:	d3 ea                	shr    %cl,%edx
 804a933:	89 d0                	mov    %edx,%eax
 804a935:	89 45 e8             	mov    %eax,-0x18(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804a938:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a93b:	8b 00                	mov    (%eax),%eax
 804a93d:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a940:	c1 ea 05             	shr    $0x5,%edx
 804a943:	83 c2 04             	add    $0x4,%edx
 804a946:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804a949:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a94c:	83 e2 1f             	and    $0x1f,%edx
 804a94f:	be 01 00 00 00       	mov    $0x1,%esi
 804a954:	88 d1                	mov    %dl,%cl
 804a956:	d3 e6                	shl    %cl,%esi
 804a958:	89 f2                	mov    %esi,%edx
 804a95a:	21 d0                	and    %edx,%eax
 804a95c:	85 c0                	test   %eax,%eax
 804a95e:	74 18                	je     804a978 <irealloc+0x1a6>
                        wrtwarning("chunk is already free.\n");
 804a960:	8d 83 66 ee ff ff    	lea    -0x119a(%ebx),%eax
 804a966:	89 04 24             	mov    %eax,(%esp)
 804a969:	e8 37 f1 ff ff       	call   8049aa5 <wrtwarning>
                        return 0;
 804a96e:	b8 00 00 00 00       	mov    $0x0,%eax
 804a973:	e9 b2 00 00 00       	jmp    804aa2a <irealloc+0x258>
                }

                osize = (*mp)->size;
 804a978:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a97b:	8b 00                	mov    (%eax),%eax
 804a97d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a981:	89 45 f4             	mov    %eax,-0xc(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804a984:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 804a98a:	85 c0                	test   %eax,%eax
 804a98c:	75 32                	jne    804a9c0 <irealloc+0x1ee>
 804a98e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a991:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804a994:	73 2a                	jae    804a9c0 <irealloc+0x1ee>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804a996:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a999:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804a99b:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a99e:	72 06                	jb     804a9a6 <irealloc+0x1d4>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804a9a0:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
 804a9a4:	75 1a                	jne    804a9c0 <irealloc+0x1ee>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804a9a6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9a9:	eb 7f                	jmp    804aa2a <irealloc+0x258>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804a9ab:	8d 83 7e ee ff ff    	lea    -0x1182(%ebx),%eax
 804a9b1:	89 04 24             	mov    %eax,(%esp)
 804a9b4:	e8 ec f0 ff ff       	call   8049aa5 <wrtwarning>
                return 0;
 804a9b9:	b8 00 00 00 00       	mov    $0x0,%eax
 804a9be:	eb 6a                	jmp    804aa2a <irealloc+0x258>
        }

        p = imalloc(size);
 804a9c0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a9c3:	89 04 24             	mov    %eax,(%esp)
 804a9c6:	e8 51 fd ff ff       	call   804a71c <imalloc>
 804a9cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (p) {
 804a9ce:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804a9d2:	74 53                	je     804aa27 <irealloc+0x255>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804a9d4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804a9d8:	74 42                	je     804aa1c <irealloc+0x24a>
 804a9da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a9de:	74 3c                	je     804aa1c <irealloc+0x24a>
                        ;
                else if (osize < size)
 804a9e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a9e3:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a9e6:	73 1b                	jae    804aa03 <irealloc+0x231>
                        memcpy(p, ptr, osize);
 804a9e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a9eb:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a9ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9f2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a9f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a9f9:	89 04 24             	mov    %eax,(%esp)
 804a9fc:	e8 23 e6 ff ff       	call   8049024 <memcpy>
 804aa01:	eb 19                	jmp    804aa1c <irealloc+0x24a>
                else
                        memcpy(p, ptr, size);
 804aa03:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aa06:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aa0a:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa0d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa14:	89 04 24             	mov    %eax,(%esp)
 804aa17:	e8 08 e6 ff ff       	call   8049024 <memcpy>
                ifree(ptr);
 804aa1c:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa1f:	89 04 24             	mov    %eax,(%esp)
 804aa22:	e8 14 06 00 00       	call   804b03b <ifree>
        }
        return p;
 804aa27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
 804aa2a:	83 c4 30             	add    $0x30,%esp
 804aa2d:	5b                   	pop    %ebx
 804aa2e:	5e                   	pop    %esi
 804aa2f:	5d                   	pop    %ebp
 804aa30:	c3                   	ret    

0804aa31 <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804aa31:	55                   	push   %ebp
 804aa32:	89 e5                	mov    %esp,%ebp
 804aa34:	53                   	push   %ebx
 804aa35:	83 ec 34             	sub    $0x34,%esp
 804aa38:	e8 90 e5 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804aa3d:	81 c3 c3 45 00 00    	add    $0x45c3,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804aa43:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804aa4a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804aa4e:	75 13                	jne    804aa63 <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804aa50:	8d 83 96 ee ff ff    	lea    -0x116a(%ebx),%eax
 804aa56:	89 04 24             	mov    %eax,(%esp)
 804aa59:	e8 47 f0 ff ff       	call   8049aa5 <wrtwarning>
                return;
 804aa5e:	e9 db 03 00 00       	jmp    804ae3e <free_pages+0x40d>
        }

        if (info != MALLOC_FIRST) {
 804aa63:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804aa67:	74 13                	je     804aa7c <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804aa69:	8d 83 7e ee ff ff    	lea    -0x1182(%ebx),%eax
 804aa6f:	89 04 24             	mov    %eax,(%esp)
 804aa72:	e8 2e f0 ff ff       	call   8049aa5 <wrtwarning>
                return;
 804aa77:	e9 c2 03 00 00       	jmp    804ae3e <free_pages+0x40d>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804aa7c:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa7f:	25 ff 0f 00 00       	and    $0xfff,%eax
 804aa84:	85 c0                	test   %eax,%eax
 804aa86:	74 13                	je     804aa9b <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804aa88:	8d 83 2f ee ff ff    	lea    -0x11d1(%ebx),%eax
 804aa8e:	89 04 24             	mov    %eax,(%esp)
 804aa91:	e8 0f f0 ff ff       	call   8049aa5 <wrtwarning>
                return;
 804aa96:	e9 a3 03 00 00       	jmp    804ae3e <free_pages+0x40d>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804aa9b:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804aaa1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804aaa4:	c1 e2 02             	shl    $0x2,%edx
 804aaa7:	01 d0                	add    %edx,%eax
 804aaa9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804aaaf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804aab6:	eb 1c                	jmp    804aad4 <free_pages+0xa3>
                page_dir[index + i] = MALLOC_FREE;
 804aab8:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804aabe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804aac1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804aac4:	01 ca                	add    %ecx,%edx
 804aac6:	c1 e2 02             	shl    $0x2,%edx
 804aac9:	01 d0                	add    %edx,%eax
 804aacb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804aad1:	ff 45 f4             	incl   -0xc(%ebp)
 804aad4:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804aada:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804aadd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804aae0:	01 ca                	add    %ecx,%edx
 804aae2:	c1 e2 02             	shl    $0x2,%edx
 804aae5:	01 d0                	add    %edx,%eax
 804aae7:	8b 00                	mov    (%eax),%eax
 804aae9:	83 f8 03             	cmp    $0x3,%eax
 804aaec:	74 ca                	je     804aab8 <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804aaee:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aaf1:	c1 e0 0c             	shl    $0xc,%eax
 804aaf4:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804aaf7:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804aafd:	85 c0                	test   %eax,%eax
 804aaff:	74 1a                	je     804ab1b <free_pages+0xea>
                memset(ptr, SOME_JUNK, l);
 804ab01:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ab04:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ab08:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804ab0f:	00 
 804ab10:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab13:	89 04 24             	mov    %eax,(%esp)
 804ab16:	e8 64 e6 ff ff       	call   804917f <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804ab1b:	8b 55 08             	mov    0x8(%ebp),%edx
 804ab1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ab21:	01 d0                	add    %edx,%eax
 804ab23:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804ab26:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab2c:	85 c0                	test   %eax,%eax
 804ab2e:	75 12                	jne    804ab42 <free_pages+0x111>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804ab30:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804ab37:	e8 e0 fb ff ff       	call   804a71c <imalloc>
 804ab3c:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
        px->page = ptr;
 804ab42:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab48:	8b 55 08             	mov    0x8(%ebp),%edx
 804ab4b:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804ab4e:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab54:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ab57:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804ab5a:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab60:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804ab63:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804ab66:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
 804ab6c:	85 c0                	test   %eax,%eax
 804ab6e:	75 41                	jne    804abb1 <free_pages+0x180>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804ab70:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab76:	8b 93 24 02 00 00    	mov    0x224(%ebx),%edx
 804ab7c:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804ab7e:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab84:	8d 93 24 02 00 00    	lea    0x224(%ebx),%edx
 804ab8a:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804ab8d:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab93:	89 83 24 02 00 00    	mov    %eax,0x224(%ebx)
                pf = px;
 804ab99:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804aba2:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804aba9:	00 00 00 
 804abac:	e9 a2 01 00 00       	jmp    804ad53 <free_pages+0x322>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804abb1:	8b 55 08             	mov    0x8(%ebp),%edx
 804abb4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804abb7:	01 d0                	add    %edx,%eax
 804abb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804abbc:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
 804abc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abc5:	eb 08                	jmp    804abcf <free_pages+0x19e>
 804abc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804abca:	8b 00                	mov    (%eax),%eax
 804abcc:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804abd2:	8b 40 0c             	mov    0xc(%eax),%eax
 804abd5:	3b 45 08             	cmp    0x8(%ebp),%eax
 804abd8:	73 09                	jae    804abe3 <free_pages+0x1b2>
 804abda:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804abdd:	8b 00                	mov    (%eax),%eax
 804abdf:	85 c0                	test   %eax,%eax
 804abe1:	75 e4                	jne    804abc7 <free_pages+0x196>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804abe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804abe6:	8b 40 08             	mov    0x8(%eax),%eax
 804abe9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804abec:	76 4f                	jbe    804ac3d <free_pages+0x20c>
                        /* Insert before entry */
                        px->next = pf;
 804abee:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804abf4:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804abf7:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804abf9:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804abff:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ac02:	8b 52 04             	mov    0x4(%edx),%edx
 804ac05:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804ac08:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804ac0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac11:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804ac14:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ac1a:	8b 40 04             	mov    0x4(%eax),%eax
 804ac1d:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804ac23:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804ac25:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ac2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804ac2e:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804ac35:	00 00 00 
 804ac38:	e9 16 01 00 00       	jmp    804ad53 <free_pages+0x322>
                } else if (pf->end == ptr) {
 804ac3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac40:	8b 40 0c             	mov    0xc(%eax),%eax
 804ac43:	3b 45 08             	cmp    0x8(%ebp),%eax
 804ac46:	0f 85 91 00 00 00    	jne    804acdd <free_pages+0x2ac>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804ac4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac4f:	8b 50 0c             	mov    0xc(%eax),%edx
 804ac52:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac55:	01 c2                	add    %eax,%edx
 804ac57:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac5a:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804ac5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac60:	8b 50 10             	mov    0x10(%eax),%edx
 804ac63:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac66:	01 c2                	add    %eax,%edx
 804ac68:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac6b:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804ac6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac71:	8b 00                	mov    (%eax),%eax
 804ac73:	85 c0                	test   %eax,%eax
 804ac75:	0f 84 d8 00 00 00    	je     804ad53 <free_pages+0x322>
 804ac7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac7e:	8b 50 0c             	mov    0xc(%eax),%edx
 804ac81:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac84:	8b 00                	mov    (%eax),%eax
 804ac86:	8b 40 08             	mov    0x8(%eax),%eax
 804ac89:	39 c2                	cmp    %eax,%edx
 804ac8b:	0f 85 c2 00 00 00    	jne    804ad53 <free_pages+0x322>
                                /* And collapse the next too. */
                                pt = pf->next;
 804ac91:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac94:	8b 00                	mov    (%eax),%eax
 804ac96:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804ac99:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ac9c:	8b 50 0c             	mov    0xc(%eax),%edx
 804ac9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aca2:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804aca5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aca8:	8b 50 10             	mov    0x10(%eax),%edx
 804acab:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804acae:	8b 40 10             	mov    0x10(%eax),%eax
 804acb1:	01 c2                	add    %eax,%edx
 804acb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acb6:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804acb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804acbc:	8b 10                	mov    (%eax),%edx
 804acbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acc1:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804acc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acc6:	8b 00                	mov    (%eax),%eax
 804acc8:	85 c0                	test   %eax,%eax
 804acca:	0f 84 83 00 00 00    	je     804ad53 <free_pages+0x322>
                                        pf->next->prev = pf;
 804acd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acd3:	8b 00                	mov    (%eax),%eax
 804acd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804acd8:	89 50 04             	mov    %edx,0x4(%eax)
 804acdb:	eb 76                	jmp    804ad53 <free_pages+0x322>
                        }
                } else if (pf->page == tail) {
 804acdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ace0:	8b 40 08             	mov    0x8(%eax),%eax
 804ace3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804ace6:	75 1c                	jne    804ad04 <free_pages+0x2d3>
                        /* Prepend to entry */
                        pf->size += l;
 804ace8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aceb:	8b 50 10             	mov    0x10(%eax),%edx
 804acee:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804acf1:	01 c2                	add    %eax,%edx
 804acf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acf6:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804acf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acfc:	8b 55 08             	mov    0x8(%ebp),%edx
 804acff:	89 50 08             	mov    %edx,0x8(%eax)
 804ad02:	eb 4f                	jmp    804ad53 <free_pages+0x322>
                } else if (!pf->next) {
 804ad04:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad07:	8b 00                	mov    (%eax),%eax
 804ad09:	85 c0                	test   %eax,%eax
 804ad0b:	75 38                	jne    804ad45 <free_pages+0x314>
                        /* Append at tail of chain */
                        px->next = 0;
 804ad0d:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ad13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804ad19:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ad1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ad22:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804ad25:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804ad2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad2e:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804ad30:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ad36:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804ad39:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804ad40:	00 00 00 
 804ad43:	eb 0e                	jmp    804ad53 <free_pages+0x322>
                } else {
                        wrterror("freelist is destroyed.\n");
 804ad45:	8d 83 ad ee ff ff    	lea    -0x1153(%ebx),%eax
 804ad4b:	89 04 24             	mov    %eax,(%esp)
 804ad4e:	e8 82 ec ff ff       	call   80499d5 <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ad53:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad56:	8b 00                	mov    (%eax),%eax
 804ad58:	85 c0                	test   %eax,%eax
 804ad5a:	0f 85 cd 00 00 00    	jne    804ae2d <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ad60:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad63:	8b 50 10             	mov    0x10(%eax),%edx
 804ad66:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ad6c:	39 c2                	cmp    %eax,%edx
 804ad6e:	0f 86 b9 00 00 00    	jbe    804ae2d <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ad74:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad77:	8b 50 0c             	mov    0xc(%eax),%edx
 804ad7a:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ad80:	39 c2                	cmp    %eax,%edx
 804ad82:	0f 85 a5 00 00 00    	jne    804ae2d <free_pages+0x3fc>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804ad88:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ad8f:	e8 df d4 ff ff       	call   8048273 <sbrk>
 804ad94:	89 c2                	mov    %eax,%edx
 804ad96:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ad9c:	39 c2                	cmp    %eax,%edx
 804ad9e:	0f 85 89 00 00 00    	jne    804ae2d <free_pages+0x3fc>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804ada4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ada7:	8b 50 08             	mov    0x8(%eax),%edx
 804adaa:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 804adb0:	01 c2                	add    %eax,%edx
 804adb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adb5:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804adb8:	8b 93 20 00 00 00    	mov    0x20(%ebx),%edx
 804adbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adc1:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804adc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adc7:	8b 40 0c             	mov    0xc(%eax),%eax
 804adca:	89 04 24             	mov    %eax,(%esp)
 804adcd:	e8 6a d5 ff ff       	call   804833c <brk>
                malloc_brk = pf->end;
 804add2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804add5:	8b 40 0c             	mov    0xc(%eax),%eax
 804add8:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

                index = ptr2index(pf->end);
 804adde:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ade1:	8b 40 0c             	mov    0xc(%eax),%eax
 804ade4:	c1 e8 0c             	shr    $0xc,%eax
 804ade7:	89 c2                	mov    %eax,%edx
 804ade9:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804adef:	29 c2                	sub    %eax,%edx
 804adf1:	89 d0                	mov    %edx,%eax
 804adf3:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804adf6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804adf9:	48                   	dec    %eax
 804adfa:	89 83 18 02 00 00    	mov    %eax,0x218(%ebx)

                for (i = index; i <= last_index;)
 804ae00:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ae03:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ae06:	eb 1a                	jmp    804ae22 <free_pages+0x3f1>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804ae08:	8b 8b 1c 02 00 00    	mov    0x21c(%ebx),%ecx
 804ae0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ae11:	8d 50 01             	lea    0x1(%eax),%edx
 804ae14:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ae17:	c1 e0 02             	shl    $0x2,%eax
 804ae1a:	01 c8                	add    %ecx,%eax
 804ae1c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804ae22:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 804ae28:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804ae2b:	76 db                	jbe    804ae08 <free_pages+0x3d7>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804ae2d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804ae31:	74 0b                	je     804ae3e <free_pages+0x40d>
                ifree(pt);
 804ae33:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ae36:	89 04 24             	mov    %eax,(%esp)
 804ae39:	e8 fd 01 00 00       	call   804b03b <ifree>
}
 804ae3e:	83 c4 34             	add    $0x34,%esp
 804ae41:	5b                   	pop    %ebx
 804ae42:	5d                   	pop    %ebp
 804ae43:	c3                   	ret    

0804ae44 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804ae44:	55                   	push   %ebp
 804ae45:	89 e5                	mov    %esp,%ebp
 804ae47:	56                   	push   %esi
 804ae48:	53                   	push   %ebx
 804ae49:	83 ec 20             	sub    $0x20,%esp
 804ae4c:	e8 7c e1 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804ae51:	81 c3 af 41 00 00    	add    $0x41af,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804ae57:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae5a:	25 ff 0f 00 00       	and    $0xfff,%eax
 804ae5f:	89 c2                	mov    %eax,%edx
 804ae61:	8b 45 10             	mov    0x10(%ebp),%eax
 804ae64:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804ae68:	88 c1                	mov    %al,%cl
 804ae6a:	d3 ea                	shr    %cl,%edx
 804ae6c:	89 d0                	mov    %edx,%eax
 804ae6e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804ae71:	8b 45 10             	mov    0x10(%ebp),%eax
 804ae74:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804ae78:	48                   	dec    %eax
 804ae79:	89 c2                	mov    %eax,%edx
 804ae7b:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae7e:	21 d0                	and    %edx,%eax
 804ae80:	85 c0                	test   %eax,%eax
 804ae82:	74 13                	je     804ae97 <free_bytes+0x53>
                wrtwarning("modified (chunk-) pointer.\n");
 804ae84:	8d 83 4a ee ff ff    	lea    -0x11b6(%ebx),%eax
 804ae8a:	89 04 24             	mov    %eax,(%esp)
 804ae8d:	e8 13 ec ff ff       	call   8049aa5 <wrtwarning>
                return;
 804ae92:	e9 9d 01 00 00       	jmp    804b034 <free_bytes+0x1f0>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804ae97:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae9a:	c1 e8 05             	shr    $0x5,%eax
 804ae9d:	89 c2                	mov    %eax,%edx
 804ae9f:	8b 45 10             	mov    0x10(%ebp),%eax
 804aea2:	83 c2 04             	add    $0x4,%edx
 804aea5:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804aea8:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804aeab:	83 e2 1f             	and    $0x1f,%edx
 804aeae:	be 01 00 00 00       	mov    $0x1,%esi
 804aeb3:	88 d1                	mov    %dl,%cl
 804aeb5:	d3 e6                	shl    %cl,%esi
 804aeb7:	89 f2                	mov    %esi,%edx
 804aeb9:	21 d0                	and    %edx,%eax
 804aebb:	85 c0                	test   %eax,%eax
 804aebd:	74 13                	je     804aed2 <free_bytes+0x8e>
                wrtwarning("chunk is already free.\n");
 804aebf:	8d 83 66 ee ff ff    	lea    -0x119a(%ebx),%eax
 804aec5:	89 04 24             	mov    %eax,(%esp)
 804aec8:	e8 d8 eb ff ff       	call   8049aa5 <wrtwarning>
                return;
 804aecd:	e9 62 01 00 00       	jmp    804b034 <free_bytes+0x1f0>
        }

        if (malloc_junk)
 804aed2:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804aed8:	85 c0                	test   %eax,%eax
 804aeda:	74 1e                	je     804aefa <free_bytes+0xb6>
                memset(ptr, SOME_JUNK, info->size);
 804aedc:	8b 45 10             	mov    0x10(%ebp),%eax
 804aedf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804aee3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aee7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804aeee:	00 
 804aeef:	8b 45 08             	mov    0x8(%ebp),%eax
 804aef2:	89 04 24             	mov    %eax,(%esp)
 804aef5:	e8 85 e2 ff ff       	call   804917f <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804aefa:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aefd:	c1 e8 05             	shr    $0x5,%eax
 804af00:	8b 55 10             	mov    0x10(%ebp),%edx
 804af03:	8d 48 04             	lea    0x4(%eax),%ecx
 804af06:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804af09:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804af0c:	83 e1 1f             	and    $0x1f,%ecx
 804af0f:	be 01 00 00 00       	mov    $0x1,%esi
 804af14:	d3 e6                	shl    %cl,%esi
 804af16:	89 f1                	mov    %esi,%ecx
 804af18:	09 d1                	or     %edx,%ecx
 804af1a:	8b 55 10             	mov    0x10(%ebp),%edx
 804af1d:	83 c0 04             	add    $0x4,%eax
 804af20:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804af23:	8b 45 10             	mov    0x10(%ebp),%eax
 804af26:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804af2a:	40                   	inc    %eax
 804af2b:	0f b7 d0             	movzwl %ax,%edx
 804af2e:	8b 45 10             	mov    0x10(%ebp),%eax
 804af31:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804af35:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804af3b:	8b 45 10             	mov    0x10(%ebp),%eax
 804af3e:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804af42:	c1 e0 02             	shl    $0x2,%eax
 804af45:	01 d0                	add    %edx,%eax
 804af47:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free == 1) {
 804af4a:	8b 45 10             	mov    0x10(%ebp),%eax
 804af4d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804af51:	83 f8 01             	cmp    $0x1,%eax
 804af54:	75 5e                	jne    804afb4 <free_bytes+0x170>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804af56:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804af5c:	8b 45 10             	mov    0x10(%ebp),%eax
 804af5f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804af63:	c1 e0 02             	shl    $0x2,%eax
 804af66:	01 d0                	add    %edx,%eax
 804af68:	89 45 f4             	mov    %eax,-0xc(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804af6b:	eb 08                	jmp    804af75 <free_bytes+0x131>
                        mp = &(*mp)->next;
 804af6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af70:	8b 00                	mov    (%eax),%eax
 804af72:	89 45 f4             	mov    %eax,-0xc(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804af75:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af78:	8b 00                	mov    (%eax),%eax
 804af7a:	85 c0                	test   %eax,%eax
 804af7c:	74 1f                	je     804af9d <free_bytes+0x159>
 804af7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af81:	8b 00                	mov    (%eax),%eax
 804af83:	8b 00                	mov    (%eax),%eax
 804af85:	85 c0                	test   %eax,%eax
 804af87:	74 14                	je     804af9d <free_bytes+0x159>
 804af89:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af8c:	8b 00                	mov    (%eax),%eax
 804af8e:	8b 00                	mov    (%eax),%eax
 804af90:	8b 50 04             	mov    0x4(%eax),%edx
 804af93:	8b 45 10             	mov    0x10(%ebp),%eax
 804af96:	8b 40 04             	mov    0x4(%eax),%eax
 804af99:	39 c2                	cmp    %eax,%edx
 804af9b:	72 d0                	jb     804af6d <free_bytes+0x129>
                        mp = &(*mp)->next;
                info->next = *mp;
 804af9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afa0:	8b 10                	mov    (%eax),%edx
 804afa2:	8b 45 10             	mov    0x10(%ebp),%eax
 804afa5:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804afa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afaa:	8b 55 10             	mov    0x10(%ebp),%edx
 804afad:	89 10                	mov    %edx,(%eax)
                return;
 804afaf:	e9 80 00 00 00       	jmp    804b034 <free_bytes+0x1f0>
        }

        if (info->free != info->total)
 804afb4:	8b 45 10             	mov    0x10(%ebp),%eax
 804afb7:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804afbb:	8b 45 10             	mov    0x10(%ebp),%eax
 804afbe:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804afc2:	39 c2                	cmp    %eax,%edx
 804afc4:	75 6d                	jne    804b033 <free_bytes+0x1ef>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804afc6:	eb 08                	jmp    804afd0 <free_bytes+0x18c>
                mp = &((*mp)->next);
 804afc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afcb:	8b 00                	mov    (%eax),%eax
 804afcd:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804afd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afd3:	8b 00                	mov    (%eax),%eax
 804afd5:	3b 45 10             	cmp    0x10(%ebp),%eax
 804afd8:	75 ee                	jne    804afc8 <free_bytes+0x184>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804afda:	8b 45 10             	mov    0x10(%ebp),%eax
 804afdd:	8b 10                	mov    (%eax),%edx
 804afdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afe2:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804afe4:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804afea:	8b 45 10             	mov    0x10(%ebp),%eax
 804afed:	8b 40 04             	mov    0x4(%eax),%eax
 804aff0:	c1 e8 0c             	shr    $0xc,%eax
 804aff3:	89 c1                	mov    %eax,%ecx
 804aff5:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804affb:	29 c1                	sub    %eax,%ecx
 804affd:	89 c8                	mov    %ecx,%eax
 804afff:	c1 e0 02             	shl    $0x2,%eax
 804b002:	01 d0                	add    %edx,%eax
 804b004:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804b00a:	8b 45 10             	mov    0x10(%ebp),%eax
 804b00d:	8b 40 04             	mov    0x4(%eax),%eax
 804b010:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (vp != (void *)info)
 804b013:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b016:	3b 45 10             	cmp    0x10(%ebp),%eax
 804b019:	74 0b                	je     804b026 <free_bytes+0x1e2>
                ifree(info);
 804b01b:	8b 45 10             	mov    0x10(%ebp),%eax
 804b01e:	89 04 24             	mov    %eax,(%esp)
 804b021:	e8 15 00 00 00       	call   804b03b <ifree>
        ifree(vp);
 804b026:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b029:	89 04 24             	mov    %eax,(%esp)
 804b02c:	e8 0a 00 00 00       	call   804b03b <ifree>
 804b031:	eb 01                	jmp    804b034 <free_bytes+0x1f0>
                *mp = info;
                return;
        }

        if (info->free != info->total)
                return;
 804b033:	90                   	nop
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
        vp = info->page;            /* Order is important ! */
        if (vp != (void *)info)
                ifree(info);
        ifree(vp);
}
 804b034:	83 c4 20             	add    $0x20,%esp
 804b037:	5b                   	pop    %ebx
 804b038:	5e                   	pop    %esi
 804b039:	5d                   	pop    %ebp
 804b03a:	c3                   	ret    

0804b03b <ifree>:

static void
ifree(void *ptr)
{
 804b03b:	55                   	push   %ebp
 804b03c:	89 e5                	mov    %esp,%ebp
 804b03e:	56                   	push   %esi
 804b03f:	53                   	push   %ebx
 804b040:	83 ec 50             	sub    $0x50,%esp
 804b043:	e8 85 df ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804b048:	81 c3 b8 3f 00 00    	add    $0x3fb8,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804b04e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b052:	0f 84 9c 06 00 00    	je     804b6f4 <ifree+0x6b9>
                return;

        if (!malloc_started) {
 804b058:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 804b05e:	85 c0                	test   %eax,%eax
 804b060:	75 13                	jne    804b075 <ifree+0x3a>
                wrtwarning("malloc() has never been called.\n");
 804b062:	8d 83 c8 ee ff ff    	lea    -0x1138(%ebx),%eax
 804b068:	89 04 24             	mov    %eax,(%esp)
 804b06b:	e8 35 ea ff ff       	call   8049aa5 <wrtwarning>
                return;
 804b070:	e9 86 06 00 00       	jmp    804b6fb <ifree+0x6c0>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804b075:	8b 83 3c 02 00 00    	mov    0x23c(%ebx),%eax
 804b07b:	85 c0                	test   %eax,%eax
 804b07d:	0f 85 74 06 00 00    	jne    804b6f7 <ifree+0x6bc>
                return;

        index = ptr2index(ptr);
 804b083:	8b 45 08             	mov    0x8(%ebp),%eax
 804b086:	c1 e8 0c             	shr    $0xc,%eax
 804b089:	89 c2                	mov    %eax,%edx
 804b08b:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804b091:	29 c2                	sub    %eax,%edx
 804b093:	89 d0                	mov    %edx,%eax
 804b095:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (index < malloc_pageshift) {
 804b098:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
 804b09c:	77 13                	ja     804b0b1 <ifree+0x76>
                wrtwarning("junk pointer, too low to make sense.\n");
 804b09e:	8d 83 e0 ed ff ff    	lea    -0x1220(%ebx),%eax
 804b0a4:	89 04 24             	mov    %eax,(%esp)
 804b0a7:	e8 f9 e9 ff ff       	call   8049aa5 <wrtwarning>
                return;
 804b0ac:	e9 4a 06 00 00       	jmp    804b6fb <ifree+0x6c0>
        }

        if (index > last_index) {
 804b0b1:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 804b0b7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804b0ba:	76 13                	jbe    804b0cf <ifree+0x94>
                wrtwarning("junk pointer, too high to make sense.\n");
 804b0bc:	8d 83 08 ee ff ff    	lea    -0x11f8(%ebx),%eax
 804b0c2:	89 04 24             	mov    %eax,(%esp)
 804b0c5:	e8 db e9 ff ff       	call   8049aa5 <wrtwarning>
                return;
 804b0ca:	e9 2c 06 00 00       	jmp    804b6fb <ifree+0x6c0>
        }

        info = page_dir[index];
 804b0cf:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804b0d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b0d8:	c1 e2 02             	shl    $0x2,%edx
 804b0db:	01 d0                	add    %edx,%eax
 804b0dd:	8b 00                	mov    (%eax),%eax
 804b0df:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (info < MALLOC_MAGIC)
 804b0e2:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
 804b0e6:	0f 87 19 04 00 00    	ja     804b505 <ifree+0x4ca>
                free_pages(ptr, index, info);
 804b0ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0ef:	8b 55 08             	mov    0x8(%ebp),%edx
 804b0f2:	89 55 e8             	mov    %edx,-0x18(%ebp)
 804b0f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b0f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b0fb:	89 45 e0             	mov    %eax,-0x20(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804b0fe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804b105:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
 804b109:	75 13                	jne    804b11e <ifree+0xe3>
                wrtwarning("page is already free.\n");
 804b10b:	8d 83 96 ee ff ff    	lea    -0x116a(%ebx),%eax
 804b111:	89 04 24             	mov    %eax,(%esp)
 804b114:	e8 8c e9 ff ff       	call   8049aa5 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b119:	e9 dc 05 00 00       	jmp    804b6fa <ifree+0x6bf>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804b11e:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
 804b122:	74 13                	je     804b137 <ifree+0xfc>
                wrtwarning("pointer to wrong page.\n");
 804b124:	8d 83 7e ee ff ff    	lea    -0x1182(%ebx),%eax
 804b12a:	89 04 24             	mov    %eax,(%esp)
 804b12d:	e8 73 e9 ff ff       	call   8049aa5 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b132:	e9 c3 05 00 00       	jmp    804b6fa <ifree+0x6bf>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804b137:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b13a:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b13f:	85 c0                	test   %eax,%eax
 804b141:	74 13                	je     804b156 <ifree+0x11b>
                wrtwarning("modified (page-) pointer.\n");
 804b143:	8d 83 2f ee ff ff    	lea    -0x11d1(%ebx),%eax
 804b149:	89 04 24             	mov    %eax,(%esp)
 804b14c:	e8 54 e9 ff ff       	call   8049aa5 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b151:	e9 a4 05 00 00       	jmp    804b6fa <ifree+0x6bf>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804b156:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804b15c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b15f:	c1 e2 02             	shl    $0x2,%edx
 804b162:	01 d0                	add    %edx,%eax
 804b164:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b16a:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
 804b171:	eb 1c                	jmp    804b18f <ifree+0x154>
                page_dir[index + i] = MALLOC_FREE;
 804b173:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804b179:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b17c:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b17f:	01 ca                	add    %ecx,%edx
 804b181:	c1 e2 02             	shl    $0x2,%edx
 804b184:	01 d0                	add    %edx,%eax
 804b186:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b18c:	ff 45 d8             	incl   -0x28(%ebp)
 804b18f:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
 804b195:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b198:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b19b:	01 ca                	add    %ecx,%edx
 804b19d:	c1 e2 02             	shl    $0x2,%edx
 804b1a0:	01 d0                	add    %edx,%eax
 804b1a2:	8b 00                	mov    (%eax),%eax
 804b1a4:	83 f8 03             	cmp    $0x3,%eax
 804b1a7:	74 ca                	je     804b173 <ifree+0x138>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804b1a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b1ac:	c1 e0 0c             	shl    $0xc,%eax
 804b1af:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (malloc_junk)
 804b1b2:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b1b8:	85 c0                	test   %eax,%eax
 804b1ba:	74 1a                	je     804b1d6 <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 804b1bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b1bf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b1c3:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b1ca:	00 
 804b1cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b1ce:	89 04 24             	mov    %eax,(%esp)
 804b1d1:	e8 a9 df ff ff       	call   804917f <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804b1d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b1d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b1dc:	01 d0                	add    %edx,%eax
 804b1de:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* add to free-list */
        if (!px)
 804b1e1:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b1e7:	85 c0                	test   %eax,%eax
 804b1e9:	75 12                	jne    804b1fd <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804b1eb:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804b1f2:	e8 25 f5 ff ff       	call   804a71c <imalloc>
 804b1f7:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
        px->page = ptr;
 804b1fd:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b203:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b206:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804b209:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b20f:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804b212:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804b215:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b21b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804b21e:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804b221:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
 804b227:	85 c0                	test   %eax,%eax
 804b229:	75 41                	jne    804b26c <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804b22b:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b231:	8b 93 24 02 00 00    	mov    0x224(%ebx),%edx
 804b237:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804b239:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b23f:	8d 93 24 02 00 00    	lea    0x224(%ebx),%edx
 804b245:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804b248:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b24e:	89 83 24 02 00 00    	mov    %eax,0x224(%ebx)
                pf = px;
 804b254:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b25a:	89 45 cc             	mov    %eax,-0x34(%ebp)
                px = 0;
 804b25d:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804b264:	00 00 00 
 804b267:	e9 a5 01 00 00       	jmp    804b411 <ifree+0x3d6>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804b26c:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b26f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b272:	01 d0                	add    %edx,%eax
 804b274:	89 45 d0             	mov    %eax,-0x30(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804b277:	8b 83 24 02 00 00    	mov    0x224(%ebx),%eax
 804b27d:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804b280:	eb 08                	jmp    804b28a <ifree+0x24f>
 804b282:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b285:	8b 00                	mov    (%eax),%eax
 804b287:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804b28a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b28d:	8b 40 0c             	mov    0xc(%eax),%eax
 804b290:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 804b293:	76 09                	jbe    804b29e <ifree+0x263>
 804b295:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b298:	8b 00                	mov    (%eax),%eax
 804b29a:	85 c0                	test   %eax,%eax
 804b29c:	75 e4                	jne    804b282 <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804b29e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b2a1:	8b 40 08             	mov    0x8(%eax),%eax
 804b2a4:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804b2a7:	73 4f                	jae    804b2f8 <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 804b2a9:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b2af:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b2b2:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804b2b4:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b2ba:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b2bd:	8b 52 04             	mov    0x4(%edx),%edx
 804b2c0:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804b2c3:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b2c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b2cc:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804b2cf:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b2d5:	8b 40 04             	mov    0x4(%eax),%eax
 804b2d8:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b2de:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b2e0:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b2e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 804b2e9:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804b2f0:	00 00 00 
 804b2f3:	e9 19 01 00 00       	jmp    804b411 <ifree+0x3d6>
                } else if (pf->end == ptr) {
 804b2f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b2fb:	8b 40 0c             	mov    0xc(%eax),%eax
 804b2fe:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 804b301:	0f 85 91 00 00 00    	jne    804b398 <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804b307:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b30a:	8b 50 0c             	mov    0xc(%eax),%edx
 804b30d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b310:	01 c2                	add    %eax,%edx
 804b312:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b315:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804b318:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b31b:	8b 50 10             	mov    0x10(%eax),%edx
 804b31e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b321:	01 c2                	add    %eax,%edx
 804b323:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b326:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804b329:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b32c:	8b 00                	mov    (%eax),%eax
 804b32e:	85 c0                	test   %eax,%eax
 804b330:	0f 84 da 00 00 00    	je     804b410 <ifree+0x3d5>
 804b336:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b339:	8b 50 0c             	mov    0xc(%eax),%edx
 804b33c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b33f:	8b 00                	mov    (%eax),%eax
 804b341:	8b 40 08             	mov    0x8(%eax),%eax
 804b344:	39 c2                	cmp    %eax,%edx
 804b346:	0f 85 c4 00 00 00    	jne    804b410 <ifree+0x3d5>
                                /* And collapse the next too. */
                                pt = pf->next;
 804b34c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b34f:	8b 00                	mov    (%eax),%eax
 804b351:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                pf->end = pt->end;
 804b354:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b357:	8b 50 0c             	mov    0xc(%eax),%edx
 804b35a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b35d:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804b360:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b363:	8b 50 10             	mov    0x10(%eax),%edx
 804b366:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b369:	8b 40 10             	mov    0x10(%eax),%eax
 804b36c:	01 c2                	add    %eax,%edx
 804b36e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b371:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804b374:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b377:	8b 10                	mov    (%eax),%edx
 804b379:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b37c:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804b37e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b381:	8b 00                	mov    (%eax),%eax
 804b383:	85 c0                	test   %eax,%eax
 804b385:	0f 84 85 00 00 00    	je     804b410 <ifree+0x3d5>
                                        pf->next->prev = pf;
 804b38b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b38e:	8b 00                	mov    (%eax),%eax
 804b390:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b393:	89 50 04             	mov    %edx,0x4(%eax)
 804b396:	eb 79                	jmp    804b411 <ifree+0x3d6>
                        }
                } else if (pf->page == tail) {
 804b398:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b39b:	8b 40 08             	mov    0x8(%eax),%eax
 804b39e:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804b3a1:	75 1c                	jne    804b3bf <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 804b3a3:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3a6:	8b 50 10             	mov    0x10(%eax),%edx
 804b3a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b3ac:	01 c2                	add    %eax,%edx
 804b3ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3b1:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804b3b4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b3ba:	89 50 08             	mov    %edx,0x8(%eax)
 804b3bd:	eb 52                	jmp    804b411 <ifree+0x3d6>
                } else if (!pf->next) {
 804b3bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3c2:	8b 00                	mov    (%eax),%eax
 804b3c4:	85 c0                	test   %eax,%eax
 804b3c6:	75 38                	jne    804b400 <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 804b3c8:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b3ce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804b3d4:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b3da:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b3dd:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804b3e0:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b3e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3e9:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b3eb:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b3f1:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 804b3f4:	c7 83 5c 02 00 00 00 	movl   $0x0,0x25c(%ebx)
 804b3fb:	00 00 00 
 804b3fe:	eb 11                	jmp    804b411 <ifree+0x3d6>
                } else {
                        wrterror("freelist is destroyed.\n");
 804b400:	8d 83 ad ee ff ff    	lea    -0x1153(%ebx),%eax
 804b406:	89 04 24             	mov    %eax,(%esp)
 804b409:	e8 c7 e5 ff ff       	call   80499d5 <wrterror>
 804b40e:	eb 01                	jmp    804b411 <ifree+0x3d6>
                                pt = pf->next;
                                pf->end = pt->end;
                                pf->size += pt->size;
                                pf->next = pt->next;
                                if (pf->next)
                                        pf->next->prev = pf;
 804b410:	90                   	nop
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b411:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b414:	8b 00                	mov    (%eax),%eax
 804b416:	85 c0                	test   %eax,%eax
 804b418:	0f 85 cd 00 00 00    	jne    804b4eb <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b41e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b421:	8b 50 10             	mov    0x10(%eax),%edx
 804b424:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b42a:	39 c2                	cmp    %eax,%edx
 804b42c:	0f 86 b9 00 00 00    	jbe    804b4eb <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b432:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b435:	8b 50 0c             	mov    0xc(%eax),%edx
 804b438:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b43e:	39 c2                	cmp    %eax,%edx
 804b440:	0f 85 a5 00 00 00    	jne    804b4eb <ifree+0x4b0>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804b446:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b44d:	e8 21 ce ff ff       	call   8048273 <sbrk>
 804b452:	89 c2                	mov    %eax,%edx
 804b454:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b45a:	39 c2                	cmp    %eax,%edx
 804b45c:	0f 85 89 00 00 00    	jne    804b4eb <ifree+0x4b0>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804b462:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b465:	8b 50 08             	mov    0x8(%eax),%edx
 804b468:	8b 83 20 00 00 00    	mov    0x20(%ebx),%eax
 804b46e:	01 c2                	add    %eax,%edx
 804b470:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b473:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804b476:	8b 93 20 00 00 00    	mov    0x20(%ebx),%edx
 804b47c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b47f:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804b482:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b485:	8b 40 0c             	mov    0xc(%eax),%eax
 804b488:	89 04 24             	mov    %eax,(%esp)
 804b48b:	e8 ac ce ff ff       	call   804833c <brk>
                malloc_brk = pf->end;
 804b490:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b493:	8b 40 0c             	mov    0xc(%eax),%eax
 804b496:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

                index = ptr2index(pf->end);
 804b49c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b49f:	8b 40 0c             	mov    0xc(%eax),%eax
 804b4a2:	c1 e8 0c             	shr    $0xc,%eax
 804b4a5:	89 c2                	mov    %eax,%edx
 804b4a7:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804b4ad:	29 c2                	sub    %eax,%edx
 804b4af:	89 d0                	mov    %edx,%eax
 804b4b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                last_index = index - 1;
 804b4b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b4b7:	48                   	dec    %eax
 804b4b8:	89 83 18 02 00 00    	mov    %eax,0x218(%ebx)

                for (i = index; i <= last_index;)
 804b4be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b4c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804b4c4:	eb 1a                	jmp    804b4e0 <ifree+0x4a5>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804b4c6:	8b 8b 1c 02 00 00    	mov    0x21c(%ebx),%ecx
 804b4cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b4cf:	8d 50 01             	lea    0x1(%eax),%edx
 804b4d2:	89 55 d8             	mov    %edx,-0x28(%ebp)
 804b4d5:	c1 e0 02             	shl    $0x2,%eax
 804b4d8:	01 c8                	add    %ecx,%eax
 804b4da:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804b4e0:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
 804b4e6:	39 45 d8             	cmp    %eax,-0x28(%ebp)
 804b4e9:	76 db                	jbe    804b4c6 <ifree+0x48b>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804b4eb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804b4ef:	0f 84 05 02 00 00    	je     804b6fa <ifree+0x6bf>
                ifree(pt);
 804b4f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b4f8:	89 04 24             	mov    %eax,(%esp)
 804b4fb:	e8 3b fb ff ff       	call   804b03b <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b500:	e9 f5 01 00 00       	jmp    804b6fa <ifree+0x6bf>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 804b505:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b508:	8b 55 08             	mov    0x8(%ebp),%edx
 804b50b:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804b50e:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804b511:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b514:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804b517:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b51a:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b51f:	89 c2                	mov    %eax,%edx
 804b521:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b524:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b528:	88 c1                	mov    %al,%cl
 804b52a:	d3 ea                	shr    %cl,%edx
 804b52c:	89 d0                	mov    %edx,%eax
 804b52e:	89 45 c0             	mov    %eax,-0x40(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804b531:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b534:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b538:	48                   	dec    %eax
 804b539:	89 c2                	mov    %eax,%edx
 804b53b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b53e:	21 d0                	and    %edx,%eax
 804b540:	85 c0                	test   %eax,%eax
 804b542:	74 13                	je     804b557 <ifree+0x51c>
                wrtwarning("modified (chunk-) pointer.\n");
 804b544:	8d 83 4a ee ff ff    	lea    -0x11b6(%ebx),%eax
 804b54a:	89 04 24             	mov    %eax,(%esp)
 804b54d:	e8 53 e5 ff ff       	call   8049aa5 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b552:	e9 a3 01 00 00       	jmp    804b6fa <ifree+0x6bf>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804b557:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b55a:	c1 e8 05             	shr    $0x5,%eax
 804b55d:	89 c2                	mov    %eax,%edx
 804b55f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b562:	83 c2 04             	add    $0x4,%edx
 804b565:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804b568:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b56b:	83 e2 1f             	and    $0x1f,%edx
 804b56e:	be 01 00 00 00       	mov    $0x1,%esi
 804b573:	88 d1                	mov    %dl,%cl
 804b575:	d3 e6                	shl    %cl,%esi
 804b577:	89 f2                	mov    %esi,%edx
 804b579:	21 d0                	and    %edx,%eax
 804b57b:	85 c0                	test   %eax,%eax
 804b57d:	74 13                	je     804b592 <ifree+0x557>
                wrtwarning("chunk is already free.\n");
 804b57f:	8d 83 66 ee ff ff    	lea    -0x119a(%ebx),%eax
 804b585:	89 04 24             	mov    %eax,(%esp)
 804b588:	e8 18 e5 ff ff       	call   8049aa5 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b58d:	e9 68 01 00 00       	jmp    804b6fa <ifree+0x6bf>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 804b592:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b598:	85 c0                	test   %eax,%eax
 804b59a:	74 1e                	je     804b5ba <ifree+0x57f>
                memset(ptr, SOME_JUNK, info->size);
 804b59c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b59f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b5a3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b5a7:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b5ae:	00 
 804b5af:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b5b2:	89 04 24             	mov    %eax,(%esp)
 804b5b5:	e8 c5 db ff ff       	call   804917f <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804b5ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b5bd:	c1 e8 05             	shr    $0x5,%eax
 804b5c0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b5c3:	8d 48 04             	lea    0x4(%eax),%ecx
 804b5c6:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804b5c9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
 804b5cc:	83 e1 1f             	and    $0x1f,%ecx
 804b5cf:	be 01 00 00 00       	mov    $0x1,%esi
 804b5d4:	d3 e6                	shl    %cl,%esi
 804b5d6:	89 f1                	mov    %esi,%ecx
 804b5d8:	09 d1                	or     %edx,%ecx
 804b5da:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b5dd:	83 c0 04             	add    $0x4,%eax
 804b5e0:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804b5e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b5e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b5ea:	40                   	inc    %eax
 804b5eb:	0f b7 d0             	movzwl %ax,%edx
 804b5ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b5f1:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804b5f5:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804b5fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b5fe:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b602:	c1 e0 02             	shl    $0x2,%eax
 804b605:	01 d0                	add    %edx,%eax
 804b607:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free == 1) {
 804b60a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b60d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b611:	83 f8 01             	cmp    $0x1,%eax
 804b614:	75 5e                	jne    804b674 <ifree+0x639>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804b616:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804b61c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b61f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b623:	c1 e0 02             	shl    $0x2,%eax
 804b626:	01 d0                	add    %edx,%eax
 804b628:	89 45 bc             	mov    %eax,-0x44(%ebp)
 804b62b:	eb 08                	jmp    804b635 <ifree+0x5fa>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 804b62d:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b630:	8b 00                	mov    (%eax),%eax
 804b632:	89 45 bc             	mov    %eax,-0x44(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b635:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b638:	8b 00                	mov    (%eax),%eax
 804b63a:	85 c0                	test   %eax,%eax
 804b63c:	74 1f                	je     804b65d <ifree+0x622>
 804b63e:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b641:	8b 00                	mov    (%eax),%eax
 804b643:	8b 00                	mov    (%eax),%eax
 804b645:	85 c0                	test   %eax,%eax
 804b647:	74 14                	je     804b65d <ifree+0x622>
 804b649:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b64c:	8b 00                	mov    (%eax),%eax
 804b64e:	8b 00                	mov    (%eax),%eax
 804b650:	8b 50 04             	mov    0x4(%eax),%edx
 804b653:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b656:	8b 40 04             	mov    0x4(%eax),%eax
 804b659:	39 c2                	cmp    %eax,%edx
 804b65b:	72 d0                	jb     804b62d <ifree+0x5f2>
                        mp = &(*mp)->next;
                info->next = *mp;
 804b65d:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b660:	8b 10                	mov    (%eax),%edx
 804b662:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b665:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804b667:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b66a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b66d:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b66f:	e9 86 00 00 00       	jmp    804b6fa <ifree+0x6bf>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 804b674:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b677:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b67b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b67e:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b682:	39 c2                	cmp    %eax,%edx
 804b684:	75 74                	jne    804b6fa <ifree+0x6bf>
 804b686:	eb 08                	jmp    804b690 <ifree+0x655>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804b688:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b68b:	8b 00                	mov    (%eax),%eax
 804b68d:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804b690:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b693:	8b 00                	mov    (%eax),%eax
 804b695:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804b698:	75 ee                	jne    804b688 <ifree+0x64d>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804b69a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b69d:	8b 10                	mov    (%eax),%edx
 804b69f:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b6a2:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804b6a4:	8b 93 1c 02 00 00    	mov    0x21c(%ebx),%edx
 804b6aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6ad:	8b 40 04             	mov    0x4(%eax),%eax
 804b6b0:	c1 e8 0c             	shr    $0xc,%eax
 804b6b3:	89 c1                	mov    %eax,%ecx
 804b6b5:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
 804b6bb:	29 c1                	sub    %eax,%ecx
 804b6bd:	89 c8                	mov    %ecx,%eax
 804b6bf:	c1 e0 02             	shl    $0x2,%eax
 804b6c2:	01 d0                	add    %edx,%eax
 804b6c4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804b6ca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6cd:	8b 40 04             	mov    0x4(%eax),%eax
 804b6d0:	89 45 b8             	mov    %eax,-0x48(%ebp)
        if (vp != (void *)info)
 804b6d3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6d6:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 804b6d9:	74 0b                	je     804b6e6 <ifree+0x6ab>
                ifree(info);
 804b6db:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6de:	89 04 24             	mov    %eax,(%esp)
 804b6e1:	e8 55 f9 ff ff       	call   804b03b <ifree>
        ifree(vp);
 804b6e6:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b6e9:	89 04 24             	mov    %eax,(%esp)
 804b6ec:	e8 4a f9 ff ff       	call   804b03b <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b6f1:	90                   	nop
 804b6f2:	eb 06                	jmp    804b6fa <ifree+0x6bf>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 804b6f4:	90                   	nop
 804b6f5:	eb 04                	jmp    804b6fb <ifree+0x6c0>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 804b6f7:	90                   	nop
 804b6f8:	eb 01                	jmp    804b6fb <ifree+0x6c0>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b6fa:	90                   	nop
}
 804b6fb:	83 c4 50             	add    $0x50,%esp
 804b6fe:	5b                   	pop    %ebx
 804b6ff:	5e                   	pop    %esi
 804b700:	5d                   	pop    %ebp
 804b701:	c3                   	ret    

0804b702 <malloc>:
 */


void *
malloc(size_t size)
{
 804b702:	55                   	push   %ebp
 804b703:	89 e5                	mov    %esp,%ebp
 804b705:	56                   	push   %esi
 804b706:	53                   	push   %ebx
 804b707:	83 ec 10             	sub    $0x10,%esp
 804b70a:	e8 be d8 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804b70f:	81 c3 f1 38 00 00    	add    $0x38f1,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 804b715:	8d 83 e9 ee ff ff    	lea    -0x1117(%ebx),%eax
 804b71b:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
        if (malloc_active++) {
 804b721:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b727:	8d 50 01             	lea    0x1(%eax),%edx
 804b72a:	89 93 10 02 00 00    	mov    %edx,0x210(%ebx)
 804b730:	85 c0                	test   %eax,%eax
 804b732:	74 22                	je     804b756 <malloc+0x54>
                wrtwarning("recursive call.\n");
 804b734:	8d 83 f7 ee ff ff    	lea    -0x1109(%ebx),%eax
 804b73a:	89 04 24             	mov    %eax,(%esp)
 804b73d:	e8 63 e3 ff ff       	call   8049aa5 <wrtwarning>
                malloc_active--;
 804b742:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b748:	48                   	dec    %eax
 804b749:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
                return (0);
 804b74f:	b8 00 00 00 00       	mov    $0x0,%eax
 804b754:	eb 5e                	jmp    804b7b4 <malloc+0xb2>
        }
        if (!malloc_started) {
 804b756:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 804b75c:	85 c0                	test   %eax,%eax
 804b75e:	75 05                	jne    804b765 <malloc+0x63>
                malloc_init();
 804b760:	e8 97 e5 ff ff       	call   8049cfc <malloc_init>
        }
        if (malloc_sysv && !size)
 804b765:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b76b:	85 c0                	test   %eax,%eax
 804b76d:	74 0d                	je     804b77c <malloc+0x7a>
 804b76f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b773:	75 07                	jne    804b77c <malloc+0x7a>
                r = 0;
 804b775:	be 00 00 00 00       	mov    $0x0,%esi
 804b77a:	eb 0d                	jmp    804b789 <malloc+0x87>
        else
                r = imalloc(size);
 804b77c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b77f:	89 04 24             	mov    %eax,(%esp)
 804b782:	e8 95 ef ff ff       	call   804a71c <imalloc>
 804b787:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 804b789:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b78f:	48                   	dec    %eax
 804b790:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804b796:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804b79c:	85 c0                	test   %eax,%eax
 804b79e:	74 12                	je     804b7b2 <malloc+0xb0>
 804b7a0:	85 f6                	test   %esi,%esi
 804b7a2:	75 0e                	jne    804b7b2 <malloc+0xb0>
                wrterror("out of memory.\n");
 804b7a4:	8d 83 08 ef ff ff    	lea    -0x10f8(%ebx),%eax
 804b7aa:	89 04 24             	mov    %eax,(%esp)
 804b7ad:	e8 23 e2 ff ff       	call   80499d5 <wrterror>
        return (r);
 804b7b2:	89 f0                	mov    %esi,%eax
}
 804b7b4:	83 c4 10             	add    $0x10,%esp
 804b7b7:	5b                   	pop    %ebx
 804b7b8:	5e                   	pop    %esi
 804b7b9:	5d                   	pop    %ebp
 804b7ba:	c3                   	ret    

0804b7bb <free>:

void
free(void *ptr)
{
 804b7bb:	55                   	push   %ebp
 804b7bc:	89 e5                	mov    %esp,%ebp
 804b7be:	53                   	push   %ebx
 804b7bf:	83 ec 14             	sub    $0x14,%esp
 804b7c2:	e8 06 d8 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804b7c7:	81 c3 39 38 00 00    	add    $0x3839,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 804b7cd:	8d 83 18 ef ff ff    	lea    -0x10e8(%ebx),%eax
 804b7d3:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
        if (malloc_active++) {
 804b7d9:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b7df:	8d 50 01             	lea    0x1(%eax),%edx
 804b7e2:	89 93 10 02 00 00    	mov    %edx,0x210(%ebx)
 804b7e8:	85 c0                	test   %eax,%eax
 804b7ea:	74 1d                	je     804b809 <free+0x4e>
                wrtwarning("recursive call.\n");
 804b7ec:	8d 83 f7 ee ff ff    	lea    -0x1109(%ebx),%eax
 804b7f2:	89 04 24             	mov    %eax,(%esp)
 804b7f5:	e8 ab e2 ff ff       	call   8049aa5 <wrtwarning>
                malloc_active--;
 804b7fa:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b800:	48                   	dec    %eax
 804b801:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
                return;
 804b807:	eb 19                	jmp    804b822 <free+0x67>
        } else {
                ifree(ptr);
 804b809:	8b 45 08             	mov    0x8(%ebp),%eax
 804b80c:	89 04 24             	mov    %eax,(%esp)
 804b80f:	e8 27 f8 ff ff       	call   804b03b <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 804b814:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b81a:	48                   	dec    %eax
 804b81b:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
        THREAD_UNLOCK();
        return;
 804b821:	90                   	nop
}
 804b822:	83 c4 14             	add    $0x14,%esp
 804b825:	5b                   	pop    %ebx
 804b826:	5d                   	pop    %ebp
 804b827:	c3                   	ret    

0804b828 <realloc>:

void *
realloc(void *ptr, size_t size)
{
 804b828:	55                   	push   %ebp
 804b829:	89 e5                	mov    %esp,%ebp
 804b82b:	56                   	push   %esi
 804b82c:	53                   	push   %ebx
 804b82d:	83 ec 10             	sub    $0x10,%esp
 804b830:	e8 98 d7 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804b835:	81 c3 cb 37 00 00    	add    $0x37cb,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 804b83b:	8d 83 24 ef ff ff    	lea    -0x10dc(%ebx),%eax
 804b841:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
        if (malloc_active++) {
 804b847:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b84d:	8d 50 01             	lea    0x1(%eax),%edx
 804b850:	89 93 10 02 00 00    	mov    %edx,0x210(%ebx)
 804b856:	85 c0                	test   %eax,%eax
 804b858:	74 25                	je     804b87f <realloc+0x57>
                wrtwarning("recursive call.\n");
 804b85a:	8d 83 f7 ee ff ff    	lea    -0x1109(%ebx),%eax
 804b860:	89 04 24             	mov    %eax,(%esp)
 804b863:	e8 3d e2 ff ff       	call   8049aa5 <wrtwarning>
                malloc_active--;
 804b868:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b86e:	48                   	dec    %eax
 804b86f:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
                return (0);
 804b875:	b8 00 00 00 00       	mov    $0x0,%eax
 804b87a:	e9 aa 00 00 00       	jmp    804b929 <realloc+0x101>
        }
        if (ptr && !malloc_started) {
 804b87f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b883:	74 1f                	je     804b8a4 <realloc+0x7c>
 804b885:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 804b88b:	85 c0                	test   %eax,%eax
 804b88d:	75 15                	jne    804b8a4 <realloc+0x7c>
                wrtwarning("malloc() has never been called.\n");
 804b88f:	8d 83 c8 ee ff ff    	lea    -0x1138(%ebx),%eax
 804b895:	89 04 24             	mov    %eax,(%esp)
 804b898:	e8 08 e2 ff ff       	call   8049aa5 <wrtwarning>
                ptr = 0;
 804b89d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 804b8a4:	8b 83 0c 02 00 00    	mov    0x20c(%ebx),%eax
 804b8aa:	85 c0                	test   %eax,%eax
 804b8ac:	75 05                	jne    804b8b3 <realloc+0x8b>
                malloc_init();
 804b8ae:	e8 49 e4 ff ff       	call   8049cfc <malloc_init>
        if (malloc_sysv && !size) {
 804b8b3:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b8b9:	85 c0                	test   %eax,%eax
 804b8bb:	74 18                	je     804b8d5 <realloc+0xad>
 804b8bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b8c1:	75 12                	jne    804b8d5 <realloc+0xad>
                ifree(ptr);
 804b8c3:	8b 45 08             	mov    0x8(%ebp),%eax
 804b8c6:	89 04 24             	mov    %eax,(%esp)
 804b8c9:	e8 6d f7 ff ff       	call   804b03b <ifree>
                r = 0;
 804b8ce:	be 00 00 00 00       	mov    $0x0,%esi
 804b8d3:	eb 29                	jmp    804b8fe <realloc+0xd6>
        } else if (!ptr) {
 804b8d5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b8d9:	75 0f                	jne    804b8ea <realloc+0xc2>
                r = imalloc(size);
 804b8db:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8de:	89 04 24             	mov    %eax,(%esp)
 804b8e1:	e8 36 ee ff ff       	call   804a71c <imalloc>
 804b8e6:	89 c6                	mov    %eax,%esi
 804b8e8:	eb 14                	jmp    804b8fe <realloc+0xd6>
        } else {
                r = irealloc(ptr, size);
 804b8ea:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8ed:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b8f1:	8b 45 08             	mov    0x8(%ebp),%eax
 804b8f4:	89 04 24             	mov    %eax,(%esp)
 804b8f7:	e8 d6 ee ff ff       	call   804a7d2 <irealloc>
 804b8fc:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 804b8fe:	8b 83 10 02 00 00    	mov    0x210(%ebx),%eax
 804b904:	48                   	dec    %eax
 804b905:	89 83 10 02 00 00    	mov    %eax,0x210(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804b90b:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804b911:	85 c0                	test   %eax,%eax
 804b913:	74 12                	je     804b927 <realloc+0xff>
 804b915:	85 f6                	test   %esi,%esi
 804b917:	75 0e                	jne    804b927 <realloc+0xff>
                wrterror("out of memory.\n");
 804b919:	8d 83 08 ef ff ff    	lea    -0x10f8(%ebx),%eax
 804b91f:	89 04 24             	mov    %eax,(%esp)
 804b922:	e8 ae e0 ff ff       	call   80499d5 <wrterror>
        return (r);
 804b927:	89 f0                	mov    %esi,%eax
}
 804b929:	83 c4 10             	add    $0x10,%esp
 804b92c:	5b                   	pop    %ebx
 804b92d:	5e                   	pop    %esi
 804b92e:	5d                   	pop    %ebp
 804b92f:	c3                   	ret    

0804b930 <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 804b930:	55                   	push   %ebp
 804b931:	89 e5                	mov    %esp,%ebp
 804b933:	53                   	push   %ebx
 804b934:	83 ec 24             	sub    $0x24,%esp
 804b937:	e8 91 d6 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804b93c:	81 c3 c4 36 00 00    	add    $0x36c4,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 804b942:	8b 45 08             	mov    0x8(%ebp),%eax
 804b945:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804b949:	89 04 24             	mov    %eax,(%esp)
 804b94c:	e8 b1 fd ff ff       	call   804b702 <malloc>
 804b951:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b954:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b958:	75 07                	jne    804b961 <calloc+0x31>
                return NULL;
 804b95a:	b8 00 00 00 00       	mov    $0x0,%eax
 804b95f:	eb 21                	jmp    804b982 <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 804b961:	8b 45 08             	mov    0x8(%ebp),%eax
 804b964:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804b968:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b96c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b973:	00 
 804b974:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b977:	89 04 24             	mov    %eax,(%esp)
 804b97a:	e8 00 d8 ff ff       	call   804917f <memset>
                return tmp;
 804b97f:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 804b982:	83 c4 24             	add    $0x24,%esp
 804b985:	5b                   	pop    %ebx
 804b986:	5d                   	pop    %ebp
 804b987:	c3                   	ret    

0804b988 <printf>:

#include "stdio.h"
#include "unistd.h"

int printf(const char *fmt, ...)
{
 804b988:	55                   	push   %ebp
 804b989:	89 e5                	mov    %esp,%ebp
 804b98b:	53                   	push   %ebx
 804b98c:	83 ec 24             	sub    $0x24,%esp
 804b98f:	e8 31 d6 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804b994:	05 6c 36 00 00       	add    $0x366c,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804b999:	8d 55 0c             	lea    0xc(%ebp),%edx
 804b99c:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vprintf(fmt, args);
 804b99f:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b9a2:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b9a6:	8b 55 08             	mov    0x8(%ebp),%edx
 804b9a9:	89 14 24             	mov    %edx,(%esp)
 804b9ac:	89 c3                	mov    %eax,%ebx
 804b9ae:	e8 cd 00 00 00       	call   804ba80 <vprintf>
 804b9b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804b9b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804b9b9:	83 c4 24             	add    $0x24,%esp
 804b9bc:	5b                   	pop    %ebx
 804b9bd:	5d                   	pop    %ebp
 804b9be:	c3                   	ret    

0804b9bf <fprintf>:

int fprintf(FILE *stream, const char *fmt, ...)
{
 804b9bf:	55                   	push   %ebp
 804b9c0:	89 e5                	mov    %esp,%ebp
 804b9c2:	53                   	push   %ebx
 804b9c3:	83 ec 24             	sub    $0x24,%esp
 804b9c6:	e8 fa d5 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804b9cb:	05 35 36 00 00       	add    $0x3635,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804b9d0:	8d 55 10             	lea    0x10(%ebp),%edx
 804b9d3:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vfprintf(stream, fmt, args);
 804b9d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b9d9:	89 54 24 08          	mov    %edx,0x8(%esp)
 804b9dd:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b9e0:	89 54 24 04          	mov    %edx,0x4(%esp)
 804b9e4:	8b 55 08             	mov    0x8(%ebp),%edx
 804b9e7:	89 14 24             	mov    %edx,(%esp)
 804b9ea:	89 c3                	mov    %eax,%ebx
 804b9ec:	e8 c6 00 00 00       	call   804bab7 <vfprintf>
 804b9f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804b9f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804b9f7:	83 c4 24             	add    $0x24,%esp
 804b9fa:	5b                   	pop    %ebx
 804b9fb:	5d                   	pop    %ebp
 804b9fc:	c3                   	ret    

0804b9fd <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
 804b9fd:	55                   	push   %ebp
 804b9fe:	89 e5                	mov    %esp,%ebp
 804ba00:	53                   	push   %ebx
 804ba01:	83 ec 24             	sub    $0x24,%esp
 804ba04:	e8 bc d5 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804ba09:	05 f7 35 00 00       	add    $0x35f7,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804ba0e:	8d 55 10             	lea    0x10(%ebp),%edx
 804ba11:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsprintf(buf, fmt, args);
 804ba14:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ba17:	89 54 24 08          	mov    %edx,0x8(%esp)
 804ba1b:	8b 55 0c             	mov    0xc(%ebp),%edx
 804ba1e:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ba22:	8b 55 08             	mov    0x8(%ebp),%edx
 804ba25:	89 14 24             	mov    %edx,(%esp)
 804ba28:	89 c3                	mov    %eax,%ebx
 804ba2a:	e8 f4 00 00 00       	call   804bb23 <vsprintf>
 804ba2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804ba32:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804ba35:	83 c4 24             	add    $0x24,%esp
 804ba38:	5b                   	pop    %ebx
 804ba39:	5d                   	pop    %ebp
 804ba3a:	c3                   	ret    

0804ba3b <snprintf>:

int snprintf(char *buf, size_t size, const char *fmt, ...)
{
 804ba3b:	55                   	push   %ebp
 804ba3c:	89 e5                	mov    %esp,%ebp
 804ba3e:	53                   	push   %ebx
 804ba3f:	83 ec 24             	sub    $0x24,%esp
 804ba42:	e8 7e d5 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804ba47:	05 b9 35 00 00       	add    $0x35b9,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804ba4c:	8d 55 14             	lea    0x14(%ebp),%edx
 804ba4f:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsnprintf(buf, size, fmt, args);
 804ba52:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ba55:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ba59:	8b 55 10             	mov    0x10(%ebp),%edx
 804ba5c:	89 54 24 08          	mov    %edx,0x8(%esp)
 804ba60:	8b 55 0c             	mov    0xc(%ebp),%edx
 804ba63:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ba67:	8b 55 08             	mov    0x8(%ebp),%edx
 804ba6a:	89 14 24             	mov    %edx,(%esp)
 804ba6d:	89 c3                	mov    %eax,%ebx
 804ba6f:	e8 8b 05 00 00       	call   804bfff <vsnprintf>
 804ba74:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804ba77:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804ba7a:	83 c4 24             	add    $0x24,%esp
 804ba7d:	5b                   	pop    %ebx
 804ba7e:	5d                   	pop    %ebp
 804ba7f:	c3                   	ret    

0804ba80 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
 804ba80:	55                   	push   %ebp
 804ba81:	89 e5                	mov    %esp,%ebp
 804ba83:	53                   	push   %ebx
 804ba84:	83 ec 14             	sub    $0x14,%esp
 804ba87:	e8 39 d5 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804ba8c:	05 74 35 00 00       	add    $0x3574,%eax
        return vfprintf(stdout, fmt, args);
 804ba91:	8d 15 38 f0 04 08    	lea    0x804f038,%edx
 804ba97:	8b 12                	mov    (%edx),%edx
 804ba99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804ba9c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804baa0:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804baa3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804baa7:	89 14 24             	mov    %edx,(%esp)
 804baaa:	89 c3                	mov    %eax,%ebx
 804baac:	e8 06 00 00 00       	call   804bab7 <vfprintf>
}
 804bab1:	83 c4 14             	add    $0x14,%esp
 804bab4:	5b                   	pop    %ebx
 804bab5:	5d                   	pop    %ebp
 804bab6:	c3                   	ret    

0804bab7 <vfprintf>:

#define __LIBC_PRINTF_BUFSIZE 1024
int vfprintf(FILE *stream, const char *fmt, va_list args)
{
 804bab7:	55                   	push   %ebp
 804bab8:	89 e5                	mov    %esp,%ebp
 804baba:	53                   	push   %ebx
 804babb:	81 ec 24 04 00 00    	sub    $0x424,%esp
 804bac1:	e8 07 d5 ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804bac6:	81 c3 3a 35 00 00    	add    $0x353a,%ebx
        /* I'm really lazy */
        char buf[__LIBC_PRINTF_BUFSIZE];
        int ret = vsnprintf(buf, __LIBC_PRINTF_BUFSIZE, fmt, args);
 804bacc:	8b 45 10             	mov    0x10(%ebp),%eax
 804bacf:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804bad3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bad6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bada:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 804bae1:	00 
 804bae2:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
 804bae8:	89 04 24             	mov    %eax,(%esp)
 804baeb:	e8 0f 05 00 00       	call   804bfff <vsnprintf>
 804baf0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (ret > 0) {
 804baf3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804baf7:	7e 1e                	jle    804bb17 <vfprintf+0x60>
                write(*stream, buf, ret);
 804baf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804bafc:	8b 45 08             	mov    0x8(%ebp),%eax
 804baff:	8b 00                	mov    (%eax),%eax
 804bb01:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bb05:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
 804bb0b:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bb0f:	89 04 24             	mov    %eax,(%esp)
 804bb12:	e8 2f cd ff ff       	call   8048846 <write>
        }
        return ret;
 804bb17:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bb1a:	81 c4 24 04 00 00    	add    $0x424,%esp
 804bb20:	5b                   	pop    %ebx
 804bb21:	5d                   	pop    %ebp
 804bb22:	c3                   	ret    

0804bb23 <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
 804bb23:	55                   	push   %ebp
 804bb24:	89 e5                	mov    %esp,%ebp
 804bb26:	53                   	push   %ebx
 804bb27:	83 ec 14             	sub    $0x14,%esp
 804bb2a:	e8 96 d4 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804bb2f:	05 d1 34 00 00       	add    $0x34d1,%eax
        return vsnprintf(buf, 0xffffffffUL, fmt, args);
 804bb34:	8b 55 10             	mov    0x10(%ebp),%edx
 804bb37:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804bb3b:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bb3e:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bb42:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
 804bb49:	ff 
 804bb4a:	8b 55 08             	mov    0x8(%ebp),%edx
 804bb4d:	89 14 24             	mov    %edx,(%esp)
 804bb50:	89 c3                	mov    %eax,%ebx
 804bb52:	e8 a8 04 00 00       	call   804bfff <vsnprintf>
}
 804bb57:	83 c4 14             	add    $0x14,%esp
 804bb5a:	5b                   	pop    %ebx
 804bb5b:	5d                   	pop    %ebp
 804bb5c:	c3                   	ret    

0804bb5d <fflush>:

int fflush(FILE *stream)
{
 804bb5d:	55                   	push   %ebp
 804bb5e:	89 e5                	mov    %esp,%ebp
 804bb60:	e8 60 d4 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804bb65:	05 9b 34 00 00       	add    $0x349b,%eax
        /* no-op */
        return 0;
 804bb6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804bb6f:	5d                   	pop    %ebp
 804bb70:	c3                   	ret    

0804bb71 <__tolower>:

#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
 804bb71:	55                   	push   %ebp
 804bb72:	89 e5                	mov    %esp,%ebp
 804bb74:	83 ec 04             	sub    $0x4,%esp
 804bb77:	e8 66 0a 00 00       	call   804c5e2 <__x86.get_pc_thunk.dx>
 804bb7c:	81 c2 84 34 00 00    	add    $0x3484,%edx
 804bb82:	8b 45 08             	mov    0x8(%ebp),%eax
 804bb85:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (isupper(c))
 804bb88:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804bb8c:	0f b6 84 02 40 00 00 	movzbl 0x40(%edx,%eax,1),%eax
 804bb93:	00 
 804bb94:	0f b6 c0             	movzbl %al,%eax
 804bb97:	83 e0 01             	and    $0x1,%eax
 804bb9a:	85 c0                	test   %eax,%eax
 804bb9c:	74 04                	je     804bba2 <__tolower+0x31>
                c -= 'A' - 'a';
 804bb9e:	80 45 fc 20          	addb   $0x20,-0x4(%ebp)
        return c;
 804bba2:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804bba6:	c9                   	leave  
 804bba7:	c3                   	ret    

0804bba8 <__toupper>:

static inline unsigned char __toupper(unsigned char c)
{
 804bba8:	55                   	push   %ebp
 804bba9:	89 e5                	mov    %esp,%ebp
 804bbab:	83 ec 04             	sub    $0x4,%esp
 804bbae:	e8 2f 0a 00 00       	call   804c5e2 <__x86.get_pc_thunk.dx>
 804bbb3:	81 c2 4d 34 00 00    	add    $0x344d,%edx
 804bbb9:	8b 45 08             	mov    0x8(%ebp),%eax
 804bbbc:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (islower(c))
 804bbbf:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804bbc3:	0f b6 84 02 40 00 00 	movzbl 0x40(%edx,%eax,1),%eax
 804bbca:	00 
 804bbcb:	0f b6 c0             	movzbl %al,%eax
 804bbce:	83 e0 02             	and    $0x2,%eax
 804bbd1:	85 c0                	test   %eax,%eax
 804bbd3:	74 04                	je     804bbd9 <__toupper+0x31>
                c -= 'a' - 'A';
 804bbd5:	80 6d fc 20          	subb   $0x20,-0x4(%ebp)
        return c;
 804bbd9:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804bbdd:	c9                   	leave  
 804bbde:	c3                   	ret    

0804bbdf <skip_atoi>:
#include "stddef.h"
#include "stdio.h"
#include "string.h"

static int skip_atoi(const char **s)
{
 804bbdf:	55                   	push   %ebp
 804bbe0:	89 e5                	mov    %esp,%ebp
 804bbe2:	56                   	push   %esi
 804bbe3:	53                   	push   %ebx
 804bbe4:	83 ec 10             	sub    $0x10,%esp
 804bbe7:	e8 dd d3 ff ff       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804bbec:	81 c1 14 34 00 00    	add    $0x3414,%ecx
        int i = 0;
 804bbf2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        while (isdigit(**s))
 804bbf9:	eb 29                	jmp    804bc24 <skip_atoi+0x45>
                i = i * 10 + *((*s)++) - '0';
 804bbfb:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804bbfe:	89 d0                	mov    %edx,%eax
 804bc00:	c1 e0 02             	shl    $0x2,%eax
 804bc03:	01 d0                	add    %edx,%eax
 804bc05:	01 c0                	add    %eax,%eax
 804bc07:	89 c6                	mov    %eax,%esi
 804bc09:	8b 45 08             	mov    0x8(%ebp),%eax
 804bc0c:	8b 00                	mov    (%eax),%eax
 804bc0e:	8d 58 01             	lea    0x1(%eax),%ebx
 804bc11:	8b 55 08             	mov    0x8(%ebp),%edx
 804bc14:	89 1a                	mov    %ebx,(%edx)
 804bc16:	0f b6 00             	movzbl (%eax),%eax
 804bc19:	0f be c0             	movsbl %al,%eax
 804bc1c:	01 f0                	add    %esi,%eax
 804bc1e:	83 e8 30             	sub    $0x30,%eax
 804bc21:	89 45 f4             	mov    %eax,-0xc(%ebp)

static int skip_atoi(const char **s)
{
        int i = 0;

        while (isdigit(**s))
 804bc24:	8b 45 08             	mov    0x8(%ebp),%eax
 804bc27:	8b 00                	mov    (%eax),%eax
 804bc29:	0f b6 00             	movzbl (%eax),%eax
 804bc2c:	0f b6 c0             	movzbl %al,%eax
 804bc2f:	0f b6 84 01 40 00 00 	movzbl 0x40(%ecx,%eax,1),%eax
 804bc36:	00 
 804bc37:	0f b6 c0             	movzbl %al,%eax
 804bc3a:	83 e0 04             	and    $0x4,%eax
 804bc3d:	85 c0                	test   %eax,%eax
 804bc3f:	75 ba                	jne    804bbfb <skip_atoi+0x1c>
                i = i * 10 + *((*s)++) - '0';
        return i;
 804bc41:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bc44:	83 c4 10             	add    $0x10,%esp
 804bc47:	5b                   	pop    %ebx
 804bc48:	5e                   	pop    %esi
 804bc49:	5d                   	pop    %ebp
 804bc4a:	c3                   	ret    

0804bc4b <number>:
#define LEFT    16              /* left justified */
#define SPECIAL 32              /* 0x */
#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */

static char *number(char *buf, char *end, long long num, int base, int size, int precision, int type)
{
 804bc4b:	55                   	push   %ebp
 804bc4c:	89 e5                	mov    %esp,%ebp
 804bc4e:	57                   	push   %edi
 804bc4f:	56                   	push   %esi
 804bc50:	53                   	push   %ebx
 804bc51:	81 ec dc 00 00 00    	sub    $0xdc,%esp
 804bc57:	e8 8a 09 00 00       	call   804c5e6 <__x86.get_pc_thunk.si>
 804bc5c:	81 c6 a4 33 00 00    	add    $0x33a4,%esi
 804bc62:	8b 45 10             	mov    0x10(%ebp),%eax
 804bc65:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
 804bc6b:	8b 45 14             	mov    0x14(%ebp),%eax
 804bc6e:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
        char c, sign, tmp[66];
        const char *digits;
        const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 804bc74:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804bc7a:	8d 96 34 ef ff ff    	lea    -0x10cc(%esi),%edx
 804bc80:	bb 25 00 00 00       	mov    $0x25,%ebx
 804bc85:	89 c1                	mov    %eax,%ecx
 804bc87:	83 e1 01             	and    $0x1,%ecx
 804bc8a:	85 c9                	test   %ecx,%ecx
 804bc8c:	74 0c                	je     804bc9a <number+0x4f>
 804bc8e:	0f b6 0a             	movzbl (%edx),%ecx
 804bc91:	88 08                	mov    %cl,(%eax)
 804bc93:	8d 40 01             	lea    0x1(%eax),%eax
 804bc96:	8d 52 01             	lea    0x1(%edx),%edx
 804bc99:	4b                   	dec    %ebx
 804bc9a:	89 c1                	mov    %eax,%ecx
 804bc9c:	83 e1 02             	and    $0x2,%ecx
 804bc9f:	85 c9                	test   %ecx,%ecx
 804bca1:	74 0f                	je     804bcb2 <number+0x67>
 804bca3:	0f b7 0a             	movzwl (%edx),%ecx
 804bca6:	66 89 08             	mov    %cx,(%eax)
 804bca9:	8d 40 02             	lea    0x2(%eax),%eax
 804bcac:	8d 52 02             	lea    0x2(%edx),%edx
 804bcaf:	83 eb 02             	sub    $0x2,%ebx
 804bcb2:	89 df                	mov    %ebx,%edi
 804bcb4:	83 e7 fc             	and    $0xfffffffc,%edi
 804bcb7:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%ebp)
 804bcbd:	b9 00 00 00 00       	mov    $0x0,%ecx
 804bcc2:	8b 3c 0a             	mov    (%edx,%ecx,1),%edi
 804bcc5:	89 3c 08             	mov    %edi,(%eax,%ecx,1)
 804bcc8:	83 c1 04             	add    $0x4,%ecx
 804bccb:	3b 8d 2c ff ff ff    	cmp    -0xd4(%ebp),%ecx
 804bcd1:	72 ef                	jb     804bcc2 <number+0x77>
 804bcd3:	01 c8                	add    %ecx,%eax
 804bcd5:	01 ca                	add    %ecx,%edx
 804bcd7:	b9 00 00 00 00       	mov    $0x0,%ecx
 804bcdc:	89 df                	mov    %ebx,%edi
 804bcde:	83 e7 02             	and    $0x2,%edi
 804bce1:	85 ff                	test   %edi,%edi
 804bce3:	74 0b                	je     804bcf0 <number+0xa5>
 804bce5:	0f b7 3c 0a          	movzwl (%edx,%ecx,1),%edi
 804bce9:	66 89 3c 08          	mov    %di,(%eax,%ecx,1)
 804bced:	83 c1 02             	add    $0x2,%ecx
 804bcf0:	83 e3 01             	and    $0x1,%ebx
 804bcf3:	85 db                	test   %ebx,%ebx
 804bcf5:	74 07                	je     804bcfe <number+0xb3>
 804bcf7:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
 804bcfb:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 804bcfe:	8d 8d 40 ff ff ff    	lea    -0xc0(%ebp),%ecx
 804bd04:	8d 96 5c ef ff ff    	lea    -0x10a4(%esi),%edx
 804bd0a:	b8 25 00 00 00       	mov    $0x25,%eax
 804bd0f:	83 e0 fc             	and    $0xfffffffc,%eax
 804bd12:	89 c7                	mov    %eax,%edi
 804bd14:	b8 00 00 00 00       	mov    $0x0,%eax
 804bd19:	8b 9c 06 5c ef ff ff 	mov    -0x10a4(%esi,%eax,1),%ebx
 804bd20:	89 9c 05 40 ff ff ff 	mov    %ebx,-0xc0(%ebp,%eax,1)
 804bd27:	83 c0 04             	add    $0x4,%eax
 804bd2a:	39 f8                	cmp    %edi,%eax
 804bd2c:	72 eb                	jb     804bd19 <number+0xce>
 804bd2e:	01 c1                	add    %eax,%ecx
 804bd30:	01 c2                	add    %eax,%edx
 804bd32:	0f b6 02             	movzbl (%edx),%eax
 804bd35:	88 01                	mov    %al,(%ecx)
        int i;

        digits = (type & LARGE) ? large_digits : small_digits;
 804bd37:	8b 45 24             	mov    0x24(%ebp),%eax
 804bd3a:	83 e0 40             	and    $0x40,%eax
 804bd3d:	85 c0                	test   %eax,%eax
 804bd3f:	74 08                	je     804bd49 <number+0xfe>
 804bd41:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 804bd47:	eb 06                	jmp    804bd4f <number+0x104>
 804bd49:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804bd4f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (type & LEFT)
 804bd52:	8b 45 24             	mov    0x24(%ebp),%eax
 804bd55:	83 e0 10             	and    $0x10,%eax
 804bd58:	85 c0                	test   %eax,%eax
 804bd5a:	74 04                	je     804bd60 <number+0x115>
                type &= ~ZEROPAD;
 804bd5c:	83 65 24 fe          	andl   $0xfffffffe,0x24(%ebp)
        if (base < 2 || base > 36)
 804bd60:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
 804bd64:	7e 06                	jle    804bd6c <number+0x121>
 804bd66:	83 7d 18 24          	cmpl   $0x24,0x18(%ebp)
 804bd6a:	7e 08                	jle    804bd74 <number+0x129>
                return buf;
 804bd6c:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd6f:	e9 80 02 00 00       	jmp    804bff4 <number+0x3a9>
        c = (type & ZEROPAD) ? '0' : ' ';
 804bd74:	8b 45 24             	mov    0x24(%ebp),%eax
 804bd77:	83 e0 01             	and    $0x1,%eax
 804bd7a:	85 c0                	test   %eax,%eax
 804bd7c:	74 04                	je     804bd82 <number+0x137>
 804bd7e:	b0 30                	mov    $0x30,%al
 804bd80:	eb 02                	jmp    804bd84 <number+0x139>
 804bd82:	b0 20                	mov    $0x20,%al
 804bd84:	88 45 d3             	mov    %al,-0x2d(%ebp)
        sign = 0;
 804bd87:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
        if (type & SIGN) {
 804bd8b:	8b 45 24             	mov    0x24(%ebp),%eax
 804bd8e:	83 e0 02             	and    $0x2,%eax
 804bd91:	85 c0                	test   %eax,%eax
 804bd93:	74 49                	je     804bdde <number+0x193>
                if (num < 0) {
 804bd95:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
 804bd9c:	79 1c                	jns    804bdba <number+0x16f>
                        sign = '-';
 804bd9e:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
                        num = -num;
 804bda2:	f7 9d 30 ff ff ff    	negl   -0xd0(%ebp)
 804bda8:	83 95 34 ff ff ff 00 	adcl   $0x0,-0xcc(%ebp)
 804bdaf:	f7 9d 34 ff ff ff    	negl   -0xcc(%ebp)
                        size--;
 804bdb5:	ff 4d 1c             	decl   0x1c(%ebp)
 804bdb8:	eb 24                	jmp    804bdde <number+0x193>
                } else if (type & PLUS) {
 804bdba:	8b 45 24             	mov    0x24(%ebp),%eax
 804bdbd:	83 e0 04             	and    $0x4,%eax
 804bdc0:	85 c0                	test   %eax,%eax
 804bdc2:	74 09                	je     804bdcd <number+0x182>
                        sign = '+';
 804bdc4:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
                        size--;
 804bdc8:	ff 4d 1c             	decl   0x1c(%ebp)
 804bdcb:	eb 11                	jmp    804bdde <number+0x193>
                } else if (type & SPACE) {
 804bdcd:	8b 45 24             	mov    0x24(%ebp),%eax
 804bdd0:	83 e0 08             	and    $0x8,%eax
 804bdd3:	85 c0                	test   %eax,%eax
 804bdd5:	74 07                	je     804bdde <number+0x193>
                        sign = ' ';
 804bdd7:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
                        size--;
 804bddb:	ff 4d 1c             	decl   0x1c(%ebp)
                }
        }
        if (type & SPECIAL) {
 804bdde:	8b 45 24             	mov    0x24(%ebp),%eax
 804bde1:	83 e0 20             	and    $0x20,%eax
 804bde4:	85 c0                	test   %eax,%eax
 804bde6:	74 15                	je     804bdfd <number+0x1b2>
                if (base == 16)
 804bde8:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804bdec:	75 06                	jne    804bdf4 <number+0x1a9>
                        size -= 2;
 804bdee:	83 6d 1c 02          	subl   $0x2,0x1c(%ebp)
 804bdf2:	eb 09                	jmp    804bdfd <number+0x1b2>
                else if (base == 8)
 804bdf4:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804bdf8:	75 03                	jne    804bdfd <number+0x1b2>
                        size--;
 804bdfa:	ff 4d 1c             	decl   0x1c(%ebp)
        }
        i = 0;
 804bdfd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        if (num == 0) {
 804be04:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
 804be0a:	0b 85 30 ff ff ff    	or     -0xd0(%ebp),%eax
 804be10:	85 c0                	test   %eax,%eax
 804be12:	75 13                	jne    804be27 <number+0x1dc>
                tmp[i++] = '0';
 804be14:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804be17:	8d 50 01             	lea    0x1(%eax),%edx
 804be1a:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804be1d:	c6 44 05 8a 30       	movb   $0x30,-0x76(%ebp,%eax,1)
 804be22:	e9 89 00 00 00       	jmp    804beb0 <number+0x265>
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
 804be27:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 804be2d:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 804be33:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804be36:	89 55 dc             	mov    %edx,-0x24(%ebp)
                unsigned int base2 = (unsigned int)base;
 804be39:	8b 45 18             	mov    0x18(%ebp),%eax
 804be3c:	89 45 cc             	mov    %eax,-0x34(%ebp)
                while (num2 != 0) {
 804be3f:	eb 65                	jmp    804bea6 <number+0x25b>
                        tmp[i++] = digits[num2 % base2];
 804be41:	8b 7d e0             	mov    -0x20(%ebp),%edi
 804be44:	8d 47 01             	lea    0x1(%edi),%eax
 804be47:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804be4a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 804be4d:	bb 00 00 00 00       	mov    $0x0,%ebx
 804be52:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804be55:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804be58:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804be5c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804be60:	89 04 24             	mov    %eax,(%esp)
 804be63:	89 54 24 04          	mov    %edx,0x4(%esp)
 804be67:	89 f3                	mov    %esi,%ebx
 804be69:	e8 b9 0f 00 00       	call   804ce27 <__umoddi3>
 804be6e:	89 c2                	mov    %eax,%edx
 804be70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804be73:	01 d0                	add    %edx,%eax
 804be75:	0f b6 00             	movzbl (%eax),%eax
 804be78:	88 44 3d 8a          	mov    %al,-0x76(%ebp,%edi,1)
                        num2 /= base2;
 804be7c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804be7f:	ba 00 00 00 00       	mov    $0x0,%edx
 804be84:	89 44 24 08          	mov    %eax,0x8(%esp)
 804be88:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804be8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804be8f:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804be92:	89 04 24             	mov    %eax,(%esp)
 804be95:	89 54 24 04          	mov    %edx,0x4(%esp)
 804be99:	89 f3                	mov    %esi,%ebx
 804be9b:	e8 2d 0f 00 00       	call   804cdcd <__udivdi3>
 804bea0:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804bea3:	89 55 dc             	mov    %edx,-0x24(%ebp)
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
                unsigned int base2 = (unsigned int)base;
                while (num2 != 0) {
 804bea6:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804bea9:	0b 45 d8             	or     -0x28(%ebp),%eax
 804beac:	85 c0                	test   %eax,%eax
 804beae:	75 91                	jne    804be41 <number+0x1f6>
                        tmp[i++] = digits[num2 % base2];
                        num2 /= base2;
                }
        }
        if (i > precision)
 804beb0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804beb3:	3b 45 20             	cmp    0x20(%ebp),%eax
 804beb6:	7e 06                	jle    804bebe <number+0x273>
                precision = i;
 804beb8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bebb:	89 45 20             	mov    %eax,0x20(%ebp)
        size -= precision;
 804bebe:	8b 45 20             	mov    0x20(%ebp),%eax
 804bec1:	29 45 1c             	sub    %eax,0x1c(%ebp)
        if (!(type & (ZEROPAD + LEFT))) {
 804bec4:	8b 45 24             	mov    0x24(%ebp),%eax
 804bec7:	83 e0 11             	and    $0x11,%eax
 804beca:	85 c0                	test   %eax,%eax
 804becc:	75 20                	jne    804beee <number+0x2a3>
                while (size-- > 0) {
 804bece:	eb 11                	jmp    804bee1 <number+0x296>
                        if (buf <= end)
 804bed0:	8b 45 08             	mov    0x8(%ebp),%eax
 804bed3:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bed6:	77 06                	ja     804bede <number+0x293>
                                *buf = ' ';
 804bed8:	8b 45 08             	mov    0x8(%ebp),%eax
 804bedb:	c6 00 20             	movb   $0x20,(%eax)
                        ++buf;
 804bede:	ff 45 08             	incl   0x8(%ebp)
        }
        if (i > precision)
                precision = i;
        size -= precision;
        if (!(type & (ZEROPAD + LEFT))) {
                while (size-- > 0) {
 804bee1:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804bee4:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bee7:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804beea:	85 c0                	test   %eax,%eax
 804beec:	7f e2                	jg     804bed0 <number+0x285>
                        if (buf <= end)
                                *buf = ' ';
                        ++buf;
                }
        }
        if (sign) {
 804beee:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804bef2:	74 14                	je     804bf08 <number+0x2bd>
                if (buf <= end)
 804bef4:	8b 45 08             	mov    0x8(%ebp),%eax
 804bef7:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804befa:	77 09                	ja     804bf05 <number+0x2ba>
                        *buf = sign;
 804befc:	8b 45 08             	mov    0x8(%ebp),%eax
 804beff:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
 804bf03:	88 10                	mov    %dl,(%eax)
                ++buf;
 804bf05:	ff 45 08             	incl   0x8(%ebp)
        }
        if (type & SPECIAL) {
 804bf08:	8b 45 24             	mov    0x24(%ebp),%eax
 804bf0b:	83 e0 20             	and    $0x20,%eax
 804bf0e:	85 c0                	test   %eax,%eax
 804bf10:	74 47                	je     804bf59 <number+0x30e>
                if (base == 8) {
 804bf12:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804bf16:	75 13                	jne    804bf2b <number+0x2e0>
                        if (buf <= end)
 804bf18:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf1b:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bf1e:	77 06                	ja     804bf26 <number+0x2db>
                                *buf = '0';
 804bf20:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf23:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804bf26:	ff 45 08             	incl   0x8(%ebp)
 804bf29:	eb 2e                	jmp    804bf59 <number+0x30e>
                } else if (base == 16) {
 804bf2b:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804bf2f:	75 28                	jne    804bf59 <number+0x30e>
                        if (buf <= end)
 804bf31:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf34:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bf37:	77 06                	ja     804bf3f <number+0x2f4>
                                *buf = '0';
 804bf39:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf3c:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804bf3f:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
 804bf42:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf45:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bf48:	77 0c                	ja     804bf56 <number+0x30b>
                                *buf = digits[33];
 804bf4a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804bf4d:	0f b6 50 21          	movzbl 0x21(%eax),%edx
 804bf51:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf54:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804bf56:	ff 45 08             	incl   0x8(%ebp)
                }
        }
        if (!(type & LEFT)) {
 804bf59:	8b 45 24             	mov    0x24(%ebp),%eax
 804bf5c:	83 e0 10             	and    $0x10,%eax
 804bf5f:	85 c0                	test   %eax,%eax
 804bf61:	75 36                	jne    804bf99 <number+0x34e>
                while (size-- > 0) {
 804bf63:	eb 14                	jmp    804bf79 <number+0x32e>
                        if (buf <= end)
 804bf65:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf68:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bf6b:	77 09                	ja     804bf76 <number+0x32b>
                                *buf = c;
 804bf6d:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf70:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 804bf74:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804bf76:	ff 45 08             	incl   0x8(%ebp)
                                *buf = digits[33];
                        ++buf;
                }
        }
        if (!(type & LEFT)) {
                while (size-- > 0) {
 804bf79:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804bf7c:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bf7f:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804bf82:	85 c0                	test   %eax,%eax
 804bf84:	7f df                	jg     804bf65 <number+0x31a>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804bf86:	eb 11                	jmp    804bf99 <number+0x34e>
                if (buf <= end)
 804bf88:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf8b:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bf8e:	77 06                	ja     804bf96 <number+0x34b>
                        *buf = '0';
 804bf90:	8b 45 08             	mov    0x8(%ebp),%eax
 804bf93:	c6 00 30             	movb   $0x30,(%eax)
                ++buf;
 804bf96:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804bf99:	8b 45 20             	mov    0x20(%ebp),%eax
 804bf9c:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bf9f:	89 55 20             	mov    %edx,0x20(%ebp)
 804bfa2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804bfa5:	7f e1                	jg     804bf88 <number+0x33d>
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804bfa7:	eb 1b                	jmp    804bfc4 <number+0x379>
                if (buf <= end)
 804bfa9:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfac:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bfaf:	77 10                	ja     804bfc1 <number+0x376>
                        *buf = tmp[i];
 804bfb1:	8d 55 8a             	lea    -0x76(%ebp),%edx
 804bfb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bfb7:	01 d0                	add    %edx,%eax
 804bfb9:	0f b6 10             	movzbl (%eax),%edx
 804bfbc:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfbf:	88 10                	mov    %dl,(%eax)
                ++buf;
 804bfc1:	ff 45 08             	incl   0x8(%ebp)
        while (i < precision--) {
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804bfc4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bfc7:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bfca:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804bfcd:	85 c0                	test   %eax,%eax
 804bfcf:	7f d8                	jg     804bfa9 <number+0x35e>
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804bfd1:	eb 11                	jmp    804bfe4 <number+0x399>
                if (buf <= end)
 804bfd3:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfd6:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bfd9:	77 06                	ja     804bfe1 <number+0x396>
                        *buf = ' ';
 804bfdb:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfde:	c6 00 20             	movb   $0x20,(%eax)
                ++buf;
 804bfe1:	ff 45 08             	incl   0x8(%ebp)
        while (i-- > 0) {
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804bfe4:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804bfe7:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bfea:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804bfed:	85 c0                	test   %eax,%eax
 804bfef:	7f e2                	jg     804bfd3 <number+0x388>
                if (buf <= end)
                        *buf = ' ';
                ++buf;
        }
        return buf;
 804bff1:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804bff4:	81 c4 dc 00 00 00    	add    $0xdc,%esp
 804bffa:	5b                   	pop    %ebx
 804bffb:	5e                   	pop    %esi
 804bffc:	5f                   	pop    %edi
 804bffd:	5d                   	pop    %ebp
 804bffe:	c3                   	ret    

0804bfff <vsnprintf>:
*
* Call this function if you are already dealing with a va_list.
* You probably want snprintf instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
 804bfff:	55                   	push   %ebp
 804c000:	89 e5                	mov    %esp,%ebp
 804c002:	53                   	push   %ebx
 804c003:	83 ec 64             	sub    $0x64,%esp
 804c006:	e8 c2 cf ff ff       	call   8048fcd <__x86.get_pc_thunk.bx>
 804c00b:	81 c3 f5 2f 00 00    	add    $0x2ff5,%ebx
                                   number of chars for from string */
        int qualifier;              /* 'h', 'l', or 'L' for integer fields */
        /* 'z' support added 23/7/1999 S.H.    */
        /* 'z' changed to 'Z' --davidm 1/25/99 */

        str = buf;
 804c011:	8b 45 08             	mov    0x8(%ebp),%eax
 804c014:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        end = buf + size - 1;
 804c017:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c01a:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c01d:	8b 45 08             	mov    0x8(%ebp),%eax
 804c020:	01 d0                	add    %edx,%eax
 804c022:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (end < buf - 1) {
 804c025:	8b 45 08             	mov    0x8(%ebp),%eax
 804c028:	48                   	dec    %eax
 804c029:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c02c:	0f 86 76 05 00 00    	jbe    804c5a8 <.L138+0x116>
                end = ((void *) - 1);
 804c032:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
                size = end - buf + 1;
 804c039:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c03c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c03f:	29 c2                	sub    %eax,%edx
 804c041:	89 d0                	mov    %edx,%eax
 804c043:	40                   	inc    %eax
 804c044:	89 45 0c             	mov    %eax,0xc(%ebp)
        }

        for (; *fmt ; ++fmt) {
 804c047:	e9 5c 05 00 00       	jmp    804c5a8 <.L138+0x116>
                if (*fmt != '%') {
 804c04c:	8b 45 10             	mov    0x10(%ebp),%eax
 804c04f:	0f b6 00             	movzbl (%eax),%eax
 804c052:	3c 25                	cmp    $0x25,%al
 804c054:	74 1b                	je     804c071 <vsnprintf+0x72>
                        if (str <= end)
 804c056:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c059:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c05c:	77 0b                	ja     804c069 <vsnprintf+0x6a>
                                *str = *fmt;
 804c05e:	8b 45 10             	mov    0x10(%ebp),%eax
 804c061:	0f b6 10             	movzbl (%eax),%edx
 804c064:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c067:	88 10                	mov    %dl,(%eax)
                        ++str;
 804c069:	ff 45 e4             	incl   -0x1c(%ebp)
                        continue;
 804c06c:	e9 30 05 00 00       	jmp    804c5a1 <.L138+0x10f>
                }

                /* process flags */
                flags = 0;
 804c071:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
repeat:
                ++fmt;          /* this also skips first '%' */
 804c078:	8b 45 10             	mov    0x10(%ebp),%eax
 804c07b:	40                   	inc    %eax
 804c07c:	89 45 10             	mov    %eax,0x10(%ebp)
                switch (*fmt) {
 804c07f:	8b 45 10             	mov    0x10(%ebp),%eax
 804c082:	0f b6 00             	movzbl (%eax),%eax
 804c085:	0f be c0             	movsbl %al,%eax
 804c088:	83 e8 20             	sub    $0x20,%eax
 804c08b:	83 f8 10             	cmp    $0x10,%eax
 804c08e:	77 2c                	ja     804c0bc <.L70>
 804c090:	c1 e0 02             	shl    $0x2,%eax
 804c093:	8b 84 18 88 ef ff ff 	mov    -0x1078(%eax,%ebx,1),%eax
 804c09a:	01 d8                	add    %ebx,%eax
 804c09c:	ff e0                	jmp    *%eax

0804c09e <.L75>:
                        case '-': flags |= LEFT; goto repeat;
 804c09e:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
 804c0a2:	eb d4                	jmp    804c078 <vsnprintf+0x79>

0804c0a4 <.L74>:
                        case '+': flags |= PLUS; goto repeat;
 804c0a4:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
 804c0a8:	eb ce                	jmp    804c078 <vsnprintf+0x79>

0804c0aa <.L71>:
                        case ' ': flags |= SPACE; goto repeat;
 804c0aa:	83 4d d8 08          	orl    $0x8,-0x28(%ebp)
 804c0ae:	eb c8                	jmp    804c078 <vsnprintf+0x79>

0804c0b0 <.L73>:
                        case '#': flags |= SPECIAL; goto repeat;
 804c0b0:	83 4d d8 20          	orl    $0x20,-0x28(%ebp)
 804c0b4:	eb c2                	jmp    804c078 <vsnprintf+0x79>

0804c0b6 <.L76>:
                        case '0': flags |= ZEROPAD; goto repeat;
 804c0b6:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
 804c0ba:	eb bc                	jmp    804c078 <vsnprintf+0x79>

0804c0bc <.L70>:
                }

                /* get field width */
                field_width = -1;
 804c0bc:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
                if (isdigit(*fmt))
 804c0c3:	8b 45 10             	mov    0x10(%ebp),%eax
 804c0c6:	0f b6 00             	movzbl (%eax),%eax
 804c0c9:	0f b6 c0             	movzbl %al,%eax
 804c0cc:	0f b6 84 03 40 00 00 	movzbl 0x40(%ebx,%eax,1),%eax
 804c0d3:	00 
 804c0d4:	0f b6 c0             	movzbl %al,%eax
 804c0d7:	83 e0 04             	and    $0x4,%eax
 804c0da:	85 c0                	test   %eax,%eax
 804c0dc:	74 10                	je     804c0ee <.L70+0x32>
                        field_width = skip_atoi(&fmt);
 804c0de:	8d 45 10             	lea    0x10(%ebp),%eax
 804c0e1:	89 04 24             	mov    %eax,(%esp)
 804c0e4:	e8 f6 fa ff ff       	call   804bbdf <skip_atoi>
 804c0e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804c0ec:	eb 2c                	jmp    804c11a <.L70+0x5e>
                else if (*fmt == '*') {
 804c0ee:	8b 45 10             	mov    0x10(%ebp),%eax
 804c0f1:	0f b6 00             	movzbl (%eax),%eax
 804c0f4:	3c 2a                	cmp    $0x2a,%al
 804c0f6:	75 22                	jne    804c11a <.L70+0x5e>
                        ++fmt;
 804c0f8:	8b 45 10             	mov    0x10(%ebp),%eax
 804c0fb:	40                   	inc    %eax
 804c0fc:	89 45 10             	mov    %eax,0x10(%ebp)
                        /* it's the next argument */
                        field_width = va_arg(args, int);
 804c0ff:	8b 45 14             	mov    0x14(%ebp),%eax
 804c102:	8d 50 04             	lea    0x4(%eax),%edx
 804c105:	89 55 14             	mov    %edx,0x14(%ebp)
 804c108:	8b 00                	mov    (%eax),%eax
 804c10a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                        if (field_width < 0) {
 804c10d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c111:	79 07                	jns    804c11a <.L70+0x5e>
                                field_width = -field_width;
 804c113:	f7 5d d4             	negl   -0x2c(%ebp)
                                flags |= LEFT;
 804c116:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
                        }
                }

                /* get the precision */
                precision = -1;
 804c11a:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
                if (*fmt == '.') {
 804c121:	8b 45 10             	mov    0x10(%ebp),%eax
 804c124:	0f b6 00             	movzbl (%eax),%eax
 804c127:	3c 2e                	cmp    $0x2e,%al
 804c129:	75 5e                	jne    804c189 <.L70+0xcd>
                        ++fmt;
 804c12b:	8b 45 10             	mov    0x10(%ebp),%eax
 804c12e:	40                   	inc    %eax
 804c12f:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (isdigit(*fmt))
 804c132:	8b 45 10             	mov    0x10(%ebp),%eax
 804c135:	0f b6 00             	movzbl (%eax),%eax
 804c138:	0f b6 c0             	movzbl %al,%eax
 804c13b:	0f b6 84 03 40 00 00 	movzbl 0x40(%ebx,%eax,1),%eax
 804c142:	00 
 804c143:	0f b6 c0             	movzbl %al,%eax
 804c146:	83 e0 04             	and    $0x4,%eax
 804c149:	85 c0                	test   %eax,%eax
 804c14b:	74 10                	je     804c15d <.L70+0xa1>
                                precision = skip_atoi(&fmt);
 804c14d:	8d 45 10             	lea    0x10(%ebp),%eax
 804c150:	89 04 24             	mov    %eax,(%esp)
 804c153:	e8 87 fa ff ff       	call   804bbdf <skip_atoi>
 804c158:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804c15b:	eb 1f                	jmp    804c17c <.L70+0xc0>
                        else if (*fmt == '*') {
 804c15d:	8b 45 10             	mov    0x10(%ebp),%eax
 804c160:	0f b6 00             	movzbl (%eax),%eax
 804c163:	3c 2a                	cmp    $0x2a,%al
 804c165:	75 15                	jne    804c17c <.L70+0xc0>
                                ++fmt;
 804c167:	8b 45 10             	mov    0x10(%ebp),%eax
 804c16a:	40                   	inc    %eax
 804c16b:	89 45 10             	mov    %eax,0x10(%ebp)
                                /* it's the next argument */
                                precision = va_arg(args, int);
 804c16e:	8b 45 14             	mov    0x14(%ebp),%eax
 804c171:	8d 50 04             	lea    0x4(%eax),%edx
 804c174:	89 55 14             	mov    %edx,0x14(%ebp)
 804c177:	8b 00                	mov    (%eax),%eax
 804c179:	89 45 d0             	mov    %eax,-0x30(%ebp)
                        }
                        if (precision < 0)
 804c17c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c180:	79 07                	jns    804c189 <.L70+0xcd>
                                precision = 0;
 804c182:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
                }

                /* get the conversion qualifier */
                qualifier = -1;
 804c189:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
 804c190:	8b 45 10             	mov    0x10(%ebp),%eax
 804c193:	0f b6 00             	movzbl (%eax),%eax
 804c196:	3c 68                	cmp    $0x68,%al
 804c198:	74 1e                	je     804c1b8 <.L70+0xfc>
 804c19a:	8b 45 10             	mov    0x10(%ebp),%eax
 804c19d:	0f b6 00             	movzbl (%eax),%eax
 804c1a0:	3c 6c                	cmp    $0x6c,%al
 804c1a2:	74 14                	je     804c1b8 <.L70+0xfc>
 804c1a4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1a7:	0f b6 00             	movzbl (%eax),%eax
 804c1aa:	3c 4c                	cmp    $0x4c,%al
 804c1ac:	74 0a                	je     804c1b8 <.L70+0xfc>
 804c1ae:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1b1:	0f b6 00             	movzbl (%eax),%eax
 804c1b4:	3c 5a                	cmp    $0x5a,%al
 804c1b6:	75 31                	jne    804c1e9 <.L70+0x12d>
                        qualifier = *fmt;
 804c1b8:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1bb:	0f b6 00             	movzbl (%eax),%eax
 804c1be:	0f be c0             	movsbl %al,%eax
 804c1c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        ++fmt;
 804c1c4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1c7:	40                   	inc    %eax
 804c1c8:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (qualifier == 'l' && *fmt == 'l') {
 804c1cb:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c1cf:	75 18                	jne    804c1e9 <.L70+0x12d>
 804c1d1:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1d4:	0f b6 00             	movzbl (%eax),%eax
 804c1d7:	3c 6c                	cmp    $0x6c,%al
 804c1d9:	75 0e                	jne    804c1e9 <.L70+0x12d>
                                qualifier = 'L';
 804c1db:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                                ++fmt;
 804c1e2:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1e5:	40                   	inc    %eax
 804c1e6:	89 45 10             	mov    %eax,0x10(%ebp)
                        }
                }
                if (*fmt == 'q') {
 804c1e9:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1ec:	0f b6 00             	movzbl (%eax),%eax
 804c1ef:	3c 71                	cmp    $0x71,%al
 804c1f1:	75 0e                	jne    804c201 <.L70+0x145>
                        qualifier = 'L';
 804c1f3:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                        ++fmt;
 804c1fa:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1fd:	40                   	inc    %eax
 804c1fe:	89 45 10             	mov    %eax,0x10(%ebp)
                }

                /* default base */
                base = 10;
 804c201:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)

                switch (*fmt) {
 804c208:	8b 45 10             	mov    0x10(%ebp),%eax
 804c20b:	0f b6 00             	movzbl (%eax),%eax
 804c20e:	0f be c0             	movsbl %al,%eax
 804c211:	83 e8 25             	sub    $0x25,%eax
 804c214:	83 f8 53             	cmp    $0x53,%eax
 804c217:	0f 87 33 02 00 00    	ja     804c450 <.L85>
 804c21d:	c1 e0 02             	shl    $0x2,%eax
 804c220:	8b 84 18 cc ef ff ff 	mov    -0x1034(%eax,%ebx,1),%eax
 804c227:	01 d8                	add    %ebx,%eax
 804c229:	ff e0                	jmp    *%eax

0804c22b <.L90>:
                        case 'c':
                                if (!(flags & LEFT)) {
 804c22b:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c22e:	83 e0 10             	and    $0x10,%eax
 804c231:	85 c0                	test   %eax,%eax
 804c233:	75 1c                	jne    804c251 <.L90+0x26>
                                        while (--field_width > 0) {
 804c235:	eb 11                	jmp    804c248 <.L90+0x1d>
                                                if (str <= end)
 804c237:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c23a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c23d:	77 06                	ja     804c245 <.L90+0x1a>
                                                        *str = ' ';
 804c23f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c242:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804c245:	ff 45 e4             	incl   -0x1c(%ebp)
                base = 10;

                switch (*fmt) {
                        case 'c':
                                if (!(flags & LEFT)) {
                                        while (--field_width > 0) {
 804c248:	ff 4d d4             	decl   -0x2c(%ebp)
 804c24b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c24f:	7f e6                	jg     804c237 <.L90+0xc>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                c = (unsigned char) va_arg(args, int);
 804c251:	8b 45 14             	mov    0x14(%ebp),%eax
 804c254:	8d 50 04             	lea    0x4(%eax),%edx
 804c257:	89 55 14             	mov    %edx,0x14(%ebp)
 804c25a:	8b 00                	mov    (%eax),%eax
 804c25c:	88 45 cb             	mov    %al,-0x35(%ebp)
                                if (str <= end)
 804c25f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c262:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c265:	77 09                	ja     804c270 <.L90+0x45>
                                        *str = c;
 804c267:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c26a:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
 804c26e:	88 10                	mov    %dl,(%eax)
                                ++str;
 804c270:	ff 45 e4             	incl   -0x1c(%ebp)
                                while (--field_width > 0) {
 804c273:	eb 11                	jmp    804c286 <.L90+0x5b>
                                        if (str <= end)
 804c275:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c278:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c27b:	77 06                	ja     804c283 <.L90+0x58>
                                                *str = ' ';
 804c27d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c280:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804c283:	ff 45 e4             	incl   -0x1c(%ebp)
                                }
                                c = (unsigned char) va_arg(args, int);
                                if (str <= end)
                                        *str = c;
                                ++str;
                                while (--field_width > 0) {
 804c286:	ff 4d d4             	decl   -0x2c(%ebp)
 804c289:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c28d:	7f e6                	jg     804c275 <.L90+0x4a>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804c28f:	e9 0d 03 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c294 <.L95>:

                        case 's':
                                s = va_arg(args, char *);
 804c294:	8b 45 14             	mov    0x14(%ebp),%eax
 804c297:	8d 50 04             	lea    0x4(%eax),%edx
 804c29a:	89 55 14             	mov    %edx,0x14(%ebp)
 804c29d:	8b 00                	mov    (%eax),%eax
 804c29f:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                if (!s)
 804c2a2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804c2a6:	75 09                	jne    804c2b1 <.L95+0x1d>
                                        s = "<NULL>";
 804c2a8:	8d 83 81 ef ff ff    	lea    -0x107f(%ebx),%eax
 804c2ae:	89 45 dc             	mov    %eax,-0x24(%ebp)

                                len = strnlen(s, precision);
 804c2b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c2b4:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c2b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c2bb:	89 04 24             	mov    %eax,(%esp)
 804c2be:	e8 f4 ce ff ff       	call   80491b7 <strnlen>
 804c2c3:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if (!(flags & LEFT)) {
 804c2c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c2c9:	83 e0 10             	and    $0x10,%eax
 804c2cc:	85 c0                	test   %eax,%eax
 804c2ce:	75 21                	jne    804c2f1 <.L95+0x5d>
                                        while (len < field_width--) {
 804c2d0:	eb 11                	jmp    804c2e3 <.L95+0x4f>
                                                if (str <= end)
 804c2d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c2d5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c2d8:	77 06                	ja     804c2e0 <.L95+0x4c>
                                                        *str = ' ';
 804c2da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c2dd:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804c2e0:	ff 45 e4             	incl   -0x1c(%ebp)
                                        s = "<NULL>";

                                len = strnlen(s, precision);

                                if (!(flags & LEFT)) {
                                        while (len < field_width--) {
 804c2e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c2e6:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c2e9:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 804c2ec:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c2ef:	7f e1                	jg     804c2d2 <.L95+0x3e>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804c2f1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 804c2f8:	eb 1c                	jmp    804c316 <.L95+0x82>
                                        if (str <= end)
 804c2fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c2fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c300:	77 0b                	ja     804c30d <.L95+0x79>
                                                *str = *s;
 804c302:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c305:	0f b6 10             	movzbl (%eax),%edx
 804c308:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c30b:	88 10                	mov    %dl,(%eax)
                                        ++str; ++s;
 804c30d:	ff 45 e4             	incl   -0x1c(%ebp)
 804c310:	ff 45 dc             	incl   -0x24(%ebp)
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804c313:	ff 45 ec             	incl   -0x14(%ebp)
 804c316:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c319:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c31c:	7c dc                	jl     804c2fa <.L95+0x66>
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804c31e:	eb 11                	jmp    804c331 <.L95+0x9d>
                                        if (str <= end)
 804c320:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c323:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c326:	77 06                	ja     804c32e <.L95+0x9a>
                                                *str = ' ';
 804c328:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c32b:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804c32e:	ff 45 e4             	incl   -0x1c(%ebp)
                                for (i = 0; i < len; ++i) {
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804c331:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c334:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c337:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 804c33a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c33d:	7f e1                	jg     804c320 <.L95+0x8c>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804c33f:	e9 5d 02 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c344 <.L94>:

                        case 'p':
                                if (field_width == -1) {
 804c344:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
 804c348:	75 0b                	jne    804c355 <.L94+0x11>
                                        field_width = 2 * sizeof(void *);
 804c34a:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                                        flags |= ZEROPAD;
 804c351:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
                                }
                                str = number(str, end,
                                             (unsigned long) va_arg(args, void *),
 804c355:	8b 45 14             	mov    0x14(%ebp),%eax
 804c358:	8d 50 04             	lea    0x4(%eax),%edx
 804c35b:	89 55 14             	mov    %edx,0x14(%ebp)
 804c35e:	8b 00                	mov    (%eax),%eax
                        case 'p':
                                if (field_width == -1) {
                                        field_width = 2 * sizeof(void *);
                                        flags |= ZEROPAD;
                                }
                                str = number(str, end,
 804c360:	ba 00 00 00 00       	mov    $0x0,%edx
 804c365:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804c368:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804c36c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804c36f:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804c373:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804c376:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804c37a:	c7 44 24 10 10 00 00 	movl   $0x10,0x10(%esp)
 804c381:	00 
 804c382:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c386:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c38a:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c38d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c391:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c394:	89 04 24             	mov    %eax,(%esp)
 804c397:	e8 af f8 ff ff       	call   804bc4b <number>
 804c39c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                                             (unsigned long) va_arg(args, void *),
                                             16, field_width, precision, flags);
                                continue;
 804c39f:	e9 fd 01 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c3a4 <.L92>:


                        case 'n':
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
 804c3a4:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c3a8:	75 20                	jne    804c3ca <.L92+0x26>
                                        long *ip = va_arg(args, long *);
 804c3aa:	8b 45 14             	mov    0x14(%ebp),%eax
 804c3ad:	8d 50 04             	lea    0x4(%eax),%edx
 804c3b0:	89 55 14             	mov    %edx,0x14(%ebp)
 804c3b3:	8b 00                	mov    (%eax),%eax
 804c3b5:	89 45 c0             	mov    %eax,-0x40(%ebp)
                                        *ip = (str - buf);
 804c3b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c3bb:	8b 45 08             	mov    0x8(%ebp),%eax
 804c3be:	29 c2                	sub    %eax,%edx
 804c3c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c3c3:	89 10                	mov    %edx,(%eax)
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804c3c5:	e9 d7 01 00 00       	jmp    804c5a1 <.L138+0x10f>
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
                                        long *ip = va_arg(args, long *);
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
 804c3ca:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804c3ce:	75 24                	jne    804c3f4 <.L92+0x50>
                                        size_t *ip = va_arg(args, size_t *);
 804c3d0:	8b 45 14             	mov    0x14(%ebp),%eax
 804c3d3:	8d 50 04             	lea    0x4(%eax),%edx
 804c3d6:	89 55 14             	mov    %edx,0x14(%ebp)
 804c3d9:	8b 00                	mov    (%eax),%eax
 804c3db:	89 45 bc             	mov    %eax,-0x44(%ebp)
                                        *ip = (str - buf);
 804c3de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c3e1:	8b 45 08             	mov    0x8(%ebp),%eax
 804c3e4:	29 c2                	sub    %eax,%edx
 804c3e6:	89 d0                	mov    %edx,%eax
 804c3e8:	89 c2                	mov    %eax,%edx
 804c3ea:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c3ed:	89 10                	mov    %edx,(%eax)
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804c3ef:	e9 ad 01 00 00       	jmp    804c5a1 <.L138+0x10f>
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
                                        size_t *ip = va_arg(args, size_t *);
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
 804c3f4:	8b 45 14             	mov    0x14(%ebp),%eax
 804c3f7:	8d 50 04             	lea    0x4(%eax),%edx
 804c3fa:	89 55 14             	mov    %edx,0x14(%ebp)
 804c3fd:	8b 00                	mov    (%eax),%eax
 804c3ff:	89 45 b8             	mov    %eax,-0x48(%ebp)
                                        *ip = (str - buf);
 804c402:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c405:	8b 45 08             	mov    0x8(%ebp),%eax
 804c408:	29 c2                	sub    %eax,%edx
 804c40a:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c40d:	89 10                	mov    %edx,(%eax)
                                }
                                continue;
 804c40f:	e9 8d 01 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c414 <.L86>:

                        case '%':
                                if (str <= end)
 804c414:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c417:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c41a:	77 06                	ja     804c422 <.L86+0xe>
                                        *str = '%';
 804c41c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c41f:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804c422:	ff 45 e4             	incl   -0x1c(%ebp)
                                continue;
 804c425:	e9 77 01 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c42a <.L93>:

                                /* integer number formats - set up the flags and "break" */
                        case 'o':
                                base = 8;
 804c42a:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
                                break;
 804c431:	eb 60                	jmp    804c493 <.L138+0x1>

0804c433 <.L89>:

                        case 'X':
                                flags |= LARGE;
 804c433:	83 4d d8 40          	orl    $0x40,-0x28(%ebp)

0804c437 <.L97>:
                        case 'x':
                                base = 16;
 804c437:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)
                                break;
 804c43e:	eb 53                	jmp    804c493 <.L138+0x1>

0804c440 <.L91>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
 804c440:	83 4d d8 02          	orl    $0x2,-0x28(%ebp)
                        case 'u':
                                break;
 804c444:	eb 4c                	jmp    804c492 <.L138>

0804c446 <.L88>:
                                /* Added - TODO - alvin */
                        case 'f':
                        case 'F':
                        case 'g':
                        case 'G':
                                return -1;
 804c446:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804c44b:	e9 8c 01 00 00       	jmp    804c5dc <.L138+0x14a>

0804c450 <.L85>:


                        default:
                                if (str <= end)
 804c450:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c453:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c456:	77 06                	ja     804c45e <.L85+0xe>
                                        *str = '%';
 804c458:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c45b:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804c45e:	ff 45 e4             	incl   -0x1c(%ebp)
                                if (*fmt) {
 804c461:	8b 45 10             	mov    0x10(%ebp),%eax
 804c464:	0f b6 00             	movzbl (%eax),%eax
 804c467:	84 c0                	test   %al,%al
 804c469:	74 1b                	je     804c486 <.L85+0x36>
                                        if (str <= end)
 804c46b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c46e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c471:	77 0b                	ja     804c47e <.L85+0x2e>
                                                *str = *fmt;
 804c473:	8b 45 10             	mov    0x10(%ebp),%eax
 804c476:	0f b6 10             	movzbl (%eax),%edx
 804c479:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c47c:	88 10                	mov    %dl,(%eax)
                                        ++str;
 804c47e:	ff 45 e4             	incl   -0x1c(%ebp)
                                } else {
                                        --fmt;
                                }
                                continue;
 804c481:	e9 1b 01 00 00       	jmp    804c5a1 <.L138+0x10f>
                                if (*fmt) {
                                        if (str <= end)
                                                *str = *fmt;
                                        ++str;
                                } else {
                                        --fmt;
 804c486:	8b 45 10             	mov    0x10(%ebp),%eax
 804c489:	48                   	dec    %eax
 804c48a:	89 45 10             	mov    %eax,0x10(%ebp)
                                }
                                continue;
 804c48d:	e9 0f 01 00 00       	jmp    804c5a1 <.L138+0x10f>

0804c492 <.L138>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
                        case 'u':
                                break;
 804c492:	90                   	nop
                                } else {
                                        --fmt;
                                }
                                continue;
                }
                if (qualifier == 'L')
 804c493:	83 7d cc 4c          	cmpl   $0x4c,-0x34(%ebp)
 804c497:	75 19                	jne    804c4b2 <.L138+0x20>
                        num = va_arg(args, long long);
 804c499:	8b 45 14             	mov    0x14(%ebp),%eax
 804c49c:	8d 50 08             	lea    0x8(%eax),%edx
 804c49f:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4a2:	8b 50 04             	mov    0x4(%eax),%edx
 804c4a5:	8b 00                	mov    (%eax),%eax
 804c4a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c4aa:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c4ad:	e9 b0 00 00 00       	jmp    804c562 <.L138+0xd0>
                else if (qualifier == 'l') {
 804c4b2:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c4b6:	75 2f                	jne    804c4e7 <.L138+0x55>
                        num = va_arg(args, unsigned long);
 804c4b8:	8b 45 14             	mov    0x14(%ebp),%eax
 804c4bb:	8d 50 04             	lea    0x4(%eax),%edx
 804c4be:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4c1:	8b 00                	mov    (%eax),%eax
 804c4c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c4c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c4cd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c4d0:	83 e0 02             	and    $0x2,%eax
 804c4d3:	85 c0                	test   %eax,%eax
 804c4d5:	0f 84 87 00 00 00    	je     804c562 <.L138+0xd0>
                                num = (signed long) num;
 804c4db:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c4de:	99                   	cltd   
 804c4df:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c4e2:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c4e5:	eb 7b                	jmp    804c562 <.L138+0xd0>
                } else if (qualifier == 'Z') {
 804c4e7:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804c4eb:	75 17                	jne    804c504 <.L138+0x72>
                        num = va_arg(args, size_t);
 804c4ed:	8b 45 14             	mov    0x14(%ebp),%eax
 804c4f0:	8d 50 04             	lea    0x4(%eax),%edx
 804c4f3:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4f6:	8b 00                	mov    (%eax),%eax
 804c4f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c4fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804c502:	eb 5e                	jmp    804c562 <.L138+0xd0>
                } else if (qualifier == 'h') {
 804c504:	83 7d cc 68          	cmpl   $0x68,-0x34(%ebp)
 804c508:	75 2f                	jne    804c539 <.L138+0xa7>
                        num = (unsigned short) va_arg(args, int);
 804c50a:	8b 45 14             	mov    0x14(%ebp),%eax
 804c50d:	8d 50 04             	lea    0x4(%eax),%edx
 804c510:	89 55 14             	mov    %edx,0x14(%ebp)
 804c513:	8b 00                	mov    (%eax),%eax
 804c515:	0f b7 c0             	movzwl %ax,%eax
 804c518:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c51b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c522:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c525:	83 e0 02             	and    $0x2,%eax
 804c528:	85 c0                	test   %eax,%eax
 804c52a:	74 36                	je     804c562 <.L138+0xd0>
                                num = (signed short) num;
 804c52c:	0f bf 45 f0          	movswl -0x10(%ebp),%eax
 804c530:	99                   	cltd   
 804c531:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c534:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c537:	eb 29                	jmp    804c562 <.L138+0xd0>
                } else {
                        num = va_arg(args, unsigned int);
 804c539:	8b 45 14             	mov    0x14(%ebp),%eax
 804c53c:	8d 50 04             	lea    0x4(%eax),%edx
 804c53f:	89 55 14             	mov    %edx,0x14(%ebp)
 804c542:	8b 00                	mov    (%eax),%eax
 804c544:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c547:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c54e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c551:	83 e0 02             	and    $0x2,%eax
 804c554:	85 c0                	test   %eax,%eax
 804c556:	74 0a                	je     804c562 <.L138+0xd0>
                                num = (signed int) num;
 804c558:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c55b:	99                   	cltd   
 804c55c:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c55f:	89 55 f4             	mov    %edx,-0xc(%ebp)
                }

                str = number(str, end, num, base,
 804c562:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c565:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c568:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804c56b:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804c56f:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804c572:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804c576:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804c579:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804c57d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804c580:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 804c584:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c588:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c58c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c58f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c593:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c596:	89 04 24             	mov    %eax,(%esp)
 804c599:	e8 ad f6 ff ff       	call   804bc4b <number>
 804c59e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (end < buf - 1) {
                end = ((void *) - 1);
                size = end - buf + 1;
        }

        for (; *fmt ; ++fmt) {
 804c5a1:	8b 45 10             	mov    0x10(%ebp),%eax
 804c5a4:	40                   	inc    %eax
 804c5a5:	89 45 10             	mov    %eax,0x10(%ebp)
 804c5a8:	8b 45 10             	mov    0x10(%ebp),%eax
 804c5ab:	0f b6 00             	movzbl (%eax),%eax
 804c5ae:	84 c0                	test   %al,%al
 804c5b0:	0f 85 96 fa ff ff    	jne    804c04c <vsnprintf+0x4d>
                }

                str = number(str, end, num, base,
                             field_width, precision, flags);
        }
        if (str <= end)
 804c5b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c5b9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c5bc:	77 08                	ja     804c5c6 <.L138+0x134>
                *str = '\0';
 804c5be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c5c1:	c6 00 00             	movb   $0x0,(%eax)
 804c5c4:	eb 0c                	jmp    804c5d2 <.L138+0x140>
        else if (size > 0)
 804c5c6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c5ca:	74 06                	je     804c5d2 <.L138+0x140>
                /* don't write out a null byte if the buf size is zero */
                *end = '\0';
 804c5cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c5cf:	c6 00 00             	movb   $0x0,(%eax)
        /* the trailing null byte doesn't count towards the total
         * ++str;
         */
        return str - buf;
 804c5d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c5d5:	8b 45 08             	mov    0x8(%ebp),%eax
 804c5d8:	29 c2                	sub    %eax,%edx
 804c5da:	89 d0                	mov    %edx,%eax
}
 804c5dc:	83 c4 64             	add    $0x64,%esp
 804c5df:	5b                   	pop    %ebx
 804c5e0:	5d                   	pop    %ebp
 804c5e1:	c3                   	ret    

0804c5e2 <__x86.get_pc_thunk.dx>:
 804c5e2:	8b 14 24             	mov    (%esp),%edx
 804c5e5:	c3                   	ret    

0804c5e6 <__x86.get_pc_thunk.si>:
 804c5e6:	8b 34 24             	mov    (%esp),%esi
 804c5e9:	c3                   	ret    

0804c5ea <shl>:
 * `fall out' the left (there never will be any such anyway).
 * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
 */
static void
shl(register digit *p, register int len, register int sh)
{
 804c5ea:	55                   	push   %ebp
 804c5eb:	89 e5                	mov    %esp,%ebp
 804c5ed:	57                   	push   %edi
 804c5ee:	56                   	push   %esi
 804c5ef:	53                   	push   %ebx
 804c5f0:	83 ec 04             	sub    $0x4,%esp
 804c5f3:	e8 cd c9 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804c5f8:	05 08 2a 00 00       	add    $0x2a08,%eax
 804c5fd:	8b 75 08             	mov    0x8(%ebp),%esi
        register int i;

        for (i = 0; i < len; i++)
 804c600:	bb 00 00 00 00       	mov    $0x0,%ebx
 804c605:	eb 41                	jmp    804c648 <shl+0x5e>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
 804c607:	89 d8                	mov    %ebx,%eax
 804c609:	c1 e0 02             	shl    $0x2,%eax
 804c60c:	8d 3c 06             	lea    (%esi,%eax,1),%edi
 804c60f:	89 d8                	mov    %ebx,%eax
 804c611:	c1 e0 02             	shl    $0x2,%eax
 804c614:	01 f0                	add    %esi,%eax
 804c616:	8b 00                	mov    (%eax),%eax
 804c618:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c61c:	d3 e0                	shl    %cl,%eax
 804c61e:	0f b7 c0             	movzwl %ax,%eax
 804c621:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c624:	89 d8                	mov    %ebx,%eax
 804c626:	40                   	inc    %eax
 804c627:	c1 e0 02             	shl    $0x2,%eax
 804c62a:	01 f0                	add    %esi,%eax
 804c62c:	8b 00                	mov    (%eax),%eax
 804c62e:	89 c1                	mov    %eax,%ecx
 804c630:	8b 55 10             	mov    0x10(%ebp),%edx
 804c633:	b8 10 00 00 00       	mov    $0x10,%eax
 804c638:	29 d0                	sub    %edx,%eax
 804c63a:	89 ca                	mov    %ecx,%edx
 804c63c:	88 c1                	mov    %al,%cl
 804c63e:	d3 ea                	shr    %cl,%edx
 804c640:	89 d0                	mov    %edx,%eax
 804c642:	0b 45 f0             	or     -0x10(%ebp),%eax
 804c645:	89 07                	mov    %eax,(%edi)
static void
shl(register digit *p, register int len, register int sh)
{
        register int i;

        for (i = 0; i < len; i++)
 804c647:	43                   	inc    %ebx
 804c648:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
 804c64b:	7c ba                	jl     804c607 <shl+0x1d>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
        p[i] = LHALF(p[i] << sh);
 804c64d:	89 d8                	mov    %ebx,%eax
 804c64f:	c1 e0 02             	shl    $0x2,%eax
 804c652:	8d 14 06             	lea    (%esi,%eax,1),%edx
 804c655:	89 d8                	mov    %ebx,%eax
 804c657:	c1 e0 02             	shl    $0x2,%eax
 804c65a:	01 f0                	add    %esi,%eax
 804c65c:	8b 00                	mov    (%eax),%eax
 804c65e:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c662:	d3 e0                	shl    %cl,%eax
 804c664:	0f b7 c0             	movzwl %ax,%eax
 804c667:	89 02                	mov    %eax,(%edx)
}
 804c669:	90                   	nop
 804c66a:	83 c4 04             	add    $0x4,%esp
 804c66d:	5b                   	pop    %ebx
 804c66e:	5e                   	pop    %esi
 804c66f:	5f                   	pop    %edi
 804c670:	5d                   	pop    %ebp
 804c671:	c3                   	ret    

0804c672 <__qdivrem>:
 * divisor are 4 `digits' in this base (they are shorter if they have
 * leading zeros).
 */
unsigned long long
__qdivrem(unsigned long long uq, unsigned long long vq, unsigned long long *arq)
{
 804c672:	55                   	push   %ebp
 804c673:	89 e5                	mov    %esp,%ebp
 804c675:	57                   	push   %edi
 804c676:	56                   	push   %esi
 804c677:	53                   	push   %ebx
 804c678:	81 ec b8 00 00 00    	sub    $0xb8,%esp
 804c67e:	e8 42 c9 ff ff       	call   8048fc5 <__x86.get_pc_thunk.ax>
 804c683:	05 7d 29 00 00       	add    $0x297d,%eax
 804c688:	8b 55 08             	mov    0x8(%ebp),%edx
 804c68b:	89 95 58 ff ff ff    	mov    %edx,-0xa8(%ebp)
 804c691:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c694:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
 804c69a:	8b 55 10             	mov    0x10(%ebp),%edx
 804c69d:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
 804c6a3:	8b 55 14             	mov    0x14(%ebp),%edx
 804c6a6:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
        digit uspace[5], vspace[5], qspace[5];

        /*
         * Take care of special cases: divide by zero, and u < v.
         */
        if (vq == 0) {
 804c6ac:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c6b2:	0b 95 50 ff ff ff    	or     -0xb0(%ebp),%edx
 804c6b8:	85 d2                	test   %edx,%edx
 804c6ba:	75 40                	jne    804c6fc <__qdivrem+0x8a>
                /* divide by zero. */
                static volatile const unsigned int zero = 0;

                tmp.ul[H] = tmp.ul[L] = 1 / zero;
 804c6bc:	8b b8 40 01 00 00    	mov    0x140(%eax),%edi
 804c6c2:	b8 01 00 00 00       	mov    $0x1,%eax
 804c6c7:	ba 00 00 00 00       	mov    $0x0,%edx
 804c6cc:	f7 f7                	div    %edi
 804c6ce:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c6d1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c6d4:	89 45 a8             	mov    %eax,-0x58(%ebp)
                if (arq)
 804c6d7:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c6db:	74 14                	je     804c6f1 <__qdivrem+0x7f>
                        *arq = uq;
 804c6dd:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c6e0:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c6e6:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c6ec:	89 01                	mov    %eax,(%ecx)
 804c6ee:	89 51 04             	mov    %edx,0x4(%ecx)
                return (tmp.q);
 804c6f1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c6f4:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c6f7:	e9 eb 05 00 00       	jmp    804cce7 <__qdivrem+0x675>
        }
        if (uq < vq) {
 804c6fc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c702:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c708:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c70e:	77 39                	ja     804c749 <__qdivrem+0xd7>
 804c710:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c716:	72 08                	jb     804c720 <__qdivrem+0xae>
 804c718:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
 804c71e:	73 29                	jae    804c749 <__qdivrem+0xd7>
                if (arq)
 804c720:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c724:	74 14                	je     804c73a <__qdivrem+0xc8>
                        *arq = uq;
 804c726:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c729:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c72f:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c735:	89 01                	mov    %eax,(%ecx)
 804c737:	89 51 04             	mov    %edx,0x4(%ecx)
                return (0);
 804c73a:	b8 00 00 00 00       	mov    $0x0,%eax
 804c73f:	ba 00 00 00 00       	mov    $0x0,%edx
 804c744:	e9 9e 05 00 00       	jmp    804cce7 <__qdivrem+0x675>
        }
        u = &uspace[0];
 804c749:	8d 45 90             	lea    -0x70(%ebp),%eax
 804c74c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        v = &vspace[0];
 804c74f:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 804c755:	89 45 e8             	mov    %eax,-0x18(%ebp)
        q = &qspace[0];
 804c758:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 804c75e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         *      m >= 0 (otherwise u < v, which we already checked)
         *      m + n = 4
         * and thus
         *      m = 4 - n <= 2
         */
        tmp.uq = uq;
 804c761:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c767:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c76d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c770:	89 55 a8             	mov    %edx,-0x58(%ebp)
        u[0] = 0;
 804c773:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c776:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        u[1] = HHALF(tmp.ul[H]);
 804c77c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c77f:	83 c0 04             	add    $0x4,%eax
 804c782:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c785:	c1 ea 10             	shr    $0x10,%edx
 804c788:	89 10                	mov    %edx,(%eax)
        u[2] = LHALF(tmp.ul[H]);
 804c78a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c78d:	8d 50 08             	lea    0x8(%eax),%edx
 804c790:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804c793:	0f b7 c0             	movzwl %ax,%eax
 804c796:	89 02                	mov    %eax,(%edx)
        u[3] = HHALF(tmp.ul[L]);
 804c798:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c79b:	83 c0 0c             	add    $0xc,%eax
 804c79e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c7a1:	c1 ea 10             	shr    $0x10,%edx
 804c7a4:	89 10                	mov    %edx,(%eax)
        u[4] = LHALF(tmp.ul[L]);
 804c7a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c7a9:	8d 50 10             	lea    0x10(%eax),%edx
 804c7ac:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c7af:	0f b7 c0             	movzwl %ax,%eax
 804c7b2:	89 02                	mov    %eax,(%edx)
        tmp.uq = vq;
 804c7b4:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804c7ba:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c7c0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c7c3:	89 55 a8             	mov    %edx,-0x58(%ebp)
        v[1] = HHALF(tmp.ul[H]);
 804c7c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c7c9:	83 c0 04             	add    $0x4,%eax
 804c7cc:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c7cf:	c1 ea 10             	shr    $0x10,%edx
 804c7d2:	89 10                	mov    %edx,(%eax)
        v[2] = LHALF(tmp.ul[H]);
 804c7d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c7d7:	8d 50 08             	lea    0x8(%eax),%edx
 804c7da:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804c7dd:	0f b7 c0             	movzwl %ax,%eax
 804c7e0:	89 02                	mov    %eax,(%edx)
        v[3] = HHALF(tmp.ul[L]);
 804c7e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c7e5:	83 c0 0c             	add    $0xc,%eax
 804c7e8:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c7eb:	c1 ea 10             	shr    $0x10,%edx
 804c7ee:	89 10                	mov    %edx,(%eax)
        v[4] = LHALF(tmp.ul[L]);
 804c7f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c7f3:	8d 50 10             	lea    0x10(%eax),%edx
 804c7f6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c7f9:	0f b7 c0             	movzwl %ax,%eax
 804c7fc:	89 02                	mov    %eax,(%edx)
        for (n = 4; v[1] == 0; v++) {
 804c7fe:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
 804c805:	e9 fc 00 00 00       	jmp    804c906 <__qdivrem+0x294>
                if (--n == 1) {
 804c80a:	ff 4d d4             	decl   -0x2c(%ebp)
 804c80d:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804c811:	0f 85 eb 00 00 00    	jne    804c902 <__qdivrem+0x290>
                         *      for j = 1..4:
                         *              q[j] = floor((r*B + u[j]) / v),
                         *              r = (r*B + u[j]) % v;
                         * We unroll this completely here.
                         */
                        t = v[2];       /* nonzero, by definition */
 804c817:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c81a:	8b 40 08             	mov    0x8(%eax),%eax
 804c81d:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        q1 = u[1] / t;
 804c820:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c823:	83 c0 04             	add    $0x4,%eax
 804c826:	8b 00                	mov    (%eax),%eax
 804c828:	ba 00 00 00 00       	mov    $0x0,%edx
 804c82d:	f7 75 dc             	divl   -0x24(%ebp)
 804c830:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        rbj = COMBINE(u[1] % t, u[2]);
 804c833:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c836:	83 c0 04             	add    $0x4,%eax
 804c839:	8b 00                	mov    (%eax),%eax
 804c83b:	ba 00 00 00 00       	mov    $0x0,%edx
 804c840:	f7 75 dc             	divl   -0x24(%ebp)
 804c843:	89 d0                	mov    %edx,%eax
 804c845:	c1 e0 10             	shl    $0x10,%eax
 804c848:	89 c2                	mov    %eax,%edx
 804c84a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c84d:	83 c0 08             	add    $0x8,%eax
 804c850:	8b 00                	mov    (%eax),%eax
 804c852:	09 d0                	or     %edx,%eax
 804c854:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q2 = rbj / t;
 804c857:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c85a:	ba 00 00 00 00       	mov    $0x0,%edx
 804c85f:	f7 75 dc             	divl   -0x24(%ebp)
 804c862:	89 45 b8             	mov    %eax,-0x48(%ebp)
                        rbj = COMBINE(rbj % t, u[3]);
 804c865:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c868:	ba 00 00 00 00       	mov    $0x0,%edx
 804c86d:	f7 75 dc             	divl   -0x24(%ebp)
 804c870:	89 d0                	mov    %edx,%eax
 804c872:	c1 e0 10             	shl    $0x10,%eax
 804c875:	89 c2                	mov    %eax,%edx
 804c877:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c87a:	83 c0 0c             	add    $0xc,%eax
 804c87d:	8b 00                	mov    (%eax),%eax
 804c87f:	09 d0                	or     %edx,%eax
 804c881:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q3 = rbj / t;
 804c884:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c887:	ba 00 00 00 00       	mov    $0x0,%edx
 804c88c:	f7 75 dc             	divl   -0x24(%ebp)
 804c88f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                        rbj = COMBINE(rbj % t, u[4]);
 804c892:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c895:	ba 00 00 00 00       	mov    $0x0,%edx
 804c89a:	f7 75 dc             	divl   -0x24(%ebp)
 804c89d:	89 d0                	mov    %edx,%eax
 804c89f:	c1 e0 10             	shl    $0x10,%eax
 804c8a2:	89 c2                	mov    %eax,%edx
 804c8a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c8a7:	83 c0 10             	add    $0x10,%eax
 804c8aa:	8b 00                	mov    (%eax),%eax
 804c8ac:	09 d0                	or     %edx,%eax
 804c8ae:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q4 = rbj / t;
 804c8b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c8b4:	ba 00 00 00 00       	mov    $0x0,%edx
 804c8b9:	f7 75 dc             	divl   -0x24(%ebp)
 804c8bc:	89 45 b0             	mov    %eax,-0x50(%ebp)
                        if (arq)
 804c8bf:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c8c3:	74 1a                	je     804c8df <__qdivrem+0x26d>
                                *arq = rbj % t;
 804c8c5:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c8c8:	ba 00 00 00 00       	mov    $0x0,%edx
 804c8cd:	f7 75 dc             	divl   -0x24(%ebp)
 804c8d0:	89 d0                	mov    %edx,%eax
 804c8d2:	ba 00 00 00 00       	mov    $0x0,%edx
 804c8d7:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c8da:	89 01                	mov    %eax,(%ecx)
 804c8dc:	89 51 04             	mov    %edx,0x4(%ecx)
                        tmp.ul[H] = COMBINE(q1, q2);
 804c8df:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c8e2:	c1 e0 10             	shl    $0x10,%eax
 804c8e5:	0b 45 b8             	or     -0x48(%ebp),%eax
 804c8e8:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        tmp.ul[L] = COMBINE(q3, q4);
 804c8eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c8ee:	c1 e0 10             	shl    $0x10,%eax
 804c8f1:	0b 45 b0             	or     -0x50(%ebp),%eax
 804c8f4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        return (tmp.q);
 804c8f7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c8fa:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c8fd:	e9 e5 03 00 00       	jmp    804cce7 <__qdivrem+0x675>
        tmp.uq = vq;
        v[1] = HHALF(tmp.ul[H]);
        v[2] = LHALF(tmp.ul[H]);
        v[3] = HHALF(tmp.ul[L]);
        v[4] = LHALF(tmp.ul[L]);
        for (n = 4; v[1] == 0; v++) {
 804c902:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
 804c906:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c909:	83 c0 04             	add    $0x4,%eax
 804c90c:	8b 00                	mov    (%eax),%eax
 804c90e:	85 c0                	test   %eax,%eax
 804c910:	0f 84 f4 fe ff ff    	je     804c80a <__qdivrem+0x198>
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804c916:	b8 04 00 00 00       	mov    $0x4,%eax
 804c91b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 804c91e:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804c921:	eb 07                	jmp    804c92a <__qdivrem+0x2b8>
                m--;
 804c923:	ff 4d d8             	decl   -0x28(%ebp)
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804c926:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
 804c92a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c92d:	83 c0 04             	add    $0x4,%eax
 804c930:	8b 00                	mov    (%eax),%eax
 804c932:	85 c0                	test   %eax,%eax
 804c934:	74 ed                	je     804c923 <__qdivrem+0x2b1>
                m--;
        for (i = 4 - m; --i >= 0;)
 804c936:	b8 04 00 00 00       	mov    $0x4,%eax
 804c93b:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804c93e:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804c941:	eb 15                	jmp    804c958 <__qdivrem+0x2e6>
                q[i] = 0;
 804c943:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804c946:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804c94d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804c950:	01 d0                	add    %edx,%eax
 804c952:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
                m--;
        for (i = 4 - m; --i >= 0;)
 804c958:	ff 4d c8             	decl   -0x38(%ebp)
 804c95b:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804c95f:	79 e2                	jns    804c943 <__qdivrem+0x2d1>
                q[i] = 0;
        q += 4 - m;
 804c961:	b8 04 00 00 00       	mov    $0x4,%eax
 804c966:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804c969:	c1 e0 02             	shl    $0x2,%eax
 804c96c:	01 45 c4             	add    %eax,-0x3c(%ebp)
         * Here we run Program D, translated from MIX to C and acquiring
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
 804c96f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        for (t = v[1]; t < B / 2; t <<= 1)
 804c976:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c979:	8b 40 04             	mov    0x4(%eax),%eax
 804c97c:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804c97f:	eb 06                	jmp    804c987 <__qdivrem+0x315>
                d++;
 804c981:	ff 45 d0             	incl   -0x30(%ebp)
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
        for (t = v[1]; t < B / 2; t <<= 1)
 804c984:	d1 65 dc             	shll   -0x24(%ebp)
 804c987:	81 7d dc ff 7f 00 00 	cmpl   $0x7fff,-0x24(%ebp)
 804c98e:	76 f1                	jbe    804c981 <__qdivrem+0x30f>
                d++;
        if (d > 0) {
 804c990:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c994:	7e 3d                	jle    804c9d3 <__qdivrem+0x361>
                shl(&u[0], m + n, d);           /* u <<= d */
 804c996:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804c999:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c99c:	01 c2                	add    %eax,%edx
 804c99e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c9a1:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c9a5:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c9a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c9ac:	89 04 24             	mov    %eax,(%esp)
 804c9af:	e8 36 fc ff ff       	call   804c5ea <shl>
                shl(&v[1], n - 1, d);           /* v <<= d */
 804c9b4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c9b7:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804c9ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c9bd:	8d 50 04             	lea    0x4(%eax),%edx
 804c9c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c9c3:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c9c7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804c9cb:	89 14 24             	mov    %edx,(%esp)
 804c9ce:	e8 17 fc ff ff       	call   804c5ea <shl>
        }
        /*
         * D2: j = 0.
         */
        j = 0;
 804c9d3:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
        v1 = v[1];      /* for D3 -- note that v[1..n] are constant */
 804c9da:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c9dd:	8b 58 04             	mov    0x4(%eax),%ebx
        v2 = v[2];      /* for D3 */
 804c9e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c9e3:	8b 40 08             	mov    0x8(%eax),%eax
 804c9e6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
                 * let rhat = (u[j]*B + u[j+1]) mod v[1].
                 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
                 * decrement qhat and increase rhat correspondingly.
                 * Note that if rhat >= B, v[2]*qhat < rhat*B.
                 */
                uj0 = u[j + 0]; /* for D3 only -- note that u[j+...] change */
 804c9ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804c9ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804c9f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c9f9:	01 d0                	add    %edx,%eax
 804c9fb:	8b 38                	mov    (%eax),%edi
                uj1 = u[j + 1]; /* for D3 only */
 804c9fd:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ca00:	40                   	inc    %eax
 804ca01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804ca08:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ca0b:	01 d0                	add    %edx,%eax
 804ca0d:	8b 30                	mov    (%eax),%esi
                uj2 = u[j + 2]; /* for D3 only */
 804ca0f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ca12:	83 c0 02             	add    $0x2,%eax
 804ca15:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804ca1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ca1f:	01 d0                	add    %edx,%eax
 804ca21:	8b 00                	mov    (%eax),%eax
 804ca23:	89 c1                	mov    %eax,%ecx
                if (uj0 == v1) {
 804ca25:	39 df                	cmp    %ebx,%edi
 804ca27:	75 0c                	jne    804ca35 <__qdivrem+0x3c3>
                        qhat = B;
 804ca29:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
                        rhat = uj1;
 804ca30:	89 75 e0             	mov    %esi,-0x20(%ebp)
                        goto qhat_too_big;
 804ca33:	eb 26                	jmp    804ca5b <__qdivrem+0x3e9>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
 804ca35:	89 f8                	mov    %edi,%eax
 804ca37:	c1 e0 10             	shl    $0x10,%eax
 804ca3a:	09 f0                	or     %esi,%eax
 804ca3c:	89 45 ac             	mov    %eax,-0x54(%ebp)
                        qhat = nn / v1;
 804ca3f:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804ca42:	ba 00 00 00 00       	mov    $0x0,%edx
 804ca47:	f7 f3                	div    %ebx
 804ca49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        rhat = nn % v1;
 804ca4c:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804ca4f:	ba 00 00 00 00       	mov    $0x0,%edx
 804ca54:	f7 f3                	div    %ebx
 804ca56:	89 55 e0             	mov    %edx,-0x20(%ebp)
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804ca59:	eb 0f                	jmp    804ca6a <__qdivrem+0x3f8>
qhat_too_big:
                        qhat--;
 804ca5b:	ff 4d e4             	decl   -0x1c(%ebp)
                        if ((rhat += v1) >= B)
 804ca5e:	01 5d e0             	add    %ebx,-0x20(%ebp)
 804ca61:	81 7d e0 ff ff 00 00 	cmpl   $0xffff,-0x20(%ebp)
 804ca68:	77 1a                	ja     804ca84 <__qdivrem+0x412>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
                        qhat = nn / v1;
                        rhat = nn % v1;
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804ca6a:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 804ca70:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804ca74:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804ca77:	c1 e2 10             	shl    $0x10,%edx
 804ca7a:	89 cf                	mov    %ecx,%edi
 804ca7c:	09 fa                	or     %edi,%edx
 804ca7e:	39 d0                	cmp    %edx,%eax
 804ca80:	77 d9                	ja     804ca5b <__qdivrem+0x3e9>
 804ca82:	eb 01                	jmp    804ca85 <__qdivrem+0x413>
qhat_too_big:
                        qhat--;
                        if ((rhat += v1) >= B)
                                break;
 804ca84:	90                   	nop
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804ca85:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804ca8c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ca8f:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804ca92:	eb 64                	jmp    804caf8 <__qdivrem+0x486>
                        t = u[i + j] - v[i] * qhat - t;
 804ca94:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804ca97:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ca9a:	01 d0                	add    %edx,%eax
 804ca9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804caa3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804caa6:	01 d0                	add    %edx,%eax
 804caa8:	8b 10                	mov    (%eax),%edx
 804caaa:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804caad:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cab4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cab7:	01 c8                	add    %ecx,%eax
 804cab9:	8b 00                	mov    (%eax),%eax
 804cabb:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804cabf:	29 c2                	sub    %eax,%edx
 804cac1:	89 d0                	mov    %edx,%eax
 804cac3:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804cac6:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        u[i + j] = LHALF(t);
 804cac9:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cacc:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cacf:	01 d0                	add    %edx,%eax
 804cad1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cad8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cadb:	01 c2                	add    %eax,%edx
 804cadd:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cae0:	0f b7 c0             	movzwl %ax,%eax
 804cae3:	89 02                	mov    %eax,(%edx)
                        t = (B - HHALF(t)) & (B - 1);
 804cae5:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cae8:	c1 e8 10             	shr    $0x10,%eax
 804caeb:	f7 d8                	neg    %eax
 804caed:	25 ff ff 00 00       	and    $0xffff,%eax
 804caf2:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804caf5:	ff 4d c8             	decl   -0x38(%ebp)
 804caf8:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804cafc:	7f 96                	jg     804ca94 <__qdivrem+0x422>
                        t = u[i + j] - v[i] * qhat - t;
                        u[i + j] = LHALF(t);
                        t = (B - HHALF(t)) & (B - 1);
                }
                t = u[j] - t;
 804cafe:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb08:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb0b:	01 d0                	add    %edx,%eax
 804cb0d:	8b 00                	mov    (%eax),%eax
 804cb0f:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804cb12:	89 45 dc             	mov    %eax,-0x24(%ebp)
                u[j] = LHALF(t);
 804cb15:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb18:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb22:	01 c2                	add    %eax,%edx
 804cb24:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cb27:	0f b7 c0             	movzwl %ax,%eax
 804cb2a:	89 02                	mov    %eax,(%edx)
                 * D5: test remainder.
                 * There is a borrow if and only if HHALF(t) is nonzero;
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
 804cb2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cb2f:	c1 e8 10             	shr    $0x10,%eax
 804cb32:	85 c0                	test   %eax,%eax
 804cb34:	0f 84 91 00 00 00    	je     804cbcb <__qdivrem+0x559>
                        qhat--;
 804cb3a:	ff 4d e4             	decl   -0x1c(%ebp)
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804cb3d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804cb44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cb47:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cb4a:	eb 4f                	jmp    804cb9b <__qdivrem+0x529>
                                t += u[i + j] + v[i];
 804cb4c:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cb4f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb52:	01 d0                	add    %edx,%eax
 804cb54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb5e:	01 d0                	add    %edx,%eax
 804cb60:	8b 10                	mov    (%eax),%edx
 804cb62:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cb65:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cb6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cb6f:	01 c8                	add    %ecx,%eax
 804cb71:	8b 00                	mov    (%eax),%eax
 804cb73:	01 d0                	add    %edx,%eax
 804cb75:	01 45 dc             	add    %eax,-0x24(%ebp)
                                u[i + j] = LHALF(t);
 804cb78:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cb7b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb7e:	01 d0                	add    %edx,%eax
 804cb80:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb87:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb8a:	01 c2                	add    %eax,%edx
 804cb8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cb8f:	0f b7 c0             	movzwl %ax,%eax
 804cb92:	89 02                	mov    %eax,(%edx)
                                t = HHALF(t);
 804cb94:	c1 6d dc 10          	shrl   $0x10,-0x24(%ebp)
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
                        qhat--;
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804cb98:	ff 4d c8             	decl   -0x38(%ebp)
 804cb9b:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804cb9f:	7f ab                	jg     804cb4c <__qdivrem+0x4da>
                                t += u[i + j] + v[i];
                                u[i + j] = LHALF(t);
                                t = HHALF(t);
                        }
                        u[j] = LHALF(u[j] + t);
 804cba1:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cba4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cbab:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cbae:	01 c2                	add    %eax,%edx
 804cbb0:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cbb3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cbba:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cbbd:	01 c8                	add    %ecx,%eax
 804cbbf:	8b 08                	mov    (%eax),%ecx
 804cbc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cbc4:	01 c8                	add    %ecx,%eax
 804cbc6:	0f b7 c0             	movzwl %ax,%eax
 804cbc9:	89 02                	mov    %eax,(%edx)
                }
                q[j] = qhat;
 804cbcb:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cbce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cbd5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804cbd8:	01 c2                	add    %eax,%edx
 804cbda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804cbdd:	89 02                	mov    %eax,(%edx)
        } while (++j <= m);             /* D7: loop on j. */
 804cbdf:	ff 45 cc             	incl   -0x34(%ebp)
 804cbe2:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cbe5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804cbe8:	0f 8e fe fd ff ff    	jle    804c9ec <__qdivrem+0x37a>
        /*
         * If caller wants the remainder, we have to calculate it as
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
 804cbee:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804cbf2:	0f 84 bd 00 00 00    	je     804ccb5 <__qdivrem+0x643>
                if (d) {
 804cbf8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804cbfc:	0f 84 85 00 00 00    	je     804cc87 <__qdivrem+0x615>
                        for (i = m + n; i > m; --i)
 804cc02:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804cc05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cc08:	01 d0                	add    %edx,%eax
 804cc0a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cc0d:	eb 5b                	jmp    804cc6a <__qdivrem+0x5f8>
                                u[i] = (u[i] >> d) |
 804cc0f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc19:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc1c:	01 c2                	add    %eax,%edx
 804cc1e:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc21:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cc28:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc2b:	01 c8                	add    %ecx,%eax
 804cc2d:	8b 18                	mov    (%eax),%ebx
 804cc2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cc32:	89 de                	mov    %ebx,%esi
 804cc34:	88 c1                	mov    %al,%cl
 804cc36:	d3 ee                	shr    %cl,%esi
                                       LHALF(u[i - 1] << (HALF_BITS - d));
 804cc38:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc3b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
 804cc40:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cc47:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc4a:	01 c8                	add    %ecx,%eax
 804cc4c:	8b 18                	mov    (%eax),%ebx
 804cc4e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cc51:	b9 10 00 00 00       	mov    $0x10,%ecx
 804cc56:	29 c1                	sub    %eax,%ecx
 804cc58:	89 c8                	mov    %ecx,%eax
 804cc5a:	88 c1                	mov    %al,%cl
 804cc5c:	d3 e3                	shl    %cl,%ebx
 804cc5e:	89 d8                	mov    %ebx,%eax
 804cc60:	0f b7 c0             	movzwl %ax,%eax
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
                                u[i] = (u[i] >> d) |
 804cc63:	09 f0                	or     %esi,%eax
 804cc65:	89 02                	mov    %eax,(%edx)
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
 804cc67:	ff 4d c8             	decl   -0x38(%ebp)
 804cc6a:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc6d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804cc70:	7f 9d                	jg     804cc0f <__qdivrem+0x59d>
                                u[i] = (u[i] >> d) |
                                       LHALF(u[i - 1] << (HALF_BITS - d));
                        u[i] = 0;
 804cc72:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc75:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc7f:	01 d0                	add    %edx,%eax
 804cc81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                }
                tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
 804cc87:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804cc8a:	c1 e0 10             	shl    $0x10,%eax
 804cc8d:	89 c2                	mov    %eax,%edx
 804cc8f:	8b 45 98             	mov    -0x68(%ebp),%eax
 804cc92:	09 d0                	or     %edx,%eax
 804cc94:	89 45 a8             	mov    %eax,-0x58(%ebp)
                tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
 804cc97:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804cc9a:	c1 e0 10             	shl    $0x10,%eax
 804cc9d:	89 c2                	mov    %eax,%edx
 804cc9f:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804cca2:	09 d0                	or     %edx,%eax
 804cca4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                *arq = tmp.q;
 804cca7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804ccaa:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804ccad:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804ccb0:	89 01                	mov    %eax,(%ecx)
 804ccb2:	89 51 04             	mov    %edx,0x4(%ecx)
        }

        tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
 804ccb5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804ccbb:	c1 e0 10             	shl    $0x10,%eax
 804ccbe:	89 c2                	mov    %eax,%edx
 804ccc0:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804ccc6:	09 d0                	or     %edx,%eax
 804ccc8:	89 45 a8             	mov    %eax,-0x58(%ebp)
        tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
 804cccb:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804ccd1:	c1 e0 10             	shl    $0x10,%eax
 804ccd4:	89 c2                	mov    %eax,%edx
 804ccd6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 804ccdc:	09 d0                	or     %edx,%eax
 804ccde:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        return (tmp.q);
 804cce1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804cce4:	8b 55 a8             	mov    -0x58(%ebp),%edx
}
 804cce7:	81 c4 b8 00 00 00    	add    $0xb8,%esp
 804cced:	5b                   	pop    %ebx
 804ccee:	5e                   	pop    %esi
 804ccef:	5f                   	pop    %edi
 804ccf0:	5d                   	pop    %ebp
 804ccf1:	c3                   	ret    

0804ccf2 <__divdi3>:
/*
 * Divide two signed quads.
 * ??? if -1/2 should produce -1 on this machine, this code is wrong
 */
long long __divdi3(long long a, long long b)
{
 804ccf2:	55                   	push   %ebp
 804ccf3:	89 e5                	mov    %esp,%ebp
 804ccf5:	53                   	push   %ebx
 804ccf6:	83 ec 54             	sub    $0x54,%esp
 804ccf9:	e8 cb c2 ff ff       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804ccfe:	81 c1 02 23 00 00    	add    $0x2302,%ecx
 804cd04:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd07:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804cd0a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd0d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804cd10:	8b 45 10             	mov    0x10(%ebp),%eax
 804cd13:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cd16:	8b 45 14             	mov    0x14(%ebp),%eax
 804cd19:	89 45 cc             	mov    %eax,-0x34(%ebp)
        unsigned long long ua, ub, uq;
        int neg;

        if (a < 0)
 804cd1c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804cd20:	79 1c                	jns    804cd3e <__divdi3+0x4c>
                ua = -(unsigned long long)a, neg = 1;
 804cd22:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cd25:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804cd28:	f7 d8                	neg    %eax
 804cd2a:	83 d2 00             	adc    $0x0,%edx
 804cd2d:	f7 da                	neg    %edx
 804cd2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804cd32:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804cd35:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
 804cd3c:	eb 13                	jmp    804cd51 <__divdi3+0x5f>
        else
                ua = a, neg = 0;
 804cd3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cd41:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804cd44:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804cd47:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804cd4a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if (b < 0)
 804cd51:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804cd55:	79 19                	jns    804cd70 <__divdi3+0x7e>
                ub = -(unsigned long long)b, neg ^= 1;
 804cd57:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd5a:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804cd5d:	f7 d8                	neg    %eax
 804cd5f:	83 d2 00             	adc    $0x0,%edx
 804cd62:	f7 da                	neg    %edx
 804cd64:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804cd67:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804cd6a:	83 75 e4 01          	xorl   $0x1,-0x1c(%ebp)
 804cd6e:	eb 0c                	jmp    804cd7c <__divdi3+0x8a>
        else
                ub = b;
 804cd70:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd73:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804cd76:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804cd79:	89 55 ec             	mov    %edx,-0x14(%ebp)
        uq = __qdivrem(ua, ub, (unsigned long long *)0);
 804cd7c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804cd83:	00 
 804cd84:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cd87:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804cd8a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cd8e:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804cd92:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cd95:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804cd98:	89 04 24             	mov    %eax,(%esp)
 804cd9b:	89 54 24 04          	mov    %edx,0x4(%esp)
 804cd9f:	89 cb                	mov    %ecx,%ebx
 804cda1:	e8 cc f8 ff ff       	call   804c672 <__qdivrem>
 804cda6:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804cda9:	89 55 dc             	mov    %edx,-0x24(%ebp)
        return (neg ? -uq : uq);
 804cdac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804cdb0:	74 0f                	je     804cdc1 <__divdi3+0xcf>
 804cdb2:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cdb5:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804cdb8:	f7 d8                	neg    %eax
 804cdba:	83 d2 00             	adc    $0x0,%edx
 804cdbd:	f7 da                	neg    %edx
 804cdbf:	eb 06                	jmp    804cdc7 <__divdi3+0xd5>
 804cdc1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cdc4:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
 804cdc7:	83 c4 54             	add    $0x54,%esp
 804cdca:	5b                   	pop    %ebx
 804cdcb:	5d                   	pop    %ebp
 804cdcc:	c3                   	ret    

0804cdcd <__udivdi3>:
/*
 * Divide two unsigned quads.
 */
unsigned long long
__udivdi3(unsigned long long a, unsigned long long b)
{
 804cdcd:	55                   	push   %ebp
 804cdce:	89 e5                	mov    %esp,%ebp
 804cdd0:	53                   	push   %ebx
 804cdd1:	83 ec 34             	sub    $0x34,%esp
 804cdd4:	e8 f0 c1 ff ff       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804cdd9:	81 c1 27 22 00 00    	add    $0x2227,%ecx
 804cddf:	8b 45 08             	mov    0x8(%ebp),%eax
 804cde2:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804cde5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cde8:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804cdeb:	8b 45 10             	mov    0x10(%ebp),%eax
 804cdee:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804cdf1:	8b 45 14             	mov    0x14(%ebp),%eax
 804cdf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (__qdivrem(a, b, (unsigned long long *)0));
 804cdf7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804cdfe:	00 
 804cdff:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ce02:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ce05:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ce09:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ce0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ce10:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ce13:	89 04 24             	mov    %eax,(%esp)
 804ce16:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ce1a:	89 cb                	mov    %ecx,%ebx
 804ce1c:	e8 51 f8 ff ff       	call   804c672 <__qdivrem>
}
 804ce21:	83 c4 34             	add    $0x34,%esp
 804ce24:	5b                   	pop    %ebx
 804ce25:	5d                   	pop    %ebp
 804ce26:	c3                   	ret    

0804ce27 <__umoddi3>:
/*
 * Return remainder after dividing two unsigned quads.
 */
unsigned long long
__umoddi3(unsigned long long a, unsigned long long b)
{
 804ce27:	55                   	push   %ebp
 804ce28:	89 e5                	mov    %esp,%ebp
 804ce2a:	53                   	push   %ebx
 804ce2b:	83 ec 44             	sub    $0x44,%esp
 804ce2e:	e8 96 c1 ff ff       	call   8048fc9 <__x86.get_pc_thunk.cx>
 804ce33:	81 c1 cd 21 00 00    	add    $0x21cd,%ecx
 804ce39:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804ce3f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ce42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804ce45:	8b 45 10             	mov    0x10(%ebp),%eax
 804ce48:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804ce4b:	8b 45 14             	mov    0x14(%ebp),%eax
 804ce4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        unsigned long long r;

        (void)__qdivrem(a, b, &r);
 804ce51:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804ce54:	89 44 24 10          	mov    %eax,0x10(%esp)
 804ce58:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ce5b:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ce5e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ce62:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ce66:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804ce69:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ce6c:	89 04 24             	mov    %eax,(%esp)
 804ce6f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ce73:	89 cb                	mov    %ecx,%ebx
 804ce75:	e8 f8 f7 ff ff       	call   804c672 <__qdivrem>
        return (r);
 804ce7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ce7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
 804ce80:	83 c4 44             	add    $0x44,%esp
 804ce83:	5b                   	pop    %ebx
 804ce84:	5d                   	pop    %ebp
 804ce85:	c3                   	ret    
