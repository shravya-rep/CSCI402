
user/sbin/init.exec:     file format elf32-i386


Disassembly of section .text:

08048094 <open_tty>:
const char      *ttystr = "tty";
const char      *home = "/";
const char      *alldone = "init: no remaining processes\n";

static int open_tty(char *tty)
{
 8048094:	55                   	push   %ebp
 8048095:	89 e5                	mov    %esp,%ebp
 8048097:	83 ec 18             	sub    $0x18,%esp
        if (-1 == open(tty, O_RDONLY, 0)) {
 804809a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480a1:	00 
 80480a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 80480a9:	00 
 80480aa:	8b 45 08             	mov    0x8(%ebp),%eax
 80480ad:	89 04 24             	mov    %eax,(%esp)
 80480b0:	e8 87 07 00 00       	call   804883c <open>
 80480b5:	83 f8 ff             	cmp    $0xffffffff,%eax
 80480b8:	75 07                	jne    80480c1 <open_tty+0x2d>
                return -1;
 80480ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480bf:	eb 44                	jmp    8048105 <open_tty+0x71>
        } else if (-1 == open(tty, O_WRONLY, 0)) {
 80480c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80480c8:	00 
 80480c9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 80480d0:	00 
 80480d1:	8b 45 08             	mov    0x8(%ebp),%eax
 80480d4:	89 04 24             	mov    %eax,(%esp)
 80480d7:	e8 60 07 00 00       	call   804883c <open>
 80480dc:	83 f8 ff             	cmp    $0xffffffff,%eax
 80480df:	75 07                	jne    80480e8 <open_tty+0x54>
                return -1;
 80480e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480e6:	eb 1d                	jmp    8048105 <open_tty+0x71>
        } else if (2 != dup(1)) {
 80480e8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 80480ef:	e8 df 08 00 00       	call   80489d3 <dup>
 80480f4:	83 f8 02             	cmp    $0x2,%eax
 80480f7:	74 07                	je     8048100 <open_tty+0x6c>
                return -1;
 80480f9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80480fe:	eb 05                	jmp    8048105 <open_tty+0x71>
        } else {
                return 0;
 8048100:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 8048105:	c9                   	leave  
 8048106:	c3                   	ret    

08048107 <spawn_shell_on>:

static void spawn_shell_on(char *tty)
{
 8048107:	55                   	push   %ebp
 8048108:	89 e5                	mov    %esp,%ebp
 804810a:	83 ec 18             	sub    $0x18,%esp
        if (!fork()) {
 804810d:	e8 90 03 00 00       	call   80484a2 <fork>
 8048112:	85 c0                	test   %eax,%eax
 8048114:	0f 85 b3 00 00 00    	jne    80481cd <spawn_shell_on+0xc6>
                close(0);
 804811a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8048121:	e8 6d 08 00 00       	call   8048993 <close>
                close(1);
 8048126:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804812d:	e8 61 08 00 00       	call   8048993 <close>
                close(2);
 8048132:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8048139:	e8 55 08 00 00       	call   8048993 <close>
                if (-1 == open_tty(tty)) {
 804813e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048141:	89 04 24             	mov    %eax,(%esp)
 8048144:	e8 4b ff ff ff       	call   8048094 <open_tty>
 8048149:	83 f8 ff             	cmp    $0xffffffff,%eax
 804814c:	75 0c                	jne    804815a <spawn_shell_on+0x53>
                        exit(1);
 804814e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048155:	e8 04 04 00 00       	call   804855e <exit>
                }

                chdir(home);
 804815a:	a1 2c f0 04 08       	mov    0x804f02c,%eax
 804815f:	89 04 24             	mov    %eax,(%esp)
 8048162:	e8 dd 0a 00 00       	call   8048c44 <chdir>

                printf(hi,NULL);
 8048167:	a1 20 f0 04 08       	mov    0x804f020,%eax
 804816c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048173:	00 
 8048174:	89 04 24             	mov    %eax,(%esp)
 8048177:	e8 08 39 00 00       	call   804ba84 <printf>
                printf(tty,NULL);
 804817c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048183:	00 
 8048184:	8b 45 08             	mov    0x8(%ebp),%eax
 8048187:	89 04 24             	mov    %eax,(%esp)
 804818a:	e8 f5 38 00 00       	call   804ba84 <printf>
                printf("\n");
 804818f:	c7 04 24 c9 cf 04 08 	movl   $0x804cfc9,(%esp)
 8048196:	e8 e9 38 00 00       	call   804ba84 <printf>

                execve(sh, empty, empty);
 804819b:	a1 24 f0 04 08       	mov    0x804f024,%eax
 80481a0:	c7 44 24 08 80 f1 04 	movl   $0x804f180,0x8(%esp)
 80481a7:	08 
 80481a8:	c7 44 24 04 80 f1 04 	movl   $0x804f180,0x4(%esp)
 80481af:	08 
 80481b0:	89 04 24             	mov    %eax,(%esp)
 80481b3:	e8 24 0b 00 00       	call   8048cdc <execve>
                fprintf(stderr, "exec failed!\n");
 80481b8:	a1 50 f0 04 08       	mov    0x804f050,%eax
 80481bd:	c7 44 24 04 cb cf 04 	movl   $0x804cfcb,0x4(%esp)
 80481c4:	08 
 80481c5:	89 04 24             	mov    %eax,(%esp)
 80481c8:	e8 ee 38 00 00       	call   804babb <fprintf>
        }
}
 80481cd:	90                   	nop
 80481ce:	c9                   	leave  
 80481cf:	c3                   	ret    

080481d0 <main>:

int main(int argc, char **argv, char **envp)
{
 80481d0:	55                   	push   %ebp
 80481d1:	89 e5                	mov    %esp,%ebp
 80481d3:	83 e4 f0             	and    $0xfffffff0,%esp
 80481d6:	83 ec 50             	sub    $0x50,%esp
        int      devdir, ii;
        dirent_t d;
        int      status;

        for (ii = 0; ii < NFILES; ii++)
 80481d9:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
 80481e0:	00 
 80481e1:	eb 10                	jmp    80481f3 <main+0x23>
                close(ii);
 80481e3:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 80481e7:	89 04 24             	mov    %eax,(%esp)
 80481ea:	e8 a4 07 00 00       	call   8048993 <close>
{
        int      devdir, ii;
        dirent_t d;
        int      status;

        for (ii = 0; ii < NFILES; ii++)
 80481ef:	ff 44 24 4c          	incl   0x4c(%esp)
 80481f3:	83 7c 24 4c 1f       	cmpl   $0x1f,0x4c(%esp)
 80481f8:	7e e9                	jle    80481e3 <main+0x13>
                close(ii);
        ii  = ii;

        if (-1 == open_tty("/dev/tty0")) {
 80481fa:	c7 04 24 d9 cf 04 08 	movl   $0x804cfd9,(%esp)
 8048201:	e8 8e fe ff ff       	call   8048094 <open_tty>
 8048206:	83 f8 ff             	cmp    $0xffffffff,%eax
 8048209:	75 0c                	jne    8048217 <main+0x47>
                exit(1);
 804820b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048212:	e8 47 03 00 00       	call   804855e <exit>
        }

        chdir("/dev");
 8048217:	c7 04 24 e3 cf 04 08 	movl   $0x804cfe3,(%esp)
 804821e:	e8 21 0a 00 00       	call   8048c44 <chdir>

        devdir = open("/dev", O_RDONLY, 0);
 8048223:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804822a:	00 
 804822b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8048232:	00 
 8048233:	c7 04 24 e3 cf 04 08 	movl   $0x804cfe3,(%esp)
 804823a:	e8 fd 05 00 00       	call   804883c <open>
 804823f:	89 44 24 48          	mov    %eax,0x48(%esp)
        while (getdents(devdir, &d, sizeof(d)) > 0) {
 8048243:	eb 3e                	jmp    8048283 <main+0xb3>
                if (0 == strncmp(d.d_name, ttystr, strlen(ttystr))) {
 8048245:	a1 28 f0 04 08       	mov    0x804f028,%eax
 804824a:	89 04 24             	mov    %eax,(%esp)
 804824d:	e8 e8 10 00 00       	call   804933a <strlen>
 8048252:	89 c2                	mov    %eax,%edx
 8048254:	a1 28 f0 04 08       	mov    0x804f028,%eax
 8048259:	89 54 24 08          	mov    %edx,0x8(%esp)
 804825d:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048261:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 8048265:	83 c0 08             	add    $0x8,%eax
 8048268:	89 04 24             	mov    %eax,(%esp)
 804826b:	e8 f7 0e 00 00       	call   8049167 <strncmp>
 8048270:	85 c0                	test   %eax,%eax
 8048272:	75 0f                	jne    8048283 <main+0xb3>
                        spawn_shell_on(d.d_name);
 8048274:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 8048278:	83 c0 08             	add    $0x8,%eax
 804827b:	89 04 24             	mov    %eax,(%esp)
 804827e:	e8 84 fe ff ff       	call   8048107 <spawn_shell_on>
        }

        chdir("/dev");

        devdir = open("/dev", O_RDONLY, 0);
        while (getdents(devdir, &d, sizeof(d)) > 0) {
 8048283:	c7 44 24 08 28 00 00 	movl   $0x28,0x8(%esp)
 804828a:	00 
 804828b:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 804828f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048293:	8b 44 24 48          	mov    0x48(%esp),%eax
 8048297:	89 04 24             	mov    %eax,(%esp)
 804829a:	e8 9b 0c 00 00       	call   8048f3a <getdents>
 804829f:	85 c0                	test   %eax,%eax
 80482a1:	7f a2                	jg     8048245 <main+0x75>
                if (0 == strncmp(d.d_name, ttystr, strlen(ttystr))) {
                        spawn_shell_on(d.d_name);
                }
        }
        close(devdir);
 80482a3:	8b 44 24 48          	mov    0x48(%esp),%eax
 80482a7:	89 04 24             	mov    %eax,(%esp)
 80482aa:	e8 e4 06 00 00       	call   8048993 <close>

        int pid;
        while (0 <= (pid = wait(&status))) {
 80482af:	eb 1d                	jmp    80482ce <main+0xfe>
                if (EFAULT == status) {
 80482b1:	8b 44 24 18          	mov    0x18(%esp),%eax
 80482b5:	83 f8 0e             	cmp    $0xe,%eax
 80482b8:	75 14                	jne    80482ce <main+0xfe>
                        printf("process %i faulted\n", pid);
 80482ba:	8b 44 24 44          	mov    0x44(%esp),%eax
 80482be:	89 44 24 04          	mov    %eax,0x4(%esp)
 80482c2:	c7 04 24 e8 cf 04 08 	movl   $0x804cfe8,(%esp)
 80482c9:	e8 b6 37 00 00       	call   804ba84 <printf>
                }
        }
        close(devdir);

        int pid;
        while (0 <= (pid = wait(&status))) {
 80482ce:	8d 44 24 18          	lea    0x18(%esp),%eax
 80482d2:	89 04 24             	mov    %eax,(%esp)
 80482d5:	e8 13 03 00 00       	call   80485ed <wait>
 80482da:	89 44 24 44          	mov    %eax,0x44(%esp)
 80482de:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
 80482e3:	79 cc                	jns    80482b1 <main+0xe1>
                if (EFAULT == status) {
                        printf("process %i faulted\n", pid);
                }
        }

        if (ECHILD != errno) {
 80482e5:	a1 a4 f2 04 08       	mov    0x804f2a4,%eax
 80482ea:	83 f8 0a             	cmp    $0xa,%eax
 80482ed:	74 24                	je     8048313 <main+0x143>
                printf("error: wait: %s\n", strerror(errno));
 80482ef:	a1 a4 f2 04 08       	mov    0x804f2a4,%eax
 80482f4:	89 04 24             	mov    %eax,(%esp)
 80482f7:	e8 cc 12 00 00       	call   80495c8 <strerror>
 80482fc:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048300:	c7 04 24 fc cf 04 08 	movl   $0x804cffc,(%esp)
 8048307:	e8 78 37 00 00       	call   804ba84 <printf>
                return 1;
 804830c:	b8 01 00 00 00       	mov    $0x1,%eax
 8048311:	eb 1a                	jmp    804832d <main+0x15d>
        } else {
                printf(alldone,NULL);
 8048313:	a1 30 f0 04 08       	mov    0x804f030,%eax
 8048318:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804831f:	00 
 8048320:	89 04 24             	mov    %eax,(%esp)
 8048323:	e8 5c 37 00 00       	call   804ba84 <printf>
                return 0;
 8048328:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 804832d:	c9                   	leave  
 804832e:	c3                   	ret    

0804832f <__libc_static_entry>:
#ifndef __DYNAMIC__

.globl __libc_static_entry

__libc_static_entry:
	addl $4, %esp; /* Make sure when we overwrite dummy return address
 804832f:	83 c4 04             	add    $0x4,%esp
	                  with the correct one, so args will be in the right
	                  place when we call main */
	call main;
 8048332:	e8 99 fe ff ff       	call   80481d0 <main>
	push %eax; /* Argument to exit is return value from main */
 8048337:	50                   	push   %eax
	call exit;
 8048338:	e8 21 02 00 00       	call   804855e <exit>

0804833d <trap>:
#include "errno.h"

#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
 804833d:	55                   	push   %ebp
 804833e:	89 e5                	mov    %esp,%ebp
 8048340:	83 ec 10             	sub    $0x10,%esp
 8048343:	e8 7d 0d 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048348:	81 c1 b8 6c 00 00    	add    $0x6cb8,%ecx
        int ret;
        __asm__ volatile(
 804834e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048351:	8b 55 0c             	mov    0xc(%ebp),%edx
 8048354:	cd 2e                	int    $0x2e
 8048356:	89 45 fc             	mov    %eax,-0x4(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048359:	b8 27 00 00 00       	mov    $0x27,%eax
 804835e:	cd 2e                	int    $0x2e
 8048360:	89 c2                	mov    %eax,%edx
 8048362:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048368:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804836a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804836d:	c9                   	leave  
 804836e:	c3                   	ret    

0804836f <sbrk>:
static void     (*atexit_func[MAX_EXIT_HANDLERS])();
static int      atexit_handlers = 0;


void *sbrk(intptr_t incr)
{
 804836f:	55                   	push   %ebp
 8048370:	89 e5                	mov    %esp,%ebp
 8048372:	53                   	push   %ebx
 8048373:	83 ec 24             	sub    $0x24,%esp
 8048376:	e8 4a 0d 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804837b:	81 c1 85 6c 00 00    	add    $0x6c85,%ecx
        uintptr_t oldbrk;

        /* If we don't have a saved break, find it from the kernel */
        if (!__curbrk) {
 8048381:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
 8048387:	85 c0                	test   %eax,%eax
 8048389:	75 44                	jne    80483cf <sbrk+0x60>
 804838b:	c7 45 f0 2c 00 00 00 	movl   $0x2c,-0x10(%ebp)
 8048392:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048399:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804839c:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804839f:	cd 2e                	int    $0x2e
 80483a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80483a4:	b8 27 00 00 00       	mov    $0x27,%eax
 80483a9:	cd 2e                	int    $0x2e
 80483ab:	89 c2                	mov    %eax,%edx
 80483ad:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80483b3:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80483b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
                if (0 > (long)(__curbrk = (void *) trap(SYS_brk, (uint32_t) NULL))) {
 80483b8:	89 81 a0 01 00 00    	mov    %eax,0x1a0(%ecx)
 80483be:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
 80483c4:	85 c0                	test   %eax,%eax
 80483c6:	79 07                	jns    80483cf <sbrk+0x60>
                        return (void *) -1;
 80483c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80483cd:	eb 63                	jmp    8048432 <sbrk+0xc3>
                }
        }

        oldbrk = (uintptr_t) __curbrk;
 80483cf:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
 80483d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /* Increment or decrement the saved break */

        if (incr < 0) {
 80483d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 80483dc:	79 2e                	jns    804840c <sbrk+0x9d>
                if ((uintptr_t) - incr > oldbrk) {
 80483de:	8b 45 08             	mov    0x8(%ebp),%eax
 80483e1:	f7 d8                	neg    %eax
 80483e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 80483e6:	76 07                	jbe    80483ef <sbrk+0x80>
                        return (void *) -1;
 80483e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80483ed:	eb 43                	jmp    8048432 <sbrk+0xc3>
                } else if (brk((void *)(oldbrk - (uintptr_t) - incr)) < 0) {
 80483ef:	8b 55 08             	mov    0x8(%ebp),%edx
 80483f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80483f5:	01 d0                	add    %edx,%eax
 80483f7:	89 04 24             	mov    %eax,(%esp)
 80483fa:	89 cb                	mov    %ecx,%ebx
 80483fc:	e8 37 00 00 00       	call   8048438 <brk>
 8048401:	85 c0                	test   %eax,%eax
 8048403:	79 2a                	jns    804842f <sbrk+0xc0>
                        return (void *) -1;
 8048405:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804840a:	eb 26                	jmp    8048432 <sbrk+0xc3>
                }
        } else if (incr > 0) {
 804840c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8048410:	7e 1d                	jle    804842f <sbrk+0xc0>
                if (brk((void *)(oldbrk + (uintptr_t) incr)) < 0) {
 8048412:	8b 55 08             	mov    0x8(%ebp),%edx
 8048415:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048418:	01 d0                	add    %edx,%eax
 804841a:	89 04 24             	mov    %eax,(%esp)
 804841d:	89 cb                	mov    %ecx,%ebx
 804841f:	e8 14 00 00 00       	call   8048438 <brk>
 8048424:	85 c0                	test   %eax,%eax
 8048426:	79 07                	jns    804842f <sbrk+0xc0>
                        return (void *) -1;
 8048428:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804842d:	eb 03                	jmp    8048432 <sbrk+0xc3>
                }
        }
        return (void *) oldbrk;
 804842f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048432:	83 c4 24             	add    $0x24,%esp
 8048435:	5b                   	pop    %ebx
 8048436:	5d                   	pop    %ebp
 8048437:	c3                   	ret    

08048438 <brk>:

int brk(void *addr)
{
 8048438:	55                   	push   %ebp
 8048439:	89 e5                	mov    %esp,%ebp
 804843b:	83 ec 10             	sub    $0x10,%esp
 804843e:	e8 82 0c 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048443:	81 c1 bd 6b 00 00    	add    $0x6bbd,%ecx
        if (NULL == addr)
 8048449:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804844d:	75 07                	jne    8048456 <brk+0x1e>
                return -1;
 804844f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048454:	eb 4a                	jmp    80484a0 <brk+0x68>
        void *newbrk = (void *) trap(SYS_brk, (uint32_t) addr);
 8048456:	8b 45 08             	mov    0x8(%ebp),%eax
 8048459:	c7 45 f8 2c 00 00 00 	movl   $0x2c,-0x8(%ebp)
 8048460:	89 45 f4             	mov    %eax,-0xc(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048463:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8048466:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048469:	cd 2e                	int    $0x2e
 804846b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804846e:	b8 27 00 00 00       	mov    $0x27,%eax
 8048473:	cd 2e                	int    $0x2e
 8048475:	89 c2                	mov    %eax,%edx
 8048477:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 804847d:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804847f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048482:	89 45 fc             	mov    %eax,-0x4(%ebp)
        if (newbrk == (void *) -1)
 8048485:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
 8048489:	75 07                	jne    8048492 <brk+0x5a>
                return -1;
 804848b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8048490:	eb 0e                	jmp    80484a0 <brk+0x68>
        __curbrk = newbrk;
 8048492:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048495:	89 81 a0 01 00 00    	mov    %eax,0x1a0(%ecx)
        return 0;
 804849b:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80484a0:	c9                   	leave  
 80484a1:	c3                   	ret    

080484a2 <fork>:

int fork(void)
{
 80484a2:	55                   	push   %ebp
 80484a3:	89 e5                	mov    %esp,%ebp
 80484a5:	83 ec 10             	sub    $0x10,%esp
 80484a8:	e8 18 0c 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80484ad:	81 c1 53 6b 00 00    	add    $0x6b53,%ecx
 80484b3:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
 80484ba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80484c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80484c4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80484c7:	cd 2e                	int    $0x2e
 80484c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80484cc:	b8 27 00 00 00       	mov    $0x27,%eax
 80484d1:	cd 2e                	int    $0x2e
 80484d3:	89 c2                	mov    %eax,%edx
 80484d5:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80484db:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80484dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_fork, 0);
 80484e0:	90                   	nop
}
 80484e1:	c9                   	leave  
 80484e2:	c3                   	ret    

080484e3 <atexit>:

int atexit(void (*func)(void))
{
 80484e3:	55                   	push   %ebp
 80484e4:	89 e5                	mov    %esp,%ebp
 80484e6:	e8 d6 0b 00 00       	call   80490c1 <__x86.get_pc_thunk.ax>
 80484eb:	05 15 6b 00 00       	add    $0x6b15,%eax
        if (atexit_handlers < MAX_EXIT_HANDLERS) {
 80484f0:	8b 90 40 02 00 00    	mov    0x240(%eax),%edx
 80484f6:	83 fa 1f             	cmp    $0x1f,%edx
 80484f9:	7f 20                	jg     804851b <atexit+0x38>
                atexit_func[atexit_handlers++] = func;
 80484fb:	8b 90 40 02 00 00    	mov    0x240(%eax),%edx
 8048501:	8d 4a 01             	lea    0x1(%edx),%ecx
 8048504:	89 88 40 02 00 00    	mov    %ecx,0x240(%eax)
 804850a:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804850d:	89 8c 90 c0 01 00 00 	mov    %ecx,0x1c0(%eax,%edx,4)
                return 0;
 8048514:	b8 00 00 00 00       	mov    $0x0,%eax
 8048519:	eb 05                	jmp    8048520 <atexit+0x3d>
        }

        return 1;
 804851b:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8048520:	5d                   	pop    %ebp
 8048521:	c3                   	ret    

08048522 <_exit>:

void _exit(int status)
{
 8048522:	55                   	push   %ebp
 8048523:	89 e5                	mov    %esp,%ebp
 8048525:	83 ec 10             	sub    $0x10,%esp
 8048528:	e8 98 0b 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804852d:	81 c1 d3 6a 00 00    	add    $0x6ad3,%ecx
        trap(SYS_exit, (uint32_t) status);
 8048533:	8b 45 08             	mov    0x8(%ebp),%eax
 8048536:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
 804853d:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048540:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048543:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048546:	cd 2e                	int    $0x2e
 8048548:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804854b:	b8 27 00 00 00       	mov    $0x27,%eax
 8048550:	cd 2e                	int    $0x2e
 8048552:	89 c2                	mov    %eax,%edx
 8048554:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 804855a:	89 10                	mov    %edx,(%eax)

        /* this keeps gcc from warning us about exit returning, because it
         * expects exit not to. We never actually get here. */
        for (;;);
 804855c:	eb fe                	jmp    804855c <_exit+0x3a>

0804855e <exit>:
}

void exit(int status)
{
 804855e:	55                   	push   %ebp
 804855f:	89 e5                	mov    %esp,%ebp
 8048561:	53                   	push   %ebx
 8048562:	83 ec 14             	sub    $0x14,%esp
 8048565:	e8 5f 0b 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 804856a:	81 c3 96 6a 00 00    	add    $0x6a96,%ebx
        while (atexit_handlers--) {
 8048570:	eb 0f                	jmp    8048581 <exit+0x23>
                atexit_func[atexit_handlers]();
 8048572:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 8048578:	8b 84 83 c0 01 00 00 	mov    0x1c0(%ebx,%eax,4),%eax
 804857f:	ff d0                	call   *%eax
        for (;;);
}

void exit(int status)
{
        while (atexit_handlers--) {
 8048581:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 8048587:	8d 50 ff             	lea    -0x1(%eax),%edx
 804858a:	89 93 40 02 00 00    	mov    %edx,0x240(%ebx)
 8048590:	85 c0                	test   %eax,%eax
 8048592:	75 de                	jne    8048572 <exit+0x14>
                atexit_func[atexit_handlers]();
        }

        _exit(status);
 8048594:	8b 45 08             	mov    0x8(%ebp),%eax
 8048597:	89 04 24             	mov    %eax,(%esp)
 804859a:	e8 83 ff ff ff       	call   8048522 <_exit>
        exit(status); /* gcc doesn't realize that _exit() exits */
 804859f:	8b 45 08             	mov    0x8(%ebp),%eax
 80485a2:	89 04 24             	mov    %eax,(%esp)
 80485a5:	e8 b4 ff ff ff       	call   804855e <exit>
}
 80485aa:	90                   	nop
 80485ab:	83 c4 14             	add    $0x14,%esp
 80485ae:	5b                   	pop    %ebx
 80485af:	5d                   	pop    %ebp
 80485b0:	c3                   	ret    

080485b1 <yield>:

void yield(void)
{
 80485b1:	55                   	push   %ebp
 80485b2:	89 e5                	mov    %esp,%ebp
 80485b4:	53                   	push   %ebx
 80485b5:	83 ec 14             	sub    $0x14,%esp
 80485b8:	e8 0c 0b 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 80485bd:	81 c3 43 6a 00 00    	add    $0x6a43,%ebx
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80485c3:	e8 da fe ff ff       	call   80484a2 <fork>
 80485c8:	85 c0                	test   %eax,%eax
 80485ca:	74 0e                	je     80485da <yield+0x29>
 80485cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80485d3:	e8 15 00 00 00       	call   80485ed <wait>
}
 80485d8:	eb 0c                	jmp    80485e6 <yield+0x35>
void yield(void)
{
        /* Due to a Bochs bug, the yield syscall itself is highly unyielding
         * (for instance, it's impossible to type while a process is in a yield
         * loop. This is good enough. */
        (fork() ? wait(NULL) : exit(0));
 80485da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80485e1:	e8 78 ff ff ff       	call   804855e <exit>
}
 80485e6:	90                   	nop
 80485e7:	83 c4 14             	add    $0x14,%esp
 80485ea:	5b                   	pop    %ebx
 80485eb:	5d                   	pop    %ebp
 80485ec:	c3                   	ret    

080485ed <wait>:

pid_t wait(int *status)
{
 80485ed:	55                   	push   %ebp
 80485ee:	89 e5                	mov    %esp,%ebp
 80485f0:	83 ec 20             	sub    $0x20,%esp
 80485f3:	e8 cd 0a 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80485f8:	81 c1 08 6a 00 00    	add    $0x6a08,%ecx
        waitpid_args_t args;

        args.wpa_pid = -1;
 80485fe:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
        args.wpa_options = 0;
 8048605:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        args.wpa_status = status;
 804860c:	8b 45 08             	mov    0x8(%ebp),%eax
 804860f:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8048612:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048615:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 804861c:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804861f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048622:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048625:	cd 2e                	int    $0x2e
 8048627:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804862a:	b8 27 00 00 00       	mov    $0x27,%eax
 804862f:	cd 2e                	int    $0x2e
 8048631:	89 c2                	mov    %eax,%edx
 8048633:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048639:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804863b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804863e:	c9                   	leave  
 804863f:	c3                   	ret    

08048640 <waitpid>:

pid_t waitpid(pid_t pid, int options, int *status)
{
 8048640:	55                   	push   %ebp
 8048641:	89 e5                	mov    %esp,%ebp
 8048643:	83 ec 20             	sub    $0x20,%esp
 8048646:	e8 7a 0a 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804864b:	81 c1 b5 69 00 00    	add    $0x69b5,%ecx
        waitpid_args_t args;

        args.wpa_pid = pid;
 8048651:	8b 45 08             	mov    0x8(%ebp),%eax
 8048654:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.wpa_options = options;
 8048657:	8b 45 0c             	mov    0xc(%ebp),%eax
 804865a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.wpa_status = status;
 804865d:	8b 45 10             	mov    0x10(%ebp),%eax
 8048660:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_waitpid, (uint32_t) &args);
 8048663:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048666:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)
 804866d:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048670:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048673:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048676:	cd 2e                	int    $0x2e
 8048678:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804867b:	b8 27 00 00 00       	mov    $0x27,%eax
 8048680:	cd 2e                	int    $0x2e
 8048682:	89 c2                	mov    %eax,%edx
 8048684:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 804868a:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804868c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804868f:	c9                   	leave  
 8048690:	c3                   	ret    

08048691 <thr_exit>:

void thr_exit(int status)
{
 8048691:	55                   	push   %ebp
 8048692:	89 e5                	mov    %esp,%ebp
 8048694:	83 ec 10             	sub    $0x10,%esp
 8048697:	e8 29 0a 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804869c:	81 c1 64 69 00 00    	add    $0x6964,%ecx
        trap(SYS_thr_exit, (uint32_t) status);
 80486a2:	8b 45 08             	mov    0x8(%ebp),%eax
 80486a5:	c7 45 fc 1f 00 00 00 	movl   $0x1f,-0x4(%ebp)
 80486ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80486af:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80486b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80486b5:	cd 2e                	int    $0x2e
 80486b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486ba:	b8 27 00 00 00       	mov    $0x27,%eax
 80486bf:	cd 2e                	int    $0x2e
 80486c1:	89 c2                	mov    %eax,%edx
 80486c3:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80486c9:	89 10                	mov    %edx,(%eax)
}
 80486cb:	90                   	nop
 80486cc:	c9                   	leave  
 80486cd:	c3                   	ret    

080486ce <getpid>:

pid_t getpid(void)
{
 80486ce:	55                   	push   %ebp
 80486cf:	89 e5                	mov    %esp,%ebp
 80486d1:	83 ec 10             	sub    $0x10,%esp
 80486d4:	e8 ec 09 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80486d9:	81 c1 27 69 00 00    	add    $0x6927,%ecx
 80486df:	c7 45 fc 23 00 00 00 	movl   $0x23,-0x4(%ebp)
 80486e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80486ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80486f0:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80486f3:	cd 2e                	int    $0x2e
 80486f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80486f8:	b8 27 00 00 00       	mov    $0x27,%eax
 80486fd:	cd 2e                	int    $0x2e
 80486ff:	89 c2                	mov    %eax,%edx
 8048701:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048707:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048709:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_getpid, 0);
 804870c:	90                   	nop
}
 804870d:	c9                   	leave  
 804870e:	c3                   	ret    

0804870f <halt>:

int halt(void)
{
 804870f:	55                   	push   %ebp
 8048710:	89 e5                	mov    %esp,%ebp
 8048712:	83 ec 10             	sub    $0x10,%esp
 8048715:	e8 ab 09 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804871a:	81 c1 e6 68 00 00    	add    $0x68e6,%ecx
 8048720:	c7 45 fc 28 00 00 00 	movl   $0x28,-0x4(%ebp)
 8048727:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804872e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048731:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048734:	cd 2e                	int    $0x2e
 8048736:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048739:	b8 27 00 00 00       	mov    $0x27,%eax
 804873e:	cd 2e                	int    $0x2e
 8048740:	89 c2                	mov    %eax,%edx
 8048742:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048748:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804874a:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_halt, 0);
 804874d:	90                   	nop
}
 804874e:	c9                   	leave  
 804874f:	c3                   	ret    

08048750 <mmap>:

void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off)
{
 8048750:	55                   	push   %ebp
 8048751:	89 e5                	mov    %esp,%ebp
 8048753:	83 ec 30             	sub    $0x30,%esp
 8048756:	e8 6a 09 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804875b:	81 c1 a5 68 00 00    	add    $0x68a5,%ecx
        mmap_args_t args;

        args.mma_addr = addr;
 8048761:	8b 45 08             	mov    0x8(%ebp),%eax
 8048764:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.mma_len = len;
 8048767:	8b 45 0c             	mov    0xc(%ebp),%eax
 804876a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mma_prot = prot;
 804876d:	8b 45 10             	mov    0x10(%ebp),%eax
 8048770:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mma_flags = flags;
 8048773:	8b 45 14             	mov    0x14(%ebp),%eax
 8048776:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.mma_fd = fd;
 8048779:	8b 45 18             	mov    0x18(%ebp),%eax
 804877c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.mma_off = off;
 804877f:	8b 45 1c             	mov    0x1c(%ebp),%eax
 8048782:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return (void *) trap(SYS_mmap, (uint32_t) &args);
 8048785:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048788:	c7 45 fc 18 00 00 00 	movl   $0x18,-0x4(%ebp)
 804878f:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048792:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048795:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048798:	cd 2e                	int    $0x2e
 804879a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804879d:	b8 27 00 00 00       	mov    $0x27,%eax
 80487a2:	cd 2e                	int    $0x2e
 80487a4:	89 c2                	mov    %eax,%edx
 80487a6:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80487ac:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80487ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80487b1:	c9                   	leave  
 80487b2:	c3                   	ret    

080487b3 <munmap>:

int munmap(void *addr, size_t len)
{
 80487b3:	55                   	push   %ebp
 80487b4:	89 e5                	mov    %esp,%ebp
 80487b6:	83 ec 20             	sub    $0x20,%esp
 80487b9:	e8 07 09 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80487be:	81 c1 42 68 00 00    	add    $0x6842,%ecx
        munmap_args_t args;

        args.addr = addr;
 80487c4:	8b 45 08             	mov    0x8(%ebp),%eax
 80487c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.len = len;
 80487ca:	8b 45 0c             	mov    0xc(%ebp),%eax
 80487cd:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_munmap, (uint32_t) &args);
 80487d0:	8d 45 ec             	lea    -0x14(%ebp),%eax
 80487d3:	c7 45 fc 1a 00 00 00 	movl   $0x1a,-0x4(%ebp)
 80487da:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80487dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80487e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80487e3:	cd 2e                	int    $0x2e
 80487e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80487e8:	b8 27 00 00 00       	mov    $0x27,%eax
 80487ed:	cd 2e                	int    $0x2e
 80487ef:	89 c2                	mov    %eax,%edx
 80487f1:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80487f7:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80487f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80487fc:	c9                   	leave  
 80487fd:	c3                   	ret    

080487fe <sync>:

void sync(void)
{
 80487fe:	55                   	push   %ebp
 80487ff:	89 e5                	mov    %esp,%ebp
 8048801:	83 ec 10             	sub    $0x10,%esp
 8048804:	e8 bc 08 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048809:	81 c1 f7 67 00 00    	add    $0x67f7,%ecx
 804880f:	c7 45 fc 0f 00 00 00 	movl   $0xf,-0x4(%ebp)
 8048816:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804881d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048820:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048823:	cd 2e                	int    $0x2e
 8048825:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048828:	b8 27 00 00 00       	mov    $0x27,%eax
 804882d:	cd 2e                	int    $0x2e
 804882f:	89 c2                	mov    %eax,%edx
 8048831:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048837:	89 10                	mov    %edx,(%eax)
        trap(SYS_sync, 0);
}
 8048839:	90                   	nop
 804883a:	c9                   	leave  
 804883b:	c3                   	ret    

0804883c <open>:

int open(const char *filename, int flags, int mode)
{
 804883c:	55                   	push   %ebp
 804883d:	89 e5                	mov    %esp,%ebp
 804883f:	53                   	push   %ebx
 8048840:	83 ec 34             	sub    $0x34,%esp
 8048843:	e8 81 08 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048848:	81 c3 b8 67 00 00    	add    $0x67b8,%ebx
        open_args_t args;

        args.filename.as_len = strlen(filename);
 804884e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048851:	89 04 24             	mov    %eax,(%esp)
 8048854:	e8 e1 0a 00 00       	call   804933a <strlen>
 8048859:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.filename.as_str = filename;
 804885c:	8b 45 08             	mov    0x8(%ebp),%eax
 804885f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.flags = flags;
 8048862:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048865:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.mode = mode;
 8048868:	8b 45 10             	mov    0x10(%ebp),%eax
 804886b:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_open, (uint32_t) &args);
 804886e:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048871:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
 8048878:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804887b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804887e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048881:	cd 2e                	int    $0x2e
 8048883:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048886:	b8 27 00 00 00       	mov    $0x27,%eax
 804888b:	cd 2e                	int    $0x2e
 804888d:	89 c2                	mov    %eax,%edx
 804888f:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048895:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048897:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 804889a:	83 c4 34             	add    $0x34,%esp
 804889d:	5b                   	pop    %ebx
 804889e:	5d                   	pop    %ebp
 804889f:	c3                   	ret    

080488a0 <lseek>:

off_t lseek(int fd, off_t offset, int whence)
{
 80488a0:	55                   	push   %ebp
 80488a1:	89 e5                	mov    %esp,%ebp
 80488a3:	83 ec 20             	sub    $0x20,%esp
 80488a6:	e8 1a 08 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80488ab:	81 c1 55 67 00 00    	add    $0x6755,%ecx
        lseek_args_t args;

        args.fd = fd;
 80488b1:	8b 45 08             	mov    0x8(%ebp),%eax
 80488b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.offset = offset;
 80488b7:	8b 45 0c             	mov    0xc(%ebp),%eax
 80488ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.whence = whence;
 80488bd:	8b 45 10             	mov    0x10(%ebp),%eax
 80488c0:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_lseek, (uint32_t) &args);
 80488c3:	8d 45 e8             	lea    -0x18(%ebp),%eax
 80488c6:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%ebp)
 80488cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80488d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80488d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80488d6:	cd 2e                	int    $0x2e
 80488d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80488db:	b8 27 00 00 00       	mov    $0x27,%eax
 80488e0:	cd 2e                	int    $0x2e
 80488e2:	89 c2                	mov    %eax,%edx
 80488e4:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80488ea:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80488ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 80488ef:	c9                   	leave  
 80488f0:	c3                   	ret    

080488f1 <read>:


int read(int fd, void *buf, size_t nbytes)
{
 80488f1:	55                   	push   %ebp
 80488f2:	89 e5                	mov    %esp,%ebp
 80488f4:	83 ec 20             	sub    $0x20,%esp
 80488f7:	e8 c9 07 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80488fc:	81 c1 04 67 00 00    	add    $0x6704,%ecx
        read_args_t args;

        args.fd = fd;
 8048902:	8b 45 08             	mov    0x8(%ebp),%eax
 8048905:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = buf;
 8048908:	8b 45 0c             	mov    0xc(%ebp),%eax
 804890b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 804890e:	8b 45 10             	mov    0x10(%ebp),%eax
 8048911:	89 45 f0             	mov    %eax,-0x10(%ebp)


        return trap(SYS_read, (uint32_t) &args);
 8048914:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048917:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
 804891e:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048921:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048924:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048927:	cd 2e                	int    $0x2e
 8048929:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804892c:	b8 27 00 00 00       	mov    $0x27,%eax
 8048931:	cd 2e                	int    $0x2e
 8048933:	89 c2                	mov    %eax,%edx
 8048935:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 804893b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804893d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048940:	c9                   	leave  
 8048941:	c3                   	ret    

08048942 <write>:

int write(int fd, const void *buf, size_t nbytes)
{
 8048942:	55                   	push   %ebp
 8048943:	89 e5                	mov    %esp,%ebp
 8048945:	83 ec 20             	sub    $0x20,%esp
 8048948:	e8 78 07 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804894d:	81 c1 b3 66 00 00    	add    $0x66b3,%ecx
        write_args_t args;

        args.fd = fd;
 8048953:	8b 45 08             	mov    0x8(%ebp),%eax
 8048956:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.buf = (void *) buf;
 8048959:	8b 45 0c             	mov    0xc(%ebp),%eax
 804895c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nbytes = nbytes;
 804895f:	8b 45 10             	mov    0x10(%ebp),%eax
 8048962:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_write, (uint32_t) &args);
 8048965:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048968:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
 804896f:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048972:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048975:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048978:	cd 2e                	int    $0x2e
 804897a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 804897d:	b8 27 00 00 00       	mov    $0x27,%eax
 8048982:	cd 2e                	int    $0x2e
 8048984:	89 c2                	mov    %eax,%edx
 8048986:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 804898c:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 804898e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048991:	c9                   	leave  
 8048992:	c3                   	ret    

08048993 <close>:

int close(int fd)
{
 8048993:	55                   	push   %ebp
 8048994:	89 e5                	mov    %esp,%ebp
 8048996:	83 ec 10             	sub    $0x10,%esp
 8048999:	e8 27 07 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 804899e:	81 c1 62 66 00 00    	add    $0x6662,%ecx
        return trap(SYS_close, (uint32_t) fd);
 80489a4:	8b 45 08             	mov    0x8(%ebp),%eax
 80489a7:	c7 45 fc 06 00 00 00 	movl   $0x6,-0x4(%ebp)
 80489ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80489b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80489b4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80489b7:	cd 2e                	int    $0x2e
 80489b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489bc:	b8 27 00 00 00       	mov    $0x27,%eax
 80489c1:	cd 2e                	int    $0x2e
 80489c3:	89 c2                	mov    %eax,%edx
 80489c5:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80489cb:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80489cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80489d0:	90                   	nop
}
 80489d1:	c9                   	leave  
 80489d2:	c3                   	ret    

080489d3 <dup>:

int dup(int fd)
{
 80489d3:	55                   	push   %ebp
 80489d4:	89 e5                	mov    %esp,%ebp
 80489d6:	83 ec 10             	sub    $0x10,%esp
 80489d9:	e8 e7 06 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 80489de:	81 c1 22 66 00 00    	add    $0x6622,%ecx
        return trap(SYS_dup, (uint32_t) fd);
 80489e4:	8b 45 08             	mov    0x8(%ebp),%eax
 80489e7:	c7 45 fc 11 00 00 00 	movl   $0x11,-0x4(%ebp)
 80489ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 80489f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80489f4:	8b 55 f8             	mov    -0x8(%ebp),%edx
 80489f7:	cd 2e                	int    $0x2e
 80489f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80489fc:	b8 27 00 00 00       	mov    $0x27,%eax
 8048a01:	cd 2e                	int    $0x2e
 8048a03:	89 c2                	mov    %eax,%edx
 8048a05:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048a0b:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a10:	90                   	nop
}
 8048a11:	c9                   	leave  
 8048a12:	c3                   	ret    

08048a13 <dup2>:

int dup2(int ofd, int nfd)
{
 8048a13:	55                   	push   %ebp
 8048a14:	89 e5                	mov    %esp,%ebp
 8048a16:	83 ec 20             	sub    $0x20,%esp
 8048a19:	e8 a7 06 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048a1e:	81 c1 e2 65 00 00    	add    $0x65e2,%ecx
        dup2_args_t args;

        args.ofd = ofd;
 8048a24:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a27:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.nfd = nfd;
 8048a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a2d:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_dup2, (uint32_t) &args);
 8048a30:	8d 45 ec             	lea    -0x14(%ebp),%eax
 8048a33:	c7 45 fc 2b 00 00 00 	movl   $0x2b,-0x4(%ebp)
 8048a3a:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048a40:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048a43:	cd 2e                	int    $0x2e
 8048a45:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048a48:	b8 27 00 00 00       	mov    $0x27,%eax
 8048a4d:	cd 2e                	int    $0x2e
 8048a4f:	89 c2                	mov    %eax,%edx
 8048a51:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048a57:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048a5c:	c9                   	leave  
 8048a5d:	c3                   	ret    

08048a5e <mkdir>:

int mkdir(const char *path, int mode)
{
 8048a5e:	55                   	push   %ebp
 8048a5f:	89 e5                	mov    %esp,%ebp
 8048a61:	53                   	push   %ebx
 8048a62:	83 ec 34             	sub    $0x34,%esp
 8048a65:	e8 5f 06 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048a6a:	81 c3 96 65 00 00    	add    $0x6596,%ebx
        mkdir_args_t args;

        args.path.as_len = strlen(path);
 8048a70:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a73:	89 04 24             	mov    %eax,(%esp)
 8048a76:	e8 bf 08 00 00       	call   804933a <strlen>
 8048a7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048a7e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048a81:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.mode = mode;
 8048a84:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048a87:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_mkdir, (uint32_t) &args);
 8048a8a:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048a8d:	c7 45 f4 16 00 00 00 	movl   $0x16,-0xc(%ebp)
 8048a94:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048a97:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048a9a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048a9d:	cd 2e                	int    $0x2e
 8048a9f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048aa2:	b8 27 00 00 00       	mov    $0x27,%eax
 8048aa7:	cd 2e                	int    $0x2e
 8048aa9:	89 c2                	mov    %eax,%edx
 8048aab:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048ab1:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048ab3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048ab6:	83 c4 34             	add    $0x34,%esp
 8048ab9:	5b                   	pop    %ebx
 8048aba:	5d                   	pop    %ebp
 8048abb:	c3                   	ret    

08048abc <rmdir>:

int rmdir(const char *path)
{
 8048abc:	55                   	push   %ebp
 8048abd:	89 e5                	mov    %esp,%ebp
 8048abf:	53                   	push   %ebx
 8048ac0:	83 ec 34             	sub    $0x34,%esp
 8048ac3:	e8 01 06 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048ac8:	81 c3 38 65 00 00    	add    $0x6538,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048ace:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ad1:	89 04 24             	mov    %eax,(%esp)
 8048ad4:	e8 61 08 00 00       	call   804933a <strlen>
 8048ad9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048adc:	8b 45 08             	mov    0x8(%ebp),%eax
 8048adf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_rmdir, (uint32_t) &args);
 8048ae2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048ae5:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)
 8048aec:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048aef:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048af2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048af5:	cd 2e                	int    $0x2e
 8048af7:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048afa:	b8 27 00 00 00       	mov    $0x27,%eax
 8048aff:	cd 2e                	int    $0x2e
 8048b01:	89 c2                	mov    %eax,%edx
 8048b03:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048b09:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048b0e:	83 c4 34             	add    $0x34,%esp
 8048b11:	5b                   	pop    %ebx
 8048b12:	5d                   	pop    %ebp
 8048b13:	c3                   	ret    

08048b14 <unlink>:

int unlink(const char *path)
{
 8048b14:	55                   	push   %ebp
 8048b15:	89 e5                	mov    %esp,%ebp
 8048b17:	53                   	push   %ebx
 8048b18:	83 ec 34             	sub    $0x34,%esp
 8048b1b:	e8 a9 05 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048b20:	81 c3 e0 64 00 00    	add    $0x64e0,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048b26:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b29:	89 04 24             	mov    %eax,(%esp)
 8048b2c:	e8 09 08 00 00       	call   804933a <strlen>
 8048b31:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048b34:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_unlink, (uint32_t) &args);
 8048b3a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048b3d:	c7 45 f4 09 00 00 00 	movl   $0x9,-0xc(%ebp)
 8048b44:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048b4a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048b4d:	cd 2e                	int    $0x2e
 8048b4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048b52:	b8 27 00 00 00       	mov    $0x27,%eax
 8048b57:	cd 2e                	int    $0x2e
 8048b59:	89 c2                	mov    %eax,%edx
 8048b5b:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048b61:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048b63:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048b66:	83 c4 34             	add    $0x34,%esp
 8048b69:	5b                   	pop    %ebx
 8048b6a:	5d                   	pop    %ebp
 8048b6b:	c3                   	ret    

08048b6c <link>:

int link(const char *from, const char *to)
{
 8048b6c:	55                   	push   %ebp
 8048b6d:	89 e5                	mov    %esp,%ebp
 8048b6f:	53                   	push   %ebx
 8048b70:	83 ec 34             	sub    $0x34,%esp
 8048b73:	e8 51 05 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048b78:	81 c3 88 64 00 00    	add    $0x6488,%ebx
        link_args_t args;

        args.from.as_len = strlen(from);
 8048b7e:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b81:	89 04 24             	mov    %eax,(%esp)
 8048b84:	e8 b1 07 00 00       	call   804933a <strlen>
 8048b89:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.from.as_str = from;
 8048b8c:	8b 45 08             	mov    0x8(%ebp),%eax
 8048b8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.to.as_len = strlen(to);
 8048b92:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048b95:	89 04 24             	mov    %eax,(%esp)
 8048b98:	e8 9d 07 00 00       	call   804933a <strlen>
 8048b9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.to.as_str = to;
 8048ba0:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048ba3:	89 45 dc             	mov    %eax,-0x24(%ebp)

        return trap(SYS_link, (uint32_t) &args);
 8048ba6:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048ba9:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
 8048bb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048bb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048bb6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048bb9:	cd 2e                	int    $0x2e
 8048bbb:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048bbe:	b8 27 00 00 00       	mov    $0x27,%eax
 8048bc3:	cd 2e                	int    $0x2e
 8048bc5:	89 c2                	mov    %eax,%edx
 8048bc7:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048bcd:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048bcf:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048bd2:	83 c4 34             	add    $0x34,%esp
 8048bd5:	5b                   	pop    %ebx
 8048bd6:	5d                   	pop    %ebp
 8048bd7:	c3                   	ret    

08048bd8 <rename>:

int rename(const char *oldname, const char *newname)
{
 8048bd8:	55                   	push   %ebp
 8048bd9:	89 e5                	mov    %esp,%ebp
 8048bdb:	53                   	push   %ebx
 8048bdc:	83 ec 34             	sub    $0x34,%esp
 8048bdf:	e8 e5 04 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048be4:	81 c3 1c 64 00 00    	add    $0x641c,%ebx
        rename_args_t args;

        args.oldname.as_len = strlen(oldname);
 8048bea:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bed:	89 04 24             	mov    %eax,(%esp)
 8048bf0:	e8 45 07 00 00       	call   804933a <strlen>
 8048bf5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.oldname.as_str = oldname;
 8048bf8:	8b 45 08             	mov    0x8(%ebp),%eax
 8048bfb:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.newname.as_len = strlen(newname);
 8048bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c01:	89 04 24             	mov    %eax,(%esp)
 8048c04:	e8 31 07 00 00       	call   804933a <strlen>
 8048c09:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.newname.as_str = newname;
 8048c0c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048c0f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        return trap(SYS_rename, (uint32_t) &args);
 8048c12:	8d 45 dc             	lea    -0x24(%ebp),%eax
 8048c15:	c7 45 f4 1b 00 00 00 	movl   $0x1b,-0xc(%ebp)
 8048c1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c22:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048c25:	cd 2e                	int    $0x2e
 8048c27:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048c2a:	b8 27 00 00 00       	mov    $0x27,%eax
 8048c2f:	cd 2e                	int    $0x2e
 8048c31:	89 c2                	mov    %eax,%edx
 8048c33:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048c39:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048c3e:	83 c4 34             	add    $0x34,%esp
 8048c41:	5b                   	pop    %ebx
 8048c42:	5d                   	pop    %ebp
 8048c43:	c3                   	ret    

08048c44 <chdir>:

int chdir(const char *path)
{
 8048c44:	55                   	push   %ebp
 8048c45:	89 e5                	mov    %esp,%ebp
 8048c47:	53                   	push   %ebx
 8048c48:	83 ec 34             	sub    $0x34,%esp
 8048c4b:	e8 79 04 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048c50:	81 c3 b0 63 00 00    	add    $0x63b0,%ebx
        argstr_t args;
        args.as_len = strlen(path);
 8048c56:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c59:	89 04 24             	mov    %eax,(%esp)
 8048c5c:	e8 d9 06 00 00       	call   804933a <strlen>
 8048c61:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.as_str = path;
 8048c64:	8b 45 08             	mov    0x8(%ebp),%eax
 8048c67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_chdir, (uint32_t) &args);
 8048c6a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8048c6d:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
 8048c74:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048c77:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048c7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048c7d:	cd 2e                	int    $0x2e
 8048c7f:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048c82:	b8 27 00 00 00       	mov    $0x27,%eax
 8048c87:	cd 2e                	int    $0x2e
 8048c89:	89 c2                	mov    %eax,%edx
 8048c8b:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048c91:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048c93:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048c96:	83 c4 34             	add    $0x34,%esp
 8048c99:	5b                   	pop    %ebx
 8048c9a:	5d                   	pop    %ebp
 8048c9b:	c3                   	ret    

08048c9c <get_free_mem>:

size_t get_free_mem(void)
{
 8048c9c:	55                   	push   %ebp
 8048c9d:	89 e5                	mov    %esp,%ebp
 8048c9f:	83 ec 10             	sub    $0x10,%esp
 8048ca2:	e8 1e 04 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048ca7:	81 c1 59 63 00 00    	add    $0x6359,%ecx
 8048cad:	c7 45 fc 29 00 00 00 	movl   $0x29,-0x4(%ebp)
 8048cb4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048cbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048cbe:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048cc1:	cd 2e                	int    $0x2e
 8048cc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048cc6:	b8 27 00 00 00       	mov    $0x27,%eax
 8048ccb:	cd 2e                	int    $0x2e
 8048ccd:	89 c2                	mov    %eax,%edx
 8048ccf:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048cd5:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return (size_t) trap(SYS_get_free_mem, 0);
}
 8048cda:	c9                   	leave  
 8048cdb:	c3                   	ret    

08048cdc <execve>:

int execve(const char *filename, char *const argv[], char *const envp[])
{
 8048cdc:	55                   	push   %ebp
 8048cdd:	89 e5                	mov    %esp,%ebp
 8048cdf:	56                   	push   %esi
 8048ce0:	53                   	push   %ebx
 8048ce1:	83 ec 40             	sub    $0x40,%esp
 8048ce4:	e8 e0 03 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048ce9:	81 c3 17 63 00 00    	add    $0x6317,%ebx
        execve_args_t           args;

        int i;

        args.filename.as_len = strlen(filename);
 8048cef:	8b 45 08             	mov    0x8(%ebp),%eax
 8048cf2:	89 04 24             	mov    %eax,(%esp)
 8048cf5:	e8 40 06 00 00       	call   804933a <strlen>
 8048cfa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        args.filename.as_str = filename;
 8048cfd:	8b 45 08             	mov    0x8(%ebp),%eax
 8048d00:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
 8048d03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048d0a:	eb 03                	jmp    8048d0f <execve+0x33>
 8048d0c:	ff 45 f4             	incl   -0xc(%ebp)
 8048d0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d12:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048d19:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048d1c:	01 d0                	add    %edx,%eax
 8048d1e:	8b 00                	mov    (%eax),%eax
 8048d20:	85 c0                	test   %eax,%eax
 8048d22:	75 e8                	jne    8048d0c <execve+0x30>
                ;
        args.argv.av_len = i;
 8048d24:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
 8048d2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8048d2d:	40                   	inc    %eax
 8048d2e:	c1 e0 03             	shl    $0x3,%eax
 8048d31:	89 04 24             	mov    %eax,(%esp)
 8048d34:	e8 c5 2a 00 00       	call   804b7fe <malloc>
 8048d39:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (i = 0; argv[i] != NULL; i++) {
 8048d3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048d43:	eb 49                	jmp    8048d8e <execve+0xb2>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
 8048d45:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048d48:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d4b:	c1 e2 03             	shl    $0x3,%edx
 8048d4e:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048d5b:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048d5e:	01 d0                	add    %edx,%eax
 8048d60:	8b 00                	mov    (%eax),%eax
 8048d62:	89 04 24             	mov    %eax,(%esp)
 8048d65:	e8 d0 05 00 00       	call   804933a <strlen>
 8048d6a:	89 46 04             	mov    %eax,0x4(%esi)
                args.argv.av_vec[i].as_str = argv[i];
 8048d6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048d70:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048d73:	c1 e2 03             	shl    $0x3,%edx
 8048d76:	01 c2                	add    %eax,%edx
 8048d78:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d7b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8048d82:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048d85:	01 c8                	add    %ecx,%eax
 8048d87:	8b 00                	mov    (%eax),%eax
 8048d89:	89 02                	mov    %eax,(%edx)
        /* Build argv vector */
        for (i = 0; argv[i] != NULL; i++)
                ;
        args.argv.av_len = i;
        args.argv.av_vec = malloc((args.argv.av_len + 1) * sizeof(argstr_t));
        for (i = 0; argv[i] != NULL; i++) {
 8048d8b:	ff 45 f4             	incl   -0xc(%ebp)
 8048d8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048d91:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048d98:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048d9b:	01 d0                	add    %edx,%eax
 8048d9d:	8b 00                	mov    (%eax),%eax
 8048d9f:	85 c0                	test   %eax,%eax
 8048da1:	75 a2                	jne    8048d45 <execve+0x69>
                args.argv.av_vec[i].as_len = strlen(argv[i]);
                args.argv.av_vec[i].as_str = argv[i];
        }
        args.argv.av_vec[i].as_len = 0;
 8048da3:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048da6:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048da9:	c1 e2 03             	shl    $0x3,%edx
 8048dac:	01 d0                	add    %edx,%eax
 8048dae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.argv.av_vec[i].as_str = NULL;
 8048db5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 8048db8:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048dbb:	c1 e2 03             	shl    $0x3,%edx
 8048dbe:	01 d0                	add    %edx,%eax
 8048dc0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
 8048dc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048dcd:	eb 03                	jmp    8048dd2 <execve+0xf6>
 8048dcf:	ff 45 f4             	incl   -0xc(%ebp)
 8048dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048dd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048ddc:	8b 45 10             	mov    0x10(%ebp),%eax
 8048ddf:	01 d0                	add    %edx,%eax
 8048de1:	8b 00                	mov    (%eax),%eax
 8048de3:	85 c0                	test   %eax,%eax
 8048de5:	75 e8                	jne    8048dcf <execve+0xf3>
                ;
        args.envp.av_len = i;
 8048de7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048dea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
 8048ded:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 8048df0:	40                   	inc    %eax
 8048df1:	c1 e0 03             	shl    $0x3,%eax
 8048df4:	89 04 24             	mov    %eax,(%esp)
 8048df7:	e8 02 2a 00 00       	call   804b7fe <malloc>
 8048dfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
        for (i = 0; envp[i] != NULL; i++) {
 8048dff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8048e06:	eb 49                	jmp    8048e51 <execve+0x175>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
 8048e08:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048e0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048e0e:	c1 e2 03             	shl    $0x3,%edx
 8048e11:	8d 34 10             	lea    (%eax,%edx,1),%esi
 8048e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048e17:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048e1e:	8b 45 10             	mov    0x10(%ebp),%eax
 8048e21:	01 d0                	add    %edx,%eax
 8048e23:	8b 00                	mov    (%eax),%eax
 8048e25:	89 04 24             	mov    %eax,(%esp)
 8048e28:	e8 0d 05 00 00       	call   804933a <strlen>
 8048e2d:	89 46 04             	mov    %eax,0x4(%esi)
                args.envp.av_vec[i].as_str = envp[i];
 8048e30:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048e33:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048e36:	c1 e2 03             	shl    $0x3,%edx
 8048e39:	01 c2                	add    %eax,%edx
 8048e3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048e3e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 8048e45:	8b 45 10             	mov    0x10(%ebp),%eax
 8048e48:	01 c8                	add    %ecx,%eax
 8048e4a:	8b 00                	mov    (%eax),%eax
 8048e4c:	89 02                	mov    %eax,(%edx)
        /* Build envp vector */
        for (i = 0; envp[i] != NULL; i++)
                ;
        args.envp.av_len = i;
        args.envp.av_vec = malloc((args.envp.av_len + 1) * sizeof(argstr_t));
        for (i = 0; envp[i] != NULL; i++) {
 8048e4e:	ff 45 f4             	incl   -0xc(%ebp)
 8048e51:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048e54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8048e5b:	8b 45 10             	mov    0x10(%ebp),%eax
 8048e5e:	01 d0                	add    %edx,%eax
 8048e60:	8b 00                	mov    (%eax),%eax
 8048e62:	85 c0                	test   %eax,%eax
 8048e64:	75 a2                	jne    8048e08 <execve+0x12c>
                args.envp.av_vec[i].as_len = strlen(envp[i]);
                args.envp.av_vec[i].as_str = envp[i];
        }
        args.envp.av_vec[i].as_len = 0;
 8048e66:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048e69:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048e6c:	c1 e2 03             	shl    $0x3,%edx
 8048e6f:	01 d0                	add    %edx,%eax
 8048e71:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        args.envp.av_vec[i].as_str = NULL;
 8048e78:	8b 45 e0             	mov    -0x20(%ebp),%eax
 8048e7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8048e7e:	c1 e2 03             	shl    $0x3,%edx
 8048e81:	01 d0                	add    %edx,%eax
 8048e83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

        /* Note that we don't need to worry about freeing since we are going to exec
         * (so all our memory will be cleaned up) */

        return trap(SYS_execve, (uint32_t) &args);
 8048e89:	8d 45 d0             	lea    -0x30(%ebp),%eax
 8048e8c:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
 8048e93:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048e96:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8048e99:	8b 55 ec             	mov    -0x14(%ebp),%edx
 8048e9c:	cd 2e                	int    $0x2e
 8048e9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048ea1:	b8 27 00 00 00       	mov    $0x27,%eax
 8048ea6:	cd 2e                	int    $0x2e
 8048ea8:	89 c2                	mov    %eax,%edx
 8048eaa:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048eb0:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048eb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
 8048eb5:	83 c4 40             	add    $0x40,%esp
 8048eb8:	5b                   	pop    %ebx
 8048eb9:	5e                   	pop    %esi
 8048eba:	5d                   	pop    %ebp
 8048ebb:	c3                   	ret    

08048ebc <thr_set_errno>:

void thr_set_errno(int n)
{
 8048ebc:	55                   	push   %ebp
 8048ebd:	89 e5                	mov    %esp,%ebp
 8048ebf:	83 ec 10             	sub    $0x10,%esp
 8048ec2:	e8 fe 01 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048ec7:	81 c1 39 61 00 00    	add    $0x6139,%ecx
        trap(SYS_set_errno, (uint32_t) n);
 8048ecd:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ed0:	c7 45 fc 2a 00 00 00 	movl   $0x2a,-0x4(%ebp)
 8048ed7:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048eda:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048edd:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048ee0:	cd 2e                	int    $0x2e
 8048ee2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048ee5:	b8 27 00 00 00       	mov    $0x27,%eax
 8048eea:	cd 2e                	int    $0x2e
 8048eec:	89 c2                	mov    %eax,%edx
 8048eee:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048ef4:	89 10                	mov    %edx,(%eax)
}
 8048ef6:	90                   	nop
 8048ef7:	c9                   	leave  
 8048ef8:	c3                   	ret    

08048ef9 <thr_errno>:

int thr_errno(void)
{
 8048ef9:	55                   	push   %ebp
 8048efa:	89 e5                	mov    %esp,%ebp
 8048efc:	83 ec 10             	sub    $0x10,%esp
 8048eff:	e8 c1 01 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048f04:	81 c1 fc 60 00 00    	add    $0x60fc,%ecx
 8048f0a:	c7 45 fc 27 00 00 00 	movl   $0x27,-0x4(%ebp)
 8048f11:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f18:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048f1b:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048f1e:	cd 2e                	int    $0x2e
 8048f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f23:	b8 27 00 00 00       	mov    $0x27,%eax
 8048f28:	cd 2e                	int    $0x2e
 8048f2a:	89 c2                	mov    %eax,%edx
 8048f2c:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048f32:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f34:	8b 45 f4             	mov    -0xc(%ebp),%eax
        return trap(SYS_errno, 0);
 8048f37:	90                   	nop
}
 8048f38:	c9                   	leave  
 8048f39:	c3                   	ret    

08048f3a <getdents>:

int getdents(int fd, dirent_t *dir, size_t size)
{
 8048f3a:	55                   	push   %ebp
 8048f3b:	89 e5                	mov    %esp,%ebp
 8048f3d:	83 ec 20             	sub    $0x20,%esp
 8048f40:	e8 80 01 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048f45:	81 c1 bb 60 00 00    	add    $0x60bb,%ecx
        getdents_args_t args;

        args.fd = fd;
 8048f4b:	8b 45 08             	mov    0x8(%ebp),%eax
 8048f4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        args.dirp = dir;
 8048f51:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048f54:	89 45 ec             	mov    %eax,-0x14(%ebp)
        args.count = size;
 8048f57:	8b 45 10             	mov    0x10(%ebp),%eax
 8048f5a:	89 45 f0             	mov    %eax,-0x10(%ebp)

        return trap(SYS_getdents, (uint32_t) &args);
 8048f5d:	8d 45 e8             	lea    -0x18(%ebp),%eax
 8048f60:	c7 45 fc 17 00 00 00 	movl   $0x17,-0x4(%ebp)
 8048f67:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048f6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048f6d:	8b 55 f8             	mov    -0x8(%ebp),%edx
 8048f70:	cd 2e                	int    $0x2e
 8048f72:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048f75:	b8 27 00 00 00       	mov    $0x27,%eax
 8048f7a:	cd 2e                	int    $0x2e
 8048f7c:	89 c2                	mov    %eax,%edx
 8048f7e:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048f84:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8048f89:	c9                   	leave  
 8048f8a:	c3                   	ret    

08048f8b <stat>:
}
#endif /* MOUNTING */

int
stat(const char *path, struct stat *buf)
{
 8048f8b:	55                   	push   %ebp
 8048f8c:	89 e5                	mov    %esp,%ebp
 8048f8e:	53                   	push   %ebx
 8048f8f:	83 ec 34             	sub    $0x34,%esp
 8048f92:	e8 32 01 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8048f97:	81 c3 69 60 00 00    	add    $0x6069,%ebx
        stat_args_t args;

        args.path.as_len = strlen(path);
 8048f9d:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fa0:	89 04 24             	mov    %eax,(%esp)
 8048fa3:	e8 92 03 00 00       	call   804933a <strlen>
 8048fa8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        args.path.as_str = path;
 8048fab:	8b 45 08             	mov    0x8(%ebp),%eax
 8048fae:	89 45 e0             	mov    %eax,-0x20(%ebp)
        args.buf = buf;
 8048fb1:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048fb4:	89 45 e8             	mov    %eax,-0x18(%ebp)

        return trap(SYS_stat, (uint32_t) &args);
 8048fb7:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8048fba:	c7 45 f4 2f 00 00 00 	movl   $0x2f,-0xc(%ebp)
 8048fc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8048fc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8048fc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8048fca:	cd 2e                	int    $0x2e
 8048fcc:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8048fcf:	b8 27 00 00 00       	mov    $0x27,%eax
 8048fd4:	cd 2e                	int    $0x2e
 8048fd6:	89 c2                	mov    %eax,%edx
 8048fd8:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8048fde:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8048fe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8048fe3:	83 c4 34             	add    $0x34,%esp
 8048fe6:	5b                   	pop    %ebx
 8048fe7:	5d                   	pop    %ebp
 8048fe8:	c3                   	ret    

08048fe9 <pipe>:

int
pipe(int pipefd[2])
{
 8048fe9:	55                   	push   %ebp
 8048fea:	89 e5                	mov    %esp,%ebp
 8048fec:	83 ec 10             	sub    $0x10,%esp
 8048fef:	e8 d1 00 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8048ff4:	81 c1 0c 60 00 00    	add    $0x600c,%ecx
        return trap(SYS_pipe, (uint32_t) pipefd);
 8048ffa:	8b 45 08             	mov    0x8(%ebp),%eax
 8048ffd:	c7 45 fc 12 00 00 00 	movl   $0x12,-0x4(%ebp)
 8049004:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049007:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804900a:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804900d:	cd 2e                	int    $0x2e
 804900f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049012:	b8 27 00 00 00       	mov    $0x27,%eax
 8049017:	cd 2e                	int    $0x2e
 8049019:	89 c2                	mov    %eax,%edx
 804901b:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8049021:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049023:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049026:	90                   	nop
}
 8049027:	c9                   	leave  
 8049028:	c3                   	ret    

08049029 <uname>:

int
uname(struct utsname *buf)
{
 8049029:	55                   	push   %ebp
 804902a:	89 e5                	mov    %esp,%ebp
 804902c:	83 ec 10             	sub    $0x10,%esp
 804902f:	e8 91 00 00 00       	call   80490c5 <__x86.get_pc_thunk.cx>
 8049034:	81 c1 cc 5f 00 00    	add    $0x5fcc,%ecx
        return trap(SYS_uname, (uint32_t) buf);
 804903a:	8b 45 08             	mov    0x8(%ebp),%eax
 804903d:	c7 45 fc 1c 00 00 00 	movl   $0x1c,-0x4(%ebp)
 8049044:	89 45 f8             	mov    %eax,-0x8(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 8049047:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804904a:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804904d:	cd 2e                	int    $0x2e
 804904f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 8049052:	b8 27 00 00 00       	mov    $0x27,%eax
 8049057:	cd 2e                	int    $0x2e
 8049059:	89 c2                	mov    %eax,%edx
 804905b:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 8049061:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 8049063:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049066:	90                   	nop
}
 8049067:	c9                   	leave  
 8049068:	c3                   	ret    

08049069 <debug>:

int
debug(const char *str)
{
 8049069:	55                   	push   %ebp
 804906a:	89 e5                	mov    %esp,%ebp
 804906c:	53                   	push   %ebx
 804906d:	83 ec 34             	sub    $0x34,%esp
 8049070:	e8 54 00 00 00       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049075:	81 c3 8b 5f 00 00    	add    $0x5f8b,%ebx
        argstr_t argstr;
        argstr.as_len = strlen(str);
 804907b:	8b 45 08             	mov    0x8(%ebp),%eax
 804907e:	89 04 24             	mov    %eax,(%esp)
 8049081:	e8 b4 02 00 00       	call   804933a <strlen>
 8049086:	89 45 e8             	mov    %eax,-0x18(%ebp)
        argstr.as_str = str;
 8049089:	8b 45 08             	mov    0x8(%ebp),%eax
 804908c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return trap(SYS_debug, (uint32_t) &argstr);
 804908f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049092:	c7 45 f4 29 23 00 00 	movl   $0x2329,-0xc(%ebp)
 8049099:	89 45 f0             	mov    %eax,-0x10(%ebp)
#define TRAP_INTR_STRING QUOTE(INTR_SYSCALL)

static inline int trap(uint32_t num, uint32_t arg)
{
        int ret;
        __asm__ volatile(
 804909c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804909f:	8b 55 f0             	mov    -0x10(%ebp),%edx
 80490a2:	cd 2e                	int    $0x2e
 80490a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
                "int $" TRAP_INTR_STRING
                : "=a"(ret)
                : "a"(num), "d"(arg)
        );
        /* Copy in errno */
        __asm__ volatile(
 80490a7:	b8 27 00 00 00       	mov    $0x27,%eax
 80490ac:	cd 2e                	int    $0x2e
 80490ae:	89 c2                	mov    %eax,%edx
 80490b0:	8d 05 a4 f2 04 08    	lea    0x804f2a4,%eax
 80490b6:	89 10                	mov    %edx,(%eax)
                "int $" TRAP_INTR_STRING
                : "=a"(errno)
                : "a"(SYS_errno)
        );
        return ret;
 80490b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 80490bb:	83 c4 34             	add    $0x34,%esp
 80490be:	5b                   	pop    %ebx
 80490bf:	5d                   	pop    %ebp
 80490c0:	c3                   	ret    

080490c1 <__x86.get_pc_thunk.ax>:
 80490c1:	8b 04 24             	mov    (%esp),%eax
 80490c4:	c3                   	ret    

080490c5 <__x86.get_pc_thunk.cx>:
 80490c5:	8b 0c 24             	mov    (%esp),%ecx
 80490c8:	c3                   	ret    

080490c9 <__x86.get_pc_thunk.bx>:
 80490c9:	8b 1c 24             	mov    (%esp),%ebx
 80490cc:	c3                   	ret    

080490cd <memcmp>:
#include "stdlib.h"
#include "string.h"
#include "errno.h"

int memcmp(const void *cs, const void *ct, size_t count)
{
 80490cd:	55                   	push   %ebp
 80490ce:	89 e5                	mov    %esp,%ebp
 80490d0:	83 ec 10             	sub    $0x10,%esp
 80490d3:	e8 e9 ff ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80490d8:	05 28 5f 00 00       	add    $0x5f28,%eax
        const unsigned char *su1, *su2;
        signed char res = 0;
 80490dd:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 80490e1:	8b 45 08             	mov    0x8(%ebp),%eax
 80490e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80490e7:	8b 45 0c             	mov    0xc(%ebp),%eax
 80490ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80490ed:	eb 22                	jmp    8049111 <memcmp+0x44>
                if ((res = *su1 - *su2) != 0)
 80490ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80490f2:	0f b6 10             	movzbl (%eax),%edx
 80490f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80490f8:	0f b6 00             	movzbl (%eax),%eax
 80490fb:	28 c2                	sub    %al,%dl
 80490fd:	88 d0                	mov    %dl,%al
 80490ff:	88 45 f7             	mov    %al,-0x9(%ebp)
 8049102:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 8049106:	75 11                	jne    8049119 <memcmp+0x4c>
int memcmp(const void *cs, const void *ct, size_t count)
{
        const unsigned char *su1, *su2;
        signed char res = 0;

        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
 8049108:	ff 45 fc             	incl   -0x4(%ebp)
 804910b:	ff 45 f8             	incl   -0x8(%ebp)
 804910e:	ff 4d 10             	decl   0x10(%ebp)
 8049111:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 8049115:	75 d8                	jne    80490ef <memcmp+0x22>
 8049117:	eb 01                	jmp    804911a <memcmp+0x4d>
                if ((res = *su1 - *su2) != 0)
                        break;
 8049119:	90                   	nop
        return res;
 804911a:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
}
 804911e:	c9                   	leave  
 804911f:	c3                   	ret    

08049120 <memcpy>:

void *memcpy(void *dest, const void *src, size_t count)
{
 8049120:	55                   	push   %ebp
 8049121:	89 e5                	mov    %esp,%ebp
 8049123:	83 ec 10             	sub    $0x10,%esp
 8049126:	e8 96 ff ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804912b:	05 d5 5e 00 00       	add    $0x5ed5,%eax
        char *tmp = (char *) dest;
 8049130:	8b 45 08             	mov    0x8(%ebp),%eax
 8049133:	89 45 fc             	mov    %eax,-0x4(%ebp)
        const char *s = src;
 8049136:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049139:	89 45 f8             	mov    %eax,-0x8(%ebp)

        while (count--)
 804913c:	eb 17                	jmp    8049155 <memcpy+0x35>
                *tmp++ = *s++;
 804913e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049141:	8d 50 01             	lea    0x1(%eax),%edx
 8049144:	89 55 fc             	mov    %edx,-0x4(%ebp)
 8049147:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804914a:	8d 4a 01             	lea    0x1(%edx),%ecx
 804914d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
 8049150:	0f b6 12             	movzbl (%edx),%edx
 8049153:	88 10                	mov    %dl,(%eax)
void *memcpy(void *dest, const void *src, size_t count)
{
        char *tmp = (char *) dest;
        const char *s = src;

        while (count--)
 8049155:	8b 45 10             	mov    0x10(%ebp),%eax
 8049158:	8d 50 ff             	lea    -0x1(%eax),%edx
 804915b:	89 55 10             	mov    %edx,0x10(%ebp)
 804915e:	85 c0                	test   %eax,%eax
 8049160:	75 dc                	jne    804913e <memcpy+0x1e>
                *tmp++ = *s++;

        return dest;
 8049162:	8b 45 08             	mov    0x8(%ebp),%eax
}
 8049165:	c9                   	leave  
 8049166:	c3                   	ret    

08049167 <strncmp>:

int strncmp(const char *cs, const char *ct, size_t count)
{
 8049167:	55                   	push   %ebp
 8049168:	89 e5                	mov    %esp,%ebp
 804916a:	53                   	push   %ebx
 804916b:	e8 51 ff ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049170:	05 90 5e 00 00       	add    $0x5e90,%eax
        register signed char __res = 0;
 8049175:	b3 00                	mov    $0x0,%bl

        while (count) {
 8049177:	eb 31                	jmp    80491aa <strncmp+0x43>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 8049179:	8b 45 08             	mov    0x8(%ebp),%eax
 804917c:	0f b6 00             	movzbl (%eax),%eax
 804917f:	88 c1                	mov    %al,%cl
 8049181:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049184:	8d 50 01             	lea    0x1(%eax),%edx
 8049187:	89 55 0c             	mov    %edx,0xc(%ebp)
 804918a:	0f b6 00             	movzbl (%eax),%eax
 804918d:	28 c1                	sub    %al,%cl
 804918f:	88 c8                	mov    %cl,%al
 8049191:	88 c3                	mov    %al,%bl
 8049193:	84 db                	test   %bl,%bl
 8049195:	75 19                	jne    80491b0 <strncmp+0x49>
 8049197:	8b 45 08             	mov    0x8(%ebp),%eax
 804919a:	8d 50 01             	lea    0x1(%eax),%edx
 804919d:	89 55 08             	mov    %edx,0x8(%ebp)
 80491a0:	0f b6 00             	movzbl (%eax),%eax
 80491a3:	84 c0                	test   %al,%al
 80491a5:	74 09                	je     80491b0 <strncmp+0x49>
                        break;
                count--;
 80491a7:	ff 4d 10             	decl   0x10(%ebp)

int strncmp(const char *cs, const char *ct, size_t count)
{
        register signed char __res = 0;

        while (count) {
 80491aa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 80491ae:	75 c9                	jne    8049179 <strncmp+0x12>
                if ((__res = *cs - *ct++) != 0 || !*cs++)
                        break;
                count--;
        }

        return __res;
 80491b0:	0f be c3             	movsbl %bl,%eax
}
 80491b3:	5b                   	pop    %ebx
 80491b4:	5d                   	pop    %ebp
 80491b5:	c3                   	ret    

080491b6 <strcmp>:

int strcmp(const char *cs, const char *ct)
{
 80491b6:	55                   	push   %ebp
 80491b7:	89 e5                	mov    %esp,%ebp
 80491b9:	53                   	push   %ebx
 80491ba:	e8 02 ff ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80491bf:	05 41 5e 00 00       	add    $0x5e41,%eax
        register signed char __res;

        while (1) {
                if ((__res = *cs - *ct++) != 0 || !*cs++)
 80491c4:	8b 45 08             	mov    0x8(%ebp),%eax
 80491c7:	0f b6 00             	movzbl (%eax),%eax
 80491ca:	88 c1                	mov    %al,%cl
 80491cc:	8b 45 0c             	mov    0xc(%ebp),%eax
 80491cf:	8d 50 01             	lea    0x1(%eax),%edx
 80491d2:	89 55 0c             	mov    %edx,0xc(%ebp)
 80491d5:	0f b6 00             	movzbl (%eax),%eax
 80491d8:	28 c1                	sub    %al,%cl
 80491da:	88 c8                	mov    %cl,%al
 80491dc:	88 c3                	mov    %al,%bl
 80491de:	84 db                	test   %bl,%bl
 80491e0:	75 12                	jne    80491f4 <strcmp+0x3e>
 80491e2:	8b 45 08             	mov    0x8(%ebp),%eax
 80491e5:	8d 50 01             	lea    0x1(%eax),%edx
 80491e8:	89 55 08             	mov    %edx,0x8(%ebp)
 80491eb:	0f b6 00             	movzbl (%eax),%eax
 80491ee:	84 c0                	test   %al,%al
 80491f0:	74 02                	je     80491f4 <strcmp+0x3e>
                        break;
        }
 80491f2:	eb d0                	jmp    80491c4 <strcmp+0xe>

        return __res;
 80491f4:	0f be c3             	movsbl %bl,%eax
}
 80491f7:	5b                   	pop    %ebx
 80491f8:	5d                   	pop    %ebp
 80491f9:	c3                   	ret    

080491fa <strcpy>:

char *strcpy(char *dest, const char *src)
{
 80491fa:	55                   	push   %ebp
 80491fb:	89 e5                	mov    %esp,%ebp
 80491fd:	83 ec 10             	sub    $0x10,%esp
 8049200:	e8 bc fe ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049205:	05 fb 5d 00 00       	add    $0x5dfb,%eax
        char *tmp = dest;
 804920a:	8b 45 08             	mov    0x8(%ebp),%eax
 804920d:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while ((*dest++ = *src++) != '\0')
 8049210:	90                   	nop
 8049211:	8b 45 08             	mov    0x8(%ebp),%eax
 8049214:	8d 50 01             	lea    0x1(%eax),%edx
 8049217:	89 55 08             	mov    %edx,0x8(%ebp)
 804921a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804921d:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049220:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 8049223:	0f b6 12             	movzbl (%edx),%edx
 8049226:	88 10                	mov    %dl,(%eax)
 8049228:	0f b6 00             	movzbl (%eax),%eax
 804922b:	84 c0                	test   %al,%al
 804922d:	75 e2                	jne    8049211 <strcpy+0x17>
                /* nothing */;
        return tmp;
 804922f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049232:	c9                   	leave  
 8049233:	c3                   	ret    

08049234 <strncpy>:

char *strncpy(char *dest, const char *src, size_t count)
{
 8049234:	55                   	push   %ebp
 8049235:	89 e5                	mov    %esp,%ebp
 8049237:	83 ec 10             	sub    $0x10,%esp
 804923a:	e8 82 fe ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804923f:	05 c1 5d 00 00       	add    $0x5dc1,%eax
        char *tmp = dest;
 8049244:	8b 45 08             	mov    0x8(%ebp),%eax
 8049247:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count-- && (*dest++ = *src++) != '\0')
 804924a:	90                   	nop
 804924b:	8b 45 10             	mov    0x10(%ebp),%eax
 804924e:	8d 50 ff             	lea    -0x1(%eax),%edx
 8049251:	89 55 10             	mov    %edx,0x10(%ebp)
 8049254:	85 c0                	test   %eax,%eax
 8049256:	74 1e                	je     8049276 <strncpy+0x42>
 8049258:	8b 45 08             	mov    0x8(%ebp),%eax
 804925b:	8d 50 01             	lea    0x1(%eax),%edx
 804925e:	89 55 08             	mov    %edx,0x8(%ebp)
 8049261:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049264:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049267:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 804926a:	0f b6 12             	movzbl (%edx),%edx
 804926d:	88 10                	mov    %dl,(%eax)
 804926f:	0f b6 00             	movzbl (%eax),%eax
 8049272:	84 c0                	test   %al,%al
 8049274:	75 d5                	jne    804924b <strncpy+0x17>
                /* nothing */;

        return tmp;
 8049276:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049279:	c9                   	leave  
 804927a:	c3                   	ret    

0804927b <memset>:

void *memset(void *s, int c, size_t count)
{
 804927b:	55                   	push   %ebp
 804927c:	89 e5                	mov    %esp,%ebp
 804927e:	83 ec 10             	sub    $0x10,%esp
 8049281:	e8 3b fe ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049286:	05 7a 5d 00 00       	add    $0x5d7a,%eax
        char *xs = (char *) s;
 804928b:	8b 45 08             	mov    0x8(%ebp),%eax
 804928e:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (count--)
 8049291:	eb 0e                	jmp    80492a1 <memset+0x26>
                *xs++ = c;
 8049293:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049296:	8d 50 01             	lea    0x1(%eax),%edx
 8049299:	89 55 fc             	mov    %edx,-0x4(%ebp)
 804929c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804929f:	88 10                	mov    %dl,(%eax)

void *memset(void *s, int c, size_t count)
{
        char *xs = (char *) s;

        while (count--)
 80492a1:	8b 45 10             	mov    0x10(%ebp),%eax
 80492a4:	8d 50 ff             	lea    -0x1(%eax),%edx
 80492a7:	89 55 10             	mov    %edx,0x10(%ebp)
 80492aa:	85 c0                	test   %eax,%eax
 80492ac:	75 e5                	jne    8049293 <memset+0x18>
                *xs++ = c;

        return s;
 80492ae:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80492b1:	c9                   	leave  
 80492b2:	c3                   	ret    

080492b3 <strnlen>:

size_t strnlen(const char *s, size_t count)
{
 80492b3:	55                   	push   %ebp
 80492b4:	89 e5                	mov    %esp,%ebp
 80492b6:	83 ec 10             	sub    $0x10,%esp
 80492b9:	e8 03 fe ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80492be:	05 42 5d 00 00       	add    $0x5d42,%eax
        const char *sc;

        for (sc = s; count-- && *sc != '\0'; ++sc)
 80492c3:	8b 45 08             	mov    0x8(%ebp),%eax
 80492c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80492c9:	eb 03                	jmp    80492ce <strnlen+0x1b>
 80492cb:	ff 45 fc             	incl   -0x4(%ebp)
 80492ce:	8b 45 0c             	mov    0xc(%ebp),%eax
 80492d1:	8d 50 ff             	lea    -0x1(%eax),%edx
 80492d4:	89 55 0c             	mov    %edx,0xc(%ebp)
 80492d7:	85 c0                	test   %eax,%eax
 80492d9:	74 0a                	je     80492e5 <strnlen+0x32>
 80492db:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80492de:	0f b6 00             	movzbl (%eax),%eax
 80492e1:	84 c0                	test   %al,%al
 80492e3:	75 e6                	jne    80492cb <strnlen+0x18>
                /* nothing */;
        return sc - s;
 80492e5:	8b 55 fc             	mov    -0x4(%ebp),%edx
 80492e8:	8b 45 08             	mov    0x8(%ebp),%eax
 80492eb:	29 c2                	sub    %eax,%edx
 80492ed:	89 d0                	mov    %edx,%eax
}
 80492ef:	c9                   	leave  
 80492f0:	c3                   	ret    

080492f1 <strcat>:


char *strcat(char *dest, const char *src)
{
 80492f1:	55                   	push   %ebp
 80492f2:	89 e5                	mov    %esp,%ebp
 80492f4:	83 ec 10             	sub    $0x10,%esp
 80492f7:	e8 c5 fd ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80492fc:	05 04 5d 00 00       	add    $0x5d04,%eax
        char *tmp = dest;
 8049301:	8b 45 08             	mov    0x8(%ebp),%eax
 8049304:	89 45 fc             	mov    %eax,-0x4(%ebp)

        while (*dest)
 8049307:	eb 03                	jmp    804930c <strcat+0x1b>
                dest++;
 8049309:	ff 45 08             	incl   0x8(%ebp)

char *strcat(char *dest, const char *src)
{
        char *tmp = dest;

        while (*dest)
 804930c:	8b 45 08             	mov    0x8(%ebp),%eax
 804930f:	0f b6 00             	movzbl (%eax),%eax
 8049312:	84 c0                	test   %al,%al
 8049314:	75 f3                	jne    8049309 <strcat+0x18>
                dest++;

        while ((*dest++ = *src++) != '\0');
 8049316:	90                   	nop
 8049317:	8b 45 08             	mov    0x8(%ebp),%eax
 804931a:	8d 50 01             	lea    0x1(%eax),%edx
 804931d:	89 55 08             	mov    %edx,0x8(%ebp)
 8049320:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049323:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049326:	89 4d 0c             	mov    %ecx,0xc(%ebp)
 8049329:	0f b6 12             	movzbl (%edx),%edx
 804932c:	88 10                	mov    %dl,(%eax)
 804932e:	0f b6 00             	movzbl (%eax),%eax
 8049331:	84 c0                	test   %al,%al
 8049333:	75 e2                	jne    8049317 <strcat+0x26>

        return tmp;
 8049335:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 8049338:	c9                   	leave  
 8049339:	c3                   	ret    

0804933a <strlen>:

size_t strlen(const char *s)
{
 804933a:	55                   	push   %ebp
 804933b:	89 e5                	mov    %esp,%ebp
 804933d:	83 ec 10             	sub    $0x10,%esp
 8049340:	e8 7c fd ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049345:	05 bb 5c 00 00       	add    $0x5cbb,%eax
        const char *sc;

        for (sc = s; *sc != '\0'; ++sc)
 804934a:	8b 45 08             	mov    0x8(%ebp),%eax
 804934d:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8049350:	eb 03                	jmp    8049355 <strlen+0x1b>
 8049352:	ff 45 fc             	incl   -0x4(%ebp)
 8049355:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049358:	0f b6 00             	movzbl (%eax),%eax
 804935b:	84 c0                	test   %al,%al
 804935d:	75 f3                	jne    8049352 <strlen+0x18>
                /* nothing */;
        return sc - s;
 804935f:	8b 55 fc             	mov    -0x4(%ebp),%edx
 8049362:	8b 45 08             	mov    0x8(%ebp),%eax
 8049365:	29 c2                	sub    %eax,%edx
 8049367:	89 d0                	mov    %edx,%eax
}
 8049369:	c9                   	leave  
 804936a:	c3                   	ret    

0804936b <strchr>:

char *strchr(const char *s, int c)
{
 804936b:	55                   	push   %ebp
 804936c:	89 e5                	mov    %esp,%ebp
 804936e:	e8 4e fd ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049373:	05 8d 5c 00 00       	add    $0x5c8d,%eax
        for (; *s != (char) c; ++s)
 8049378:	eb 14                	jmp    804938e <strchr+0x23>
                if (*s == '\0')
 804937a:	8b 45 08             	mov    0x8(%ebp),%eax
 804937d:	0f b6 00             	movzbl (%eax),%eax
 8049380:	84 c0                	test   %al,%al
 8049382:	75 07                	jne    804938b <strchr+0x20>
                        return NULL;
 8049384:	b8 00 00 00 00       	mov    $0x0,%eax
 8049389:	eb 13                	jmp    804939e <strchr+0x33>
        return sc - s;
}

char *strchr(const char *s, int c)
{
        for (; *s != (char) c; ++s)
 804938b:	ff 45 08             	incl   0x8(%ebp)
 804938e:	8b 45 08             	mov    0x8(%ebp),%eax
 8049391:	0f b6 00             	movzbl (%eax),%eax
 8049394:	8b 55 0c             	mov    0xc(%ebp),%edx
 8049397:	38 d0                	cmp    %dl,%al
 8049399:	75 df                	jne    804937a <strchr+0xf>
                if (*s == '\0')
                        return NULL;
        return (char *)s;
 804939b:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804939e:	5d                   	pop    %ebp
 804939f:	c3                   	ret    

080493a0 <strrchr>:

char *strrchr(const char *s, int c)
{
 80493a0:	55                   	push   %ebp
 80493a1:	89 e5                	mov    %esp,%ebp
 80493a3:	83 ec 10             	sub    $0x10,%esp
 80493a6:	e8 16 fd ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80493ab:	05 55 5c 00 00       	add    $0x5c55,%eax
        char *r = NULL;
 80493b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        for (; *s; ++s)
 80493b7:	eb 16                	jmp    80493cf <strrchr+0x2f>
                if (*s == (char)c)
 80493b9:	8b 45 08             	mov    0x8(%ebp),%eax
 80493bc:	0f b6 00             	movzbl (%eax),%eax
 80493bf:	8b 55 0c             	mov    0xc(%ebp),%edx
 80493c2:	38 d0                	cmp    %dl,%al
 80493c4:	75 06                	jne    80493cc <strrchr+0x2c>
                        r = (char *)s;
 80493c6:	8b 45 08             	mov    0x8(%ebp),%eax
 80493c9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

char *strrchr(const char *s, int c)
{
        char *r = NULL;
        for (; *s; ++s)
 80493cc:	ff 45 08             	incl   0x8(%ebp)
 80493cf:	8b 45 08             	mov    0x8(%ebp),%eax
 80493d2:	0f b6 00             	movzbl (%eax),%eax
 80493d5:	84 c0                	test   %al,%al
 80493d7:	75 e0                	jne    80493b9 <strrchr+0x19>
                if (*s == (char)c)
                        r = (char *)s;
        return r;
 80493d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80493dc:	c9                   	leave  
 80493dd:	c3                   	ret    

080493de <strstr>:

char *strstr(const char *s1, const char *s2)
{
 80493de:	55                   	push   %ebp
 80493df:	89 e5                	mov    %esp,%ebp
 80493e1:	53                   	push   %ebx
 80493e2:	83 ec 24             	sub    $0x24,%esp
 80493e5:	e8 df fc ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 80493ea:	81 c3 16 5c 00 00    	add    $0x5c16,%ebx
        int l1, l2;

        l2 = strlen(s2);
 80493f0:	8b 45 0c             	mov    0xc(%ebp),%eax
 80493f3:	89 04 24             	mov    %eax,(%esp)
 80493f6:	e8 3f ff ff ff       	call   804933a <strlen>
 80493fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!l2)
 80493fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049402:	75 05                	jne    8049409 <strstr+0x2b>
                return (char *) s1;
 8049404:	8b 45 08             	mov    0x8(%ebp),%eax
 8049407:	eb 45                	jmp    804944e <strstr+0x70>
        l1 = strlen(s1);
 8049409:	8b 45 08             	mov    0x8(%ebp),%eax
 804940c:	89 04 24             	mov    %eax,(%esp)
 804940f:	e8 26 ff ff ff       	call   804933a <strlen>
 8049414:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (l1 >= l2) {
 8049417:	eb 28                	jmp    8049441 <strstr+0x63>
                l1--;
 8049419:	ff 4d f4             	decl   -0xc(%ebp)
                if (!memcmp(s1, s2, l2))
 804941c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804941f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049423:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049426:	89 44 24 04          	mov    %eax,0x4(%esp)
 804942a:	8b 45 08             	mov    0x8(%ebp),%eax
 804942d:	89 04 24             	mov    %eax,(%esp)
 8049430:	e8 98 fc ff ff       	call   80490cd <memcmp>
 8049435:	85 c0                	test   %eax,%eax
 8049437:	75 05                	jne    804943e <strstr+0x60>
                        return (char *) s1;
 8049439:	8b 45 08             	mov    0x8(%ebp),%eax
 804943c:	eb 10                	jmp    804944e <strstr+0x70>
                s1++;
 804943e:	ff 45 08             	incl   0x8(%ebp)

        l2 = strlen(s2);
        if (!l2)
                return (char *) s1;
        l1 = strlen(s1);
        while (l1 >= l2) {
 8049441:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049444:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 8049447:	7d d0                	jge    8049419 <strstr+0x3b>
                l1--;
                if (!memcmp(s1, s2, l2))
                        return (char *) s1;
                s1++;
        }
        return NULL;
 8049449:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804944e:	83 c4 24             	add    $0x24,%esp
 8049451:	5b                   	pop    %ebx
 8049452:	5d                   	pop    %ebp
 8049453:	c3                   	ret    

08049454 <strdup>:

char *strdup(const char *s)
{
 8049454:	55                   	push   %ebp
 8049455:	89 e5                	mov    %esp,%ebp
 8049457:	e8 65 fc ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804945c:	05 a4 5b 00 00       	add    $0x5ba4,%eax
        /* TODO - alvin */
        return NULL;
 8049461:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049466:	5d                   	pop    %ebp
 8049467:	c3                   	ret    

08049468 <strpbrk>:
 * Got this from /onnv-gate/usr/src/common/uti/string.c.
 */

char *
strpbrk(const char *string, const char *brkset)
{
 8049468:	55                   	push   %ebp
 8049469:	89 e5                	mov    %esp,%ebp
 804946b:	83 ec 10             	sub    $0x10,%esp
 804946e:	e8 4e fc ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 8049473:	05 8d 5b 00 00       	add    $0x5b8d,%eax
        const char *p;

        do {
                for (p = brkset; *p != '\0' && *p != *string; ++p)
 8049478:	8b 45 0c             	mov    0xc(%ebp),%eax
 804947b:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804947e:	eb 03                	jmp    8049483 <strpbrk+0x1b>
 8049480:	ff 45 fc             	incl   -0x4(%ebp)
 8049483:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049486:	0f b6 00             	movzbl (%eax),%eax
 8049489:	84 c0                	test   %al,%al
 804948b:	74 10                	je     804949d <strpbrk+0x35>
 804948d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049490:	0f b6 10             	movzbl (%eax),%edx
 8049493:	8b 45 08             	mov    0x8(%ebp),%eax
 8049496:	0f b6 00             	movzbl (%eax),%eax
 8049499:	38 c2                	cmp    %al,%dl
 804949b:	75 e3                	jne    8049480 <strpbrk+0x18>
                        ;
                if (*p != '\0')
 804949d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80494a0:	0f b6 00             	movzbl (%eax),%eax
 80494a3:	84 c0                	test   %al,%al
 80494a5:	74 05                	je     80494ac <strpbrk+0x44>
                        return ((char *)string);
 80494a7:	8b 45 08             	mov    0x8(%ebp),%eax
 80494aa:	eb 15                	jmp    80494c1 <strpbrk+0x59>
        } while (*string++);
 80494ac:	8b 45 08             	mov    0x8(%ebp),%eax
 80494af:	8d 50 01             	lea    0x1(%eax),%edx
 80494b2:	89 55 08             	mov    %edx,0x8(%ebp)
 80494b5:	0f b6 00             	movzbl (%eax),%eax
 80494b8:	84 c0                	test   %al,%al
 80494ba:	75 bc                	jne    8049478 <strpbrk+0x10>

        return (NULL);
 80494bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80494c1:	c9                   	leave  
 80494c2:	c3                   	ret    

080494c3 <strspn>:

size_t
strspn(const char *string, const char *charset)
{
 80494c3:	55                   	push   %ebp
 80494c4:	89 e5                	mov    %esp,%ebp
 80494c6:	83 ec 10             	sub    $0x10,%esp
 80494c9:	e8 f3 fb ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80494ce:	05 32 5b 00 00       	add    $0x5b32,%eax
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 80494d3:	8b 45 08             	mov    0x8(%ebp),%eax
 80494d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
 80494d9:	eb 32                	jmp    804950d <strspn+0x4a>
                for (p = charset; *p != '\0' && *p != *q; ++p)
 80494db:	8b 45 0c             	mov    0xc(%ebp),%eax
 80494de:	89 45 fc             	mov    %eax,-0x4(%ebp)
 80494e1:	eb 03                	jmp    80494e6 <strspn+0x23>
 80494e3:	ff 45 fc             	incl   -0x4(%ebp)
 80494e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80494e9:	0f b6 00             	movzbl (%eax),%eax
 80494ec:	84 c0                	test   %al,%al
 80494ee:	74 10                	je     8049500 <strspn+0x3d>
 80494f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80494f3:	0f b6 10             	movzbl (%eax),%edx
 80494f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
 80494f9:	0f b6 00             	movzbl (%eax),%eax
 80494fc:	38 c2                	cmp    %al,%dl
 80494fe:	75 e3                	jne    80494e3 <strspn+0x20>
                        ;
                if (*p == '\0')
 8049500:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8049503:	0f b6 00             	movzbl (%eax),%eax
 8049506:	84 c0                	test   %al,%al
 8049508:	74 0f                	je     8049519 <strspn+0x56>
size_t
strspn(const char *string, const char *charset)
{
        const char *p, *q;

        for (q = string; *q != '\0'; ++q) {
 804950a:	ff 45 f8             	incl   -0x8(%ebp)
 804950d:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8049510:	0f b6 00             	movzbl (%eax),%eax
 8049513:	84 c0                	test   %al,%al
 8049515:	75 c4                	jne    80494db <strspn+0x18>
 8049517:	eb 01                	jmp    804951a <strspn+0x57>
                for (p = charset; *p != '\0' && *p != *q; ++p)
                        ;
                if (*p == '\0')
                        break;
 8049519:	90                   	nop
        }

        return (q - string);
 804951a:	8b 55 f8             	mov    -0x8(%ebp),%edx
 804951d:	8b 45 08             	mov    0x8(%ebp),%eax
 8049520:	29 c2                	sub    %eax,%edx
 8049522:	89 d0                	mov    %edx,%eax
}
 8049524:	c9                   	leave  
 8049525:	c3                   	ret    

08049526 <strtok>:

char *
strtok(char *string, const char *sepset)
{
 8049526:	55                   	push   %ebp
 8049527:	89 e5                	mov    %esp,%ebp
 8049529:	53                   	push   %ebx
 804952a:	83 ec 24             	sub    $0x24,%esp
 804952d:	e8 97 fb ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049532:	81 c3 ce 5a 00 00    	add    $0x5ace,%ebx
        static char     *savept;

        /*
         * Set `p' to our current location in the string.
         */
        p = (string == NULL) ? savept : string;
 8049538:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804953c:	75 08                	jne    8049546 <strtok+0x20>
 804953e:	8b 83 44 02 00 00    	mov    0x244(%ebx),%eax
 8049544:	eb 03                	jmp    8049549 <strtok+0x23>
 8049546:	8b 45 08             	mov    0x8(%ebp),%eax
 8049549:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == NULL)
 804954c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049550:	75 07                	jne    8049559 <strtok+0x33>
                return (NULL);
 8049552:	b8 00 00 00 00       	mov    $0x0,%eax
 8049557:	eb 69                	jmp    80495c2 <strtok+0x9c>

        /*
         * Skip leading separators; bail if no tokens remain.
         */
        q = p + strspn(p, sepset);
 8049559:	8b 45 0c             	mov    0xc(%ebp),%eax
 804955c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049560:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049563:	89 04 24             	mov    %eax,(%esp)
 8049566:	e8 58 ff ff ff       	call   80494c3 <strspn>
 804956b:	89 c2                	mov    %eax,%edx
 804956d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049570:	01 d0                	add    %edx,%eax
 8049572:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (*q == '\0')
 8049575:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049578:	0f b6 00             	movzbl (%eax),%eax
 804957b:	84 c0                	test   %al,%al
 804957d:	75 07                	jne    8049586 <strtok+0x60>
                return (NULL);
 804957f:	b8 00 00 00 00       	mov    $0x0,%eax
 8049584:	eb 3c                	jmp    80495c2 <strtok+0x9c>

        /*
         * Mark the end of the token and set `savept' for the next iteration.
         */
        if ((r = strpbrk(q, sepset)) == NULL)
 8049586:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049589:	89 44 24 04          	mov    %eax,0x4(%esp)
 804958d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049590:	89 04 24             	mov    %eax,(%esp)
 8049593:	e8 d0 fe ff ff       	call   8049468 <strpbrk>
 8049598:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804959b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804959f:	75 0c                	jne    80495ad <strtok+0x87>
                savept = NULL;
 80495a1:	c7 83 44 02 00 00 00 	movl   $0x0,0x244(%ebx)
 80495a8:	00 00 00 
 80495ab:	eb 12                	jmp    80495bf <strtok+0x99>
        else {
                *r = '\0';
 80495ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80495b0:	c6 00 00             	movb   $0x0,(%eax)
                savept = ++r;
 80495b3:	ff 45 ec             	incl   -0x14(%ebp)
 80495b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80495b9:	89 83 44 02 00 00    	mov    %eax,0x244(%ebx)
        }

        return (q);
 80495bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
 80495c2:	83 c4 24             	add    $0x24,%esp
 80495c5:	5b                   	pop    %ebx
 80495c6:	5d                   	pop    %ebp
 80495c7:	c3                   	ret    

080495c8 <strerror>:

/* created with the help of:
 * perl -p -e 's/#define\s+(\w+)\s+\d+\s+\/\* ([^\t\*]+)\s*\*\/\s*$/case $1: return "$2";\n/' < /usr/include/sys/errno.h
 */
char *strerror(int errnum)
{
 80495c8:	55                   	push   %ebp
 80495c9:	89 e5                	mov    %esp,%ebp
 80495cb:	e8 f1 fa ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 80495d0:	05 30 5a 00 00       	add    $0x5a30,%eax
        switch (errnum) {
 80495d5:	81 7d 08 83 00 00 00 	cmpl   $0x83,0x8(%ebp)
 80495dc:	0f 87 e8 04 00 00    	ja     8049aca <.L90>
 80495e2:	8b 55 08             	mov    0x8(%ebp),%edx
 80495e5:	c1 e2 02             	shl    $0x2,%edx
 80495e8:	8b 94 02 cc ea ff ff 	mov    -0x1534(%edx,%eax,1),%edx
 80495ef:	01 c2                	add    %eax,%edx
 80495f1:	ff e2                	jmp    *%edx

080495f3 <.L91>:
                case EPERM: return "Not super-user";
 80495f3:	8d 80 10 e0 ff ff    	lea    -0x1ff0(%eax),%eax
 80495f9:	e9 d1 04 00 00       	jmp    8049acf <.L90+0x5>

080495fe <.L93>:
                case ENOENT: return "No such file or directory";
 80495fe:	8d 80 1f e0 ff ff    	lea    -0x1fe1(%eax),%eax
 8049604:	e9 c6 04 00 00       	jmp    8049acf <.L90+0x5>

08049609 <.L94>:
                case ESRCH: return "No such process";
 8049609:	8d 80 39 e0 ff ff    	lea    -0x1fc7(%eax),%eax
 804960f:	e9 bb 04 00 00       	jmp    8049acf <.L90+0x5>

08049614 <.L95>:
                case EINTR: return "interrupted system call";
 8049614:	8d 80 49 e0 ff ff    	lea    -0x1fb7(%eax),%eax
 804961a:	e9 b0 04 00 00       	jmp    8049acf <.L90+0x5>

0804961f <.L96>:
                case EIO: return "I/O error";
 804961f:	8d 80 61 e0 ff ff    	lea    -0x1f9f(%eax),%eax
 8049625:	e9 a5 04 00 00       	jmp    8049acf <.L90+0x5>

0804962a <.L97>:
                case ENXIO: return "No such device or address";
 804962a:	8d 80 6b e0 ff ff    	lea    -0x1f95(%eax),%eax
 8049630:	e9 9a 04 00 00       	jmp    8049acf <.L90+0x5>

08049635 <.L98>:
                case E2BIG: return "Arg list too long";
 8049635:	8d 80 85 e0 ff ff    	lea    -0x1f7b(%eax),%eax
 804963b:	e9 8f 04 00 00       	jmp    8049acf <.L90+0x5>

08049640 <.L99>:
                case ENOEXEC: return "Exec format error";
 8049640:	8d 80 97 e0 ff ff    	lea    -0x1f69(%eax),%eax
 8049646:	e9 84 04 00 00       	jmp    8049acf <.L90+0x5>

0804964b <.L100>:
                case EBADF: return "Bad file number";
 804964b:	8d 80 a9 e0 ff ff    	lea    -0x1f57(%eax),%eax
 8049651:	e9 79 04 00 00       	jmp    8049acf <.L90+0x5>

08049656 <.L101>:
                case ECHILD: return "No children";
 8049656:	8d 80 b9 e0 ff ff    	lea    -0x1f47(%eax),%eax
 804965c:	e9 6e 04 00 00       	jmp    8049acf <.L90+0x5>

08049661 <.L102>:
                case EAGAIN: return "Resource temporarily unavailable";
 8049661:	8d 80 c8 e0 ff ff    	lea    -0x1f38(%eax),%eax
 8049667:	e9 63 04 00 00       	jmp    8049acf <.L90+0x5>

0804966c <.L103>:
                case ENOMEM: return "Not enough core";
 804966c:	8d 80 e9 e0 ff ff    	lea    -0x1f17(%eax),%eax
 8049672:	e9 58 04 00 00       	jmp    8049acf <.L90+0x5>

08049677 <.L104>:
                case EACCES: return "Permission denied";
 8049677:	8d 80 f9 e0 ff ff    	lea    -0x1f07(%eax),%eax
 804967d:	e9 4d 04 00 00       	jmp    8049acf <.L90+0x5>

08049682 <.L105>:
                case EFAULT: return "Bad address";
 8049682:	8d 80 0b e1 ff ff    	lea    -0x1ef5(%eax),%eax
 8049688:	e9 42 04 00 00       	jmp    8049acf <.L90+0x5>

0804968d <.L106>:
                case ENOTBLK: return "Block device required";
 804968d:	8d 80 17 e1 ff ff    	lea    -0x1ee9(%eax),%eax
 8049693:	e9 37 04 00 00       	jmp    8049acf <.L90+0x5>

08049698 <.L107>:
                case EBUSY: return "Mount device busy";
 8049698:	8d 80 2d e1 ff ff    	lea    -0x1ed3(%eax),%eax
 804969e:	e9 2c 04 00 00       	jmp    8049acf <.L90+0x5>

080496a3 <.L108>:
                case EEXIST: return "File exists";
 80496a3:	8d 80 3f e1 ff ff    	lea    -0x1ec1(%eax),%eax
 80496a9:	e9 21 04 00 00       	jmp    8049acf <.L90+0x5>

080496ae <.L109>:
                case EXDEV: return "Cross-device link";
 80496ae:	8d 80 4b e1 ff ff    	lea    -0x1eb5(%eax),%eax
 80496b4:	e9 16 04 00 00       	jmp    8049acf <.L90+0x5>

080496b9 <.L110>:
                case ENODEV: return "No such device";
 80496b9:	8d 80 5d e1 ff ff    	lea    -0x1ea3(%eax),%eax
 80496bf:	e9 0b 04 00 00       	jmp    8049acf <.L90+0x5>

080496c4 <.L111>:
                case ENOTDIR: return "Not a directory";
 80496c4:	8d 80 6c e1 ff ff    	lea    -0x1e94(%eax),%eax
 80496ca:	e9 00 04 00 00       	jmp    8049acf <.L90+0x5>

080496cf <.L112>:
                case EISDIR: return "Is a directory";
 80496cf:	8d 80 7c e1 ff ff    	lea    -0x1e84(%eax),%eax
 80496d5:	e9 f5 03 00 00       	jmp    8049acf <.L90+0x5>

080496da <.L113>:
                case EINVAL: return "Invalid argument";
 80496da:	8d 80 8b e1 ff ff    	lea    -0x1e75(%eax),%eax
 80496e0:	e9 ea 03 00 00       	jmp    8049acf <.L90+0x5>

080496e5 <.L114>:
                case ENFILE: return "File table overflow";
 80496e5:	8d 80 9c e1 ff ff    	lea    -0x1e64(%eax),%eax
 80496eb:	e9 df 03 00 00       	jmp    8049acf <.L90+0x5>

080496f0 <.L115>:
                case EMFILE: return "Too many open files";
 80496f0:	8d 80 b0 e1 ff ff    	lea    -0x1e50(%eax),%eax
 80496f6:	e9 d4 03 00 00       	jmp    8049acf <.L90+0x5>

080496fb <.L116>:
                case ENOTTY: return "Inappropriate ioctl for device";
 80496fb:	8d 80 c4 e1 ff ff    	lea    -0x1e3c(%eax),%eax
 8049701:	e9 c9 03 00 00       	jmp    8049acf <.L90+0x5>

08049706 <.L117>:
                case ETXTBSY: return "Text file busy";
 8049706:	8d 80 e3 e1 ff ff    	lea    -0x1e1d(%eax),%eax
 804970c:	e9 be 03 00 00       	jmp    8049acf <.L90+0x5>

08049711 <.L118>:
                case EFBIG: return "File too large";
 8049711:	8d 80 f2 e1 ff ff    	lea    -0x1e0e(%eax),%eax
 8049717:	e9 b3 03 00 00       	jmp    8049acf <.L90+0x5>

0804971c <.L119>:
                case ENOSPC: return "No space left on device";
 804971c:	8d 80 01 e2 ff ff    	lea    -0x1dff(%eax),%eax
 8049722:	e9 a8 03 00 00       	jmp    8049acf <.L90+0x5>

08049727 <.L120>:
                case ESPIPE: return "Illegal seek";
 8049727:	8d 80 19 e2 ff ff    	lea    -0x1de7(%eax),%eax
 804972d:	e9 9d 03 00 00       	jmp    8049acf <.L90+0x5>

08049732 <.L121>:
                case EROFS: return "Read only file system";
 8049732:	8d 80 26 e2 ff ff    	lea    -0x1dda(%eax),%eax
 8049738:	e9 92 03 00 00       	jmp    8049acf <.L90+0x5>

0804973d <.L122>:
                case EMLINK: return "Too many links";
 804973d:	8d 80 3c e2 ff ff    	lea    -0x1dc4(%eax),%eax
 8049743:	e9 87 03 00 00       	jmp    8049acf <.L90+0x5>

08049748 <.L123>:
                case EPIPE: return "Broken pipe";
 8049748:	8d 80 4b e2 ff ff    	lea    -0x1db5(%eax),%eax
 804974e:	e9 7c 03 00 00       	jmp    8049acf <.L90+0x5>

08049753 <.L124>:
                case EDOM: return "Math arg out of domain of func";
 8049753:	8d 80 58 e2 ff ff    	lea    -0x1da8(%eax),%eax
 8049759:	e9 71 03 00 00       	jmp    8049acf <.L90+0x5>

0804975e <.L125>:
                case ERANGE: return "Math result not representable";
 804975e:	8d 80 77 e2 ff ff    	lea    -0x1d89(%eax),%eax
 8049764:	e9 66 03 00 00       	jmp    8049acf <.L90+0x5>

08049769 <.L132>:
                case ENOMSG: return "No message of desired type";
 8049769:	8d 80 95 e2 ff ff    	lea    -0x1d6b(%eax),%eax
 804976f:	e9 5b 03 00 00       	jmp    8049acf <.L90+0x5>

08049774 <.L133>:
                case EIDRM: return "Identifier removed";
 8049774:	8d 80 b0 e2 ff ff    	lea    -0x1d50(%eax),%eax
 804977a:	e9 50 03 00 00       	jmp    8049acf <.L90+0x5>

0804977f <.L134>:
                case ECHRNG: return "Channel number out of range";
 804977f:	8d 80 c3 e2 ff ff    	lea    -0x1d3d(%eax),%eax
 8049785:	e9 45 03 00 00       	jmp    8049acf <.L90+0x5>

0804978a <.L135>:
                case EL2NSYNC: return "Level 2 not synchronized";
 804978a:	8d 80 df e2 ff ff    	lea    -0x1d21(%eax),%eax
 8049790:	e9 3a 03 00 00       	jmp    8049acf <.L90+0x5>

08049795 <.L136>:
                case EL3HLT: return "Level 3 halted";
 8049795:	8d 80 f8 e2 ff ff    	lea    -0x1d08(%eax),%eax
 804979b:	e9 2f 03 00 00       	jmp    8049acf <.L90+0x5>

080497a0 <.L137>:
                case EL3RST: return "Level 3 reset";
 80497a0:	8d 80 07 e3 ff ff    	lea    -0x1cf9(%eax),%eax
 80497a6:	e9 24 03 00 00       	jmp    8049acf <.L90+0x5>

080497ab <.L138>:
                case ELNRNG: return "Link number out of range";
 80497ab:	8d 80 15 e3 ff ff    	lea    -0x1ceb(%eax),%eax
 80497b1:	e9 19 03 00 00       	jmp    8049acf <.L90+0x5>

080497b6 <.L139>:
                case EUNATCH: return "Protocol driver not attached";
 80497b6:	8d 80 2e e3 ff ff    	lea    -0x1cd2(%eax),%eax
 80497bc:	e9 0e 03 00 00       	jmp    8049acf <.L90+0x5>

080497c1 <.L140>:
                case ENOCSI: return "No CSI structure available";
 80497c1:	8d 80 4b e3 ff ff    	lea    -0x1cb5(%eax),%eax
 80497c7:	e9 03 03 00 00       	jmp    8049acf <.L90+0x5>

080497cc <.L141>:
                case EL2HLT: return "Level 2 halted";
 80497cc:	8d 80 66 e3 ff ff    	lea    -0x1c9a(%eax),%eax
 80497d2:	e9 f8 02 00 00       	jmp    8049acf <.L90+0x5>

080497d7 <.L126>:
                case EDEADLK: return "Deadlock condition.";
 80497d7:	8d 80 75 e3 ff ff    	lea    -0x1c8b(%eax),%eax
 80497dd:	e9 ed 02 00 00       	jmp    8049acf <.L90+0x5>

080497e2 <.L128>:
                case ENOLCK: return "No record locks available.";
 80497e2:	8d 80 89 e3 ff ff    	lea    -0x1c77(%eax),%eax
 80497e8:	e9 e2 02 00 00       	jmp    8049acf <.L90+0x5>

080497ed <.L206>:
                case ECANCELED: return "Operation canceled";
 80497ed:	8d 80 a4 e3 ff ff    	lea    -0x1c5c(%eax),%eax
 80497f3:	e9 d7 02 00 00       	jmp    8049acf <.L90+0x5>

080497f8 <.L183>:
                case ENOTSUP: return "Operation not supported";
 80497f8:	8d 80 b7 e3 ff ff    	lea    -0x1c49(%eax),%eax
 80497fe:	e9 cc 02 00 00       	jmp    8049acf <.L90+0x5>

08049803 <.L205>:
                case EDQUOT: return "Disc quota exceeded";
 8049803:	8d 80 cf e3 ff ff    	lea    -0x1c31(%eax),%eax
 8049809:	e9 c1 02 00 00       	jmp    8049acf <.L90+0x5>

0804980e <.L142>:
                case EBADE: return "invalid exchange";
 804980e:	8d 80 e3 e3 ff ff    	lea    -0x1c1d(%eax),%eax
 8049814:	e9 b6 02 00 00       	jmp    8049acf <.L90+0x5>

08049819 <.L143>:
                case EBADR: return "invalid request descriptor";
 8049819:	8d 80 f4 e3 ff ff    	lea    -0x1c0c(%eax),%eax
 804981f:	e9 ab 02 00 00       	jmp    8049acf <.L90+0x5>

08049824 <.L144>:
                case EXFULL: return "exchange full";
 8049824:	8d 80 0f e4 ff ff    	lea    -0x1bf1(%eax),%eax
 804982a:	e9 a0 02 00 00       	jmp    8049acf <.L90+0x5>

0804982f <.L145>:
                case ENOANO: return "no anode";
 804982f:	8d 80 1d e4 ff ff    	lea    -0x1be3(%eax),%eax
 8049835:	e9 95 02 00 00       	jmp    8049acf <.L90+0x5>

0804983a <.L146>:
                case EBADRQC: return "invalid request code";
 804983a:	8d 80 26 e4 ff ff    	lea    -0x1bda(%eax),%eax
 8049840:	e9 8a 02 00 00       	jmp    8049acf <.L90+0x5>

08049845 <.L147>:
                case EBADSLT: return "invalid slot";
 8049845:	8d 80 3b e4 ff ff    	lea    -0x1bc5(%eax),%eax
 804984b:	e9 7f 02 00 00       	jmp    8049acf <.L90+0x5>

08049850 <.L148>:
                case EBFONT: return "bad font file fmt";
 8049850:	8d 80 48 e4 ff ff    	lea    -0x1bb8(%eax),%eax
 8049856:	e9 74 02 00 00       	jmp    8049acf <.L90+0x5>

0804985b <.L207>:
                case EOWNERDEAD: return "process died with the lock";
 804985b:	8d 80 5a e4 ff ff    	lea    -0x1ba6(%eax),%eax
 8049861:	e9 69 02 00 00       	jmp    8049acf <.L90+0x5>

08049866 <.L208>:
                case ENOTRECOVERABLE: return "lock is not recoverable";
 8049866:	8d 80 75 e4 ff ff    	lea    -0x1b8b(%eax),%eax
 804986c:	e9 5e 02 00 00       	jmp    8049acf <.L90+0x5>

08049871 <.L149>:
                case ENOSTR: return "Device not a stream";
 8049871:	8d 80 8d e4 ff ff    	lea    -0x1b73(%eax),%eax
 8049877:	e9 53 02 00 00       	jmp    8049acf <.L90+0x5>

0804987c <.L150>:
                case ENODATA: return "no data (for no delay io)";
 804987c:	8d 80 a1 e4 ff ff    	lea    -0x1b5f(%eax),%eax
 8049882:	e9 48 02 00 00       	jmp    8049acf <.L90+0x5>

08049887 <.L151>:
                case ETIME: return "timer expired";
 8049887:	8d 80 bb e4 ff ff    	lea    -0x1b45(%eax),%eax
 804988d:	e9 3d 02 00 00       	jmp    8049acf <.L90+0x5>

08049892 <.L152>:
                case ENOSR: return "out of streams resources";
 8049892:	8d 80 c9 e4 ff ff    	lea    -0x1b37(%eax),%eax
 8049898:	e9 32 02 00 00       	jmp    8049acf <.L90+0x5>

0804989d <.L153>:
                case ENONET: return "Machine is not on the network";
 804989d:	8d 80 e2 e4 ff ff    	lea    -0x1b1e(%eax),%eax
 80498a3:	e9 27 02 00 00       	jmp    8049acf <.L90+0x5>

080498a8 <.L154>:
                case ENOPKG: return "Package not installed";
 80498a8:	8d 80 00 e5 ff ff    	lea    -0x1b00(%eax),%eax
 80498ae:	e9 1c 02 00 00       	jmp    8049acf <.L90+0x5>

080498b3 <.L155>:
                case EREMOTE: return "The object is remote";
 80498b3:	8d 80 16 e5 ff ff    	lea    -0x1aea(%eax),%eax
 80498b9:	e9 11 02 00 00       	jmp    8049acf <.L90+0x5>

080498be <.L156>:
                case ENOLINK: return "the link has been severed";
 80498be:	8d 80 2b e5 ff ff    	lea    -0x1ad5(%eax),%eax
 80498c4:	e9 06 02 00 00       	jmp    8049acf <.L90+0x5>

080498c9 <.L157>:
                case EADV: return "advertise error";
 80498c9:	8d 80 45 e5 ff ff    	lea    -0x1abb(%eax),%eax
 80498cf:	e9 fb 01 00 00       	jmp    8049acf <.L90+0x5>

080498d4 <.L158>:
                case ESRMNT: return "srmount error";
 80498d4:	8d 80 55 e5 ff ff    	lea    -0x1aab(%eax),%eax
 80498da:	e9 f0 01 00 00       	jmp    8049acf <.L90+0x5>

080498df <.L159>:
                case ECOMM: return "Communication error on send";
 80498df:	8d 80 63 e5 ff ff    	lea    -0x1a9d(%eax),%eax
 80498e5:	e9 e5 01 00 00       	jmp    8049acf <.L90+0x5>

080498ea <.L160>:
                case EPROTO: return "Protocol error";
 80498ea:	8d 80 7f e5 ff ff    	lea    -0x1a81(%eax),%eax
 80498f0:	e9 da 01 00 00       	jmp    8049acf <.L90+0x5>

080498f5 <.L161>:
                case EMULTIHOP: return "multihop attempted";
 80498f5:	8d 80 8e e5 ff ff    	lea    -0x1a72(%eax),%eax
 80498fb:	e9 cf 01 00 00       	jmp    8049acf <.L90+0x5>

08049900 <.L162>:
                case EBADMSG: return "trying to read unreadable message";
 8049900:	8d 80 a4 e5 ff ff    	lea    -0x1a5c(%eax),%eax
 8049906:	e9 c4 01 00 00       	jmp    8049acf <.L90+0x5>

0804990b <.L127>:
                case ENAMETOOLONG: return "path name is too long";
 804990b:	8d 80 c6 e5 ff ff    	lea    -0x1a3a(%eax),%eax
 8049911:	e9 b9 01 00 00       	jmp    8049acf <.L90+0x5>

08049916 <.L163>:
                case EOVERFLOW: return "value too large to be stored in data type";
 8049916:	8d 80 dc e5 ff ff    	lea    -0x1a24(%eax),%eax
 804991c:	e9 ae 01 00 00       	jmp    8049acf <.L90+0x5>

08049921 <.L164>:
                case ENOTUNIQ: return "given log. name not unique";
 8049921:	8d 80 06 e6 ff ff    	lea    -0x19fa(%eax),%eax
 8049927:	e9 a3 01 00 00       	jmp    8049acf <.L90+0x5>

0804992c <.L165>:
                case EBADFD: return "f.d. invalid for this operation";
 804992c:	8d 80 24 e6 ff ff    	lea    -0x19dc(%eax),%eax
 8049932:	e9 98 01 00 00       	jmp    8049acf <.L90+0x5>

08049937 <.L166>:
                case EREMCHG: return "Remote address changed";
 8049937:	8d 80 44 e6 ff ff    	lea    -0x19bc(%eax),%eax
 804993d:	e9 8d 01 00 00       	jmp    8049acf <.L90+0x5>

08049942 <.L167>:
                case ELIBACC: return "Can't access a needed shared lib.";
 8049942:	8d 80 5c e6 ff ff    	lea    -0x19a4(%eax),%eax
 8049948:	e9 82 01 00 00       	jmp    8049acf <.L90+0x5>

0804994d <.L168>:
                case ELIBBAD: return "Accessing a corrupted shared lib.";
 804994d:	8d 80 80 e6 ff ff    	lea    -0x1980(%eax),%eax
 8049953:	e9 77 01 00 00       	jmp    8049acf <.L90+0x5>

08049958 <.L169>:
                case ELIBSCN: return ".lib section in a.out corrupted.";
 8049958:	8d 80 a4 e6 ff ff    	lea    -0x195c(%eax),%eax
 804995e:	e9 6c 01 00 00       	jmp    8049acf <.L90+0x5>

08049963 <.L170>:
                case ELIBMAX: return "Attempting to link in too many libs.";
 8049963:	8d 80 c8 e6 ff ff    	lea    -0x1938(%eax),%eax
 8049969:	e9 61 01 00 00       	jmp    8049acf <.L90+0x5>

0804996e <.L171>:
                case ELIBEXEC: return "Attempting to exec a shared library.";
 804996e:	8d 80 f0 e6 ff ff    	lea    -0x1910(%eax),%eax
 8049974:	e9 56 01 00 00       	jmp    8049acf <.L90+0x5>

08049979 <.L172>:
                case EILSEQ: return "Illegal byte sequence.";
 8049979:	8d 80 15 e7 ff ff    	lea    -0x18eb(%eax),%eax
 804997f:	e9 4b 01 00 00       	jmp    8049acf <.L90+0x5>

08049984 <.L129>:
                case ENOSYS: return "Unsupported file system operation";
 8049984:	8d 80 2c e7 ff ff    	lea    -0x18d4(%eax),%eax
 804998a:	e9 40 01 00 00       	jmp    8049acf <.L90+0x5>

0804998f <.L131>:
                case ELOOP: return "Symbolic link loop";
 804998f:	8d 80 4e e7 ff ff    	lea    -0x18b2(%eax),%eax
 8049995:	e9 35 01 00 00       	jmp    8049acf <.L90+0x5>

0804999a <.L173>:
                case ERESTART: return "Restartable system call";
 804999a:	8d 80 61 e7 ff ff    	lea    -0x189f(%eax),%eax
 80499a0:	e9 2a 01 00 00       	jmp    8049acf <.L90+0x5>

080499a5 <.L174>:
                case ESTRPIPE: return "if pipe/FIFO, don't sleep in stream head";
 80499a5:	8d 80 7c e7 ff ff    	lea    -0x1884(%eax),%eax
 80499ab:	e9 1f 01 00 00       	jmp    8049acf <.L90+0x5>

080499b0 <.L130>:
                case ENOTEMPTY: return "directory not empty";
 80499b0:	8d 80 a5 e7 ff ff    	lea    -0x185b(%eax),%eax
 80499b6:	e9 14 01 00 00       	jmp    8049acf <.L90+0x5>

080499bb <.L175>:
                case EUSERS: return "Too many users (for UFS)";
 80499bb:	8d 80 b9 e7 ff ff    	lea    -0x1847(%eax),%eax
 80499c1:	e9 09 01 00 00       	jmp    8049acf <.L90+0x5>

080499c6 <.L176>:
                case ENOTSOCK: return "Socket operation on non-socket";
 80499c6:	8d 80 d4 e7 ff ff    	lea    -0x182c(%eax),%eax
 80499cc:	e9 fe 00 00 00       	jmp    8049acf <.L90+0x5>

080499d1 <.L177>:
                case EDESTADDRREQ: return "Destination address required";
 80499d1:	8d 80 f3 e7 ff ff    	lea    -0x180d(%eax),%eax
 80499d7:	e9 f3 00 00 00       	jmp    8049acf <.L90+0x5>

080499dc <.L178>:
                case EMSGSIZE: return "Message too long";
 80499dc:	8d 80 10 e8 ff ff    	lea    -0x17f0(%eax),%eax
 80499e2:	e9 e8 00 00 00       	jmp    8049acf <.L90+0x5>

080499e7 <.L179>:
                case EPROTOTYPE: return "Protocol wrong type for socket";
 80499e7:	8d 80 24 e8 ff ff    	lea    -0x17dc(%eax),%eax
 80499ed:	e9 dd 00 00 00       	jmp    8049acf <.L90+0x5>

080499f2 <.L180>:
                case ENOPROTOOPT: return "Protocol not available";
 80499f2:	8d 80 43 e8 ff ff    	lea    -0x17bd(%eax),%eax
 80499f8:	e9 d2 00 00 00       	jmp    8049acf <.L90+0x5>

080499fd <.L181>:
                case EPROTONOSUPPORT: return "Protocol not supported";
 80499fd:	8d 80 5a e8 ff ff    	lea    -0x17a6(%eax),%eax
 8049a03:	e9 c7 00 00 00       	jmp    8049acf <.L90+0x5>

08049a08 <.L182>:
                case ESOCKTNOSUPPORT: return "Socket type not supported";
 8049a08:	8d 80 71 e8 ff ff    	lea    -0x178f(%eax),%eax
 8049a0e:	e9 bc 00 00 00       	jmp    8049acf <.L90+0x5>

08049a13 <.L184>:
                case EPFNOSUPPORT: return "Protocol family not supported";
 8049a13:	8d 80 8b e8 ff ff    	lea    -0x1775(%eax),%eax
 8049a19:	e9 b1 00 00 00       	jmp    8049acf <.L90+0x5>

08049a1e <.L185>:
                case EAFNOSUPPORT: return "Address family not supported by protocol family";
 8049a1e:	8d 80 ac e8 ff ff    	lea    -0x1754(%eax),%eax
 8049a24:	e9 a6 00 00 00       	jmp    8049acf <.L90+0x5>

08049a29 <.L186>:
                case EADDRINUSE: return "Address already in use";
 8049a29:	8d 80 dc e8 ff ff    	lea    -0x1724(%eax),%eax
 8049a2f:	e9 9b 00 00 00       	jmp    8049acf <.L90+0x5>

08049a34 <.L187>:
                case EADDRNOTAVAIL: return "Can't assign requested address";
 8049a34:	8d 80 f4 e8 ff ff    	lea    -0x170c(%eax),%eax
 8049a3a:	e9 90 00 00 00       	jmp    8049acf <.L90+0x5>

08049a3f <.L188>:
                case ENETDOWN: return "Network is down";
 8049a3f:	8d 80 13 e9 ff ff    	lea    -0x16ed(%eax),%eax
 8049a45:	e9 85 00 00 00       	jmp    8049acf <.L90+0x5>

08049a4a <.L189>:
                case ENETUNREACH: return "Network is unreachable";
 8049a4a:	8d 80 23 e9 ff ff    	lea    -0x16dd(%eax),%eax
 8049a50:	eb 7d                	jmp    8049acf <.L90+0x5>

08049a52 <.L190>:
                case ENETRESET: return "Network dropped connection because of reset";
 8049a52:	8d 80 3c e9 ff ff    	lea    -0x16c4(%eax),%eax
 8049a58:	eb 75                	jmp    8049acf <.L90+0x5>

08049a5a <.L191>:
                case ECONNABORTED: return "Software caused connection abort";
 8049a5a:	8d 80 68 e9 ff ff    	lea    -0x1698(%eax),%eax
 8049a60:	eb 6d                	jmp    8049acf <.L90+0x5>

08049a62 <.L192>:
                case ECONNRESET: return "Connection reset by peer";
 8049a62:	8d 80 89 e9 ff ff    	lea    -0x1677(%eax),%eax
 8049a68:	eb 65                	jmp    8049acf <.L90+0x5>

08049a6a <.L193>:
                case ENOBUFS: return "No buffer space available";
 8049a6a:	8d 80 a2 e9 ff ff    	lea    -0x165e(%eax),%eax
 8049a70:	eb 5d                	jmp    8049acf <.L90+0x5>

08049a72 <.L194>:
                case EISCONN: return "Socket is already connected";
 8049a72:	8d 80 bc e9 ff ff    	lea    -0x1644(%eax),%eax
 8049a78:	eb 55                	jmp    8049acf <.L90+0x5>

08049a7a <.L195>:
                case ENOTCONN: return "Socket is not connected";
 8049a7a:	8d 80 d8 e9 ff ff    	lea    -0x1628(%eax),%eax
 8049a80:	eb 4d                	jmp    8049acf <.L90+0x5>

08049a82 <.L196>:
                case ESHUTDOWN: return "Can't send after socket shutdown";
 8049a82:	8d 80 f0 e9 ff ff    	lea    -0x1610(%eax),%eax
 8049a88:	eb 45                	jmp    8049acf <.L90+0x5>

08049a8a <.L197>:
                case ETOOMANYREFS: return "Too many references: can't splice";
 8049a8a:	8d 80 14 ea ff ff    	lea    -0x15ec(%eax),%eax
 8049a90:	eb 3d                	jmp    8049acf <.L90+0x5>

08049a92 <.L198>:
                case ETIMEDOUT: return "Connection timed out";
 8049a92:	8d 80 36 ea ff ff    	lea    -0x15ca(%eax),%eax
 8049a98:	eb 35                	jmp    8049acf <.L90+0x5>

08049a9a <.L199>:
                case ECONNREFUSED: return "Connection refused";
 8049a9a:	8d 80 4b ea ff ff    	lea    -0x15b5(%eax),%eax
 8049aa0:	eb 2d                	jmp    8049acf <.L90+0x5>

08049aa2 <.L200>:
                case EHOSTDOWN: return "Host is down";
 8049aa2:	8d 80 5e ea ff ff    	lea    -0x15a2(%eax),%eax
 8049aa8:	eb 25                	jmp    8049acf <.L90+0x5>

08049aaa <.L201>:
                case EHOSTUNREACH: return "No route to host";
 8049aaa:	8d 80 6b ea ff ff    	lea    -0x1595(%eax),%eax
 8049ab0:	eb 1d                	jmp    8049acf <.L90+0x5>

08049ab2 <.L202>:
                case EALREADY: return "operation already in progress";
 8049ab2:	8d 80 7c ea ff ff    	lea    -0x1584(%eax),%eax
 8049ab8:	eb 15                	jmp    8049acf <.L90+0x5>

08049aba <.L203>:
                case EINPROGRESS: return "operation now in progress";
 8049aba:	8d 80 9a ea ff ff    	lea    -0x1566(%eax),%eax
 8049ac0:	eb 0d                	jmp    8049acf <.L90+0x5>

08049ac2 <.L204>:
                case ESTALE: return "Stale NFS file handle";
 8049ac2:	8d 80 b4 ea ff ff    	lea    -0x154c(%eax),%eax
 8049ac8:	eb 05                	jmp    8049acf <.L90+0x5>

08049aca <.L90>:
                default: return 0;
 8049aca:	b8 00 00 00 00       	mov    $0x0,%eax
        }
}
 8049acf:	5d                   	pop    %ebp
 8049ad0:	c3                   	ret    

08049ad1 <wrterror>:
#define abort() exit(1)
#endif

static void
wrterror(char *p)
{
 8049ad1:	55                   	push   %ebp
 8049ad2:	89 e5                	mov    %esp,%ebp
 8049ad4:	53                   	push   %ebx
 8049ad5:	83 ec 24             	sub    $0x24,%esp
 8049ad8:	e8 ec f5 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049add:	81 c3 23 55 00 00    	add    $0x5523,%ebx
        char *q = " error: ";
 8049ae3:	8d 83 dd ec ff ff    	lea    -0x1323(%ebx),%eax
 8049ae9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        _write(STDERR_FILENO, __progname, strlen(__progname));
 8049aec:	8b 83 38 00 00 00    	mov    0x38(%ebx),%eax
 8049af2:	89 04 24             	mov    %eax,(%esp)
 8049af5:	e8 40 f8 ff ff       	call   804933a <strlen>
 8049afa:	89 c2                	mov    %eax,%edx
 8049afc:	8b 83 38 00 00 00    	mov    0x38(%ebx),%eax
 8049b02:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049b06:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b0a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b11:	e8 2c ee ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 8049b16:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 8049b1c:	89 04 24             	mov    %eax,(%esp)
 8049b1f:	e8 16 f8 ff ff       	call   804933a <strlen>
 8049b24:	89 c2                	mov    %eax,%edx
 8049b26:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 8049b2c:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049b30:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b34:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b3b:	e8 02 ee ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, q, strlen(q));
 8049b40:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b43:	89 04 24             	mov    %eax,(%esp)
 8049b46:	e8 ef f7 ff ff       	call   804933a <strlen>
 8049b4b:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b52:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b56:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b5d:	e8 e0 ed ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, p, strlen(p));
 8049b62:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b65:	89 04 24             	mov    %eax,(%esp)
 8049b68:	e8 cd f7 ff ff       	call   804933a <strlen>
 8049b6d:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b71:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b74:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b78:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049b7f:	e8 be ed ff ff       	call   8048942 <write>
        suicide = 1;
 8049b84:	c7 83 7c 02 00 00 01 	movl   $0x1,0x27c(%ebx)
 8049b8b:	00 00 00 
        abort();
 8049b8e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049b95:	e8 c4 e9 ff ff       	call   804855e <exit>
}
 8049b9a:	90                   	nop
 8049b9b:	83 c4 24             	add    $0x24,%esp
 8049b9e:	5b                   	pop    %ebx
 8049b9f:	5d                   	pop    %ebp
 8049ba0:	c3                   	ret    

08049ba1 <wrtwarning>:

static void
wrtwarning(char *p)
{
 8049ba1:	55                   	push   %ebp
 8049ba2:	89 e5                	mov    %esp,%ebp
 8049ba4:	53                   	push   %ebx
 8049ba5:	83 ec 24             	sub    $0x24,%esp
 8049ba8:	e8 1c f5 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049bad:	81 c3 53 54 00 00    	add    $0x5453,%ebx
        char *q = " warning: ";
 8049bb3:	8d 83 e6 ec ff ff    	lea    -0x131a(%ebx),%eax
 8049bb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (malloc_abort)
 8049bbc:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 8049bc2:	85 c0                	test   %eax,%eax
 8049bc4:	74 0b                	je     8049bd1 <wrtwarning+0x30>
                wrterror(p);
 8049bc6:	8b 45 08             	mov    0x8(%ebp),%eax
 8049bc9:	89 04 24             	mov    %eax,(%esp)
 8049bcc:	e8 00 ff ff ff       	call   8049ad1 <wrterror>
        _write(STDERR_FILENO, __progname, strlen(__progname));
 8049bd1:	8b 83 38 00 00 00    	mov    0x38(%ebx),%eax
 8049bd7:	89 04 24             	mov    %eax,(%esp)
 8049bda:	e8 5b f7 ff ff       	call   804933a <strlen>
 8049bdf:	89 c2                	mov    %eax,%edx
 8049be1:	8b 83 38 00 00 00    	mov    0x38(%ebx),%eax
 8049be7:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049beb:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049bef:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049bf6:	e8 47 ed ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, malloc_func, strlen(malloc_func));
 8049bfb:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 8049c01:	89 04 24             	mov    %eax,(%esp)
 8049c04:	e8 31 f7 ff ff       	call   804933a <strlen>
 8049c09:	89 c2                	mov    %eax,%edx
 8049c0b:	8b 83 a0 02 00 00    	mov    0x2a0(%ebx),%eax
 8049c11:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049c15:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c19:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049c20:	e8 1d ed ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, q, strlen(q));
 8049c25:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c28:	89 04 24             	mov    %eax,(%esp)
 8049c2b:	e8 0a f7 ff ff       	call   804933a <strlen>
 8049c30:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049c34:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049c37:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c3b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049c42:	e8 fb ec ff ff       	call   8048942 <write>
        _write(STDERR_FILENO, p, strlen(p));
 8049c47:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c4a:	89 04 24             	mov    %eax,(%esp)
 8049c4d:	e8 e8 f6 ff ff       	call   804933a <strlen>
 8049c52:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049c56:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c59:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c5d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 8049c64:	e8 d9 ec ff ff       	call   8048942 <write>
}
 8049c69:	90                   	nop
 8049c6a:	83 c4 24             	add    $0x24,%esp
 8049c6d:	5b                   	pop    %ebx
 8049c6e:	5d                   	pop    %ebp
 8049c6f:	c3                   	ret    

08049c70 <map_pages>:
/*
 * Allocate a number of pages from the OS
 */
static void *
map_pages(int pages)
{
 8049c70:	55                   	push   %ebp
 8049c71:	89 e5                	mov    %esp,%ebp
 8049c73:	53                   	push   %ebx
 8049c74:	83 ec 24             	sub    $0x24,%esp
 8049c77:	e8 4d f4 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049c7c:	81 c3 84 53 00 00    	add    $0x5384,%ebx
        caddr_t result, tail;

        result = (caddr_t)pageround((u_long)sbrk(0));
 8049c82:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049c89:	e8 e1 e6 ff ff       	call   804836f <sbrk>
 8049c8e:	05 ff 0f 00 00       	add    $0xfff,%eax
 8049c93:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 8049c98:	89 45 f4             	mov    %eax,-0xc(%ebp)
        tail = result + (pages << malloc_pageshift);
 8049c9b:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c9e:	c1 e0 0c             	shl    $0xc,%eax
 8049ca1:	89 c2                	mov    %eax,%edx
 8049ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ca6:	01 d0                	add    %edx,%eax
 8049ca8:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (brk(tail)) {
 8049cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049cae:	89 04 24             	mov    %eax,(%esp)
 8049cb1:	e8 82 e7 ff ff       	call   8048438 <brk>
 8049cb6:	85 c0                	test   %eax,%eax
 8049cb8:	74 07                	je     8049cc1 <map_pages+0x51>
#ifdef EXTRA_SANITY
                wrterror("(ES): map_pages fails\n");
#endif /* EXTRA_SANITY */
                return 0;
 8049cba:	b8 00 00 00 00       	mov    $0x0,%eax
 8049cbf:	eb 51                	jmp    8049d12 <map_pages+0xa2>
        }

        last_index = ptr2index(tail) - 1;
 8049cc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049cc4:	c1 e8 0c             	shr    $0xc,%eax
 8049cc7:	89 c2                	mov    %eax,%edx
 8049cc9:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 8049ccf:	29 c2                	sub    %eax,%edx
 8049cd1:	89 d0                	mov    %edx,%eax
 8049cd3:	48                   	dec    %eax
 8049cd4:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)
        malloc_brk = tail;
 8049cda:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049cdd:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)

        if ((last_index + 1) >= malloc_ninfo && !extend_pgdir(last_index))
 8049ce3:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 8049ce9:	8d 50 01             	lea    0x1(%eax),%edx
 8049cec:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049cf2:	39 c2                	cmp    %eax,%edx
 8049cf4:	72 19                	jb     8049d0f <map_pages+0x9f>
 8049cf6:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 8049cfc:	89 04 24             	mov    %eax,(%esp)
 8049cff:	e8 14 00 00 00       	call   8049d18 <extend_pgdir>
 8049d04:	85 c0                	test   %eax,%eax
 8049d06:	75 07                	jne    8049d0f <map_pages+0x9f>
                return 0;;
 8049d08:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d0d:	eb 03                	jmp    8049d12 <map_pages+0xa2>

        return result;
 8049d0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049d12:	83 c4 24             	add    $0x24,%esp
 8049d15:	5b                   	pop    %ebx
 8049d16:	5d                   	pop    %ebp
 8049d17:	c3                   	ret    

08049d18 <extend_pgdir>:
/*
 * Extend page directory
 */
static int
extend_pgdir(u_long index)
{
 8049d18:	55                   	push   %ebp
 8049d19:	89 e5                	mov    %esp,%ebp
 8049d1b:	53                   	push   %ebx
 8049d1c:	83 ec 34             	sub    $0x34,%esp
 8049d1f:	e8 a5 f3 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049d24:	81 c3 dc 52 00 00    	add    $0x52dc,%ebx
        struct  pginfo **new, **old;
        int i, oldlen;

        /* Make it this many pages */
        i = index * sizeof * page_dir;
 8049d2a:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d2d:	c1 e0 02             	shl    $0x2,%eax
 8049d30:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i /= malloc_pagesize;
 8049d33:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049d36:	c1 e8 0c             	shr    $0xc,%eax
 8049d39:	89 45 f4             	mov    %eax,-0xc(%ebp)
        i += 2;
 8049d3c:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)

        /* remember the old mapping size */
        oldlen = malloc_ninfo * sizeof * page_dir;
 8049d40:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049d46:	c1 e0 02             	shl    $0x2,%eax
 8049d49:	89 45 f0             	mov    %eax,-0x10(%ebp)
         * address, the old pages will be "magically" remapped..  But this means
         * keeping open a "secret" file descriptor.....
         */

        /* Get new pages */
        new = (struct pginfo **) MMAP(i * malloc_pagesize);
 8049d4c:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 8049d52:	8b 55 f4             	mov    -0xc(%ebp),%edx
 8049d55:	c1 e2 0c             	shl    $0xc,%edx
 8049d58:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 8049d5f:	00 
 8049d60:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049d64:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 8049d6b:	00 
 8049d6c:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 8049d73:	00 
 8049d74:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049d78:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 8049d7f:	e8 cc e9 ff ff       	call   8048750 <mmap>
 8049d84:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (new == (struct pginfo **) - 1)
 8049d87:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
 8049d8b:	75 07                	jne    8049d94 <extend_pgdir+0x7c>
                return 0;
 8049d8d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d92:	eb 5e                	jmp    8049df2 <extend_pgdir+0xda>

        /* Copy the old stuff */
        memcpy(new, page_dir,
 8049d94:	8b 83 60 02 00 00    	mov    0x260(%ebx),%eax
 8049d9a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8049da1:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 8049da7:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049dab:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049daf:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049db2:	89 04 24             	mov    %eax,(%esp)
 8049db5:	e8 66 f3 ff ff       	call   8049120 <memcpy>
               malloc_ninfo * sizeof * page_dir);

        /* register the new size */
        malloc_ninfo = i * malloc_pagesize / sizeof * page_dir;
 8049dba:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049dbd:	c1 e0 0c             	shl    $0xc,%eax
 8049dc0:	c1 e8 02             	shr    $0x2,%eax
 8049dc3:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)

        /* swap the pointers */
        old = page_dir;
 8049dc9:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 8049dcf:	89 45 e8             	mov    %eax,-0x18(%ebp)
        page_dir = new;
 8049dd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049dd5:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)

        /* Now free the old stuff */
        munmap((char *)old, oldlen);
 8049ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049dde:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049de2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 8049de5:	89 04 24             	mov    %eax,(%esp)
 8049de8:	e8 c6 e9 ff ff       	call   80487b3 <munmap>
        return 1;
 8049ded:	b8 01 00 00 00       	mov    $0x1,%eax
}
 8049df2:	83 c4 34             	add    $0x34,%esp
 8049df5:	5b                   	pop    %ebx
 8049df6:	5d                   	pop    %ebp
 8049df7:	c3                   	ret    

08049df8 <malloc_init>:
/*
 * Initialize the world
 */
static void
malloc_init()
{
 8049df8:	55                   	push   %ebp
 8049df9:	89 e5                	mov    %esp,%ebp
 8049dfb:	53                   	push   %ebx
 8049dfc:	83 ec 34             	sub    $0x34,%esp
 8049dff:	e8 c5 f2 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 8049e04:	81 c3 fc 51 00 00    	add    $0x51fc,%ebx
        char *p;
        int i, j;

        INIT_MMAP();
 8049e0a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049e11:	00 
 8049e12:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 8049e19:	00 
 8049e1a:	8d 83 f1 ec ff ff    	lea    -0x130f(%ebx),%eax
 8049e20:	89 04 24             	mov    %eax,(%esp)
 8049e23:	e8 14 ea ff ff       	call   804883c <open>
 8049e28:	89 83 48 02 00 00    	mov    %eax,0x248(%ebx)
 8049e2e:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 8049e34:	83 f8 ff             	cmp    $0xffffffff,%eax
 8049e37:	75 0e                	jne    8049e47 <malloc_init+0x4f>
 8049e39:	8d 83 fb ec ff ff    	lea    -0x1305(%ebx),%eax
 8049e3f:	89 04 24             	mov    %eax,(%esp)
 8049e42:	e8 8a fc ff ff       	call   8049ad1 <wrterror>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 8049e47:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 8049e4e:	e9 7c 01 00 00       	jmp    8049fcf <.L18+0x45>
                if (i == 0) {
 8049e53:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 8049e57:	75 0c                	jne    8049e65 <malloc_init+0x6d>
                        if (j <= 0)
                                continue;
                        b[j] = '\0';
                        p = b;
#else
                        p = NULL;
 8049e59:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049e60:	e9 53 01 00 00       	jmp    8049fb8 <.L18+0x2e>
#endif
                } else if (i == 1) {
 8049e65:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
 8049e69:	75 0c                	jne    8049e77 <malloc_init+0x7f>
#ifdef HAS_GETENV
                        p = getenv("MALLOC_OPTIONS");
#else
                        p = NULL;
 8049e6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049e72:	e9 41 01 00 00       	jmp    8049fb8 <.L18+0x2e>
#endif
                } else {
                        p = malloc_options;
 8049e77:	8d 05 a8 f2 04 08    	lea    0x804f2a8,%eax
 8049e7d:	8b 00                	mov    (%eax),%eax
 8049e7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                }
                for (; p && *p; p++) {
 8049e82:	e9 31 01 00 00       	jmp    8049fb8 <.L18+0x2e>
                        switch (*p) {
 8049e87:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049e8a:	0f b6 00             	movzbl (%eax),%eax
 8049e8d:	0f be c0             	movsbl %al,%eax
 8049e90:	83 e8 3c             	sub    $0x3c,%eax
 8049e93:	83 f8 3e             	cmp    $0x3e,%eax
 8049e96:	0f 87 ee 00 00 00    	ja     8049f8a <.L18>
 8049e9c:	c1 e0 02             	shl    $0x2,%eax
 8049e9f:	8b 84 18 50 ed ff ff 	mov    -0x12b0(%eax,%ebx,1),%eax
 8049ea6:	01 d8                	add    %ebx,%eax
 8049ea8:	ff e0                	jmp    *%eax

08049eaa <.L21>:
                                case '>': malloc_cache   <<= 1; break;
 8049eaa:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 8049eb0:	01 c0                	add    %eax,%eax
 8049eb2:	89 83 34 00 00 00    	mov    %eax,0x34(%ebx)
 8049eb8:	e9 f8 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049ebd <.L19>:
                                case '<': malloc_cache   >>= 1; break;
 8049ebd:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 8049ec3:	d1 e8                	shr    %eax
 8049ec5:	89 83 34 00 00 00    	mov    %eax,0x34(%ebx)
 8049ecb:	e9 e5 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049ed0 <.L29>:
                                case 'a': malloc_abort   = 0; break;
 8049ed0:	c7 83 78 02 00 00 00 	movl   $0x0,0x278(%ebx)
 8049ed7:	00 00 00 
 8049eda:	e9 d6 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049edf <.L22>:
                                case 'A': malloc_abort   = 1; break;
 8049edf:	c7 83 78 02 00 00 01 	movl   $0x1,0x278(%ebx)
 8049ee6:	00 00 00 
 8049ee9:	e9 c7 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049eee <.L30>:
                                case 'h': malloc_hint    = 0; break;
 8049eee:	c7 83 84 02 00 00 00 	movl   $0x0,0x284(%ebx)
 8049ef5:	00 00 00 
 8049ef8:	e9 b8 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049efd <.L23>:
                                case 'H': malloc_hint    = 1; break;
 8049efd:	c7 83 84 02 00 00 01 	movl   $0x1,0x284(%ebx)
 8049f04:	00 00 00 
 8049f07:	e9 a9 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049f0c <.L32>:
                                case 'r': malloc_realloc = 0; break;
 8049f0c:	c7 83 80 02 00 00 00 	movl   $0x0,0x280(%ebx)
 8049f13:	00 00 00 
 8049f16:	e9 9a 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049f1b <.L25>:
                                case 'R': malloc_realloc = 1; break;
 8049f1b:	c7 83 80 02 00 00 01 	movl   $0x1,0x280(%ebx)
 8049f22:	00 00 00 
 8049f25:	e9 8b 00 00 00       	jmp    8049fb5 <.L18+0x2b>

08049f2a <.L31>:
                                case 'j': malloc_junk    = 0; break;
 8049f2a:	c7 83 94 02 00 00 00 	movl   $0x0,0x294(%ebx)
 8049f31:	00 00 00 
 8049f34:	eb 7f                	jmp    8049fb5 <.L18+0x2b>

08049f36 <.L24>:
                                case 'J': malloc_junk    = 1; break;
 8049f36:	c7 83 94 02 00 00 01 	movl   $0x1,0x294(%ebx)
 8049f3d:	00 00 00 
 8049f40:	eb 73                	jmp    8049fb5 <.L18+0x2b>

08049f42 <.L33>:
#ifdef HAS_UTRACE
                                case 'u': malloc_utrace  = 0; break;
                                case 'U': malloc_utrace  = 1; break;
#endif
                                case 'v': malloc_sysv    = 0; break;
 8049f42:	c7 83 8c 02 00 00 00 	movl   $0x0,0x28c(%ebx)
 8049f49:	00 00 00 
 8049f4c:	eb 67                	jmp    8049fb5 <.L18+0x2b>

08049f4e <.L26>:
                                case 'V': malloc_sysv    = 1; break;
 8049f4e:	c7 83 8c 02 00 00 01 	movl   $0x1,0x28c(%ebx)
 8049f55:	00 00 00 
 8049f58:	eb 5b                	jmp    8049fb5 <.L18+0x2b>

08049f5a <.L34>:
                                case 'x': malloc_xmalloc = 0; break;
 8049f5a:	c7 83 88 02 00 00 00 	movl   $0x0,0x288(%ebx)
 8049f61:	00 00 00 
 8049f64:	eb 4f                	jmp    8049fb5 <.L18+0x2b>

08049f66 <.L27>:
                                case 'X': malloc_xmalloc = 1; break;
 8049f66:	c7 83 88 02 00 00 01 	movl   $0x1,0x288(%ebx)
 8049f6d:	00 00 00 
 8049f70:	eb 43                	jmp    8049fb5 <.L18+0x2b>

08049f72 <.L35>:
                                case 'z': malloc_zero    = 0; break;
 8049f72:	c7 83 90 02 00 00 00 	movl   $0x0,0x290(%ebx)
 8049f79:	00 00 00 
 8049f7c:	eb 37                	jmp    8049fb5 <.L18+0x2b>

08049f7e <.L28>:
                                case 'Z': malloc_zero    = 1; break;
 8049f7e:	c7 83 90 02 00 00 01 	movl   $0x1,0x290(%ebx)
 8049f85:	00 00 00 
 8049f88:	eb 2b                	jmp    8049fb5 <.L18+0x2b>

08049f8a <.L18>:
                                default:
                                        j = malloc_abort;
 8049f8a:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 8049f90:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                        malloc_abort = 0;
 8049f93:	c7 83 78 02 00 00 00 	movl   $0x0,0x278(%ebx)
 8049f9a:	00 00 00 
                                        wrtwarning("unknown char in MALLOC_OPTIONS\n");
 8049f9d:	8d 83 10 ed ff ff    	lea    -0x12f0(%ebx),%eax
 8049fa3:	89 04 24             	mov    %eax,(%esp)
 8049fa6:	e8 f6 fb ff ff       	call   8049ba1 <wrtwarning>
                                        malloc_abort = j;
 8049fab:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049fae:	89 83 78 02 00 00    	mov    %eax,0x278(%ebx)
                                        break;
 8049fb4:	90                   	nop
                        p = NULL;
#endif
                } else {
                        p = malloc_options;
                }
                for (; p && *p; p++) {
 8049fb5:	ff 45 f4             	incl   -0xc(%ebp)
 8049fb8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049fbc:	74 0e                	je     8049fcc <.L18+0x42>
 8049fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049fc1:	0f b6 00             	movzbl (%eax),%eax
 8049fc4:	84 c0                	test   %al,%al
 8049fc6:	0f 85 bb fe ff ff    	jne    8049e87 <malloc_init+0x8f>

#ifdef EXTRA_SANITY
        malloc_junk = 1;
#endif /* EXTRA_SANITY */

        for (i = 0; i < 3; i++) {
 8049fcc:	ff 45 f0             	incl   -0x10(%ebp)
 8049fcf:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
 8049fd3:	0f 8e 7a fe ff ff    	jle    8049e53 <malloc_init+0x5b>

        /*
         * We want junk in the entire allocation, and zero only in the part
         * the user asked for.
         */
        if (malloc_zero)
 8049fd9:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 8049fdf:	85 c0                	test   %eax,%eax
 8049fe1:	74 0a                	je     8049fed <.L18+0x63>
                malloc_junk = 1;
 8049fe3:	c7 83 94 02 00 00 01 	movl   $0x1,0x294(%ebx)
 8049fea:	00 00 00 

        /*
         * If we run with junk (or implicitly from above: zero), we want to
         * force realloc() to get new storage, so we can DTRT with it.
         */
        if (malloc_junk)
 8049fed:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 8049ff3:	85 c0                	test   %eax,%eax
 8049ff5:	74 0a                	je     804a001 <.L18+0x77>
                malloc_realloc = 1;
 8049ff7:	c7 83 80 02 00 00 01 	movl   $0x1,0x280(%ebx)
 8049ffe:	00 00 00 

        /* Allocate one page for the page directory */
        page_dir = (struct pginfo **) MMAP(malloc_pagesize);
 804a001:	8b 83 48 02 00 00    	mov    0x248(%ebx),%eax
 804a007:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a00e:	00 
 804a00f:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a013:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
 804a01a:	00 
 804a01b:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804a022:	00 
 804a023:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
 804a02a:	00 
 804a02b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a032:	e8 19 e7 ff ff       	call   8048750 <mmap>
 804a037:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)

        if (page_dir == (struct pginfo **) - 1)
 804a03d:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a043:	83 f8 ff             	cmp    $0xffffffff,%eax
 804a046:	75 0e                	jne    804a056 <.L18+0xcc>
                wrterror("mmap(2) failed, check limits\n");
 804a048:	8d 83 30 ed ff ff    	lea    -0x12d0(%ebx),%eax
 804a04e:	89 04 24             	mov    %eax,(%esp)
 804a051:	e8 7b fa ff ff       	call   8049ad1 <wrterror>

        /*
         * We need a maximum of malloc_pageshift buckets, steal these from the
         * front of the page_directory;
         */
        malloc_origo = ((u_long)pageround((u_long)sbrk(0))) >> malloc_pageshift;
 804a056:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a05d:	e8 0d e3 ff ff       	call   804836f <sbrk>
 804a062:	05 ff 0f 00 00       	add    $0xfff,%eax
 804a067:	c1 e8 0c             	shr    $0xc,%eax
 804a06a:	89 83 54 02 00 00    	mov    %eax,0x254(%ebx)
        malloc_origo -= malloc_pageshift;
 804a070:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804a076:	83 e8 0c             	sub    $0xc,%eax
 804a079:	89 83 54 02 00 00    	mov    %eax,0x254(%ebx)

        malloc_ninfo = malloc_pagesize / sizeof * page_dir;
 804a07f:	c7 83 60 02 00 00 00 	movl   $0x400,0x260(%ebx)
 804a086:	04 00 00 

        /* Recalculate the cache size in bytes, and make sure it's nonzero */

        if (!malloc_cache)
 804a089:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 804a08f:	85 c0                	test   %eax,%eax
 804a091:	75 0d                	jne    804a0a0 <.L18+0x116>
                malloc_cache++;
 804a093:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 804a099:	40                   	inc    %eax
 804a09a:	89 83 34 00 00 00    	mov    %eax,0x34(%ebx)

        malloc_cache <<= malloc_pageshift;
 804a0a0:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 804a0a6:	c1 e0 0c             	shl    $0xc,%eax
 804a0a9:	89 83 34 00 00 00    	mov    %eax,0x34(%ebx)

        /*
         * This is a nice hack from Kaleb Keithly (kaleb@x.org).
         * We can sbrk(2) further back when we keep this on a low address.
         */
        px = (struct pgfree *) imalloc(sizeof * px);
 804a0af:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804a0b6:	e8 5d 07 00 00       	call   804a818 <imalloc>
 804a0bb:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)

        /* Been here, done that */
        malloc_started++;
 804a0c1:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804a0c7:	40                   	inc    %eax
 804a0c8:	89 83 4c 02 00 00    	mov    %eax,0x24c(%ebx)
}
 804a0ce:	90                   	nop
 804a0cf:	83 c4 34             	add    $0x34,%esp
 804a0d2:	5b                   	pop    %ebx
 804a0d3:	5d                   	pop    %ebp
 804a0d4:	c3                   	ret    

0804a0d5 <malloc_pages>:
/*
 * Allocate a number of complete pages
 */
static void *
malloc_pages(size_t size)
{
 804a0d5:	55                   	push   %ebp
 804a0d6:	89 e5                	mov    %esp,%ebp
 804a0d8:	53                   	push   %ebx
 804a0d9:	83 ec 34             	sub    $0x34,%esp
 804a0dc:	e8 e8 ef ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804a0e1:	81 c3 1f 4f 00 00    	add    $0x4f1f,%ebx
        void *p, *delay_free = 0;
 804a0e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        unsigned int i;
        struct pgfree *pf;
        u_long index;

        size = pageround(size);
 804a0ee:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0f1:	05 ff 0f 00 00       	add    $0xfff,%eax
 804a0f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
 804a0fb:	89 45 08             	mov    %eax,0x8(%ebp)

        p = 0;
 804a0fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a105:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 804a10b:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a10e:	e9 82 00 00 00       	jmp    804a195 <malloc_pages+0xc0>
                        wrterror("(ES): non-free first page on free-list\n");
                if (page_dir[ptr2index(pf->end) - 1] != MALLOC_FREE)
                        wrterror("(ES): non-free last page on free-list\n");
#endif /* EXTRA_SANITY */

                if (pf->size < size)
 804a113:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a116:	8b 40 10             	mov    0x10(%eax),%eax
 804a119:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a11c:	73 0a                	jae    804a128 <malloc_pages+0x53>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a11e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a121:	8b 00                	mov    (%eax),%eax
 804a123:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804a126:	eb 6d                	jmp    804a195 <malloc_pages+0xc0>
#endif /* EXTRA_SANITY */

                if (pf->size < size)
                        continue;

                if (pf->size == size) {
 804a128:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a12b:	8b 40 10             	mov    0x10(%eax),%eax
 804a12e:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a131:	75 35                	jne    804a168 <malloc_pages+0x93>
                        p = pf->page;
 804a133:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a136:	8b 40 08             	mov    0x8(%eax),%eax
 804a139:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        if (pf->next)
 804a13c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a13f:	8b 00                	mov    (%eax),%eax
 804a141:	85 c0                	test   %eax,%eax
 804a143:	74 0e                	je     804a153 <malloc_pages+0x7e>
                                pf->next->prev = pf->prev;
 804a145:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a148:	8b 00                	mov    (%eax),%eax
 804a14a:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a14d:	8b 52 04             	mov    0x4(%edx),%edx
 804a150:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev->next = pf->next;
 804a153:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a156:	8b 40 04             	mov    0x4(%eax),%eax
 804a159:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a15c:	8b 12                	mov    (%edx),%edx
 804a15e:	89 10                	mov    %edx,(%eax)
                        delay_free = pf;
 804a160:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a163:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        break;
 804a166:	eb 37                	jmp    804a19f <malloc_pages+0xca>
                }

                p = pf->page;
 804a168:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a16b:	8b 40 08             	mov    0x8(%eax),%eax
 804a16e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                pf->page = (char *)pf->page + size;
 804a171:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a174:	8b 50 08             	mov    0x8(%eax),%edx
 804a177:	8b 45 08             	mov    0x8(%ebp),%eax
 804a17a:	01 c2                	add    %eax,%edx
 804a17c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a17f:	89 50 08             	mov    %edx,0x8(%eax)
                pf->size -= size;
 804a182:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a185:	8b 40 10             	mov    0x10(%eax),%eax
 804a188:	2b 45 08             	sub    0x8(%ebp),%eax
 804a18b:	89 c2                	mov    %eax,%edx
 804a18d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a190:	89 50 10             	mov    %edx,0x10(%eax)
                break;
 804a193:	eb 0a                	jmp    804a19f <malloc_pages+0xca>
        size = pageround(size);

        p = 0;

        /* Look for free pages before asking for more */
        for (pf = free_list.next; pf; pf = pf->next) {
 804a195:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a199:	0f 85 74 ff ff ff    	jne    804a113 <malloc_pages+0x3e>
#ifdef EXTRA_SANITY
        if (p && page_dir[ptr2index(p)] != MALLOC_FREE)
                wrterror("(ES): allocated non-free page on free-list\n");
#endif /* EXTRA_SANITY */

        size >>= malloc_pageshift;
 804a19f:	c1 6d 08 0c          	shrl   $0xc,0x8(%ebp)

        /* Map new pages */
        if (!p)
 804a1a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a1a7:	75 0e                	jne    804a1b7 <malloc_pages+0xe2>
                p = map_pages(size);
 804a1a9:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1ac:	89 04 24             	mov    %eax,(%esp)
 804a1af:	e8 bc fa ff ff       	call   8049c70 <map_pages>
 804a1b4:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (p) {
 804a1b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a1bb:	74 7d                	je     804a23a <malloc_pages+0x165>

                index = ptr2index(p);
 804a1bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a1c0:	c1 e8 0c             	shr    $0xc,%eax
 804a1c3:	89 c2                	mov    %eax,%edx
 804a1c5:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804a1cb:	29 c2                	sub    %eax,%edx
 804a1cd:	89 d0                	mov    %edx,%eax
 804a1cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                page_dir[index] = MALLOC_FIRST;
 804a1d2:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a1d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a1db:	c1 e2 02             	shl    $0x2,%edx
 804a1de:	01 d0                	add    %edx,%eax
 804a1e0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
                for (i = 1; i < size; i++)
 804a1e6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 804a1ed:	eb 1c                	jmp    804a20b <malloc_pages+0x136>
                        page_dir[index + i] = MALLOC_FOLLOW;
 804a1ef:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a1f5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804a1f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a1fb:	01 ca                	add    %ecx,%edx
 804a1fd:	c1 e2 02             	shl    $0x2,%edx
 804a200:	01 d0                	add    %edx,%eax
 804a202:	c7 00 03 00 00 00    	movl   $0x3,(%eax)

        if (p) {

                index = ptr2index(p);
                page_dir[index] = MALLOC_FIRST;
                for (i = 1; i < size; i++)
 804a208:	ff 45 ec             	incl   -0x14(%ebp)
 804a20b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a20e:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a211:	72 dc                	jb     804a1ef <malloc_pages+0x11a>
                        page_dir[index + i] = MALLOC_FOLLOW;

                if (malloc_junk)
 804a213:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804a219:	85 c0                	test   %eax,%eax
 804a21b:	74 1d                	je     804a23a <malloc_pages+0x165>
                        memset(p, SOME_JUNK, size << malloc_pageshift);
 804a21d:	8b 45 08             	mov    0x8(%ebp),%eax
 804a220:	c1 e0 0c             	shl    $0xc,%eax
 804a223:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a227:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a22e:	00 
 804a22f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a232:	89 04 24             	mov    %eax,(%esp)
 804a235:	e8 41 f0 ff ff       	call   804927b <memset>
        }

        if (delay_free) {
 804a23a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a23e:	74 20                	je     804a260 <malloc_pages+0x18b>
                if (!px)
 804a240:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804a246:	85 c0                	test   %eax,%eax
 804a248:	75 0b                	jne    804a255 <malloc_pages+0x180>
                        px = delay_free;
 804a24a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a24d:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
 804a253:	eb 0b                	jmp    804a260 <malloc_pages+0x18b>
                else
                        ifree(delay_free);
 804a255:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a258:	89 04 24             	mov    %eax,(%esp)
 804a25b:	e8 d7 0e 00 00       	call   804b137 <ifree>
        }

        return p;
 804a260:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a263:	83 c4 34             	add    $0x34,%esp
 804a266:	5b                   	pop    %ebx
 804a267:	5d                   	pop    %ebp
 804a268:	c3                   	ret    

0804a269 <malloc_make_chunks>:
 * Allocate a page of fragments
 */

static __inline__ int
malloc_make_chunks(int bits)
{
 804a269:	55                   	push   %ebp
 804a26a:	89 e5                	mov    %esp,%ebp
 804a26c:	56                   	push   %esi
 804a26d:	53                   	push   %ebx
 804a26e:	83 ec 30             	sub    $0x30,%esp
 804a271:	e8 53 ee ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804a276:	81 c3 8a 4d 00 00    	add    $0x4d8a,%ebx
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804a27c:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a283:	e8 4d fe ff ff       	call   804a0d5 <malloc_pages>
 804a288:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (!pp)
 804a28b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a28f:	75 0a                	jne    804a29b <malloc_make_chunks+0x32>
                return 0;
 804a291:	b8 00 00 00 00       	mov    $0x0,%eax
 804a296:	e9 f4 01 00 00       	jmp    804a48f <malloc_make_chunks+0x226>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804a29b:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804a2a2:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2a5:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a2aa:	88 c1                	mov    %al,%cl
 804a2ac:	d3 ea                	shr    %cl,%edx
 804a2ae:	89 d0                	mov    %edx,%eax
 804a2b0:	83 c0 1f             	add    $0x1f,%eax
 804a2b3:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804a2b6:	c1 e0 02             	shl    $0x2,%eax
 804a2b9:	01 45 ec             	add    %eax,-0x14(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804a2bc:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2bf:	ba 01 00 00 00       	mov    $0x1,%edx
 804a2c4:	88 c1                	mov    %al,%cl
 804a2c6:	d3 e2                	shl    %cl,%edx
 804a2c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a2cb:	01 c0                	add    %eax,%eax
 804a2cd:	39 c2                	cmp    %eax,%edx
 804a2cf:	77 08                	ja     804a2d9 <malloc_make_chunks+0x70>
                bp = (struct  pginfo *)pp;
 804a2d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a2d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a2d7:	eb 29                	jmp    804a302 <malloc_make_chunks+0x99>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804a2d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a2dc:	89 04 24             	mov    %eax,(%esp)
 804a2df:	e8 34 05 00 00       	call   804a818 <imalloc>
 804a2e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if (!bp) {
 804a2e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a2eb:	75 15                	jne    804a302 <malloc_make_chunks+0x99>
                        ifree(pp);
 804a2ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a2f0:	89 04 24             	mov    %eax,(%esp)
 804a2f3:	e8 3f 0e 00 00       	call   804b137 <ifree>
                        return 0;
 804a2f8:	b8 00 00 00 00       	mov    $0x0,%eax
 804a2fd:	e9 8d 01 00 00       	jmp    804a48f <malloc_make_chunks+0x226>
                }
        }

        bp->size = (1 << bits);
 804a302:	8b 45 08             	mov    0x8(%ebp),%eax
 804a305:	ba 01 00 00 00       	mov    $0x1,%edx
 804a30a:	88 c1                	mov    %al,%cl
 804a30c:	d3 e2                	shl    %cl,%edx
 804a30e:	89 d0                	mov    %edx,%eax
 804a310:	0f b7 d0             	movzwl %ax,%edx
 804a313:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a316:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804a31a:	8b 45 08             	mov    0x8(%ebp),%eax
 804a31d:	0f b7 d0             	movzwl %ax,%edx
 804a320:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a323:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804a327:	8b 45 08             	mov    0x8(%ebp),%eax
 804a32a:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a32f:	88 c1                	mov    %al,%cl
 804a331:	d3 ea                	shr    %cl,%edx
 804a333:	89 d0                	mov    %edx,%eax
 804a335:	0f b7 d0             	movzwl %ax,%edx
 804a338:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a33b:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a33f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a342:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a346:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a349:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804a34d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a350:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a353:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804a356:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a359:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a35d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        i = 0;
 804a360:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a367:	eb 19                	jmp    804a382 <malloc_make_chunks+0x119>
                bp->bits[i / MALLOC_BITS] = ~0;
 804a369:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a36c:	c1 e8 05             	shr    $0x5,%eax
 804a36f:	89 c2                	mov    %eax,%edx
 804a371:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a374:	83 c2 04             	add    $0x4,%edx
 804a377:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a37e:	83 45 f0 20          	addl   $0x20,-0x10(%ebp)
 804a382:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a385:	2b 45 f0             	sub    -0x10(%ebp),%eax
 804a388:	83 f8 1f             	cmp    $0x1f,%eax
 804a38b:	77 dc                	ja     804a369 <malloc_make_chunks+0x100>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a38d:	eb 2c                	jmp    804a3bb <malloc_make_chunks+0x152>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a38f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a392:	c1 e8 05             	shr    $0x5,%eax
 804a395:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a398:	8d 48 04             	lea    0x4(%eax),%ecx
 804a39b:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a39e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804a3a1:	83 e1 1f             	and    $0x1f,%ecx
 804a3a4:	be 01 00 00 00       	mov    $0x1,%esi
 804a3a9:	d3 e6                	shl    %cl,%esi
 804a3ab:	89 f1                	mov    %esi,%ecx
 804a3ad:	09 d1                	or     %edx,%ecx
 804a3af:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a3b2:	83 c0 04             	add    $0x4,%eax
 804a3b5:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a3b8:	ff 45 f0             	incl   -0x10(%ebp)
 804a3bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3be:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804a3c1:	72 cc                	jb     804a38f <malloc_make_chunks+0x126>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804a3c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a3c6:	8b 40 04             	mov    0x4(%eax),%eax
 804a3c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804a3cc:	75 72                	jne    804a440 <malloc_make_chunks+0x1d7>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a3ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804a3d5:	eb 63                	jmp    804a43a <malloc_make_chunks+0x1d1>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804a3d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a3da:	c1 e8 05             	shr    $0x5,%eax
 804a3dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a3e0:	8d 48 04             	lea    0x4(%eax),%ecx
 804a3e3:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a3e6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804a3e9:	83 e1 1f             	and    $0x1f,%ecx
 804a3ec:	be 01 00 00 00       	mov    $0x1,%esi
 804a3f1:	d3 e6                	shl    %cl,%esi
 804a3f3:	89 f1                	mov    %esi,%ecx
 804a3f5:	f7 d1                	not    %ecx
 804a3f7:	21 d1                	and    %edx,%ecx
 804a3f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a3fc:	83 c0 04             	add    $0x4,%eax
 804a3ff:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804a402:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a405:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a409:	48                   	dec    %eax
 804a40a:	0f b7 d0             	movzwl %ax,%edx
 804a40d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a410:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804a414:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a417:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a41b:	48                   	dec    %eax
 804a41c:	0f b7 d0             	movzwl %ax,%edx
 804a41f:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a422:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804a426:	8b 45 08             	mov    0x8(%ebp),%eax
 804a429:	ba 01 00 00 00       	mov    $0x1,%edx
 804a42e:	88 c1                	mov    %al,%cl
 804a430:	d3 e2                	shl    %cl,%edx
 804a432:	89 d0                	mov    %edx,%eax
 804a434:	29 45 ec             	sub    %eax,-0x14(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a437:	ff 45 f0             	incl   -0x10(%ebp)
 804a43a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804a43e:	75 97                	jne    804a3d7 <malloc_make_chunks+0x16e>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804a440:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a446:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a449:	89 d1                	mov    %edx,%ecx
 804a44b:	c1 e9 0c             	shr    $0xc,%ecx
 804a44e:	8b 93 54 02 00 00    	mov    0x254(%ebx),%edx
 804a454:	29 d1                	sub    %edx,%ecx
 804a456:	89 ca                	mov    %ecx,%edx
 804a458:	c1 e2 02             	shl    $0x2,%edx
 804a45b:	01 c2                	add    %eax,%edx
 804a45d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a460:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804a462:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a468:	8b 55 08             	mov    0x8(%ebp),%edx
 804a46b:	c1 e2 02             	shl    $0x2,%edx
 804a46e:	01 d0                	add    %edx,%eax
 804a470:	8b 10                	mov    (%eax),%edx
 804a472:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a475:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804a477:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a47d:	8b 55 08             	mov    0x8(%ebp),%edx
 804a480:	c1 e2 02             	shl    $0x2,%edx
 804a483:	01 c2                	add    %eax,%edx
 804a485:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a488:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804a48a:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804a48f:	83 c4 30             	add    $0x30,%esp
 804a492:	5b                   	pop    %ebx
 804a493:	5e                   	pop    %esi
 804a494:	5d                   	pop    %ebp
 804a495:	c3                   	ret    

0804a496 <malloc_bytes>:
/*
 * Allocate a fragment
 */
static void *
malloc_bytes(size_t size)
{
 804a496:	55                   	push   %ebp
 804a497:	89 e5                	mov    %esp,%ebp
 804a499:	56                   	push   %esi
 804a49a:	53                   	push   %ebx
 804a49b:	83 ec 40             	sub    $0x40,%esp
 804a49e:	e8 26 ec ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804a4a3:	81 c3 5d 4b 00 00    	add    $0x4b5d,%ebx
        struct  pginfo *bp;
        int k;
        u_int *lp;

        /* Don't bother with anything less than this */
        if (size < malloc_minsize)
 804a4a9:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
 804a4ad:	77 07                	ja     804a4b6 <malloc_bytes+0x20>
                size = malloc_minsize;
 804a4af:	c7 45 08 10 00 00 00 	movl   $0x10,0x8(%ebp)

        /* Find the right bucket */
        j = 1;
 804a4b6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
        i = size - 1;
 804a4bd:	8b 45 08             	mov    0x8(%ebp),%eax
 804a4c0:	48                   	dec    %eax
 804a4c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        while (i >>= 1)
 804a4c4:	eb 03                	jmp    804a4c9 <malloc_bytes+0x33>
                j++;
 804a4c6:	ff 45 f0             	incl   -0x10(%ebp)
                size = malloc_minsize;

        /* Find the right bucket */
        j = 1;
        i = size - 1;
        while (i >>= 1)
 804a4c9:	d1 7d f4             	sarl   -0xc(%ebp)
 804a4cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a4d0:	75 f4                	jne    804a4c6 <malloc_bytes+0x30>
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804a4d2:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a4d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a4db:	c1 e2 02             	shl    $0x2,%edx
 804a4de:	01 d0                	add    %edx,%eax
 804a4e0:	8b 00                	mov    (%eax),%eax
 804a4e2:	85 c0                	test   %eax,%eax
 804a4e4:	0f 85 27 02 00 00    	jne    804a711 <malloc_bytes+0x27b>
 804a4ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a4ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
        struct  pginfo *bp;
        void *pp;
        unsigned int i, k, l;

        /* Allocate a new bucket */
        pp = malloc_pages(malloc_pagesize);
 804a4f0:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
 804a4f7:	e8 d9 fb ff ff       	call   804a0d5 <malloc_pages>
 804a4fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if (!pp)
 804a4ff:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
 804a503:	75 0a                	jne    804a50f <malloc_bytes+0x79>
                return 0;
 804a505:	b8 00 00 00 00       	mov    $0x0,%eax
 804a50a:	e9 f4 01 00 00       	jmp    804a703 <malloc_bytes+0x26d>

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
 804a50f:	c7 45 d4 10 00 00 00 	movl   $0x10,-0x2c(%ebp)
        l += sizeof bp->bits[0] *
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);
 804a516:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a519:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a51e:	88 c1                	mov    %al,%cl
 804a520:	d3 ea                	shr    %cl,%edx
 804a522:	89 d0                	mov    %edx,%eax
 804a524:	83 c0 1f             	add    $0x1f,%eax
 804a527:	c1 e8 05             	shr    $0x5,%eax
        if (!pp)
                return 0;

        /* Find length of admin structure */
        l = offsetof(struct pginfo, bits[0]);
        l += sizeof bp->bits[0] *
 804a52a:	c1 e0 02             	shl    $0x2,%eax
 804a52d:	01 45 d4             	add    %eax,-0x2c(%ebp)
             (((malloc_pagesize >> bits) + MALLOC_BITS - 1) / MALLOC_BITS);

        /* Don't waste more than two chunks on this */
        if ((1U << (bits)) <= l + l) {
 804a530:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a533:	ba 01 00 00 00       	mov    $0x1,%edx
 804a538:	88 c1                	mov    %al,%cl
 804a53a:	d3 e2                	shl    %cl,%edx
 804a53c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a53f:	01 c0                	add    %eax,%eax
 804a541:	39 c2                	cmp    %eax,%edx
 804a543:	77 08                	ja     804a54d <malloc_bytes+0xb7>
                bp = (struct  pginfo *)pp;
 804a545:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a548:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804a54b:	eb 29                	jmp    804a576 <malloc_bytes+0xe0>
        } else {
                bp = (struct  pginfo *)imalloc(l);
 804a54d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804a550:	89 04 24             	mov    %eax,(%esp)
 804a553:	e8 c0 02 00 00       	call   804a818 <imalloc>
 804a558:	89 45 d0             	mov    %eax,-0x30(%ebp)
                if (!bp) {
 804a55b:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804a55f:	75 15                	jne    804a576 <malloc_bytes+0xe0>
                        ifree(pp);
 804a561:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804a564:	89 04 24             	mov    %eax,(%esp)
 804a567:	e8 cb 0b 00 00       	call   804b137 <ifree>
                        return 0;
 804a56c:	b8 00 00 00 00       	mov    $0x0,%eax
 804a571:	e9 8d 01 00 00       	jmp    804a703 <malloc_bytes+0x26d>
                }
        }

        bp->size = (1 << bits);
 804a576:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a579:	ba 01 00 00 00       	mov    $0x1,%edx
 804a57e:	88 c1                	mov    %al,%cl
 804a580:	d3 e2                	shl    %cl,%edx
 804a582:	89 d0                	mov    %edx,%eax
 804a584:	0f b7 d0             	movzwl %ax,%edx
 804a587:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a58a:	66 89 50 08          	mov    %dx,0x8(%eax)
        bp->shift = bits;
 804a58e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a591:	0f b7 d0             	movzwl %ax,%edx
 804a594:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a597:	66 89 50 0a          	mov    %dx,0xa(%eax)
        bp->total = bp->free = malloc_pagesize >> bits;
 804a59b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a59e:	ba 00 10 00 00       	mov    $0x1000,%edx
 804a5a3:	88 c1                	mov    %al,%cl
 804a5a5:	d3 ea                	shr    %cl,%edx
 804a5a7:	89 d0                	mov    %edx,%eax
 804a5a9:	0f b7 d0             	movzwl %ax,%edx
 804a5ac:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5af:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a5b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5b6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804a5ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5bd:	66 89 50 0e          	mov    %dx,0xe(%eax)
        bp->page = pp;
 804a5c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5c4:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a5c7:	89 50 04             	mov    %edx,0x4(%eax)

        /* set all valid bits in the bitmap */
        k = bp->total;
 804a5ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5cd:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a5d1:	89 45 cc             	mov    %eax,-0x34(%ebp)
        i = 0;
 804a5d4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804a5db:	eb 19                	jmp    804a5f6 <malloc_bytes+0x160>

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;
 804a5dd:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a5e0:	c1 e8 05             	shr    $0x5,%eax
 804a5e3:	89 c2                	mov    %eax,%edx
 804a5e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a5e8:	83 c2 04             	add    $0x4,%edx
 804a5eb:	c7 04 90 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,4)
        /* set all valid bits in the bitmap */
        k = bp->total;
        i = 0;

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
 804a5f2:	83 45 c8 20          	addl   $0x20,-0x38(%ebp)
 804a5f6:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a5f9:	2b 45 c8             	sub    -0x38(%ebp),%eax
 804a5fc:	83 f8 1f             	cmp    $0x1f,%eax
 804a5ff:	77 dc                	ja     804a5dd <malloc_bytes+0x147>
 804a601:	eb 2c                	jmp    804a62f <malloc_bytes+0x199>
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804a603:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a606:	c1 e8 05             	shr    $0x5,%eax
 804a609:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a60c:	8d 48 04             	lea    0x4(%eax),%ecx
 804a60f:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a612:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804a615:	83 e1 1f             	and    $0x1f,%ecx
 804a618:	be 01 00 00 00       	mov    $0x1,%esi
 804a61d:	d3 e6                	shl    %cl,%esi
 804a61f:	89 f1                	mov    %esi,%ecx
 804a621:	09 d1                	or     %edx,%ecx
 804a623:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a626:	83 c0 04             	add    $0x4,%eax
 804a629:	89 0c 82             	mov    %ecx,(%edx,%eax,4)

        /* Do a bunch at a time */
        for (; k - i >= MALLOC_BITS; i += MALLOC_BITS)
                bp->bits[i / MALLOC_BITS] = ~0;

        for (; i < k; i++)
 804a62c:	ff 45 c8             	incl   -0x38(%ebp)
 804a62f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804a632:	3b 45 c8             	cmp    -0x38(%ebp),%eax
 804a635:	77 cc                	ja     804a603 <malloc_bytes+0x16d>
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
 804a637:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a63a:	8b 40 04             	mov    0x4(%eax),%eax
 804a63d:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804a640:	75 72                	jne    804a6b4 <malloc_bytes+0x21e>
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a642:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
 804a649:	eb 63                	jmp    804a6ae <malloc_bytes+0x218>
                        bp->bits[i / MALLOC_BITS] &= ~(1 << (i % MALLOC_BITS));
 804a64b:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804a64e:	c1 e8 05             	shr    $0x5,%eax
 804a651:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a654:	8d 48 04             	lea    0x4(%eax),%ecx
 804a657:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804a65a:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804a65d:	83 e1 1f             	and    $0x1f,%ecx
 804a660:	be 01 00 00 00       	mov    $0x1,%esi
 804a665:	d3 e6                	shl    %cl,%esi
 804a667:	89 f1                	mov    %esi,%ecx
 804a669:	f7 d1                	not    %ecx
 804a66b:	21 d1                	and    %edx,%ecx
 804a66d:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804a670:	83 c0 04             	add    $0x4,%eax
 804a673:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
                        bp->free--;
 804a676:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a679:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a67d:	48                   	dec    %eax
 804a67e:	0f b7 d0             	movzwl %ax,%edx
 804a681:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a684:	66 89 50 0c          	mov    %dx,0xc(%eax)
                        bp->total--;
 804a688:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a68b:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804a68f:	48                   	dec    %eax
 804a690:	0f b7 d0             	movzwl %ax,%edx
 804a693:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a696:	66 89 50 0e          	mov    %dx,0xe(%eax)
                        l -= (1 << bits);
 804a69a:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a69d:	ba 01 00 00 00       	mov    $0x1,%edx
 804a6a2:	88 c1                	mov    %al,%cl
 804a6a4:	d3 e2                	shl    %cl,%edx
 804a6a6:	89 d0                	mov    %edx,%eax
 804a6a8:	29 45 d4             	sub    %eax,-0x2c(%ebp)
        for (; i < k; i++)
                bp->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);

        if (bp == bp->page) {
                /* Mark the ones we stole for ourselves */
                for (i = 0; l > 0; i++) {
 804a6ab:	ff 45 c8             	incl   -0x38(%ebp)
 804a6ae:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804a6b2:	75 97                	jne    804a64b <malloc_bytes+0x1b5>
                }
        }

        /* MALLOC_LOCK */

        page_dir[ptr2index(pp)] = bp;
 804a6b4:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a6ba:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804a6bd:	89 d1                	mov    %edx,%ecx
 804a6bf:	c1 e9 0c             	shr    $0xc,%ecx
 804a6c2:	8b 93 54 02 00 00    	mov    0x254(%ebx),%edx
 804a6c8:	29 d1                	sub    %edx,%ecx
 804a6ca:	89 ca                	mov    %ecx,%edx
 804a6cc:	c1 e2 02             	shl    $0x2,%edx
 804a6cf:	01 c2                	add    %eax,%edx
 804a6d1:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a6d4:	89 02                	mov    %eax,(%edx)

        bp->next = page_dir[bits];
 804a6d6:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a6dc:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a6df:	c1 e2 02             	shl    $0x2,%edx
 804a6e2:	01 d0                	add    %edx,%eax
 804a6e4:	8b 10                	mov    (%eax),%edx
 804a6e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a6e9:	89 10                	mov    %edx,(%eax)
        page_dir[bits] = bp;
 804a6eb:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a6f1:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a6f4:	c1 e2 02             	shl    $0x2,%edx
 804a6f7:	01 c2                	add    %eax,%edx
 804a6f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804a6fc:	89 02                	mov    %eax,(%edx)

        /* MALLOC_UNLOCK */

        return 1;
 804a6fe:	b8 01 00 00 00       	mov    $0x1,%eax
        i = size - 1;
        while (i >>= 1)
                j++;

        /* If it's empty, make a page more of that size chunks */
        if (!page_dir[j] && !malloc_make_chunks(j))
 804a703:	85 c0                	test   %eax,%eax
 804a705:	75 0a                	jne    804a711 <malloc_bytes+0x27b>
                return 0;
 804a707:	b8 00 00 00 00       	mov    $0x0,%eax
 804a70c:	e9 00 01 00 00       	jmp    804a811 <malloc_bytes+0x37b>

        bp = page_dir[j];
 804a711:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a717:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a71a:	c1 e2 02             	shl    $0x2,%edx
 804a71d:	01 d0                	add    %edx,%eax
 804a71f:	8b 00                	mov    (%eax),%eax
 804a721:	89 45 e0             	mov    %eax,-0x20(%ebp)

        /* Find first word of bitmap which isn't empty */
        for (lp = bp->bits; !*lp; lp++)
 804a724:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a727:	83 c0 10             	add    $0x10,%eax
 804a72a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804a72d:	eb 04                	jmp    804a733 <malloc_bytes+0x29d>
 804a72f:	83 45 e4 04          	addl   $0x4,-0x1c(%ebp)
 804a733:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a736:	8b 00                	mov    (%eax),%eax
 804a738:	85 c0                	test   %eax,%eax
 804a73a:	74 f3                	je     804a72f <malloc_bytes+0x299>
                ;

        /* Find that bit, and tweak it */
        u = 1;
 804a73c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        k = 0;
 804a743:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        while (!(*lp & u)) {
 804a74a:	eb 0b                	jmp    804a757 <malloc_bytes+0x2c1>
                u += u;
 804a74c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a74f:	01 c0                	add    %eax,%eax
 804a751:	89 45 ec             	mov    %eax,-0x14(%ebp)
                k++;
 804a754:	ff 45 e8             	incl   -0x18(%ebp)
                ;

        /* Find that bit, and tweak it */
        u = 1;
        k = 0;
        while (!(*lp & u)) {
 804a757:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a75a:	8b 00                	mov    (%eax),%eax
 804a75c:	23 45 ec             	and    -0x14(%ebp),%eax
 804a75f:	85 c0                	test   %eax,%eax
 804a761:	74 e9                	je     804a74c <malloc_bytes+0x2b6>
                u += u;
                k++;
        }
        *lp ^= u;
 804a763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a766:	8b 00                	mov    (%eax),%eax
 804a768:	33 45 ec             	xor    -0x14(%ebp),%eax
 804a76b:	89 c2                	mov    %eax,%edx
 804a76d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a770:	89 10                	mov    %edx,(%eax)

        /* If there are no more free, remove from free-list */
        if (!--bp->free) {
 804a772:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a775:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a779:	48                   	dec    %eax
 804a77a:	0f b7 d0             	movzwl %ax,%edx
 804a77d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a780:	66 89 50 0c          	mov    %dx,0xc(%eax)
 804a784:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a787:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804a78b:	85 c0                	test   %eax,%eax
 804a78d:	75 1e                	jne    804a7ad <malloc_bytes+0x317>
                page_dir[j] = bp->next;
 804a78f:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a795:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a798:	c1 e2 02             	shl    $0x2,%edx
 804a79b:	01 c2                	add    %eax,%edx
 804a79d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a7a0:	8b 00                	mov    (%eax),%eax
 804a7a2:	89 02                	mov    %eax,(%edx)
                bp->next = 0;
 804a7a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a7a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        /* Adjust to the real offset of that chunk */
        k += (lp - bp->bits) * MALLOC_BITS;
 804a7ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a7b0:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a7b3:	83 c2 10             	add    $0x10,%edx
 804a7b6:	29 d0                	sub    %edx,%eax
 804a7b8:	c1 f8 02             	sar    $0x2,%eax
 804a7bb:	c1 e0 05             	shl    $0x5,%eax
 804a7be:	89 c2                	mov    %eax,%edx
 804a7c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7c3:	01 d0                	add    %edx,%eax
 804a7c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
        k <<= bp->shift;
 804a7c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a7cb:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804a7cf:	88 c1                	mov    %al,%cl
 804a7d1:	d3 65 e8             	shll   %cl,-0x18(%ebp)

        if (malloc_junk)
 804a7d4:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804a7da:	85 c0                	test   %eax,%eax
 804a7dc:	74 28                	je     804a806 <malloc_bytes+0x370>
                memset((u_char *)bp->page + k, SOME_JUNK, bp->size);
 804a7de:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a7e1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a7e5:	89 c2                	mov    %eax,%edx
 804a7e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a7ea:	8b 48 04             	mov    0x4(%eax),%ecx
 804a7ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7f0:	01 c8                	add    %ecx,%eax
 804a7f2:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a7f6:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804a7fd:	00 
 804a7fe:	89 04 24             	mov    %eax,(%esp)
 804a801:	e8 75 ea ff ff       	call   804927b <memset>

        return (u_char *)bp->page + k;
 804a806:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a809:	8b 50 04             	mov    0x4(%eax),%edx
 804a80c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a80f:	01 d0                	add    %edx,%eax
}
 804a811:	83 c4 40             	add    $0x40,%esp
 804a814:	5b                   	pop    %ebx
 804a815:	5e                   	pop    %esi
 804a816:	5d                   	pop    %ebp
 804a817:	c3                   	ret    

0804a818 <imalloc>:
/*
 * Allocate a piece of memory
 */
static void *
imalloc(size_t size)
{
 804a818:	55                   	push   %ebp
 804a819:	89 e5                	mov    %esp,%ebp
 804a81b:	53                   	push   %ebx
 804a81c:	83 ec 24             	sub    $0x24,%esp
 804a81f:	e8 a5 e8 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804a824:	81 c3 dc 47 00 00    	add    $0x47dc,%ebx
        void *result;

        if (suicide)
 804a82a:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
 804a830:	85 c0                	test   %eax,%eax
 804a832:	74 0c                	je     804a840 <imalloc+0x28>
                abort();
 804a834:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a83b:	e8 1e dd ff ff       	call   804855e <exit>

        if ((size + malloc_pagesize) < size)        /* Check for overflow */
 804a840:	8b 45 08             	mov    0x8(%ebp),%eax
 804a843:	05 00 10 00 00       	add    $0x1000,%eax
 804a848:	3b 45 08             	cmp    0x8(%ebp),%eax
 804a84b:	73 09                	jae    804a856 <imalloc+0x3e>
                result = 0;
 804a84d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804a854:	eb 27                	jmp    804a87d <imalloc+0x65>
        else if (size <= malloc_maxsize)
 804a856:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
 804a85d:	77 10                	ja     804a86f <imalloc+0x57>
                result =  malloc_bytes(size);
 804a85f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a862:	89 04 24             	mov    %eax,(%esp)
 804a865:	e8 2c fc ff ff       	call   804a496 <malloc_bytes>
 804a86a:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a86d:	eb 0e                	jmp    804a87d <imalloc+0x65>
        else
                result =  malloc_pages(size);
 804a86f:	8b 45 08             	mov    0x8(%ebp),%eax
 804a872:	89 04 24             	mov    %eax,(%esp)
 804a875:	e8 5b f8 ff ff       	call   804a0d5 <malloc_pages>
 804a87a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (malloc_abort && !result)
 804a87d:	8b 83 78 02 00 00    	mov    0x278(%ebx),%eax
 804a883:	85 c0                	test   %eax,%eax
 804a885:	74 14                	je     804a89b <imalloc+0x83>
 804a887:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a88b:	75 0e                	jne    804a89b <imalloc+0x83>
                wrterror("allocation failed.\n");
 804a88d:	8d 83 4c ee ff ff    	lea    -0x11b4(%ebx),%eax
 804a893:	89 04 24             	mov    %eax,(%esp)
 804a896:	e8 36 f2 ff ff       	call   8049ad1 <wrterror>

        if (malloc_zero && result)
 804a89b:	8b 83 90 02 00 00    	mov    0x290(%ebx),%eax
 804a8a1:	85 c0                	test   %eax,%eax
 804a8a3:	74 20                	je     804a8c5 <imalloc+0xad>
 804a8a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804a8a9:	74 1a                	je     804a8c5 <imalloc+0xad>
                memset(result, 0, size);
 804a8ab:	8b 45 08             	mov    0x8(%ebp),%eax
 804a8ae:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a8b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804a8b9:	00 
 804a8ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a8bd:	89 04 24             	mov    %eax,(%esp)
 804a8c0:	e8 b6 e9 ff ff       	call   804927b <memset>

        return result;
 804a8c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804a8c8:	83 c4 24             	add    $0x24,%esp
 804a8cb:	5b                   	pop    %ebx
 804a8cc:	5d                   	pop    %ebp
 804a8cd:	c3                   	ret    

0804a8ce <irealloc>:
/*
 * Change the size of an allocation.
 */
static void *
irealloc(void *ptr, size_t size)
{
 804a8ce:	55                   	push   %ebp
 804a8cf:	89 e5                	mov    %esp,%ebp
 804a8d1:	56                   	push   %esi
 804a8d2:	53                   	push   %ebx
 804a8d3:	83 ec 30             	sub    $0x30,%esp
 804a8d6:	e8 ee e7 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804a8db:	81 c3 25 47 00 00    	add    $0x4725,%ebx
        void *p;
        u_long osize, index;
        struct pginfo **mp;
        int i;

        if (suicide)
 804a8e1:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
 804a8e7:	85 c0                	test   %eax,%eax
 804a8e9:	74 0c                	je     804a8f7 <irealloc+0x29>
                abort();
 804a8eb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a8f2:	e8 67 dc ff ff       	call   804855e <exit>

        index = ptr2index(ptr);
 804a8f7:	8b 45 08             	mov    0x8(%ebp),%eax
 804a8fa:	c1 e8 0c             	shr    $0xc,%eax
 804a8fd:	89 c2                	mov    %eax,%edx
 804a8ff:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804a905:	29 c2                	sub    %eax,%edx
 804a907:	89 d0                	mov    %edx,%eax
 804a909:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (index < malloc_pageshift) {
 804a90c:	83 7d ec 0b          	cmpl   $0xb,-0x14(%ebp)
 804a910:	77 18                	ja     804a92a <irealloc+0x5c>
                wrtwarning("junk pointer, too low to make sense.\n");
 804a912:	8d 83 60 ee ff ff    	lea    -0x11a0(%ebx),%eax
 804a918:	89 04 24             	mov    %eax,(%esp)
 804a91b:	e8 81 f2 ff ff       	call   8049ba1 <wrtwarning>
                return 0;
 804a920:	b8 00 00 00 00       	mov    $0x0,%eax
 804a925:	e9 fc 01 00 00       	jmp    804ab26 <irealloc+0x258>
        }

        if (index > last_index) {
 804a92a:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804a930:	39 45 ec             	cmp    %eax,-0x14(%ebp)
 804a933:	76 18                	jbe    804a94d <irealloc+0x7f>
                wrtwarning("junk pointer, too high to make sense.\n");
 804a935:	8d 83 88 ee ff ff    	lea    -0x1178(%ebx),%eax
 804a93b:	89 04 24             	mov    %eax,(%esp)
 804a93e:	e8 5e f2 ff ff       	call   8049ba1 <wrtwarning>
                return 0;
 804a943:	b8 00 00 00 00       	mov    $0x0,%eax
 804a948:	e9 d9 01 00 00       	jmp    804ab26 <irealloc+0x258>
        }

        mp = &page_dir[index];
 804a94d:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804a953:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a956:	c1 e2 02             	shl    $0x2,%edx
 804a959:	01 d0                	add    %edx,%eax
 804a95b:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (*mp == MALLOC_FIRST) {                  /* Page allocation */
 804a95e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a961:	8b 00                	mov    (%eax),%eax
 804a963:	83 f8 02             	cmp    $0x2,%eax
 804a966:	75 75                	jne    804a9dd <irealloc+0x10f>

                /* Check the pointer */
                if ((u_long)ptr & malloc_pagemask) {
 804a968:	8b 45 08             	mov    0x8(%ebp),%eax
 804a96b:	25 ff 0f 00 00       	and    $0xfff,%eax
 804a970:	85 c0                	test   %eax,%eax
 804a972:	74 18                	je     804a98c <irealloc+0xbe>
                        wrtwarning("modified (page-) pointer.\n");
 804a974:	8d 83 af ee ff ff    	lea    -0x1151(%ebx),%eax
 804a97a:	89 04 24             	mov    %eax,(%esp)
 804a97d:	e8 1f f2 ff ff       	call   8049ba1 <wrtwarning>
                        return 0;
 804a982:	b8 00 00 00 00       	mov    $0x0,%eax
 804a987:	e9 9a 01 00 00       	jmp    804ab26 <irealloc+0x258>
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a98c:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
 804a993:	eb 07                	jmp    804a99c <irealloc+0xce>
                        osize += malloc_pagesize;
 804a995:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
                        wrtwarning("modified (page-) pointer.\n");
                        return 0;
                }

                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
 804a99c:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
 804a9a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a9a3:	8b 00                	mov    (%eax),%eax
 804a9a5:	83 f8 03             	cmp    $0x3,%eax
 804a9a8:	74 eb                	je     804a995 <irealloc+0xc7>
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
 804a9aa:	8b 83 80 02 00 00    	mov    0x280(%ebx),%eax
 804a9b0:	85 c0                	test   %eax,%eax
 804a9b2:	0f 85 04 01 00 00    	jne    804aabc <irealloc+0x1ee>
 804a9b8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a9bb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804a9be:	0f 87 f8 00 00 00    	ja     804aabc <irealloc+0x1ee>
                    size <= osize &&                      /* .. or are too small, */
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
 804a9c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a9c7:	2d 00 10 00 00       	sub    $0x1000,%eax
                /* Find the size in bytes */
                for (osize = malloc_pagesize; *++mp == MALLOC_FOLLOW;)
                        osize += malloc_pagesize;

                if (!malloc_realloc &&                  /* unless we have to, */
                    size <= osize &&                      /* .. or are too small, */
 804a9cc:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a9cf:	0f 83 e7 00 00 00    	jae    804aabc <irealloc+0x1ee>
                    size > (osize - malloc_pagesize)) {   /* .. or can free a page, */
                        return ptr;                         /* don't do anything. */
 804a9d5:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9d8:	e9 49 01 00 00       	jmp    804ab26 <irealloc+0x258>
                }

        } else if (*mp >= MALLOC_MAGIC) {           /* Chunk allocation */
 804a9dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a9e0:	8b 00                	mov    (%eax),%eax
 804a9e2:	83 f8 03             	cmp    $0x3,%eax
 804a9e5:	0f 86 bc 00 00 00    	jbe    804aaa7 <irealloc+0x1d9>

                /* Check the pointer for sane values */
                if (((u_long)ptr & ((*mp)->size - 1))) {
 804a9eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a9ee:	8b 00                	mov    (%eax),%eax
 804a9f0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804a9f4:	48                   	dec    %eax
 804a9f5:	89 c2                	mov    %eax,%edx
 804a9f7:	8b 45 08             	mov    0x8(%ebp),%eax
 804a9fa:	21 d0                	and    %edx,%eax
 804a9fc:	85 c0                	test   %eax,%eax
 804a9fe:	74 18                	je     804aa18 <irealloc+0x14a>
                        wrtwarning("modified (chunk-) pointer.\n");
 804aa00:	8d 83 ca ee ff ff    	lea    -0x1136(%ebx),%eax
 804aa06:	89 04 24             	mov    %eax,(%esp)
 804aa09:	e8 93 f1 ff ff       	call   8049ba1 <wrtwarning>
                        return 0;
 804aa0e:	b8 00 00 00 00       	mov    $0x0,%eax
 804aa13:	e9 0e 01 00 00       	jmp    804ab26 <irealloc+0x258>
                }

                /* Find the chunk index in the page */
                i = ((u_long)ptr & malloc_pagemask) >> (*mp)->shift;
 804aa18:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa1b:	25 ff 0f 00 00       	and    $0xfff,%eax
 804aa20:	89 c2                	mov    %eax,%edx
 804aa22:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aa25:	8b 00                	mov    (%eax),%eax
 804aa27:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804aa2b:	88 c1                	mov    %al,%cl
 804aa2d:	d3 ea                	shr    %cl,%edx
 804aa2f:	89 d0                	mov    %edx,%eax
 804aa31:	89 45 e8             	mov    %eax,-0x18(%ebp)

                /* Verify that it isn't a free chunk already */
                if ((*mp)->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804aa34:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aa37:	8b 00                	mov    (%eax),%eax
 804aa39:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804aa3c:	c1 ea 05             	shr    $0x5,%edx
 804aa3f:	83 c2 04             	add    $0x4,%edx
 804aa42:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804aa45:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804aa48:	83 e2 1f             	and    $0x1f,%edx
 804aa4b:	be 01 00 00 00       	mov    $0x1,%esi
 804aa50:	88 d1                	mov    %dl,%cl
 804aa52:	d3 e6                	shl    %cl,%esi
 804aa54:	89 f2                	mov    %esi,%edx
 804aa56:	21 d0                	and    %edx,%eax
 804aa58:	85 c0                	test   %eax,%eax
 804aa5a:	74 18                	je     804aa74 <irealloc+0x1a6>
                        wrtwarning("chunk is already free.\n");
 804aa5c:	8d 83 e6 ee ff ff    	lea    -0x111a(%ebx),%eax
 804aa62:	89 04 24             	mov    %eax,(%esp)
 804aa65:	e8 37 f1 ff ff       	call   8049ba1 <wrtwarning>
                        return 0;
 804aa6a:	b8 00 00 00 00       	mov    $0x0,%eax
 804aa6f:	e9 b2 00 00 00       	jmp    804ab26 <irealloc+0x258>
                }

                osize = (*mp)->size;
 804aa74:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aa77:	8b 00                	mov    (%eax),%eax
 804aa79:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804aa7d:	89 45 f4             	mov    %eax,-0xc(%ebp)

                if (!malloc_realloc &&          /* Unless we have to, */
 804aa80:	8b 83 80 02 00 00    	mov    0x280(%ebx),%eax
 804aa86:	85 c0                	test   %eax,%eax
 804aa88:	75 32                	jne    804aabc <irealloc+0x1ee>
 804aa8a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aa8d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804aa90:	73 2a                	jae    804aabc <irealloc+0x1ee>
                    size < osize &&               /* ..or are too small, */
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804aa92:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aa95:	d1 e8                	shr    %eax
                }

                osize = (*mp)->size;

                if (!malloc_realloc &&          /* Unless we have to, */
                    size < osize &&               /* ..or are too small, */
 804aa97:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804aa9a:	72 06                	jb     804aaa2 <irealloc+0x1d4>
                    (size > osize / 2 ||          /* ..or could use a smaller size, */
 804aa9c:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
 804aaa0:	75 1a                	jne    804aabc <irealloc+0x1ee>
                     osize == malloc_minsize)) {   /* ..(if there is one) */
                        return ptr;                 /* ..Don't do anything */
 804aaa2:	8b 45 08             	mov    0x8(%ebp),%eax
 804aaa5:	eb 7f                	jmp    804ab26 <irealloc+0x258>
                }

        } else {
                wrtwarning("pointer to wrong page.\n");
 804aaa7:	8d 83 fe ee ff ff    	lea    -0x1102(%ebx),%eax
 804aaad:	89 04 24             	mov    %eax,(%esp)
 804aab0:	e8 ec f0 ff ff       	call   8049ba1 <wrtwarning>
                return 0;
 804aab5:	b8 00 00 00 00       	mov    $0x0,%eax
 804aaba:	eb 6a                	jmp    804ab26 <irealloc+0x258>
        }

        p = imalloc(size);
 804aabc:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aabf:	89 04 24             	mov    %eax,(%esp)
 804aac2:	e8 51 fd ff ff       	call   804a818 <imalloc>
 804aac7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (p) {
 804aaca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804aace:	74 53                	je     804ab23 <irealloc+0x255>
                /* copy the lesser of the two sizes, and free the old one */
                if (!size || !osize)
 804aad0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804aad4:	74 42                	je     804ab18 <irealloc+0x24a>
 804aad6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804aada:	74 3c                	je     804ab18 <irealloc+0x24a>
                        ;
                else if (osize < size)
 804aadc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aadf:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804aae2:	73 1b                	jae    804aaff <irealloc+0x231>
                        memcpy(p, ptr, osize);
 804aae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aae7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aaeb:	8b 45 08             	mov    0x8(%ebp),%eax
 804aaee:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aaf2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aaf5:	89 04 24             	mov    %eax,(%esp)
 804aaf8:	e8 23 e6 ff ff       	call   8049120 <memcpy>
 804aafd:	eb 19                	jmp    804ab18 <irealloc+0x24a>
                else
                        memcpy(p, ptr, size);
 804aaff:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab02:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ab06:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab09:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ab0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ab10:	89 04 24             	mov    %eax,(%esp)
 804ab13:	e8 08 e6 ff ff       	call   8049120 <memcpy>
                ifree(ptr);
 804ab18:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab1b:	89 04 24             	mov    %eax,(%esp)
 804ab1e:	e8 14 06 00 00       	call   804b137 <ifree>
        }
        return p;
 804ab23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
 804ab26:	83 c4 30             	add    $0x30,%esp
 804ab29:	5b                   	pop    %ebx
 804ab2a:	5e                   	pop    %esi
 804ab2b:	5d                   	pop    %ebp
 804ab2c:	c3                   	ret    

0804ab2d <free_pages>:
 * Free a sequence of pages
 */

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
 804ab2d:	55                   	push   %ebp
 804ab2e:	89 e5                	mov    %esp,%ebp
 804ab30:	53                   	push   %ebx
 804ab31:	83 ec 34             	sub    $0x34,%esp
 804ab34:	e8 90 e5 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804ab39:	81 c3 c7 44 00 00    	add    $0x44c7,%ebx
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804ab3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804ab46:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
 804ab4a:	75 13                	jne    804ab5f <free_pages+0x32>
                wrtwarning("page is already free.\n");
 804ab4c:	8d 83 16 ef ff ff    	lea    -0x10ea(%ebx),%eax
 804ab52:	89 04 24             	mov    %eax,(%esp)
 804ab55:	e8 47 f0 ff ff       	call   8049ba1 <wrtwarning>
                return;
 804ab5a:	e9 db 03 00 00       	jmp    804af3a <free_pages+0x40d>
        }

        if (info != MALLOC_FIRST) {
 804ab5f:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
 804ab63:	74 13                	je     804ab78 <free_pages+0x4b>
                wrtwarning("pointer to wrong page.\n");
 804ab65:	8d 83 fe ee ff ff    	lea    -0x1102(%ebx),%eax
 804ab6b:	89 04 24             	mov    %eax,(%esp)
 804ab6e:	e8 2e f0 ff ff       	call   8049ba1 <wrtwarning>
                return;
 804ab73:	e9 c2 03 00 00       	jmp    804af3a <free_pages+0x40d>
        }

        if ((u_long)ptr & malloc_pagemask) {
 804ab78:	8b 45 08             	mov    0x8(%ebp),%eax
 804ab7b:	25 ff 0f 00 00       	and    $0xfff,%eax
 804ab80:	85 c0                	test   %eax,%eax
 804ab82:	74 13                	je     804ab97 <free_pages+0x6a>
                wrtwarning("modified (page-) pointer.\n");
 804ab84:	8d 83 af ee ff ff    	lea    -0x1151(%ebx),%eax
 804ab8a:	89 04 24             	mov    %eax,(%esp)
 804ab8d:	e8 0f f0 ff ff       	call   8049ba1 <wrtwarning>
                return;
 804ab92:	e9 a3 03 00 00       	jmp    804af3a <free_pages+0x40d>
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804ab97:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804ab9d:	8b 55 0c             	mov    0xc(%ebp),%edx
 804aba0:	c1 e2 02             	shl    $0x2,%edx
 804aba3:	01 d0                	add    %edx,%eax
 804aba5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804abab:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
 804abb2:	eb 1c                	jmp    804abd0 <free_pages+0xa3>
                page_dir[index + i] = MALLOC_FREE;
 804abb4:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804abba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804abbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804abc0:	01 ca                	add    %ecx,%edx
 804abc2:	c1 e2 02             	shl    $0x2,%edx
 804abc5:	01 d0                	add    %edx,%eax
 804abc7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804abcd:	ff 45 f4             	incl   -0xc(%ebp)
 804abd0:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804abd6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804abd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804abdc:	01 ca                	add    %ecx,%edx
 804abde:	c1 e2 02             	shl    $0x2,%edx
 804abe1:	01 d0                	add    %edx,%eax
 804abe3:	8b 00                	mov    (%eax),%eax
 804abe5:	83 f8 03             	cmp    $0x3,%eax
 804abe8:	74 ca                	je     804abb4 <free_pages+0x87>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804abea:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804abed:	c1 e0 0c             	shl    $0xc,%eax
 804abf0:	89 45 e8             	mov    %eax,-0x18(%ebp)

        if (malloc_junk)
 804abf3:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804abf9:	85 c0                	test   %eax,%eax
 804abfb:	74 1a                	je     804ac17 <free_pages+0xea>
                memset(ptr, SOME_JUNK, l);
 804abfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac00:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ac04:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804ac0b:	00 
 804ac0c:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac0f:	89 04 24             	mov    %eax,(%esp)
 804ac12:	e8 64 e6 ff ff       	call   804927b <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804ac17:	8b 55 08             	mov    0x8(%ebp),%edx
 804ac1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac1d:	01 d0                	add    %edx,%eax
 804ac1f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        /* add to free-list */
        if (!px)
 804ac22:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac28:	85 c0                	test   %eax,%eax
 804ac2a:	75 12                	jne    804ac3e <free_pages+0x111>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804ac2c:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804ac33:	e8 e0 fb ff ff       	call   804a818 <imalloc>
 804ac38:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
        px->page = ptr;
 804ac3e:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac44:	8b 55 08             	mov    0x8(%ebp),%edx
 804ac47:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804ac4a:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac50:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ac53:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804ac56:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac5c:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804ac5f:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804ac62:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 804ac68:	85 c0                	test   %eax,%eax
 804ac6a:	75 41                	jne    804acad <free_pages+0x180>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804ac6c:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac72:	8b 93 64 02 00 00    	mov    0x264(%ebx),%edx
 804ac78:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804ac7a:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac80:	8d 93 64 02 00 00    	lea    0x264(%ebx),%edx
 804ac86:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804ac89:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac8f:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
                pf = px;
 804ac95:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ac9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                px = 0;
 804ac9e:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804aca5:	00 00 00 
 804aca8:	e9 a2 01 00 00       	jmp    804ae4f <free_pages+0x322>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804acad:	8b 55 08             	mov    0x8(%ebp),%edx
 804acb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804acb3:	01 d0                	add    %edx,%eax
 804acb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804acb8:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 804acbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804acc1:	eb 08                	jmp    804accb <free_pages+0x19e>
 804acc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acc6:	8b 00                	mov    (%eax),%eax
 804acc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804accb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acce:	8b 40 0c             	mov    0xc(%eax),%eax
 804acd1:	3b 45 08             	cmp    0x8(%ebp),%eax
 804acd4:	73 09                	jae    804acdf <free_pages+0x1b2>
 804acd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804acd9:	8b 00                	mov    (%eax),%eax
 804acdb:	85 c0                	test   %eax,%eax
 804acdd:	75 e4                	jne    804acc3 <free_pages+0x196>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804acdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ace2:	8b 40 08             	mov    0x8(%eax),%eax
 804ace5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804ace8:	76 4f                	jbe    804ad39 <free_pages+0x20c>
                        /* Insert before entry */
                        px->next = pf;
 804acea:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804acf0:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804acf3:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804acf5:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804acfb:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804acfe:	8b 52 04             	mov    0x4(%edx),%edx
 804ad01:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804ad04:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804ad0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad0d:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804ad10:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ad16:	8b 40 04             	mov    0x4(%eax),%eax
 804ad19:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804ad1f:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804ad21:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ad27:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804ad2a:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804ad31:	00 00 00 
 804ad34:	e9 16 01 00 00       	jmp    804ae4f <free_pages+0x322>
                } else if (pf->end == ptr) {
 804ad39:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad3c:	8b 40 0c             	mov    0xc(%eax),%eax
 804ad3f:	3b 45 08             	cmp    0x8(%ebp),%eax
 804ad42:	0f 85 91 00 00 00    	jne    804add9 <free_pages+0x2ac>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804ad48:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad4b:	8b 50 0c             	mov    0xc(%eax),%edx
 804ad4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ad51:	01 c2                	add    %eax,%edx
 804ad53:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad56:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804ad59:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad5c:	8b 50 10             	mov    0x10(%eax),%edx
 804ad5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ad62:	01 c2                	add    %eax,%edx
 804ad64:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad67:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804ad6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad6d:	8b 00                	mov    (%eax),%eax
 804ad6f:	85 c0                	test   %eax,%eax
 804ad71:	0f 84 d8 00 00 00    	je     804ae4f <free_pages+0x322>
 804ad77:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad7a:	8b 50 0c             	mov    0xc(%eax),%edx
 804ad7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad80:	8b 00                	mov    (%eax),%eax
 804ad82:	8b 40 08             	mov    0x8(%eax),%eax
 804ad85:	39 c2                	cmp    %eax,%edx
 804ad87:	0f 85 c2 00 00 00    	jne    804ae4f <free_pages+0x322>
                                /* And collapse the next too. */
                                pt = pf->next;
 804ad8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad90:	8b 00                	mov    (%eax),%eax
 804ad92:	89 45 ec             	mov    %eax,-0x14(%ebp)
                                pf->end = pt->end;
 804ad95:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad98:	8b 50 0c             	mov    0xc(%eax),%edx
 804ad9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad9e:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804ada1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ada4:	8b 50 10             	mov    0x10(%eax),%edx
 804ada7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804adaa:	8b 40 10             	mov    0x10(%eax),%eax
 804adad:	01 c2                	add    %eax,%edx
 804adaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adb2:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804adb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804adb8:	8b 10                	mov    (%eax),%edx
 804adba:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adbd:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804adbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adc2:	8b 00                	mov    (%eax),%eax
 804adc4:	85 c0                	test   %eax,%eax
 804adc6:	0f 84 83 00 00 00    	je     804ae4f <free_pages+0x322>
                                        pf->next->prev = pf;
 804adcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adcf:	8b 00                	mov    (%eax),%eax
 804add1:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804add4:	89 50 04             	mov    %edx,0x4(%eax)
 804add7:	eb 76                	jmp    804ae4f <free_pages+0x322>
                        }
                } else if (pf->page == tail) {
 804add9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804addc:	8b 40 08             	mov    0x8(%eax),%eax
 804addf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804ade2:	75 1c                	jne    804ae00 <free_pages+0x2d3>
                        /* Prepend to entry */
                        pf->size += l;
 804ade4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ade7:	8b 50 10             	mov    0x10(%eax),%edx
 804adea:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804aded:	01 c2                	add    %eax,%edx
 804adef:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adf2:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804adf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804adf8:	8b 55 08             	mov    0x8(%ebp),%edx
 804adfb:	89 50 08             	mov    %edx,0x8(%eax)
 804adfe:	eb 4f                	jmp    804ae4f <free_pages+0x322>
                } else if (!pf->next) {
 804ae00:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae03:	8b 00                	mov    (%eax),%eax
 804ae05:	85 c0                	test   %eax,%eax
 804ae07:	75 38                	jne    804ae41 <free_pages+0x314>
                        /* Append at tail of chain */
                        px->next = 0;
 804ae09:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ae0f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804ae15:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ae1b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ae1e:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804ae21:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804ae27:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae2a:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804ae2c:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804ae32:	89 45 f0             	mov    %eax,-0x10(%ebp)
                        px = 0;
 804ae35:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804ae3c:	00 00 00 
 804ae3f:	eb 0e                	jmp    804ae4f <free_pages+0x322>
                } else {
                        wrterror("freelist is destroyed.\n");
 804ae41:	8d 83 2d ef ff ff    	lea    -0x10d3(%ebx),%eax
 804ae47:	89 04 24             	mov    %eax,(%esp)
 804ae4a:	e8 82 ec ff ff       	call   8049ad1 <wrterror>
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ae4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae52:	8b 00                	mov    (%eax),%eax
 804ae54:	85 c0                	test   %eax,%eax
 804ae56:	0f 85 cd 00 00 00    	jne    804af29 <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ae5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae5f:	8b 50 10             	mov    0x10(%eax),%edx
 804ae62:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804ae68:	39 c2                	cmp    %eax,%edx
 804ae6a:	0f 86 b9 00 00 00    	jbe    804af29 <free_pages+0x3fc>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ae70:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ae73:	8b 50 0c             	mov    0xc(%eax),%edx
 804ae76:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804ae7c:	39 c2                	cmp    %eax,%edx
 804ae7e:	0f 85 a5 00 00 00    	jne    804af29 <free_pages+0x3fc>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804ae84:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ae8b:	e8 df d4 ff ff       	call   804836f <sbrk>
 804ae90:	89 c2                	mov    %eax,%edx
 804ae92:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804ae98:	39 c2                	cmp    %eax,%edx
 804ae9a:	0f 85 89 00 00 00    	jne    804af29 <free_pages+0x3fc>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804aea0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aea3:	8b 50 08             	mov    0x8(%eax),%edx
 804aea6:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 804aeac:	01 c2                	add    %eax,%edx
 804aeae:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aeb1:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804aeb4:	8b 93 34 00 00 00    	mov    0x34(%ebx),%edx
 804aeba:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aebd:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804aec0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aec3:	8b 40 0c             	mov    0xc(%eax),%eax
 804aec6:	89 04 24             	mov    %eax,(%esp)
 804aec9:	e8 6a d5 ff ff       	call   8048438 <brk>
                malloc_brk = pf->end;
 804aece:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aed1:	8b 40 0c             	mov    0xc(%eax),%eax
 804aed4:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)

                index = ptr2index(pf->end);
 804aeda:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aedd:	8b 40 0c             	mov    0xc(%eax),%eax
 804aee0:	c1 e8 0c             	shr    $0xc,%eax
 804aee3:	89 c2                	mov    %eax,%edx
 804aee5:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804aeeb:	29 c2                	sub    %eax,%edx
 804aeed:	89 d0                	mov    %edx,%eax
 804aeef:	89 45 0c             	mov    %eax,0xc(%ebp)
                last_index = index - 1;
 804aef2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aef5:	48                   	dec    %eax
 804aef6:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

                for (i = index; i <= last_index;)
 804aefc:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aeff:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804af02:	eb 1a                	jmp    804af1e <free_pages+0x3f1>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804af04:	8b 8b 5c 02 00 00    	mov    0x25c(%ebx),%ecx
 804af0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af0d:	8d 50 01             	lea    0x1(%eax),%edx
 804af10:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804af13:	c1 e0 02             	shl    $0x2,%eax
 804af16:	01 c8                	add    %ecx,%eax
 804af18:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804af1e:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804af24:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804af27:	76 db                	jbe    804af04 <free_pages+0x3d7>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804af29:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804af2d:	74 0b                	je     804af3a <free_pages+0x40d>
                ifree(pt);
 804af2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804af32:	89 04 24             	mov    %eax,(%esp)
 804af35:	e8 fd 01 00 00       	call   804b137 <ifree>
}
 804af3a:	83 c4 34             	add    $0x34,%esp
 804af3d:	5b                   	pop    %ebx
 804af3e:	5d                   	pop    %ebp
 804af3f:	c3                   	ret    

0804af40 <free_bytes>:
 * Free a chunk, and possibly the page it's on, if the page becomes empty.
 */

static __inline__ void
free_bytes(void *ptr, int index, struct pginfo *info)
{
 804af40:	55                   	push   %ebp
 804af41:	89 e5                	mov    %esp,%ebp
 804af43:	56                   	push   %esi
 804af44:	53                   	push   %ebx
 804af45:	83 ec 20             	sub    $0x20,%esp
 804af48:	e8 7c e1 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804af4d:	81 c3 b3 40 00 00    	add    $0x40b3,%ebx
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804af53:	8b 45 08             	mov    0x8(%ebp),%eax
 804af56:	25 ff 0f 00 00       	and    $0xfff,%eax
 804af5b:	89 c2                	mov    %eax,%edx
 804af5d:	8b 45 10             	mov    0x10(%ebp),%eax
 804af60:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804af64:	88 c1                	mov    %al,%cl
 804af66:	d3 ea                	shr    %cl,%edx
 804af68:	89 d0                	mov    %edx,%eax
 804af6a:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804af6d:	8b 45 10             	mov    0x10(%ebp),%eax
 804af70:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804af74:	48                   	dec    %eax
 804af75:	89 c2                	mov    %eax,%edx
 804af77:	8b 45 08             	mov    0x8(%ebp),%eax
 804af7a:	21 d0                	and    %edx,%eax
 804af7c:	85 c0                	test   %eax,%eax
 804af7e:	74 13                	je     804af93 <free_bytes+0x53>
                wrtwarning("modified (chunk-) pointer.\n");
 804af80:	8d 83 ca ee ff ff    	lea    -0x1136(%ebx),%eax
 804af86:	89 04 24             	mov    %eax,(%esp)
 804af89:	e8 13 ec ff ff       	call   8049ba1 <wrtwarning>
                return;
 804af8e:	e9 9d 01 00 00       	jmp    804b130 <free_bytes+0x1f0>
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804af93:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804af96:	c1 e8 05             	shr    $0x5,%eax
 804af99:	89 c2                	mov    %eax,%edx
 804af9b:	8b 45 10             	mov    0x10(%ebp),%eax
 804af9e:	83 c2 04             	add    $0x4,%edx
 804afa1:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804afa4:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804afa7:	83 e2 1f             	and    $0x1f,%edx
 804afaa:	be 01 00 00 00       	mov    $0x1,%esi
 804afaf:	88 d1                	mov    %dl,%cl
 804afb1:	d3 e6                	shl    %cl,%esi
 804afb3:	89 f2                	mov    %esi,%edx
 804afb5:	21 d0                	and    %edx,%eax
 804afb7:	85 c0                	test   %eax,%eax
 804afb9:	74 13                	je     804afce <free_bytes+0x8e>
                wrtwarning("chunk is already free.\n");
 804afbb:	8d 83 e6 ee ff ff    	lea    -0x111a(%ebx),%eax
 804afc1:	89 04 24             	mov    %eax,(%esp)
 804afc4:	e8 d8 eb ff ff       	call   8049ba1 <wrtwarning>
                return;
 804afc9:	e9 62 01 00 00       	jmp    804b130 <free_bytes+0x1f0>
        }

        if (malloc_junk)
 804afce:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804afd4:	85 c0                	test   %eax,%eax
 804afd6:	74 1e                	je     804aff6 <free_bytes+0xb6>
                memset(ptr, SOME_JUNK, info->size);
 804afd8:	8b 45 10             	mov    0x10(%ebp),%eax
 804afdb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804afdf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804afe3:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804afea:	00 
 804afeb:	8b 45 08             	mov    0x8(%ebp),%eax
 804afee:	89 04 24             	mov    %eax,(%esp)
 804aff1:	e8 85 e2 ff ff       	call   804927b <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804aff6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aff9:	c1 e8 05             	shr    $0x5,%eax
 804affc:	8b 55 10             	mov    0x10(%ebp),%edx
 804afff:	8d 48 04             	lea    0x4(%eax),%ecx
 804b002:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804b005:	8b 4d f0             	mov    -0x10(%ebp),%ecx
 804b008:	83 e1 1f             	and    $0x1f,%ecx
 804b00b:	be 01 00 00 00       	mov    $0x1,%esi
 804b010:	d3 e6                	shl    %cl,%esi
 804b012:	89 f1                	mov    %esi,%ecx
 804b014:	09 d1                	or     %edx,%ecx
 804b016:	8b 55 10             	mov    0x10(%ebp),%edx
 804b019:	83 c0 04             	add    $0x4,%eax
 804b01c:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804b01f:	8b 45 10             	mov    0x10(%ebp),%eax
 804b022:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b026:	40                   	inc    %eax
 804b027:	0f b7 d0             	movzwl %ax,%edx
 804b02a:	8b 45 10             	mov    0x10(%ebp),%eax
 804b02d:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804b031:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b037:	8b 45 10             	mov    0x10(%ebp),%eax
 804b03a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b03e:	c1 e0 02             	shl    $0x2,%eax
 804b041:	01 d0                	add    %edx,%eax
 804b043:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free == 1) {
 804b046:	8b 45 10             	mov    0x10(%ebp),%eax
 804b049:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b04d:	83 f8 01             	cmp    $0x1,%eax
 804b050:	75 5e                	jne    804b0b0 <free_bytes+0x170>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804b052:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b058:	8b 45 10             	mov    0x10(%ebp),%eax
 804b05b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b05f:	c1 e0 02             	shl    $0x2,%eax
 804b062:	01 d0                	add    %edx,%eax
 804b064:	89 45 f4             	mov    %eax,-0xc(%ebp)
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b067:	eb 08                	jmp    804b071 <free_bytes+0x131>
                        mp = &(*mp)->next;
 804b069:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b06c:	8b 00                	mov    (%eax),%eax
 804b06e:	89 45 f4             	mov    %eax,-0xc(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b071:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b074:	8b 00                	mov    (%eax),%eax
 804b076:	85 c0                	test   %eax,%eax
 804b078:	74 1f                	je     804b099 <free_bytes+0x159>
 804b07a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b07d:	8b 00                	mov    (%eax),%eax
 804b07f:	8b 00                	mov    (%eax),%eax
 804b081:	85 c0                	test   %eax,%eax
 804b083:	74 14                	je     804b099 <free_bytes+0x159>
 804b085:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b088:	8b 00                	mov    (%eax),%eax
 804b08a:	8b 00                	mov    (%eax),%eax
 804b08c:	8b 50 04             	mov    0x4(%eax),%edx
 804b08f:	8b 45 10             	mov    0x10(%ebp),%eax
 804b092:	8b 40 04             	mov    0x4(%eax),%eax
 804b095:	39 c2                	cmp    %eax,%edx
 804b097:	72 d0                	jb     804b069 <free_bytes+0x129>
                        mp = &(*mp)->next;
                info->next = *mp;
 804b099:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b09c:	8b 10                	mov    (%eax),%edx
 804b09e:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0a1:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804b0a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0a6:	8b 55 10             	mov    0x10(%ebp),%edx
 804b0a9:	89 10                	mov    %edx,(%eax)
                return;
 804b0ab:	e9 80 00 00 00       	jmp    804b130 <free_bytes+0x1f0>
        }

        if (info->free != info->total)
 804b0b0:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0b3:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b0b7:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0ba:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b0be:	39 c2                	cmp    %eax,%edx
 804b0c0:	75 6d                	jne    804b12f <free_bytes+0x1ef>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804b0c2:	eb 08                	jmp    804b0cc <free_bytes+0x18c>
                mp = &((*mp)->next);
 804b0c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0c7:	8b 00                	mov    (%eax),%eax
 804b0c9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804b0cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0cf:	8b 00                	mov    (%eax),%eax
 804b0d1:	3b 45 10             	cmp    0x10(%ebp),%eax
 804b0d4:	75 ee                	jne    804b0c4 <free_bytes+0x184>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804b0d6:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0d9:	8b 10                	mov    (%eax),%edx
 804b0db:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b0de:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804b0e0:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b0e6:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0e9:	8b 40 04             	mov    0x4(%eax),%eax
 804b0ec:	c1 e8 0c             	shr    $0xc,%eax
 804b0ef:	89 c1                	mov    %eax,%ecx
 804b0f1:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b0f7:	29 c1                	sub    %eax,%ecx
 804b0f9:	89 c8                	mov    %ecx,%eax
 804b0fb:	c1 e0 02             	shl    $0x2,%eax
 804b0fe:	01 d0                	add    %edx,%eax
 804b100:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804b106:	8b 45 10             	mov    0x10(%ebp),%eax
 804b109:	8b 40 04             	mov    0x4(%eax),%eax
 804b10c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (vp != (void *)info)
 804b10f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b112:	3b 45 10             	cmp    0x10(%ebp),%eax
 804b115:	74 0b                	je     804b122 <free_bytes+0x1e2>
                ifree(info);
 804b117:	8b 45 10             	mov    0x10(%ebp),%eax
 804b11a:	89 04 24             	mov    %eax,(%esp)
 804b11d:	e8 15 00 00 00       	call   804b137 <ifree>
        ifree(vp);
 804b122:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b125:	89 04 24             	mov    %eax,(%esp)
 804b128:	e8 0a 00 00 00       	call   804b137 <ifree>
 804b12d:	eb 01                	jmp    804b130 <free_bytes+0x1f0>
                *mp = info;
                return;
        }

        if (info->free != info->total)
                return;
 804b12f:	90                   	nop
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
        vp = info->page;            /* Order is important ! */
        if (vp != (void *)info)
                ifree(info);
        ifree(vp);
}
 804b130:	83 c4 20             	add    $0x20,%esp
 804b133:	5b                   	pop    %ebx
 804b134:	5e                   	pop    %esi
 804b135:	5d                   	pop    %ebp
 804b136:	c3                   	ret    

0804b137 <ifree>:

static void
ifree(void *ptr)
{
 804b137:	55                   	push   %ebp
 804b138:	89 e5                	mov    %esp,%ebp
 804b13a:	56                   	push   %esi
 804b13b:	53                   	push   %ebx
 804b13c:	83 ec 50             	sub    $0x50,%esp
 804b13f:	e8 85 df ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804b144:	81 c3 bc 3e 00 00    	add    $0x3ebc,%ebx
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
 804b14a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b14e:	0f 84 9c 06 00 00    	je     804b7f0 <ifree+0x6b9>
                return;

        if (!malloc_started) {
 804b154:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b15a:	85 c0                	test   %eax,%eax
 804b15c:	75 13                	jne    804b171 <ifree+0x3a>
                wrtwarning("malloc() has never been called.\n");
 804b15e:	8d 83 48 ef ff ff    	lea    -0x10b8(%ebx),%eax
 804b164:	89 04 24             	mov    %eax,(%esp)
 804b167:	e8 35 ea ff ff       	call   8049ba1 <wrtwarning>
                return;
 804b16c:	e9 86 06 00 00       	jmp    804b7f7 <ifree+0x6c0>
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
 804b171:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
 804b177:	85 c0                	test   %eax,%eax
 804b179:	0f 85 74 06 00 00    	jne    804b7f3 <ifree+0x6bc>
                return;

        index = ptr2index(ptr);
 804b17f:	8b 45 08             	mov    0x8(%ebp),%eax
 804b182:	c1 e8 0c             	shr    $0xc,%eax
 804b185:	89 c2                	mov    %eax,%edx
 804b187:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b18d:	29 c2                	sub    %eax,%edx
 804b18f:	89 d0                	mov    %edx,%eax
 804b191:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if (index < malloc_pageshift) {
 804b194:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
 804b198:	77 13                	ja     804b1ad <ifree+0x76>
                wrtwarning("junk pointer, too low to make sense.\n");
 804b19a:	8d 83 60 ee ff ff    	lea    -0x11a0(%ebx),%eax
 804b1a0:	89 04 24             	mov    %eax,(%esp)
 804b1a3:	e8 f9 e9 ff ff       	call   8049ba1 <wrtwarning>
                return;
 804b1a8:	e9 4a 06 00 00       	jmp    804b7f7 <ifree+0x6c0>
        }

        if (index > last_index) {
 804b1ad:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b1b3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
 804b1b6:	76 13                	jbe    804b1cb <ifree+0x94>
                wrtwarning("junk pointer, too high to make sense.\n");
 804b1b8:	8d 83 88 ee ff ff    	lea    -0x1178(%ebx),%eax
 804b1be:	89 04 24             	mov    %eax,(%esp)
 804b1c1:	e8 db e9 ff ff       	call   8049ba1 <wrtwarning>
                return;
 804b1c6:	e9 2c 06 00 00       	jmp    804b7f7 <ifree+0x6c0>
        }

        info = page_dir[index];
 804b1cb:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b1d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b1d4:	c1 e2 02             	shl    $0x2,%edx
 804b1d7:	01 d0                	add    %edx,%eax
 804b1d9:	8b 00                	mov    (%eax),%eax
 804b1db:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (info < MALLOC_MAGIC)
 804b1de:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
 804b1e2:	0f 87 19 04 00 00    	ja     804b601 <ifree+0x4ca>
                free_pages(ptr, index, info);
 804b1e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b1eb:	8b 55 08             	mov    0x8(%ebp),%edx
 804b1ee:	89 55 e8             	mov    %edx,-0x18(%ebp)
 804b1f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804b1f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b1f7:	89 45 e0             	mov    %eax,-0x20(%ebp)

static __inline__ void
free_pages(void *ptr, int index, struct pginfo *info)
{
        unsigned int i;
        struct pgfree *pf, *pt = 0;
 804b1fa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        u_long l;
        void *tail;

        if (info == MALLOC_FREE) {
 804b201:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
 804b205:	75 13                	jne    804b21a <ifree+0xe3>
                wrtwarning("page is already free.\n");
 804b207:	8d 83 16 ef ff ff    	lea    -0x10ea(%ebx),%eax
 804b20d:	89 04 24             	mov    %eax,(%esp)
 804b210:	e8 8c e9 ff ff       	call   8049ba1 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b215:	e9 dc 05 00 00       	jmp    804b7f6 <ifree+0x6bf>
        if (info == MALLOC_FREE) {
                wrtwarning("page is already free.\n");
                return;
        }

        if (info != MALLOC_FIRST) {
 804b21a:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
 804b21e:	74 13                	je     804b233 <ifree+0xfc>
                wrtwarning("pointer to wrong page.\n");
 804b220:	8d 83 fe ee ff ff    	lea    -0x1102(%ebx),%eax
 804b226:	89 04 24             	mov    %eax,(%esp)
 804b229:	e8 73 e9 ff ff       	call   8049ba1 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b22e:	e9 c3 05 00 00       	jmp    804b7f6 <ifree+0x6bf>
        if (info != MALLOC_FIRST) {
                wrtwarning("pointer to wrong page.\n");
                return;
        }

        if ((u_long)ptr & malloc_pagemask) {
 804b233:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b236:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b23b:	85 c0                	test   %eax,%eax
 804b23d:	74 13                	je     804b252 <ifree+0x11b>
                wrtwarning("modified (page-) pointer.\n");
 804b23f:	8d 83 af ee ff ff    	lea    -0x1151(%ebx),%eax
 804b245:	89 04 24             	mov    %eax,(%esp)
 804b248:	e8 54 e9 ff ff       	call   8049ba1 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b24d:	e9 a4 05 00 00       	jmp    804b7f6 <ifree+0x6bf>
                wrtwarning("modified (page-) pointer.\n");
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
 804b252:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b258:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804b25b:	c1 e2 02             	shl    $0x2,%edx
 804b25e:	01 d0                	add    %edx,%eax
 804b260:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b266:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
 804b26d:	eb 1c                	jmp    804b28b <ifree+0x154>
                page_dir[index + i] = MALLOC_FREE;
 804b26f:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b275:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b278:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b27b:	01 ca                	add    %ecx,%edx
 804b27d:	c1 e2 02             	shl    $0x2,%edx
 804b280:	01 d0                	add    %edx,%eax
 804b282:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
                return;
        }

        /* Count how many pages and mark them free at the same time */
        page_dir[index] = MALLOC_FREE;
        for (i = 1; page_dir[index + i] == MALLOC_FOLLOW; i++)
 804b288:	ff 45 d8             	incl   -0x28(%ebp)
 804b28b:	8b 83 5c 02 00 00    	mov    0x25c(%ebx),%eax
 804b291:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 804b294:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b297:	01 ca                	add    %ecx,%edx
 804b299:	c1 e2 02             	shl    $0x2,%edx
 804b29c:	01 d0                	add    %edx,%eax
 804b29e:	8b 00                	mov    (%eax),%eax
 804b2a0:	83 f8 03             	cmp    $0x3,%eax
 804b2a3:	74 ca                	je     804b26f <ifree+0x138>
                page_dir[index + i] = MALLOC_FREE;

        l = i << malloc_pageshift;
 804b2a5:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b2a8:	c1 e0 0c             	shl    $0xc,%eax
 804b2ab:	89 45 d4             	mov    %eax,-0x2c(%ebp)

        if (malloc_junk)
 804b2ae:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804b2b4:	85 c0                	test   %eax,%eax
 804b2b6:	74 1a                	je     804b2d2 <ifree+0x19b>
                memset(ptr, SOME_JUNK, l);
 804b2b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b2bb:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b2bf:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b2c6:	00 
 804b2c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804b2ca:	89 04 24             	mov    %eax,(%esp)
 804b2cd:	e8 a9 df ff ff       	call   804927b <memset>
#ifdef HAS_MADVISE
        if (malloc_hint)
                madvise(ptr, l, MADV_FREE);
#endif

        tail = (char *)ptr + l;
 804b2d2:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b2d5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b2d8:	01 d0                	add    %edx,%eax
 804b2da:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /* add to free-list */
        if (!px)
 804b2dd:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b2e3:	85 c0                	test   %eax,%eax
 804b2e5:	75 12                	jne    804b2f9 <ifree+0x1c2>
                px = imalloc(sizeof * pt);      /* This cannot fail... */
 804b2e7:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
 804b2ee:	e8 25 f5 ff ff       	call   804a818 <imalloc>
 804b2f3:	89 83 9c 02 00 00    	mov    %eax,0x29c(%ebx)
        px->page = ptr;
 804b2f9:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b2ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b302:	89 50 08             	mov    %edx,0x8(%eax)
        px->end =  tail;
 804b305:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b30b:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804b30e:	89 50 0c             	mov    %edx,0xc(%eax)
        px->size = l;
 804b311:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b317:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804b31a:	89 50 10             	mov    %edx,0x10(%eax)
        if (!free_list.next) {
 804b31d:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 804b323:	85 c0                	test   %eax,%eax
 804b325:	75 41                	jne    804b368 <ifree+0x231>

                /* Nothing on free list, put this at head */
                px->next = free_list.next;
 804b327:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b32d:	8b 93 64 02 00 00    	mov    0x264(%ebx),%edx
 804b333:	89 10                	mov    %edx,(%eax)
                px->prev = &free_list;
 804b335:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b33b:	8d 93 64 02 00 00    	lea    0x264(%ebx),%edx
 804b341:	89 50 04             	mov    %edx,0x4(%eax)
                free_list.next = px;
 804b344:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b34a:	89 83 64 02 00 00    	mov    %eax,0x264(%ebx)
                pf = px;
 804b350:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b356:	89 45 cc             	mov    %eax,-0x34(%ebp)
                px = 0;
 804b359:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804b360:	00 00 00 
 804b363:	e9 a5 01 00 00       	jmp    804b50d <ifree+0x3d6>

        } else {

                /* Find the right spot, leave pf pointing to the modified entry. */
                tail = (char *)ptr + l;
 804b368:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b36b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b36e:	01 d0                	add    %edx,%eax
 804b370:	89 45 d0             	mov    %eax,-0x30(%ebp)

                for (pf = free_list.next; pf->end < ptr && pf->next; pf = pf->next)
 804b373:	8b 83 64 02 00 00    	mov    0x264(%ebx),%eax
 804b379:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804b37c:	eb 08                	jmp    804b386 <ifree+0x24f>
 804b37e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b381:	8b 00                	mov    (%eax),%eax
 804b383:	89 45 cc             	mov    %eax,-0x34(%ebp)
 804b386:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b389:	8b 40 0c             	mov    0xc(%eax),%eax
 804b38c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 804b38f:	76 09                	jbe    804b39a <ifree+0x263>
 804b391:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b394:	8b 00                	mov    (%eax),%eax
 804b396:	85 c0                	test   %eax,%eax
 804b398:	75 e4                	jne    804b37e <ifree+0x247>
                        ; /* Race ahead here */

                if (pf->page > tail) {
 804b39a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b39d:	8b 40 08             	mov    0x8(%eax),%eax
 804b3a0:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804b3a3:	73 4f                	jae    804b3f4 <ifree+0x2bd>
                        /* Insert before entry */
                        px->next = pf;
 804b3a5:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b3ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b3ae:	89 10                	mov    %edx,(%eax)
                        px->prev = pf->prev;
 804b3b0:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b3b6:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b3b9:	8b 52 04             	mov    0x4(%edx),%edx
 804b3bc:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->prev = px;
 804b3bf:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804b3c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3c8:	89 50 04             	mov    %edx,0x4(%eax)
                        px->prev->next = px;
 804b3cb:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b3d1:	8b 40 04             	mov    0x4(%eax),%eax
 804b3d4:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804b3da:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b3dc:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b3e2:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 804b3e5:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804b3ec:	00 00 00 
 804b3ef:	e9 19 01 00 00       	jmp    804b50d <ifree+0x3d6>
                } else if (pf->end == ptr) {
 804b3f4:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b3f7:	8b 40 0c             	mov    0xc(%eax),%eax
 804b3fa:	39 45 e8             	cmp    %eax,-0x18(%ebp)
 804b3fd:	0f 85 91 00 00 00    	jne    804b494 <ifree+0x35d>
                        /* Append to the previous entry */
                        pf->end = (char *)pf->end + l;
 804b403:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b406:	8b 50 0c             	mov    0xc(%eax),%edx
 804b409:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b40c:	01 c2                	add    %eax,%edx
 804b40e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b411:	89 50 0c             	mov    %edx,0xc(%eax)
                        pf->size += l;
 804b414:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b417:	8b 50 10             	mov    0x10(%eax),%edx
 804b41a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b41d:	01 c2                	add    %eax,%edx
 804b41f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b422:	89 50 10             	mov    %edx,0x10(%eax)
                        if (pf->next && pf->end == pf->next->page) {
 804b425:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b428:	8b 00                	mov    (%eax),%eax
 804b42a:	85 c0                	test   %eax,%eax
 804b42c:	0f 84 da 00 00 00    	je     804b50c <ifree+0x3d5>
 804b432:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b435:	8b 50 0c             	mov    0xc(%eax),%edx
 804b438:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b43b:	8b 00                	mov    (%eax),%eax
 804b43d:	8b 40 08             	mov    0x8(%eax),%eax
 804b440:	39 c2                	cmp    %eax,%edx
 804b442:	0f 85 c4 00 00 00    	jne    804b50c <ifree+0x3d5>
                                /* And collapse the next too. */
                                pt = pf->next;
 804b448:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b44b:	8b 00                	mov    (%eax),%eax
 804b44d:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                pf->end = pt->end;
 804b450:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b453:	8b 50 0c             	mov    0xc(%eax),%edx
 804b456:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b459:	89 50 0c             	mov    %edx,0xc(%eax)
                                pf->size += pt->size;
 804b45c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b45f:	8b 50 10             	mov    0x10(%eax),%edx
 804b462:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b465:	8b 40 10             	mov    0x10(%eax),%eax
 804b468:	01 c2                	add    %eax,%edx
 804b46a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b46d:	89 50 10             	mov    %edx,0x10(%eax)
                                pf->next = pt->next;
 804b470:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b473:	8b 10                	mov    (%eax),%edx
 804b475:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b478:	89 10                	mov    %edx,(%eax)
                                if (pf->next)
 804b47a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b47d:	8b 00                	mov    (%eax),%eax
 804b47f:	85 c0                	test   %eax,%eax
 804b481:	0f 84 85 00 00 00    	je     804b50c <ifree+0x3d5>
                                        pf->next->prev = pf;
 804b487:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b48a:	8b 00                	mov    (%eax),%eax
 804b48c:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b48f:	89 50 04             	mov    %edx,0x4(%eax)
 804b492:	eb 79                	jmp    804b50d <ifree+0x3d6>
                        }
                } else if (pf->page == tail) {
 804b494:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b497:	8b 40 08             	mov    0x8(%eax),%eax
 804b49a:	39 45 d0             	cmp    %eax,-0x30(%ebp)
 804b49d:	75 1c                	jne    804b4bb <ifree+0x384>
                        /* Prepend to entry */
                        pf->size += l;
 804b49f:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b4a2:	8b 50 10             	mov    0x10(%eax),%edx
 804b4a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b4a8:	01 c2                	add    %eax,%edx
 804b4aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b4ad:	89 50 10             	mov    %edx,0x10(%eax)
                        pf->page = ptr;
 804b4b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b4b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804b4b6:	89 50 08             	mov    %edx,0x8(%eax)
 804b4b9:	eb 52                	jmp    804b50d <ifree+0x3d6>
                } else if (!pf->next) {
 804b4bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b4be:	8b 00                	mov    (%eax),%eax
 804b4c0:	85 c0                	test   %eax,%eax
 804b4c2:	75 38                	jne    804b4fc <ifree+0x3c5>
                        /* Append at tail of chain */
                        px->next = 0;
 804b4c4:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b4ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                        px->prev = pf;
 804b4d0:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b4d6:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804b4d9:	89 50 04             	mov    %edx,0x4(%eax)
                        pf->next = px;
 804b4dc:	8b 93 9c 02 00 00    	mov    0x29c(%ebx),%edx
 804b4e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b4e5:	89 10                	mov    %edx,(%eax)
                        pf = px;
 804b4e7:	8b 83 9c 02 00 00    	mov    0x29c(%ebx),%eax
 804b4ed:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        px = 0;
 804b4f0:	c7 83 9c 02 00 00 00 	movl   $0x0,0x29c(%ebx)
 804b4f7:	00 00 00 
 804b4fa:	eb 11                	jmp    804b50d <ifree+0x3d6>
                } else {
                        wrterror("freelist is destroyed.\n");
 804b4fc:	8d 83 2d ef ff ff    	lea    -0x10d3(%ebx),%eax
 804b502:	89 04 24             	mov    %eax,(%esp)
 804b505:	e8 c7 e5 ff ff       	call   8049ad1 <wrterror>
 804b50a:	eb 01                	jmp    804b50d <ifree+0x3d6>
                                pt = pf->next;
                                pf->end = pt->end;
                                pf->size += pt->size;
                                pf->next = pt->next;
                                if (pf->next)
                                        pf->next->prev = pf;
 804b50c:	90                   	nop
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b50d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b510:	8b 00                	mov    (%eax),%eax
 804b512:	85 c0                	test   %eax,%eax
 804b514:	0f 85 cd 00 00 00    	jne    804b5e7 <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b51a:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b51d:	8b 50 10             	mov    0x10(%eax),%edx
 804b520:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
                        wrterror("freelist is destroyed.\n");
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
 804b526:	39 c2                	cmp    %eax,%edx
 804b528:	0f 86 b9 00 00 00    	jbe    804b5e7 <ifree+0x4b0>
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b52e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b531:	8b 50 0c             	mov    0xc(%eax),%edx
 804b534:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
                }
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
 804b53a:	39 c2                	cmp    %eax,%edx
 804b53c:	0f 85 a5 00 00 00    	jne    804b5e7 <ifree+0x4b0>
            pf->end == malloc_brk &&                  /* ..and none behind us, */
            malloc_brk == sbrk(0)) {                  /* ..and it's OK to do... */
 804b542:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804b549:	e8 21 ce ff ff       	call   804836f <sbrk>
 804b54e:	89 c2                	mov    %eax,%edx
 804b550:	8b 83 98 02 00 00    	mov    0x298(%ebx),%eax
        }

        /* Return something to OS ? */
        if (!pf->next &&                            /* If we're the last one, */
            pf->size > malloc_cache &&                /* ..and the cache is full, */
            pf->end == malloc_brk &&                  /* ..and none behind us, */
 804b556:	39 c2                	cmp    %eax,%edx
 804b558:	0f 85 89 00 00 00    	jne    804b5e7 <ifree+0x4b0>

                /*
                 * Keep the cache intact.  Notice that the '>' above guarantees that
                 * the pf will always have at least one page afterwards.
                 */
                pf->end = (char *)pf->page + malloc_cache;
 804b55e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b561:	8b 50 08             	mov    0x8(%eax),%edx
 804b564:	8b 83 34 00 00 00    	mov    0x34(%ebx),%eax
 804b56a:	01 c2                	add    %eax,%edx
 804b56c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b56f:	89 50 0c             	mov    %edx,0xc(%eax)
                pf->size = malloc_cache;
 804b572:	8b 93 34 00 00 00    	mov    0x34(%ebx),%edx
 804b578:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b57b:	89 50 10             	mov    %edx,0x10(%eax)

                brk(pf->end);
 804b57e:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b581:	8b 40 0c             	mov    0xc(%eax),%eax
 804b584:	89 04 24             	mov    %eax,(%esp)
 804b587:	e8 ac ce ff ff       	call   8048438 <brk>
                malloc_brk = pf->end;
 804b58c:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b58f:	8b 40 0c             	mov    0xc(%eax),%eax
 804b592:	89 83 98 02 00 00    	mov    %eax,0x298(%ebx)

                index = ptr2index(pf->end);
 804b598:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b59b:	8b 40 0c             	mov    0xc(%eax),%eax
 804b59e:	c1 e8 0c             	shr    $0xc,%eax
 804b5a1:	89 c2                	mov    %eax,%edx
 804b5a3:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b5a9:	29 c2                	sub    %eax,%edx
 804b5ab:	89 d0                	mov    %edx,%eax
 804b5ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                last_index = index - 1;
 804b5b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b5b3:	48                   	dec    %eax
 804b5b4:	89 83 58 02 00 00    	mov    %eax,0x258(%ebx)

                for (i = index; i <= last_index;)
 804b5ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b5bd:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804b5c0:	eb 1a                	jmp    804b5dc <ifree+0x4a5>
                        page_dir[i++] = MALLOC_NOT_MINE;
 804b5c2:	8b 8b 5c 02 00 00    	mov    0x25c(%ebx),%ecx
 804b5c8:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b5cb:	8d 50 01             	lea    0x1(%eax),%edx
 804b5ce:	89 55 d8             	mov    %edx,-0x28(%ebp)
 804b5d1:	c1 e0 02             	shl    $0x2,%eax
 804b5d4:	01 c8                	add    %ecx,%eax
 804b5d6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                malloc_brk = pf->end;

                index = ptr2index(pf->end);
                last_index = index - 1;

                for (i = index; i <= last_index;)
 804b5dc:	8b 83 58 02 00 00    	mov    0x258(%ebx),%eax
 804b5e2:	39 45 d8             	cmp    %eax,-0x28(%ebp)
 804b5e5:	76 db                	jbe    804b5c2 <ifree+0x48b>
                        page_dir[i++] = MALLOC_NOT_MINE;

                /* XXX: We could realloc/shrink the pagedir here I guess. */
        }
        if (pt)
 804b5e7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804b5eb:	0f 84 05 02 00 00    	je     804b7f6 <ifree+0x6bf>
                ifree(pt);
 804b5f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b5f4:	89 04 24             	mov    %eax,(%esp)
 804b5f7:	e8 3b fb ff ff       	call   804b137 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b5fc:	e9 f5 01 00 00       	jmp    804b7f6 <ifree+0x6bf>
        info = page_dir[index];

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
 804b601:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b604:	8b 55 08             	mov    0x8(%ebp),%edx
 804b607:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804b60a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804b60d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b610:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        int i;
        struct pginfo **mp;
        void *vp;

        /* Find the chunk number on the page */
        i = ((u_long)ptr & malloc_pagemask) >> info->shift;
 804b613:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b616:	25 ff 0f 00 00       	and    $0xfff,%eax
 804b61b:	89 c2                	mov    %eax,%edx
 804b61d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b620:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b624:	88 c1                	mov    %al,%cl
 804b626:	d3 ea                	shr    %cl,%edx
 804b628:	89 d0                	mov    %edx,%eax
 804b62a:	89 45 c0             	mov    %eax,-0x40(%ebp)

        if (((u_long)ptr & (info->size - 1))) {
 804b62d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b630:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b634:	48                   	dec    %eax
 804b635:	89 c2                	mov    %eax,%edx
 804b637:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b63a:	21 d0                	and    %edx,%eax
 804b63c:	85 c0                	test   %eax,%eax
 804b63e:	74 13                	je     804b653 <ifree+0x51c>
                wrtwarning("modified (chunk-) pointer.\n");
 804b640:	8d 83 ca ee ff ff    	lea    -0x1136(%ebx),%eax
 804b646:	89 04 24             	mov    %eax,(%esp)
 804b649:	e8 53 e5 ff ff       	call   8049ba1 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b64e:	e9 a3 01 00 00       	jmp    804b7f6 <ifree+0x6bf>
        if (((u_long)ptr & (info->size - 1))) {
                wrtwarning("modified (chunk-) pointer.\n");
                return;
        }

        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
 804b653:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b656:	c1 e8 05             	shr    $0x5,%eax
 804b659:	89 c2                	mov    %eax,%edx
 804b65b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b65e:	83 c2 04             	add    $0x4,%edx
 804b661:	8b 04 90             	mov    (%eax,%edx,4),%eax
 804b664:	8b 55 c0             	mov    -0x40(%ebp),%edx
 804b667:	83 e2 1f             	and    $0x1f,%edx
 804b66a:	be 01 00 00 00       	mov    $0x1,%esi
 804b66f:	88 d1                	mov    %dl,%cl
 804b671:	d3 e6                	shl    %cl,%esi
 804b673:	89 f2                	mov    %esi,%edx
 804b675:	21 d0                	and    %edx,%eax
 804b677:	85 c0                	test   %eax,%eax
 804b679:	74 13                	je     804b68e <ifree+0x557>
                wrtwarning("chunk is already free.\n");
 804b67b:	8d 83 e6 ee ff ff    	lea    -0x111a(%ebx),%eax
 804b681:	89 04 24             	mov    %eax,(%esp)
 804b684:	e8 18 e5 ff ff       	call   8049ba1 <wrtwarning>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b689:	e9 68 01 00 00       	jmp    804b7f6 <ifree+0x6bf>
        if (info->bits[i / MALLOC_BITS] & (1 << (i % MALLOC_BITS))) {
                wrtwarning("chunk is already free.\n");
                return;
        }

        if (malloc_junk)
 804b68e:	8b 83 94 02 00 00    	mov    0x294(%ebx),%eax
 804b694:	85 c0                	test   %eax,%eax
 804b696:	74 1e                	je     804b6b6 <ifree+0x57f>
                memset(ptr, SOME_JUNK, info->size);
 804b698:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b69b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
 804b69f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b6a3:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
 804b6aa:	00 
 804b6ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b6ae:	89 04 24             	mov    %eax,(%esp)
 804b6b1:	e8 c5 db ff ff       	call   804927b <memset>

        info->bits[i / MALLOC_BITS] |= 1 << (i % MALLOC_BITS);
 804b6b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804b6b9:	c1 e8 05             	shr    $0x5,%eax
 804b6bc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b6bf:	8d 48 04             	lea    0x4(%eax),%ecx
 804b6c2:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
 804b6c5:	8b 4d c0             	mov    -0x40(%ebp),%ecx
 804b6c8:	83 e1 1f             	and    $0x1f,%ecx
 804b6cb:	be 01 00 00 00       	mov    $0x1,%esi
 804b6d0:	d3 e6                	shl    %cl,%esi
 804b6d2:	89 f1                	mov    %esi,%ecx
 804b6d4:	09 d1                	or     %edx,%ecx
 804b6d6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b6d9:	83 c0 04             	add    $0x4,%eax
 804b6dc:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
        info->free++;
 804b6df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6e2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b6e6:	40                   	inc    %eax
 804b6e7:	0f b7 d0             	movzwl %ax,%edx
 804b6ea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6ed:	66 89 50 0c          	mov    %dx,0xc(%eax)

        mp = page_dir + info->shift;
 804b6f1:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b6f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b6fa:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b6fe:	c1 e0 02             	shl    $0x2,%eax
 804b701:	01 d0                	add    %edx,%eax
 804b703:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free == 1) {
 804b706:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b709:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
 804b70d:	83 f8 01             	cmp    $0x1,%eax
 804b710:	75 5e                	jne    804b770 <ifree+0x639>

                /* Page became non-full */

                mp = page_dir + info->shift;
 804b712:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b718:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b71b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
 804b71f:	c1 e0 02             	shl    $0x2,%eax
 804b722:	01 d0                	add    %edx,%eax
 804b724:	89 45 bc             	mov    %eax,-0x44(%ebp)
 804b727:	eb 08                	jmp    804b731 <ifree+0x5fa>
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
                        mp = &(*mp)->next;
 804b729:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b72c:	8b 00                	mov    (%eax),%eax
 804b72e:	89 45 bc             	mov    %eax,-0x44(%ebp)

                /* Page became non-full */

                mp = page_dir + info->shift;
                /* Insert in address order */
                while (*mp && (*mp)->next && (*mp)->next->page < info->page)
 804b731:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b734:	8b 00                	mov    (%eax),%eax
 804b736:	85 c0                	test   %eax,%eax
 804b738:	74 1f                	je     804b759 <ifree+0x622>
 804b73a:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b73d:	8b 00                	mov    (%eax),%eax
 804b73f:	8b 00                	mov    (%eax),%eax
 804b741:	85 c0                	test   %eax,%eax
 804b743:	74 14                	je     804b759 <ifree+0x622>
 804b745:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b748:	8b 00                	mov    (%eax),%eax
 804b74a:	8b 00                	mov    (%eax),%eax
 804b74c:	8b 50 04             	mov    0x4(%eax),%edx
 804b74f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b752:	8b 40 04             	mov    0x4(%eax),%eax
 804b755:	39 c2                	cmp    %eax,%edx
 804b757:	72 d0                	jb     804b729 <ifree+0x5f2>
                        mp = &(*mp)->next;
                info->next = *mp;
 804b759:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b75c:	8b 10                	mov    (%eax),%edx
 804b75e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b761:	89 10                	mov    %edx,(%eax)
                *mp = info;
 804b763:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b766:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 804b769:	89 10                	mov    %edx,(%eax)

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b76b:	e9 86 00 00 00       	jmp    804b7f6 <ifree+0x6bf>
                info->next = *mp;
                *mp = info;
                return;
        }

        if (info->free != info->total)
 804b770:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b773:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
 804b777:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b77a:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
 804b77e:	39 c2                	cmp    %eax,%edx
 804b780:	75 74                	jne    804b7f6 <ifree+0x6bf>
 804b782:	eb 08                	jmp    804b78c <ifree+0x655>
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
                mp = &((*mp)->next);
 804b784:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b787:	8b 00                	mov    (%eax),%eax
 804b789:	89 45 bc             	mov    %eax,-0x44(%ebp)

        if (info->free != info->total)
                return;

        /* Find & remove this page in the queue */
        while (*mp != info) {
 804b78c:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b78f:	8b 00                	mov    (%eax),%eax
 804b791:	39 45 c4             	cmp    %eax,-0x3c(%ebp)
 804b794:	75 ee                	jne    804b784 <ifree+0x64d>
#ifdef EXTRA_SANITY
                if (!*mp)
                        wrterror("(ES): Not on queue\n");
#endif /* EXTRA_SANITY */
        }
        *mp = info->next;
 804b796:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b799:	8b 10                	mov    (%eax),%edx
 804b79b:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804b79e:	89 10                	mov    %edx,(%eax)

        /* Free the page & the info structure if need be */
        page_dir[ptr2index(info->page)] = MALLOC_FIRST;
 804b7a0:	8b 93 5c 02 00 00    	mov    0x25c(%ebx),%edx
 804b7a6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b7a9:	8b 40 04             	mov    0x4(%eax),%eax
 804b7ac:	c1 e8 0c             	shr    $0xc,%eax
 804b7af:	89 c1                	mov    %eax,%ecx
 804b7b1:	8b 83 54 02 00 00    	mov    0x254(%ebx),%eax
 804b7b7:	29 c1                	sub    %eax,%ecx
 804b7b9:	89 c8                	mov    %ecx,%eax
 804b7bb:	c1 e0 02             	shl    $0x2,%eax
 804b7be:	01 d0                	add    %edx,%eax
 804b7c0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        vp = info->page;            /* Order is important ! */
 804b7c6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b7c9:	8b 40 04             	mov    0x4(%eax),%eax
 804b7cc:	89 45 b8             	mov    %eax,-0x48(%ebp)
        if (vp != (void *)info)
 804b7cf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b7d2:	3b 45 b8             	cmp    -0x48(%ebp),%eax
 804b7d5:	74 0b                	je     804b7e2 <ifree+0x6ab>
                ifree(info);
 804b7d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804b7da:	89 04 24             	mov    %eax,(%esp)
 804b7dd:	e8 55 f9 ff ff       	call   804b137 <ifree>
        ifree(vp);
 804b7e2:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804b7e5:	89 04 24             	mov    %eax,(%esp)
 804b7e8:	e8 4a f9 ff ff       	call   804b137 <ifree>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b7ed:	90                   	nop
 804b7ee:	eb 06                	jmp    804b7f6 <ifree+0x6bf>
        struct pginfo *info;
        unsigned int index;

        /* This is legal */
        if (!ptr)
                return;
 804b7f0:	90                   	nop
 804b7f1:	eb 04                	jmp    804b7f7 <ifree+0x6c0>
                return;
        }

        /* If we're already sinking, don't make matters any worse. */
        if (suicide)
                return;
 804b7f3:	90                   	nop
 804b7f4:	eb 01                	jmp    804b7f7 <ifree+0x6c0>

        if (info < MALLOC_MAGIC)
                free_pages(ptr, index, info);
        else
                free_bytes(ptr, index, info);
        return;
 804b7f6:	90                   	nop
}
 804b7f7:	83 c4 50             	add    $0x50,%esp
 804b7fa:	5b                   	pop    %ebx
 804b7fb:	5e                   	pop    %esi
 804b7fc:	5d                   	pop    %ebp
 804b7fd:	c3                   	ret    

0804b7fe <malloc>:
 */


void *
malloc(size_t size)
{
 804b7fe:	55                   	push   %ebp
 804b7ff:	89 e5                	mov    %esp,%ebp
 804b801:	56                   	push   %esi
 804b802:	53                   	push   %ebx
 804b803:	83 ec 10             	sub    $0x10,%esp
 804b806:	e8 be d8 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804b80b:	81 c3 f5 37 00 00    	add    $0x37f5,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in malloc():";
 804b811:	8d 83 69 ef ff ff    	lea    -0x1097(%ebx),%eax
 804b817:	89 83 a0 02 00 00    	mov    %eax,0x2a0(%ebx)
        if (malloc_active++) {
 804b81d:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b823:	8d 50 01             	lea    0x1(%eax),%edx
 804b826:	89 93 50 02 00 00    	mov    %edx,0x250(%ebx)
 804b82c:	85 c0                	test   %eax,%eax
 804b82e:	74 22                	je     804b852 <malloc+0x54>
                wrtwarning("recursive call.\n");
 804b830:	8d 83 77 ef ff ff    	lea    -0x1089(%ebx),%eax
 804b836:	89 04 24             	mov    %eax,(%esp)
 804b839:	e8 63 e3 ff ff       	call   8049ba1 <wrtwarning>
                malloc_active--;
 804b83e:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b844:	48                   	dec    %eax
 804b845:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
                return (0);
 804b84b:	b8 00 00 00 00       	mov    $0x0,%eax
 804b850:	eb 5e                	jmp    804b8b0 <malloc+0xb2>
        }
        if (!malloc_started) {
 804b852:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b858:	85 c0                	test   %eax,%eax
 804b85a:	75 05                	jne    804b861 <malloc+0x63>
                malloc_init();
 804b85c:	e8 97 e5 ff ff       	call   8049df8 <malloc_init>
        }
        if (malloc_sysv && !size)
 804b861:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804b867:	85 c0                	test   %eax,%eax
 804b869:	74 0d                	je     804b878 <malloc+0x7a>
 804b86b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b86f:	75 07                	jne    804b878 <malloc+0x7a>
                r = 0;
 804b871:	be 00 00 00 00       	mov    $0x0,%esi
 804b876:	eb 0d                	jmp    804b885 <malloc+0x87>
        else
                r = imalloc(size);
 804b878:	8b 45 08             	mov    0x8(%ebp),%eax
 804b87b:	89 04 24             	mov    %eax,(%esp)
 804b87e:	e8 95 ef ff ff       	call   804a818 <imalloc>
 804b883:	89 c6                	mov    %eax,%esi
        UTRACE(0, size, r);
        malloc_active--;
 804b885:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b88b:	48                   	dec    %eax
 804b88c:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804b892:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
 804b898:	85 c0                	test   %eax,%eax
 804b89a:	74 12                	je     804b8ae <malloc+0xb0>
 804b89c:	85 f6                	test   %esi,%esi
 804b89e:	75 0e                	jne    804b8ae <malloc+0xb0>
                wrterror("out of memory.\n");
 804b8a0:	8d 83 88 ef ff ff    	lea    -0x1078(%ebx),%eax
 804b8a6:	89 04 24             	mov    %eax,(%esp)
 804b8a9:	e8 23 e2 ff ff       	call   8049ad1 <wrterror>
        return (r);
 804b8ae:	89 f0                	mov    %esi,%eax
}
 804b8b0:	83 c4 10             	add    $0x10,%esp
 804b8b3:	5b                   	pop    %ebx
 804b8b4:	5e                   	pop    %esi
 804b8b5:	5d                   	pop    %ebp
 804b8b6:	c3                   	ret    

0804b8b7 <free>:

void
free(void *ptr)
{
 804b8b7:	55                   	push   %ebp
 804b8b8:	89 e5                	mov    %esp,%ebp
 804b8ba:	53                   	push   %ebx
 804b8bb:	83 ec 14             	sub    $0x14,%esp
 804b8be:	e8 06 d8 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804b8c3:	81 c3 3d 37 00 00    	add    $0x373d,%ebx
        THREAD_LOCK();
        malloc_func = " in free():";
 804b8c9:	8d 83 98 ef ff ff    	lea    -0x1068(%ebx),%eax
 804b8cf:	89 83 a0 02 00 00    	mov    %eax,0x2a0(%ebx)
        if (malloc_active++) {
 804b8d5:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b8db:	8d 50 01             	lea    0x1(%eax),%edx
 804b8de:	89 93 50 02 00 00    	mov    %edx,0x250(%ebx)
 804b8e4:	85 c0                	test   %eax,%eax
 804b8e6:	74 1d                	je     804b905 <free+0x4e>
                wrtwarning("recursive call.\n");
 804b8e8:	8d 83 77 ef ff ff    	lea    -0x1089(%ebx),%eax
 804b8ee:	89 04 24             	mov    %eax,(%esp)
 804b8f1:	e8 ab e2 ff ff       	call   8049ba1 <wrtwarning>
                malloc_active--;
 804b8f6:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b8fc:	48                   	dec    %eax
 804b8fd:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
                return;
 804b903:	eb 19                	jmp    804b91e <free+0x67>
        } else {
                ifree(ptr);
 804b905:	8b 45 08             	mov    0x8(%ebp),%eax
 804b908:	89 04 24             	mov    %eax,(%esp)
 804b90b:	e8 27 f8 ff ff       	call   804b137 <ifree>
                UTRACE(ptr, 0, 0);
        }
        malloc_active--;
 804b910:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b916:	48                   	dec    %eax
 804b917:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
        THREAD_UNLOCK();
        return;
 804b91d:	90                   	nop
}
 804b91e:	83 c4 14             	add    $0x14,%esp
 804b921:	5b                   	pop    %ebx
 804b922:	5d                   	pop    %ebp
 804b923:	c3                   	ret    

0804b924 <realloc>:

void *
realloc(void *ptr, size_t size)
{
 804b924:	55                   	push   %ebp
 804b925:	89 e5                	mov    %esp,%ebp
 804b927:	56                   	push   %esi
 804b928:	53                   	push   %ebx
 804b929:	83 ec 10             	sub    $0x10,%esp
 804b92c:	e8 98 d7 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804b931:	81 c3 cf 36 00 00    	add    $0x36cf,%ebx
        register void *r;

        THREAD_LOCK();
        malloc_func = " in realloc():";
 804b937:	8d 83 a4 ef ff ff    	lea    -0x105c(%ebx),%eax
 804b93d:	89 83 a0 02 00 00    	mov    %eax,0x2a0(%ebx)
        if (malloc_active++) {
 804b943:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b949:	8d 50 01             	lea    0x1(%eax),%edx
 804b94c:	89 93 50 02 00 00    	mov    %edx,0x250(%ebx)
 804b952:	85 c0                	test   %eax,%eax
 804b954:	74 25                	je     804b97b <realloc+0x57>
                wrtwarning("recursive call.\n");
 804b956:	8d 83 77 ef ff ff    	lea    -0x1089(%ebx),%eax
 804b95c:	89 04 24             	mov    %eax,(%esp)
 804b95f:	e8 3d e2 ff ff       	call   8049ba1 <wrtwarning>
                malloc_active--;
 804b964:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804b96a:	48                   	dec    %eax
 804b96b:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
                return (0);
 804b971:	b8 00 00 00 00       	mov    $0x0,%eax
 804b976:	e9 aa 00 00 00       	jmp    804ba25 <realloc+0x101>
        }
        if (ptr && !malloc_started) {
 804b97b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b97f:	74 1f                	je     804b9a0 <realloc+0x7c>
 804b981:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b987:	85 c0                	test   %eax,%eax
 804b989:	75 15                	jne    804b9a0 <realloc+0x7c>
                wrtwarning("malloc() has never been called.\n");
 804b98b:	8d 83 48 ef ff ff    	lea    -0x10b8(%ebx),%eax
 804b991:	89 04 24             	mov    %eax,(%esp)
 804b994:	e8 08 e2 ff ff       	call   8049ba1 <wrtwarning>
                ptr = 0;
 804b999:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
        if (!malloc_started)
 804b9a0:	8b 83 4c 02 00 00    	mov    0x24c(%ebx),%eax
 804b9a6:	85 c0                	test   %eax,%eax
 804b9a8:	75 05                	jne    804b9af <realloc+0x8b>
                malloc_init();
 804b9aa:	e8 49 e4 ff ff       	call   8049df8 <malloc_init>
        if (malloc_sysv && !size) {
 804b9af:	8b 83 8c 02 00 00    	mov    0x28c(%ebx),%eax
 804b9b5:	85 c0                	test   %eax,%eax
 804b9b7:	74 18                	je     804b9d1 <realloc+0xad>
 804b9b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b9bd:	75 12                	jne    804b9d1 <realloc+0xad>
                ifree(ptr);
 804b9bf:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9c2:	89 04 24             	mov    %eax,(%esp)
 804b9c5:	e8 6d f7 ff ff       	call   804b137 <ifree>
                r = 0;
 804b9ca:	be 00 00 00 00       	mov    $0x0,%esi
 804b9cf:	eb 29                	jmp    804b9fa <realloc+0xd6>
        } else if (!ptr) {
 804b9d1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b9d5:	75 0f                	jne    804b9e6 <realloc+0xc2>
                r = imalloc(size);
 804b9d7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9da:	89 04 24             	mov    %eax,(%esp)
 804b9dd:	e8 36 ee ff ff       	call   804a818 <imalloc>
 804b9e2:	89 c6                	mov    %eax,%esi
 804b9e4:	eb 14                	jmp    804b9fa <realloc+0xd6>
        } else {
                r = irealloc(ptr, size);
 804b9e6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9e9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b9ed:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9f0:	89 04 24             	mov    %eax,(%esp)
 804b9f3:	e8 d6 ee ff ff       	call   804a8ce <irealloc>
 804b9f8:	89 c6                	mov    %eax,%esi
        }
        UTRACE(ptr, size, r);
        malloc_active--;
 804b9fa:	8b 83 50 02 00 00    	mov    0x250(%ebx),%eax
 804ba00:	48                   	dec    %eax
 804ba01:	89 83 50 02 00 00    	mov    %eax,0x250(%ebx)
        THREAD_UNLOCK();
        if (malloc_xmalloc && !r)
 804ba07:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
 804ba0d:	85 c0                	test   %eax,%eax
 804ba0f:	74 12                	je     804ba23 <realloc+0xff>
 804ba11:	85 f6                	test   %esi,%esi
 804ba13:	75 0e                	jne    804ba23 <realloc+0xff>
                wrterror("out of memory.\n");
 804ba15:	8d 83 88 ef ff ff    	lea    -0x1078(%ebx),%eax
 804ba1b:	89 04 24             	mov    %eax,(%esp)
 804ba1e:	e8 ae e0 ff ff       	call   8049ad1 <wrterror>
        return (r);
 804ba23:	89 f0                	mov    %esi,%eax
}
 804ba25:	83 c4 10             	add    $0x10,%esp
 804ba28:	5b                   	pop    %ebx
 804ba29:	5e                   	pop    %esi
 804ba2a:	5d                   	pop    %ebp
 804ba2b:	c3                   	ret    

0804ba2c <calloc>:

/* Added */
void *calloc(size_t nelem, size_t elsize)
{
 804ba2c:	55                   	push   %ebp
 804ba2d:	89 e5                	mov    %esp,%ebp
 804ba2f:	53                   	push   %ebx
 804ba30:	83 ec 24             	sub    $0x24,%esp
 804ba33:	e8 91 d6 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804ba38:	81 c3 c8 35 00 00    	add    $0x35c8,%ebx
        void *tmp;
        if (NULL == (tmp = malloc(nelem * elsize))) {
 804ba3e:	8b 45 08             	mov    0x8(%ebp),%eax
 804ba41:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804ba45:	89 04 24             	mov    %eax,(%esp)
 804ba48:	e8 b1 fd ff ff       	call   804b7fe <malloc>
 804ba4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ba50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ba54:	75 07                	jne    804ba5d <calloc+0x31>
                return NULL;
 804ba56:	b8 00 00 00 00       	mov    $0x0,%eax
 804ba5b:	eb 21                	jmp    804ba7e <calloc+0x52>
        } else {
                memset(tmp, 0, nelem * elsize);
 804ba5d:	8b 45 08             	mov    0x8(%ebp),%eax
 804ba60:	0f af 45 0c          	imul   0xc(%ebp),%eax
 804ba64:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ba68:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804ba6f:	00 
 804ba70:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ba73:	89 04 24             	mov    %eax,(%esp)
 804ba76:	e8 00 d8 ff ff       	call   804927b <memset>
                return tmp;
 804ba7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
        }
}
 804ba7e:	83 c4 24             	add    $0x24,%esp
 804ba81:	5b                   	pop    %ebx
 804ba82:	5d                   	pop    %ebp
 804ba83:	c3                   	ret    

0804ba84 <printf>:

#include "stdio.h"
#include "unistd.h"

int printf(const char *fmt, ...)
{
 804ba84:	55                   	push   %ebp
 804ba85:	89 e5                	mov    %esp,%ebp
 804ba87:	53                   	push   %ebx
 804ba88:	83 ec 24             	sub    $0x24,%esp
 804ba8b:	e8 31 d6 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804ba90:	05 70 35 00 00       	add    $0x3570,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804ba95:	8d 55 0c             	lea    0xc(%ebp),%edx
 804ba98:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vprintf(fmt, args);
 804ba9b:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804ba9e:	89 54 24 04          	mov    %edx,0x4(%esp)
 804baa2:	8b 55 08             	mov    0x8(%ebp),%edx
 804baa5:	89 14 24             	mov    %edx,(%esp)
 804baa8:	89 c3                	mov    %eax,%ebx
 804baaa:	e8 cd 00 00 00       	call   804bb7c <vprintf>
 804baaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804bab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bab5:	83 c4 24             	add    $0x24,%esp
 804bab8:	5b                   	pop    %ebx
 804bab9:	5d                   	pop    %ebp
 804baba:	c3                   	ret    

0804babb <fprintf>:

int fprintf(FILE *stream, const char *fmt, ...)
{
 804babb:	55                   	push   %ebp
 804babc:	89 e5                	mov    %esp,%ebp
 804babe:	53                   	push   %ebx
 804babf:	83 ec 24             	sub    $0x24,%esp
 804bac2:	e8 fa d5 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bac7:	05 39 35 00 00       	add    $0x3539,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804bacc:	8d 55 10             	lea    0x10(%ebp),%edx
 804bacf:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vfprintf(stream, fmt, args);
 804bad2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804bad5:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bad9:	8b 55 0c             	mov    0xc(%ebp),%edx
 804badc:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bae0:	8b 55 08             	mov    0x8(%ebp),%edx
 804bae3:	89 14 24             	mov    %edx,(%esp)
 804bae6:	89 c3                	mov    %eax,%ebx
 804bae8:	e8 c6 00 00 00       	call   804bbb3 <vfprintf>
 804baed:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804baf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804baf3:	83 c4 24             	add    $0x24,%esp
 804baf6:	5b                   	pop    %ebx
 804baf7:	5d                   	pop    %ebp
 804baf8:	c3                   	ret    

0804baf9 <sprintf>:

int sprintf(char *buf, const char *fmt, ...)
{
 804baf9:	55                   	push   %ebp
 804bafa:	89 e5                	mov    %esp,%ebp
 804bafc:	53                   	push   %ebx
 804bafd:	83 ec 24             	sub    $0x24,%esp
 804bb00:	e8 bc d5 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bb05:	05 fb 34 00 00       	add    $0x34fb,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804bb0a:	8d 55 10             	lea    0x10(%ebp),%edx
 804bb0d:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsprintf(buf, fmt, args);
 804bb10:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804bb13:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bb17:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bb1a:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bb1e:	8b 55 08             	mov    0x8(%ebp),%edx
 804bb21:	89 14 24             	mov    %edx,(%esp)
 804bb24:	89 c3                	mov    %eax,%ebx
 804bb26:	e8 f4 00 00 00       	call   804bc1f <vsprintf>
 804bb2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804bb2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bb31:	83 c4 24             	add    $0x24,%esp
 804bb34:	5b                   	pop    %ebx
 804bb35:	5d                   	pop    %ebp
 804bb36:	c3                   	ret    

0804bb37 <snprintf>:

int snprintf(char *buf, size_t size, const char *fmt, ...)
{
 804bb37:	55                   	push   %ebp
 804bb38:	89 e5                	mov    %esp,%ebp
 804bb3a:	53                   	push   %ebx
 804bb3b:	83 ec 24             	sub    $0x24,%esp
 804bb3e:	e8 7e d5 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bb43:	05 bd 34 00 00       	add    $0x34bd,%eax
        va_list args;
        int i;

        va_start(args, fmt);
 804bb48:	8d 55 14             	lea    0x14(%ebp),%edx
 804bb4b:	89 55 f0             	mov    %edx,-0x10(%ebp)
        i = vsnprintf(buf, size, fmt, args);
 804bb4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804bb51:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804bb55:	8b 55 10             	mov    0x10(%ebp),%edx
 804bb58:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bb5c:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bb5f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bb63:	8b 55 08             	mov    0x8(%ebp),%edx
 804bb66:	89 14 24             	mov    %edx,(%esp)
 804bb69:	89 c3                	mov    %eax,%ebx
 804bb6b:	e8 8b 05 00 00       	call   804c0fb <vsnprintf>
 804bb70:	89 45 f4             	mov    %eax,-0xc(%ebp)
        va_end(args);
        return i;
 804bb73:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bb76:	83 c4 24             	add    $0x24,%esp
 804bb79:	5b                   	pop    %ebx
 804bb7a:	5d                   	pop    %ebp
 804bb7b:	c3                   	ret    

0804bb7c <vprintf>:

int vprintf(const char *fmt, va_list args)
{
 804bb7c:	55                   	push   %ebp
 804bb7d:	89 e5                	mov    %esp,%ebp
 804bb7f:	53                   	push   %ebx
 804bb80:	83 ec 14             	sub    $0x14,%esp
 804bb83:	e8 39 d5 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bb88:	05 78 34 00 00       	add    $0x3478,%eax
        return vfprintf(stdout, fmt, args);
 804bb8d:	8d 15 4c f0 04 08    	lea    0x804f04c,%edx
 804bb93:	8b 12                	mov    (%edx),%edx
 804bb95:	8b 4d 0c             	mov    0xc(%ebp),%ecx
 804bb98:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804bb9c:	8b 4d 08             	mov    0x8(%ebp),%ecx
 804bb9f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804bba3:	89 14 24             	mov    %edx,(%esp)
 804bba6:	89 c3                	mov    %eax,%ebx
 804bba8:	e8 06 00 00 00       	call   804bbb3 <vfprintf>
}
 804bbad:	83 c4 14             	add    $0x14,%esp
 804bbb0:	5b                   	pop    %ebx
 804bbb1:	5d                   	pop    %ebp
 804bbb2:	c3                   	ret    

0804bbb3 <vfprintf>:

#define __LIBC_PRINTF_BUFSIZE 1024
int vfprintf(FILE *stream, const char *fmt, va_list args)
{
 804bbb3:	55                   	push   %ebp
 804bbb4:	89 e5                	mov    %esp,%ebp
 804bbb6:	53                   	push   %ebx
 804bbb7:	81 ec 24 04 00 00    	sub    $0x424,%esp
 804bbbd:	e8 07 d5 ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804bbc2:	81 c3 3e 34 00 00    	add    $0x343e,%ebx
        /* I'm really lazy */
        char buf[__LIBC_PRINTF_BUFSIZE];
        int ret = vsnprintf(buf, __LIBC_PRINTF_BUFSIZE, fmt, args);
 804bbc8:	8b 45 10             	mov    0x10(%ebp),%eax
 804bbcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804bbcf:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbd2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bbd6:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 804bbdd:	00 
 804bbde:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
 804bbe4:	89 04 24             	mov    %eax,(%esp)
 804bbe7:	e8 0f 05 00 00       	call   804c0fb <vsnprintf>
 804bbec:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (ret > 0) {
 804bbef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804bbf3:	7e 1e                	jle    804bc13 <vfprintf+0x60>
                write(*stream, buf, ret);
 804bbf5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804bbf8:	8b 45 08             	mov    0x8(%ebp),%eax
 804bbfb:	8b 00                	mov    (%eax),%eax
 804bbfd:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bc01:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
 804bc07:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bc0b:	89 04 24             	mov    %eax,(%esp)
 804bc0e:	e8 2f cd ff ff       	call   8048942 <write>
        }
        return ret;
 804bc13:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bc16:	81 c4 24 04 00 00    	add    $0x424,%esp
 804bc1c:	5b                   	pop    %ebx
 804bc1d:	5d                   	pop    %ebp
 804bc1e:	c3                   	ret    

0804bc1f <vsprintf>:

int vsprintf(char *buf, const char *fmt, va_list args)
{
 804bc1f:	55                   	push   %ebp
 804bc20:	89 e5                	mov    %esp,%ebp
 804bc22:	53                   	push   %ebx
 804bc23:	83 ec 14             	sub    $0x14,%esp
 804bc26:	e8 96 d4 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bc2b:	05 d5 33 00 00       	add    $0x33d5,%eax
        return vsnprintf(buf, 0xffffffffUL, fmt, args);
 804bc30:	8b 55 10             	mov    0x10(%ebp),%edx
 804bc33:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804bc37:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bc3a:	89 54 24 08          	mov    %edx,0x8(%esp)
 804bc3e:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
 804bc45:	ff 
 804bc46:	8b 55 08             	mov    0x8(%ebp),%edx
 804bc49:	89 14 24             	mov    %edx,(%esp)
 804bc4c:	89 c3                	mov    %eax,%ebx
 804bc4e:	e8 a8 04 00 00       	call   804c0fb <vsnprintf>
}
 804bc53:	83 c4 14             	add    $0x14,%esp
 804bc56:	5b                   	pop    %ebx
 804bc57:	5d                   	pop    %ebp
 804bc58:	c3                   	ret    

0804bc59 <fflush>:

int fflush(FILE *stream)
{
 804bc59:	55                   	push   %ebp
 804bc5a:	89 e5                	mov    %esp,%ebp
 804bc5c:	e8 60 d4 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804bc61:	05 9f 33 00 00       	add    $0x339f,%eax
        /* no-op */
        return 0;
 804bc66:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804bc6b:	5d                   	pop    %ebp
 804bc6c:	c3                   	ret    

0804bc6d <__tolower>:

#define isascii(c) (((unsigned char)(c))<=0x7f)
#define toascii(c) (((unsigned char)(c))&0x7f)

static inline unsigned char __tolower(unsigned char c)
{
 804bc6d:	55                   	push   %ebp
 804bc6e:	89 e5                	mov    %esp,%ebp
 804bc70:	83 ec 04             	sub    $0x4,%esp
 804bc73:	e8 66 0a 00 00       	call   804c6de <__x86.get_pc_thunk.dx>
 804bc78:	81 c2 88 33 00 00    	add    $0x3388,%edx
 804bc7e:	8b 45 08             	mov    0x8(%ebp),%eax
 804bc81:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (isupper(c))
 804bc84:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804bc88:	0f b6 84 02 60 00 00 	movzbl 0x60(%edx,%eax,1),%eax
 804bc8f:	00 
 804bc90:	0f b6 c0             	movzbl %al,%eax
 804bc93:	83 e0 01             	and    $0x1,%eax
 804bc96:	85 c0                	test   %eax,%eax
 804bc98:	74 04                	je     804bc9e <__tolower+0x31>
                c -= 'A' - 'a';
 804bc9a:	80 45 fc 20          	addb   $0x20,-0x4(%ebp)
        return c;
 804bc9e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804bca2:	c9                   	leave  
 804bca3:	c3                   	ret    

0804bca4 <__toupper>:

static inline unsigned char __toupper(unsigned char c)
{
 804bca4:	55                   	push   %ebp
 804bca5:	89 e5                	mov    %esp,%ebp
 804bca7:	83 ec 04             	sub    $0x4,%esp
 804bcaa:	e8 2f 0a 00 00       	call   804c6de <__x86.get_pc_thunk.dx>
 804bcaf:	81 c2 51 33 00 00    	add    $0x3351,%edx
 804bcb5:	8b 45 08             	mov    0x8(%ebp),%eax
 804bcb8:	88 45 fc             	mov    %al,-0x4(%ebp)
        if (islower(c))
 804bcbb:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
 804bcbf:	0f b6 84 02 60 00 00 	movzbl 0x60(%edx,%eax,1),%eax
 804bcc6:	00 
 804bcc7:	0f b6 c0             	movzbl %al,%eax
 804bcca:	83 e0 02             	and    $0x2,%eax
 804bccd:	85 c0                	test   %eax,%eax
 804bccf:	74 04                	je     804bcd5 <__toupper+0x31>
                c -= 'a' - 'A';
 804bcd1:	80 6d fc 20          	subb   $0x20,-0x4(%ebp)
        return c;
 804bcd5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
}
 804bcd9:	c9                   	leave  
 804bcda:	c3                   	ret    

0804bcdb <skip_atoi>:
#include "stddef.h"
#include "stdio.h"
#include "string.h"

static int skip_atoi(const char **s)
{
 804bcdb:	55                   	push   %ebp
 804bcdc:	89 e5                	mov    %esp,%ebp
 804bcde:	56                   	push   %esi
 804bcdf:	53                   	push   %ebx
 804bce0:	83 ec 10             	sub    $0x10,%esp
 804bce3:	e8 dd d3 ff ff       	call   80490c5 <__x86.get_pc_thunk.cx>
 804bce8:	81 c1 18 33 00 00    	add    $0x3318,%ecx
        int i = 0;
 804bcee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

        while (isdigit(**s))
 804bcf5:	eb 29                	jmp    804bd20 <skip_atoi+0x45>
                i = i * 10 + *((*s)++) - '0';
 804bcf7:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804bcfa:	89 d0                	mov    %edx,%eax
 804bcfc:	c1 e0 02             	shl    $0x2,%eax
 804bcff:	01 d0                	add    %edx,%eax
 804bd01:	01 c0                	add    %eax,%eax
 804bd03:	89 c6                	mov    %eax,%esi
 804bd05:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd08:	8b 00                	mov    (%eax),%eax
 804bd0a:	8d 58 01             	lea    0x1(%eax),%ebx
 804bd0d:	8b 55 08             	mov    0x8(%ebp),%edx
 804bd10:	89 1a                	mov    %ebx,(%edx)
 804bd12:	0f b6 00             	movzbl (%eax),%eax
 804bd15:	0f be c0             	movsbl %al,%eax
 804bd18:	01 f0                	add    %esi,%eax
 804bd1a:	83 e8 30             	sub    $0x30,%eax
 804bd1d:	89 45 f4             	mov    %eax,-0xc(%ebp)

static int skip_atoi(const char **s)
{
        int i = 0;

        while (isdigit(**s))
 804bd20:	8b 45 08             	mov    0x8(%ebp),%eax
 804bd23:	8b 00                	mov    (%eax),%eax
 804bd25:	0f b6 00             	movzbl (%eax),%eax
 804bd28:	0f b6 c0             	movzbl %al,%eax
 804bd2b:	0f b6 84 01 60 00 00 	movzbl 0x60(%ecx,%eax,1),%eax
 804bd32:	00 
 804bd33:	0f b6 c0             	movzbl %al,%eax
 804bd36:	83 e0 04             	and    $0x4,%eax
 804bd39:	85 c0                	test   %eax,%eax
 804bd3b:	75 ba                	jne    804bcf7 <skip_atoi+0x1c>
                i = i * 10 + *((*s)++) - '0';
        return i;
 804bd3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804bd40:	83 c4 10             	add    $0x10,%esp
 804bd43:	5b                   	pop    %ebx
 804bd44:	5e                   	pop    %esi
 804bd45:	5d                   	pop    %ebp
 804bd46:	c3                   	ret    

0804bd47 <number>:
#define LEFT    16              /* left justified */
#define SPECIAL 32              /* 0x */
#define LARGE   64              /* use 'ABCDEF' instead of 'abcdef' */

static char *number(char *buf, char *end, long long num, int base, int size, int precision, int type)
{
 804bd47:	55                   	push   %ebp
 804bd48:	89 e5                	mov    %esp,%ebp
 804bd4a:	57                   	push   %edi
 804bd4b:	56                   	push   %esi
 804bd4c:	53                   	push   %ebx
 804bd4d:	81 ec dc 00 00 00    	sub    $0xdc,%esp
 804bd53:	e8 8a 09 00 00       	call   804c6e2 <__x86.get_pc_thunk.si>
 804bd58:	81 c6 a8 32 00 00    	add    $0x32a8,%esi
 804bd5e:	8b 45 10             	mov    0x10(%ebp),%eax
 804bd61:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
 804bd67:	8b 45 14             	mov    0x14(%ebp),%eax
 804bd6a:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
        char c, sign, tmp[66];
        const char *digits;
        const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 804bd70:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804bd76:	8d 96 b4 ef ff ff    	lea    -0x104c(%esi),%edx
 804bd7c:	bb 25 00 00 00       	mov    $0x25,%ebx
 804bd81:	89 c1                	mov    %eax,%ecx
 804bd83:	83 e1 01             	and    $0x1,%ecx
 804bd86:	85 c9                	test   %ecx,%ecx
 804bd88:	74 0c                	je     804bd96 <number+0x4f>
 804bd8a:	0f b6 0a             	movzbl (%edx),%ecx
 804bd8d:	88 08                	mov    %cl,(%eax)
 804bd8f:	8d 40 01             	lea    0x1(%eax),%eax
 804bd92:	8d 52 01             	lea    0x1(%edx),%edx
 804bd95:	4b                   	dec    %ebx
 804bd96:	89 c1                	mov    %eax,%ecx
 804bd98:	83 e1 02             	and    $0x2,%ecx
 804bd9b:	85 c9                	test   %ecx,%ecx
 804bd9d:	74 0f                	je     804bdae <number+0x67>
 804bd9f:	0f b7 0a             	movzwl (%edx),%ecx
 804bda2:	66 89 08             	mov    %cx,(%eax)
 804bda5:	8d 40 02             	lea    0x2(%eax),%eax
 804bda8:	8d 52 02             	lea    0x2(%edx),%edx
 804bdab:	83 eb 02             	sub    $0x2,%ebx
 804bdae:	89 df                	mov    %ebx,%edi
 804bdb0:	83 e7 fc             	and    $0xfffffffc,%edi
 804bdb3:	89 bd 2c ff ff ff    	mov    %edi,-0xd4(%ebp)
 804bdb9:	b9 00 00 00 00       	mov    $0x0,%ecx
 804bdbe:	8b 3c 0a             	mov    (%edx,%ecx,1),%edi
 804bdc1:	89 3c 08             	mov    %edi,(%eax,%ecx,1)
 804bdc4:	83 c1 04             	add    $0x4,%ecx
 804bdc7:	3b 8d 2c ff ff ff    	cmp    -0xd4(%ebp),%ecx
 804bdcd:	72 ef                	jb     804bdbe <number+0x77>
 804bdcf:	01 c8                	add    %ecx,%eax
 804bdd1:	01 ca                	add    %ecx,%edx
 804bdd3:	b9 00 00 00 00       	mov    $0x0,%ecx
 804bdd8:	89 df                	mov    %ebx,%edi
 804bdda:	83 e7 02             	and    $0x2,%edi
 804bddd:	85 ff                	test   %edi,%edi
 804bddf:	74 0b                	je     804bdec <number+0xa5>
 804bde1:	0f b7 3c 0a          	movzwl (%edx,%ecx,1),%edi
 804bde5:	66 89 3c 08          	mov    %di,(%eax,%ecx,1)
 804bde9:	83 c1 02             	add    $0x2,%ecx
 804bdec:	83 e3 01             	and    $0x1,%ebx
 804bdef:	85 db                	test   %ebx,%ebx
 804bdf1:	74 07                	je     804bdfa <number+0xb3>
 804bdf3:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
 804bdf7:	88 14 08             	mov    %dl,(%eax,%ecx,1)
        const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 804bdfa:	8d 8d 40 ff ff ff    	lea    -0xc0(%ebp),%ecx
 804be00:	8d 96 dc ef ff ff    	lea    -0x1024(%esi),%edx
 804be06:	b8 25 00 00 00       	mov    $0x25,%eax
 804be0b:	83 e0 fc             	and    $0xfffffffc,%eax
 804be0e:	89 c7                	mov    %eax,%edi
 804be10:	b8 00 00 00 00       	mov    $0x0,%eax
 804be15:	8b 9c 06 dc ef ff ff 	mov    -0x1024(%esi,%eax,1),%ebx
 804be1c:	89 9c 05 40 ff ff ff 	mov    %ebx,-0xc0(%ebp,%eax,1)
 804be23:	83 c0 04             	add    $0x4,%eax
 804be26:	39 f8                	cmp    %edi,%eax
 804be28:	72 eb                	jb     804be15 <number+0xce>
 804be2a:	01 c1                	add    %eax,%ecx
 804be2c:	01 c2                	add    %eax,%edx
 804be2e:	0f b6 02             	movzbl (%edx),%eax
 804be31:	88 01                	mov    %al,(%ecx)
        int i;

        digits = (type & LARGE) ? large_digits : small_digits;
 804be33:	8b 45 24             	mov    0x24(%ebp),%eax
 804be36:	83 e0 40             	and    $0x40,%eax
 804be39:	85 c0                	test   %eax,%eax
 804be3b:	74 08                	je     804be45 <number+0xfe>
 804be3d:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
 804be43:	eb 06                	jmp    804be4b <number+0x104>
 804be45:	8d 85 65 ff ff ff    	lea    -0x9b(%ebp),%eax
 804be4b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (type & LEFT)
 804be4e:	8b 45 24             	mov    0x24(%ebp),%eax
 804be51:	83 e0 10             	and    $0x10,%eax
 804be54:	85 c0                	test   %eax,%eax
 804be56:	74 04                	je     804be5c <number+0x115>
                type &= ~ZEROPAD;
 804be58:	83 65 24 fe          	andl   $0xfffffffe,0x24(%ebp)
        if (base < 2 || base > 36)
 804be5c:	83 7d 18 01          	cmpl   $0x1,0x18(%ebp)
 804be60:	7e 06                	jle    804be68 <number+0x121>
 804be62:	83 7d 18 24          	cmpl   $0x24,0x18(%ebp)
 804be66:	7e 08                	jle    804be70 <number+0x129>
                return buf;
 804be68:	8b 45 08             	mov    0x8(%ebp),%eax
 804be6b:	e9 80 02 00 00       	jmp    804c0f0 <number+0x3a9>
        c = (type & ZEROPAD) ? '0' : ' ';
 804be70:	8b 45 24             	mov    0x24(%ebp),%eax
 804be73:	83 e0 01             	and    $0x1,%eax
 804be76:	85 c0                	test   %eax,%eax
 804be78:	74 04                	je     804be7e <number+0x137>
 804be7a:	b0 30                	mov    $0x30,%al
 804be7c:	eb 02                	jmp    804be80 <number+0x139>
 804be7e:	b0 20                	mov    $0x20,%al
 804be80:	88 45 d3             	mov    %al,-0x2d(%ebp)
        sign = 0;
 804be83:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
        if (type & SIGN) {
 804be87:	8b 45 24             	mov    0x24(%ebp),%eax
 804be8a:	83 e0 02             	and    $0x2,%eax
 804be8d:	85 c0                	test   %eax,%eax
 804be8f:	74 49                	je     804beda <number+0x193>
                if (num < 0) {
 804be91:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%ebp)
 804be98:	79 1c                	jns    804beb6 <number+0x16f>
                        sign = '-';
 804be9a:	c6 45 e7 2d          	movb   $0x2d,-0x19(%ebp)
                        num = -num;
 804be9e:	f7 9d 30 ff ff ff    	negl   -0xd0(%ebp)
 804bea4:	83 95 34 ff ff ff 00 	adcl   $0x0,-0xcc(%ebp)
 804beab:	f7 9d 34 ff ff ff    	negl   -0xcc(%ebp)
                        size--;
 804beb1:	ff 4d 1c             	decl   0x1c(%ebp)
 804beb4:	eb 24                	jmp    804beda <number+0x193>
                } else if (type & PLUS) {
 804beb6:	8b 45 24             	mov    0x24(%ebp),%eax
 804beb9:	83 e0 04             	and    $0x4,%eax
 804bebc:	85 c0                	test   %eax,%eax
 804bebe:	74 09                	je     804bec9 <number+0x182>
                        sign = '+';
 804bec0:	c6 45 e7 2b          	movb   $0x2b,-0x19(%ebp)
                        size--;
 804bec4:	ff 4d 1c             	decl   0x1c(%ebp)
 804bec7:	eb 11                	jmp    804beda <number+0x193>
                } else if (type & SPACE) {
 804bec9:	8b 45 24             	mov    0x24(%ebp),%eax
 804becc:	83 e0 08             	and    $0x8,%eax
 804becf:	85 c0                	test   %eax,%eax
 804bed1:	74 07                	je     804beda <number+0x193>
                        sign = ' ';
 804bed3:	c6 45 e7 20          	movb   $0x20,-0x19(%ebp)
                        size--;
 804bed7:	ff 4d 1c             	decl   0x1c(%ebp)
                }
        }
        if (type & SPECIAL) {
 804beda:	8b 45 24             	mov    0x24(%ebp),%eax
 804bedd:	83 e0 20             	and    $0x20,%eax
 804bee0:	85 c0                	test   %eax,%eax
 804bee2:	74 15                	je     804bef9 <number+0x1b2>
                if (base == 16)
 804bee4:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804bee8:	75 06                	jne    804bef0 <number+0x1a9>
                        size -= 2;
 804beea:	83 6d 1c 02          	subl   $0x2,0x1c(%ebp)
 804beee:	eb 09                	jmp    804bef9 <number+0x1b2>
                else if (base == 8)
 804bef0:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804bef4:	75 03                	jne    804bef9 <number+0x1b2>
                        size--;
 804bef6:	ff 4d 1c             	decl   0x1c(%ebp)
        }
        i = 0;
 804bef9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
        if (num == 0) {
 804bf00:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
 804bf06:	0b 85 30 ff ff ff    	or     -0xd0(%ebp),%eax
 804bf0c:	85 c0                	test   %eax,%eax
 804bf0e:	75 13                	jne    804bf23 <number+0x1dc>
                tmp[i++] = '0';
 804bf10:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bf13:	8d 50 01             	lea    0x1(%eax),%edx
 804bf16:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804bf19:	c6 44 05 8a 30       	movb   $0x30,-0x76(%ebp,%eax,1)
 804bf1e:	e9 89 00 00 00       	jmp    804bfac <number+0x265>
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
 804bf23:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
 804bf29:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
 804bf2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804bf32:	89 55 dc             	mov    %edx,-0x24(%ebp)
                unsigned int base2 = (unsigned int)base;
 804bf35:	8b 45 18             	mov    0x18(%ebp),%eax
 804bf38:	89 45 cc             	mov    %eax,-0x34(%ebp)
                while (num2 != 0) {
 804bf3b:	eb 65                	jmp    804bfa2 <number+0x25b>
                        tmp[i++] = digits[num2 % base2];
 804bf3d:	8b 7d e0             	mov    -0x20(%ebp),%edi
 804bf40:	8d 47 01             	lea    0x1(%edi),%eax
 804bf43:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804bf46:	8b 4d cc             	mov    -0x34(%ebp),%ecx
 804bf49:	bb 00 00 00 00       	mov    $0x0,%ebx
 804bf4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bf51:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804bf54:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804bf58:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804bf5c:	89 04 24             	mov    %eax,(%esp)
 804bf5f:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bf63:	89 f3                	mov    %esi,%ebx
 804bf65:	e8 b9 0f 00 00       	call   804cf23 <__umoddi3>
 804bf6a:	89 c2                	mov    %eax,%edx
 804bf6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804bf6f:	01 d0                	add    %edx,%eax
 804bf71:	0f b6 00             	movzbl (%eax),%eax
 804bf74:	88 44 3d 8a          	mov    %al,-0x76(%ebp,%edi,1)
                        num2 /= base2;
 804bf78:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804bf7b:	ba 00 00 00 00       	mov    $0x0,%edx
 804bf80:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bf84:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804bf88:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804bf8b:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804bf8e:	89 04 24             	mov    %eax,(%esp)
 804bf91:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bf95:	89 f3                	mov    %esi,%ebx
 804bf97:	e8 2d 0f 00 00       	call   804cec9 <__udivdi3>
 804bf9c:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804bf9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
        } else {
                /* XXX KAF: force unsigned mod and div. */
                /* XXX kernel does not support long long division */
                unsigned long long num2 = (unsigned long long)num;
                unsigned int base2 = (unsigned int)base;
                while (num2 != 0) {
 804bfa2:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804bfa5:	0b 45 d8             	or     -0x28(%ebp),%eax
 804bfa8:	85 c0                	test   %eax,%eax
 804bfaa:	75 91                	jne    804bf3d <number+0x1f6>
                        tmp[i++] = digits[num2 % base2];
                        num2 /= base2;
                }
        }
        if (i > precision)
 804bfac:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bfaf:	3b 45 20             	cmp    0x20(%ebp),%eax
 804bfb2:	7e 06                	jle    804bfba <number+0x273>
                precision = i;
 804bfb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bfb7:	89 45 20             	mov    %eax,0x20(%ebp)
        size -= precision;
 804bfba:	8b 45 20             	mov    0x20(%ebp),%eax
 804bfbd:	29 45 1c             	sub    %eax,0x1c(%ebp)
        if (!(type & (ZEROPAD + LEFT))) {
 804bfc0:	8b 45 24             	mov    0x24(%ebp),%eax
 804bfc3:	83 e0 11             	and    $0x11,%eax
 804bfc6:	85 c0                	test   %eax,%eax
 804bfc8:	75 20                	jne    804bfea <number+0x2a3>
                while (size-- > 0) {
 804bfca:	eb 11                	jmp    804bfdd <number+0x296>
                        if (buf <= end)
 804bfcc:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfcf:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bfd2:	77 06                	ja     804bfda <number+0x293>
                                *buf = ' ';
 804bfd4:	8b 45 08             	mov    0x8(%ebp),%eax
 804bfd7:	c6 00 20             	movb   $0x20,(%eax)
                        ++buf;
 804bfda:	ff 45 08             	incl   0x8(%ebp)
        }
        if (i > precision)
                precision = i;
        size -= precision;
        if (!(type & (ZEROPAD + LEFT))) {
                while (size-- > 0) {
 804bfdd:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804bfe0:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bfe3:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804bfe6:	85 c0                	test   %eax,%eax
 804bfe8:	7f e2                	jg     804bfcc <number+0x285>
                        if (buf <= end)
                                *buf = ' ';
                        ++buf;
                }
        }
        if (sign) {
 804bfea:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
 804bfee:	74 14                	je     804c004 <number+0x2bd>
                if (buf <= end)
 804bff0:	8b 45 08             	mov    0x8(%ebp),%eax
 804bff3:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804bff6:	77 09                	ja     804c001 <number+0x2ba>
                        *buf = sign;
 804bff8:	8b 45 08             	mov    0x8(%ebp),%eax
 804bffb:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
 804bfff:	88 10                	mov    %dl,(%eax)
                ++buf;
 804c001:	ff 45 08             	incl   0x8(%ebp)
        }
        if (type & SPECIAL) {
 804c004:	8b 45 24             	mov    0x24(%ebp),%eax
 804c007:	83 e0 20             	and    $0x20,%eax
 804c00a:	85 c0                	test   %eax,%eax
 804c00c:	74 47                	je     804c055 <number+0x30e>
                if (base == 8) {
 804c00e:	83 7d 18 08          	cmpl   $0x8,0x18(%ebp)
 804c012:	75 13                	jne    804c027 <number+0x2e0>
                        if (buf <= end)
 804c014:	8b 45 08             	mov    0x8(%ebp),%eax
 804c017:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c01a:	77 06                	ja     804c022 <number+0x2db>
                                *buf = '0';
 804c01c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c01f:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804c022:	ff 45 08             	incl   0x8(%ebp)
 804c025:	eb 2e                	jmp    804c055 <number+0x30e>
                } else if (base == 16) {
 804c027:	83 7d 18 10          	cmpl   $0x10,0x18(%ebp)
 804c02b:	75 28                	jne    804c055 <number+0x30e>
                        if (buf <= end)
 804c02d:	8b 45 08             	mov    0x8(%ebp),%eax
 804c030:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c033:	77 06                	ja     804c03b <number+0x2f4>
                                *buf = '0';
 804c035:	8b 45 08             	mov    0x8(%ebp),%eax
 804c038:	c6 00 30             	movb   $0x30,(%eax)
                        ++buf;
 804c03b:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
 804c03e:	8b 45 08             	mov    0x8(%ebp),%eax
 804c041:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c044:	77 0c                	ja     804c052 <number+0x30b>
                                *buf = digits[33];
 804c046:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c049:	0f b6 50 21          	movzbl 0x21(%eax),%edx
 804c04d:	8b 45 08             	mov    0x8(%ebp),%eax
 804c050:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804c052:	ff 45 08             	incl   0x8(%ebp)
                }
        }
        if (!(type & LEFT)) {
 804c055:	8b 45 24             	mov    0x24(%ebp),%eax
 804c058:	83 e0 10             	and    $0x10,%eax
 804c05b:	85 c0                	test   %eax,%eax
 804c05d:	75 36                	jne    804c095 <number+0x34e>
                while (size-- > 0) {
 804c05f:	eb 14                	jmp    804c075 <number+0x32e>
                        if (buf <= end)
 804c061:	8b 45 08             	mov    0x8(%ebp),%eax
 804c064:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c067:	77 09                	ja     804c072 <number+0x32b>
                                *buf = c;
 804c069:	8b 45 08             	mov    0x8(%ebp),%eax
 804c06c:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 804c070:	88 10                	mov    %dl,(%eax)
                        ++buf;
 804c072:	ff 45 08             	incl   0x8(%ebp)
                                *buf = digits[33];
                        ++buf;
                }
        }
        if (!(type & LEFT)) {
                while (size-- > 0) {
 804c075:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804c078:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c07b:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804c07e:	85 c0                	test   %eax,%eax
 804c080:	7f df                	jg     804c061 <number+0x31a>
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804c082:	eb 11                	jmp    804c095 <number+0x34e>
                if (buf <= end)
 804c084:	8b 45 08             	mov    0x8(%ebp),%eax
 804c087:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c08a:	77 06                	ja     804c092 <number+0x34b>
                        *buf = '0';
 804c08c:	8b 45 08             	mov    0x8(%ebp),%eax
 804c08f:	c6 00 30             	movb   $0x30,(%eax)
                ++buf;
 804c092:	ff 45 08             	incl   0x8(%ebp)
                        if (buf <= end)
                                *buf = c;
                        ++buf;
                }
        }
        while (i < precision--) {
 804c095:	8b 45 20             	mov    0x20(%ebp),%eax
 804c098:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c09b:	89 55 20             	mov    %edx,0x20(%ebp)
 804c09e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c0a1:	7f e1                	jg     804c084 <number+0x33d>
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804c0a3:	eb 1b                	jmp    804c0c0 <number+0x379>
                if (buf <= end)
 804c0a5:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0a8:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c0ab:	77 10                	ja     804c0bd <number+0x376>
                        *buf = tmp[i];
 804c0ad:	8d 55 8a             	lea    -0x76(%ebp),%edx
 804c0b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c0b3:	01 d0                	add    %edx,%eax
 804c0b5:	0f b6 10             	movzbl (%eax),%edx
 804c0b8:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0bb:	88 10                	mov    %dl,(%eax)
                ++buf;
 804c0bd:	ff 45 08             	incl   0x8(%ebp)
        while (i < precision--) {
                if (buf <= end)
                        *buf = '0';
                ++buf;
        }
        while (i-- > 0) {
 804c0c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c0c3:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c0c6:	89 55 e0             	mov    %edx,-0x20(%ebp)
 804c0c9:	85 c0                	test   %eax,%eax
 804c0cb:	7f d8                	jg     804c0a5 <number+0x35e>
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804c0cd:	eb 11                	jmp    804c0e0 <number+0x399>
                if (buf <= end)
 804c0cf:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0d2:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c0d5:	77 06                	ja     804c0dd <number+0x396>
                        *buf = ' ';
 804c0d7:	8b 45 08             	mov    0x8(%ebp),%eax
 804c0da:	c6 00 20             	movb   $0x20,(%eax)
                ++buf;
 804c0dd:	ff 45 08             	incl   0x8(%ebp)
        while (i-- > 0) {
                if (buf <= end)
                        *buf = tmp[i];
                ++buf;
        }
        while (size-- > 0) {
 804c0e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
 804c0e3:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c0e6:	89 55 1c             	mov    %edx,0x1c(%ebp)
 804c0e9:	85 c0                	test   %eax,%eax
 804c0eb:	7f e2                	jg     804c0cf <number+0x388>
                if (buf <= end)
                        *buf = ' ';
                ++buf;
        }
        return buf;
 804c0ed:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804c0f0:	81 c4 dc 00 00 00    	add    $0xdc,%esp
 804c0f6:	5b                   	pop    %ebx
 804c0f7:	5e                   	pop    %esi
 804c0f8:	5f                   	pop    %edi
 804c0f9:	5d                   	pop    %ebp
 804c0fa:	c3                   	ret    

0804c0fb <vsnprintf>:
*
* Call this function if you are already dealing with a va_list.
* You probably want snprintf instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
 804c0fb:	55                   	push   %ebp
 804c0fc:	89 e5                	mov    %esp,%ebp
 804c0fe:	53                   	push   %ebx
 804c0ff:	83 ec 64             	sub    $0x64,%esp
 804c102:	e8 c2 cf ff ff       	call   80490c9 <__x86.get_pc_thunk.bx>
 804c107:	81 c3 f9 2e 00 00    	add    $0x2ef9,%ebx
                                   number of chars for from string */
        int qualifier;              /* 'h', 'l', or 'L' for integer fields */
        /* 'z' support added 23/7/1999 S.H.    */
        /* 'z' changed to 'Z' --davidm 1/25/99 */

        str = buf;
 804c10d:	8b 45 08             	mov    0x8(%ebp),%eax
 804c110:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        end = buf + size - 1;
 804c113:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c116:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c119:	8b 45 08             	mov    0x8(%ebp),%eax
 804c11c:	01 d0                	add    %edx,%eax
 804c11e:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if (end < buf - 1) {
 804c121:	8b 45 08             	mov    0x8(%ebp),%eax
 804c124:	48                   	dec    %eax
 804c125:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c128:	0f 86 76 05 00 00    	jbe    804c6a4 <.L138+0x116>
                end = ((void *) - 1);
 804c12e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
                size = end - buf + 1;
 804c135:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804c138:	8b 45 08             	mov    0x8(%ebp),%eax
 804c13b:	29 c2                	sub    %eax,%edx
 804c13d:	89 d0                	mov    %edx,%eax
 804c13f:	40                   	inc    %eax
 804c140:	89 45 0c             	mov    %eax,0xc(%ebp)
        }

        for (; *fmt ; ++fmt) {
 804c143:	e9 5c 05 00 00       	jmp    804c6a4 <.L138+0x116>
                if (*fmt != '%') {
 804c148:	8b 45 10             	mov    0x10(%ebp),%eax
 804c14b:	0f b6 00             	movzbl (%eax),%eax
 804c14e:	3c 25                	cmp    $0x25,%al
 804c150:	74 1b                	je     804c16d <vsnprintf+0x72>
                        if (str <= end)
 804c152:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c155:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c158:	77 0b                	ja     804c165 <vsnprintf+0x6a>
                                *str = *fmt;
 804c15a:	8b 45 10             	mov    0x10(%ebp),%eax
 804c15d:	0f b6 10             	movzbl (%eax),%edx
 804c160:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c163:	88 10                	mov    %dl,(%eax)
                        ++str;
 804c165:	ff 45 e4             	incl   -0x1c(%ebp)
                        continue;
 804c168:	e9 30 05 00 00       	jmp    804c69d <.L138+0x10f>
                }

                /* process flags */
                flags = 0;
 804c16d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
repeat:
                ++fmt;          /* this also skips first '%' */
 804c174:	8b 45 10             	mov    0x10(%ebp),%eax
 804c177:	40                   	inc    %eax
 804c178:	89 45 10             	mov    %eax,0x10(%ebp)
                switch (*fmt) {
 804c17b:	8b 45 10             	mov    0x10(%ebp),%eax
 804c17e:	0f b6 00             	movzbl (%eax),%eax
 804c181:	0f be c0             	movsbl %al,%eax
 804c184:	83 e8 20             	sub    $0x20,%eax
 804c187:	83 f8 10             	cmp    $0x10,%eax
 804c18a:	77 2c                	ja     804c1b8 <.L70>
 804c18c:	c1 e0 02             	shl    $0x2,%eax
 804c18f:	8b 84 18 08 f0 ff ff 	mov    -0xff8(%eax,%ebx,1),%eax
 804c196:	01 d8                	add    %ebx,%eax
 804c198:	ff e0                	jmp    *%eax

0804c19a <.L75>:
                        case '-': flags |= LEFT; goto repeat;
 804c19a:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
 804c19e:	eb d4                	jmp    804c174 <vsnprintf+0x79>

0804c1a0 <.L74>:
                        case '+': flags |= PLUS; goto repeat;
 804c1a0:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
 804c1a4:	eb ce                	jmp    804c174 <vsnprintf+0x79>

0804c1a6 <.L71>:
                        case ' ': flags |= SPACE; goto repeat;
 804c1a6:	83 4d d8 08          	orl    $0x8,-0x28(%ebp)
 804c1aa:	eb c8                	jmp    804c174 <vsnprintf+0x79>

0804c1ac <.L73>:
                        case '#': flags |= SPECIAL; goto repeat;
 804c1ac:	83 4d d8 20          	orl    $0x20,-0x28(%ebp)
 804c1b0:	eb c2                	jmp    804c174 <vsnprintf+0x79>

0804c1b2 <.L76>:
                        case '0': flags |= ZEROPAD; goto repeat;
 804c1b2:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
 804c1b6:	eb bc                	jmp    804c174 <vsnprintf+0x79>

0804c1b8 <.L70>:
                }

                /* get field width */
                field_width = -1;
 804c1b8:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
                if (isdigit(*fmt))
 804c1bf:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1c2:	0f b6 00             	movzbl (%eax),%eax
 804c1c5:	0f b6 c0             	movzbl %al,%eax
 804c1c8:	0f b6 84 03 60 00 00 	movzbl 0x60(%ebx,%eax,1),%eax
 804c1cf:	00 
 804c1d0:	0f b6 c0             	movzbl %al,%eax
 804c1d3:	83 e0 04             	and    $0x4,%eax
 804c1d6:	85 c0                	test   %eax,%eax
 804c1d8:	74 10                	je     804c1ea <.L70+0x32>
                        field_width = skip_atoi(&fmt);
 804c1da:	8d 45 10             	lea    0x10(%ebp),%eax
 804c1dd:	89 04 24             	mov    %eax,(%esp)
 804c1e0:	e8 f6 fa ff ff       	call   804bcdb <skip_atoi>
 804c1e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804c1e8:	eb 2c                	jmp    804c216 <.L70+0x5e>
                else if (*fmt == '*') {
 804c1ea:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1ed:	0f b6 00             	movzbl (%eax),%eax
 804c1f0:	3c 2a                	cmp    $0x2a,%al
 804c1f2:	75 22                	jne    804c216 <.L70+0x5e>
                        ++fmt;
 804c1f4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c1f7:	40                   	inc    %eax
 804c1f8:	89 45 10             	mov    %eax,0x10(%ebp)
                        /* it's the next argument */
                        field_width = va_arg(args, int);
 804c1fb:	8b 45 14             	mov    0x14(%ebp),%eax
 804c1fe:	8d 50 04             	lea    0x4(%eax),%edx
 804c201:	89 55 14             	mov    %edx,0x14(%ebp)
 804c204:	8b 00                	mov    (%eax),%eax
 804c206:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                        if (field_width < 0) {
 804c209:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c20d:	79 07                	jns    804c216 <.L70+0x5e>
                                field_width = -field_width;
 804c20f:	f7 5d d4             	negl   -0x2c(%ebp)
                                flags |= LEFT;
 804c212:	83 4d d8 10          	orl    $0x10,-0x28(%ebp)
                        }
                }

                /* get the precision */
                precision = -1;
 804c216:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
                if (*fmt == '.') {
 804c21d:	8b 45 10             	mov    0x10(%ebp),%eax
 804c220:	0f b6 00             	movzbl (%eax),%eax
 804c223:	3c 2e                	cmp    $0x2e,%al
 804c225:	75 5e                	jne    804c285 <.L70+0xcd>
                        ++fmt;
 804c227:	8b 45 10             	mov    0x10(%ebp),%eax
 804c22a:	40                   	inc    %eax
 804c22b:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (isdigit(*fmt))
 804c22e:	8b 45 10             	mov    0x10(%ebp),%eax
 804c231:	0f b6 00             	movzbl (%eax),%eax
 804c234:	0f b6 c0             	movzbl %al,%eax
 804c237:	0f b6 84 03 60 00 00 	movzbl 0x60(%ebx,%eax,1),%eax
 804c23e:	00 
 804c23f:	0f b6 c0             	movzbl %al,%eax
 804c242:	83 e0 04             	and    $0x4,%eax
 804c245:	85 c0                	test   %eax,%eax
 804c247:	74 10                	je     804c259 <.L70+0xa1>
                                precision = skip_atoi(&fmt);
 804c249:	8d 45 10             	lea    0x10(%ebp),%eax
 804c24c:	89 04 24             	mov    %eax,(%esp)
 804c24f:	e8 87 fa ff ff       	call   804bcdb <skip_atoi>
 804c254:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804c257:	eb 1f                	jmp    804c278 <.L70+0xc0>
                        else if (*fmt == '*') {
 804c259:	8b 45 10             	mov    0x10(%ebp),%eax
 804c25c:	0f b6 00             	movzbl (%eax),%eax
 804c25f:	3c 2a                	cmp    $0x2a,%al
 804c261:	75 15                	jne    804c278 <.L70+0xc0>
                                ++fmt;
 804c263:	8b 45 10             	mov    0x10(%ebp),%eax
 804c266:	40                   	inc    %eax
 804c267:	89 45 10             	mov    %eax,0x10(%ebp)
                                /* it's the next argument */
                                precision = va_arg(args, int);
 804c26a:	8b 45 14             	mov    0x14(%ebp),%eax
 804c26d:	8d 50 04             	lea    0x4(%eax),%edx
 804c270:	89 55 14             	mov    %edx,0x14(%ebp)
 804c273:	8b 00                	mov    (%eax),%eax
 804c275:	89 45 d0             	mov    %eax,-0x30(%ebp)
                        }
                        if (precision < 0)
 804c278:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804c27c:	79 07                	jns    804c285 <.L70+0xcd>
                                precision = 0;
 804c27e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
                }

                /* get the conversion qualifier */
                qualifier = -1;
 804c285:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
                if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z') {
 804c28c:	8b 45 10             	mov    0x10(%ebp),%eax
 804c28f:	0f b6 00             	movzbl (%eax),%eax
 804c292:	3c 68                	cmp    $0x68,%al
 804c294:	74 1e                	je     804c2b4 <.L70+0xfc>
 804c296:	8b 45 10             	mov    0x10(%ebp),%eax
 804c299:	0f b6 00             	movzbl (%eax),%eax
 804c29c:	3c 6c                	cmp    $0x6c,%al
 804c29e:	74 14                	je     804c2b4 <.L70+0xfc>
 804c2a0:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2a3:	0f b6 00             	movzbl (%eax),%eax
 804c2a6:	3c 4c                	cmp    $0x4c,%al
 804c2a8:	74 0a                	je     804c2b4 <.L70+0xfc>
 804c2aa:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2ad:	0f b6 00             	movzbl (%eax),%eax
 804c2b0:	3c 5a                	cmp    $0x5a,%al
 804c2b2:	75 31                	jne    804c2e5 <.L70+0x12d>
                        qualifier = *fmt;
 804c2b4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2b7:	0f b6 00             	movzbl (%eax),%eax
 804c2ba:	0f be c0             	movsbl %al,%eax
 804c2bd:	89 45 cc             	mov    %eax,-0x34(%ebp)
                        ++fmt;
 804c2c0:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2c3:	40                   	inc    %eax
 804c2c4:	89 45 10             	mov    %eax,0x10(%ebp)
                        if (qualifier == 'l' && *fmt == 'l') {
 804c2c7:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c2cb:	75 18                	jne    804c2e5 <.L70+0x12d>
 804c2cd:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2d0:	0f b6 00             	movzbl (%eax),%eax
 804c2d3:	3c 6c                	cmp    $0x6c,%al
 804c2d5:	75 0e                	jne    804c2e5 <.L70+0x12d>
                                qualifier = 'L';
 804c2d7:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                                ++fmt;
 804c2de:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2e1:	40                   	inc    %eax
 804c2e2:	89 45 10             	mov    %eax,0x10(%ebp)
                        }
                }
                if (*fmt == 'q') {
 804c2e5:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2e8:	0f b6 00             	movzbl (%eax),%eax
 804c2eb:	3c 71                	cmp    $0x71,%al
 804c2ed:	75 0e                	jne    804c2fd <.L70+0x145>
                        qualifier = 'L';
 804c2ef:	c7 45 cc 4c 00 00 00 	movl   $0x4c,-0x34(%ebp)
                        ++fmt;
 804c2f6:	8b 45 10             	mov    0x10(%ebp),%eax
 804c2f9:	40                   	inc    %eax
 804c2fa:	89 45 10             	mov    %eax,0x10(%ebp)
                }

                /* default base */
                base = 10;
 804c2fd:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)

                switch (*fmt) {
 804c304:	8b 45 10             	mov    0x10(%ebp),%eax
 804c307:	0f b6 00             	movzbl (%eax),%eax
 804c30a:	0f be c0             	movsbl %al,%eax
 804c30d:	83 e8 25             	sub    $0x25,%eax
 804c310:	83 f8 53             	cmp    $0x53,%eax
 804c313:	0f 87 33 02 00 00    	ja     804c54c <.L85>
 804c319:	c1 e0 02             	shl    $0x2,%eax
 804c31c:	8b 84 18 4c f0 ff ff 	mov    -0xfb4(%eax,%ebx,1),%eax
 804c323:	01 d8                	add    %ebx,%eax
 804c325:	ff e0                	jmp    *%eax

0804c327 <.L90>:
                        case 'c':
                                if (!(flags & LEFT)) {
 804c327:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c32a:	83 e0 10             	and    $0x10,%eax
 804c32d:	85 c0                	test   %eax,%eax
 804c32f:	75 1c                	jne    804c34d <.L90+0x26>
                                        while (--field_width > 0) {
 804c331:	eb 11                	jmp    804c344 <.L90+0x1d>
                                                if (str <= end)
 804c333:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c336:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c339:	77 06                	ja     804c341 <.L90+0x1a>
                                                        *str = ' ';
 804c33b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c33e:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804c341:	ff 45 e4             	incl   -0x1c(%ebp)
                base = 10;

                switch (*fmt) {
                        case 'c':
                                if (!(flags & LEFT)) {
                                        while (--field_width > 0) {
 804c344:	ff 4d d4             	decl   -0x2c(%ebp)
 804c347:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c34b:	7f e6                	jg     804c333 <.L90+0xc>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                c = (unsigned char) va_arg(args, int);
 804c34d:	8b 45 14             	mov    0x14(%ebp),%eax
 804c350:	8d 50 04             	lea    0x4(%eax),%edx
 804c353:	89 55 14             	mov    %edx,0x14(%ebp)
 804c356:	8b 00                	mov    (%eax),%eax
 804c358:	88 45 cb             	mov    %al,-0x35(%ebp)
                                if (str <= end)
 804c35b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c35e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c361:	77 09                	ja     804c36c <.L90+0x45>
                                        *str = c;
 804c363:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c366:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
 804c36a:	88 10                	mov    %dl,(%eax)
                                ++str;
 804c36c:	ff 45 e4             	incl   -0x1c(%ebp)
                                while (--field_width > 0) {
 804c36f:	eb 11                	jmp    804c382 <.L90+0x5b>
                                        if (str <= end)
 804c371:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c374:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c377:	77 06                	ja     804c37f <.L90+0x58>
                                                *str = ' ';
 804c379:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c37c:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804c37f:	ff 45 e4             	incl   -0x1c(%ebp)
                                }
                                c = (unsigned char) va_arg(args, int);
                                if (str <= end)
                                        *str = c;
                                ++str;
                                while (--field_width > 0) {
 804c382:	ff 4d d4             	decl   -0x2c(%ebp)
 804c385:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804c389:	7f e6                	jg     804c371 <.L90+0x4a>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804c38b:	e9 0d 03 00 00       	jmp    804c69d <.L138+0x10f>

0804c390 <.L95>:

                        case 's':
                                s = va_arg(args, char *);
 804c390:	8b 45 14             	mov    0x14(%ebp),%eax
 804c393:	8d 50 04             	lea    0x4(%eax),%edx
 804c396:	89 55 14             	mov    %edx,0x14(%ebp)
 804c399:	8b 00                	mov    (%eax),%eax
 804c39b:	89 45 dc             	mov    %eax,-0x24(%ebp)
                                if (!s)
 804c39e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804c3a2:	75 09                	jne    804c3ad <.L95+0x1d>
                                        s = "<NULL>";
 804c3a4:	8d 83 01 f0 ff ff    	lea    -0xfff(%ebx),%eax
 804c3aa:	89 45 dc             	mov    %eax,-0x24(%ebp)

                                len = strnlen(s, precision);
 804c3ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804c3b0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c3b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c3b7:	89 04 24             	mov    %eax,(%esp)
 804c3ba:	e8 f4 ce ff ff       	call   80492b3 <strnlen>
 804c3bf:	89 45 c4             	mov    %eax,-0x3c(%ebp)

                                if (!(flags & LEFT)) {
 804c3c2:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c3c5:	83 e0 10             	and    $0x10,%eax
 804c3c8:	85 c0                	test   %eax,%eax
 804c3ca:	75 21                	jne    804c3ed <.L95+0x5d>
                                        while (len < field_width--) {
 804c3cc:	eb 11                	jmp    804c3df <.L95+0x4f>
                                                if (str <= end)
 804c3ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3d1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c3d4:	77 06                	ja     804c3dc <.L95+0x4c>
                                                        *str = ' ';
 804c3d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3d9:	c6 00 20             	movb   $0x20,(%eax)
                                                ++str;
 804c3dc:	ff 45 e4             	incl   -0x1c(%ebp)
                                        s = "<NULL>";

                                len = strnlen(s, precision);

                                if (!(flags & LEFT)) {
                                        while (len < field_width--) {
 804c3df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c3e2:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c3e5:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 804c3e8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c3eb:	7f e1                	jg     804c3ce <.L95+0x3e>
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804c3ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
 804c3f4:	eb 1c                	jmp    804c412 <.L95+0x82>
                                        if (str <= end)
 804c3f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c3f9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c3fc:	77 0b                	ja     804c409 <.L95+0x79>
                                                *str = *s;
 804c3fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804c401:	0f b6 10             	movzbl (%eax),%edx
 804c404:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c407:	88 10                	mov    %dl,(%eax)
                                        ++str; ++s;
 804c409:	ff 45 e4             	incl   -0x1c(%ebp)
 804c40c:	ff 45 dc             	incl   -0x24(%ebp)
                                                if (str <= end)
                                                        *str = ' ';
                                                ++str;
                                        }
                                }
                                for (i = 0; i < len; ++i) {
 804c40f:	ff 45 ec             	incl   -0x14(%ebp)
 804c412:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c415:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c418:	7c dc                	jl     804c3f6 <.L95+0x66>
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804c41a:	eb 11                	jmp    804c42d <.L95+0x9d>
                                        if (str <= end)
 804c41c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c41f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c422:	77 06                	ja     804c42a <.L95+0x9a>
                                                *str = ' ';
 804c424:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c427:	c6 00 20             	movb   $0x20,(%eax)
                                        ++str;
 804c42a:	ff 45 e4             	incl   -0x1c(%ebp)
                                for (i = 0; i < len; ++i) {
                                        if (str <= end)
                                                *str = *s;
                                        ++str; ++s;
                                }
                                while (len < field_width--) {
 804c42d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804c430:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c433:	89 55 d4             	mov    %edx,-0x2c(%ebp)
 804c436:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
 804c439:	7f e1                	jg     804c41c <.L95+0x8c>
                                        if (str <= end)
                                                *str = ' ';
                                        ++str;
                                }
                                continue;
 804c43b:	e9 5d 02 00 00       	jmp    804c69d <.L138+0x10f>

0804c440 <.L94>:

                        case 'p':
                                if (field_width == -1) {
 804c440:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
 804c444:	75 0b                	jne    804c451 <.L94+0x11>
                                        field_width = 2 * sizeof(void *);
 804c446:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
                                        flags |= ZEROPAD;
 804c44d:	83 4d d8 01          	orl    $0x1,-0x28(%ebp)
                                }
                                str = number(str, end,
                                             (unsigned long) va_arg(args, void *),
 804c451:	8b 45 14             	mov    0x14(%ebp),%eax
 804c454:	8d 50 04             	lea    0x4(%eax),%edx
 804c457:	89 55 14             	mov    %edx,0x14(%ebp)
 804c45a:	8b 00                	mov    (%eax),%eax
                        case 'p':
                                if (field_width == -1) {
                                        field_width = 2 * sizeof(void *);
                                        flags |= ZEROPAD;
                                }
                                str = number(str, end,
 804c45c:	ba 00 00 00 00       	mov    $0x0,%edx
 804c461:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804c464:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804c468:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804c46b:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804c46f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804c472:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804c476:	c7 44 24 10 10 00 00 	movl   $0x10,0x10(%esp)
 804c47d:	00 
 804c47e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c482:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c486:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c489:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c48d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c490:	89 04 24             	mov    %eax,(%esp)
 804c493:	e8 af f8 ff ff       	call   804bd47 <number>
 804c498:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                                             (unsigned long) va_arg(args, void *),
                                             16, field_width, precision, flags);
                                continue;
 804c49b:	e9 fd 01 00 00       	jmp    804c69d <.L138+0x10f>

0804c4a0 <.L92>:


                        case 'n':
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
 804c4a0:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c4a4:	75 20                	jne    804c4c6 <.L92+0x26>
                                        long *ip = va_arg(args, long *);
 804c4a6:	8b 45 14             	mov    0x14(%ebp),%eax
 804c4a9:	8d 50 04             	lea    0x4(%eax),%edx
 804c4ac:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4af:	8b 00                	mov    (%eax),%eax
 804c4b1:	89 45 c0             	mov    %eax,-0x40(%ebp)
                                        *ip = (str - buf);
 804c4b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c4b7:	8b 45 08             	mov    0x8(%ebp),%eax
 804c4ba:	29 c2                	sub    %eax,%edx
 804c4bc:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c4bf:	89 10                	mov    %edx,(%eax)
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804c4c1:	e9 d7 01 00 00       	jmp    804c69d <.L138+0x10f>
                                /* FIXME:
                                 * What does C99 say about the overflow case here? */
                                if (qualifier == 'l') {
                                        long *ip = va_arg(args, long *);
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
 804c4c6:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804c4ca:	75 24                	jne    804c4f0 <.L92+0x50>
                                        size_t *ip = va_arg(args, size_t *);
 804c4cc:	8b 45 14             	mov    0x14(%ebp),%eax
 804c4cf:	8d 50 04             	lea    0x4(%eax),%edx
 804c4d2:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4d5:	8b 00                	mov    (%eax),%eax
 804c4d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
                                        *ip = (str - buf);
 804c4da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c4dd:	8b 45 08             	mov    0x8(%ebp),%eax
 804c4e0:	29 c2                	sub    %eax,%edx
 804c4e2:	89 d0                	mov    %edx,%eax
 804c4e4:	89 c2                	mov    %eax,%edx
 804c4e6:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c4e9:	89 10                	mov    %edx,(%eax)
                                } else {
                                        int *ip = va_arg(args, int *);
                                        *ip = (str - buf);
                                }
                                continue;
 804c4eb:	e9 ad 01 00 00       	jmp    804c69d <.L138+0x10f>
                                        *ip = (str - buf);
                                } else if (qualifier == 'Z') {
                                        size_t *ip = va_arg(args, size_t *);
                                        *ip = (str - buf);
                                } else {
                                        int *ip = va_arg(args, int *);
 804c4f0:	8b 45 14             	mov    0x14(%ebp),%eax
 804c4f3:	8d 50 04             	lea    0x4(%eax),%edx
 804c4f6:	89 55 14             	mov    %edx,0x14(%ebp)
 804c4f9:	8b 00                	mov    (%eax),%eax
 804c4fb:	89 45 b8             	mov    %eax,-0x48(%ebp)
                                        *ip = (str - buf);
 804c4fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c501:	8b 45 08             	mov    0x8(%ebp),%eax
 804c504:	29 c2                	sub    %eax,%edx
 804c506:	8b 45 b8             	mov    -0x48(%ebp),%eax
 804c509:	89 10                	mov    %edx,(%eax)
                                }
                                continue;
 804c50b:	e9 8d 01 00 00       	jmp    804c69d <.L138+0x10f>

0804c510 <.L86>:

                        case '%':
                                if (str <= end)
 804c510:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c513:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c516:	77 06                	ja     804c51e <.L86+0xe>
                                        *str = '%';
 804c518:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c51b:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804c51e:	ff 45 e4             	incl   -0x1c(%ebp)
                                continue;
 804c521:	e9 77 01 00 00       	jmp    804c69d <.L138+0x10f>

0804c526 <.L93>:

                                /* integer number formats - set up the flags and "break" */
                        case 'o':
                                base = 8;
 804c526:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
                                break;
 804c52d:	eb 60                	jmp    804c58f <.L138+0x1>

0804c52f <.L89>:

                        case 'X':
                                flags |= LARGE;
 804c52f:	83 4d d8 40          	orl    $0x40,-0x28(%ebp)

0804c533 <.L97>:
                        case 'x':
                                base = 16;
 804c533:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)
                                break;
 804c53a:	eb 53                	jmp    804c58f <.L138+0x1>

0804c53c <.L91>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
 804c53c:	83 4d d8 02          	orl    $0x2,-0x28(%ebp)
                        case 'u':
                                break;
 804c540:	eb 4c                	jmp    804c58e <.L138>

0804c542 <.L88>:
                                /* Added - TODO - alvin */
                        case 'f':
                        case 'F':
                        case 'g':
                        case 'G':
                                return -1;
 804c542:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804c547:	e9 8c 01 00 00       	jmp    804c6d8 <.L138+0x14a>

0804c54c <.L85>:


                        default:
                                if (str <= end)
 804c54c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c54f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c552:	77 06                	ja     804c55a <.L85+0xe>
                                        *str = '%';
 804c554:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c557:	c6 00 25             	movb   $0x25,(%eax)
                                ++str;
 804c55a:	ff 45 e4             	incl   -0x1c(%ebp)
                                if (*fmt) {
 804c55d:	8b 45 10             	mov    0x10(%ebp),%eax
 804c560:	0f b6 00             	movzbl (%eax),%eax
 804c563:	84 c0                	test   %al,%al
 804c565:	74 1b                	je     804c582 <.L85+0x36>
                                        if (str <= end)
 804c567:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c56a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c56d:	77 0b                	ja     804c57a <.L85+0x2e>
                                                *str = *fmt;
 804c56f:	8b 45 10             	mov    0x10(%ebp),%eax
 804c572:	0f b6 10             	movzbl (%eax),%edx
 804c575:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c578:	88 10                	mov    %dl,(%eax)
                                        ++str;
 804c57a:	ff 45 e4             	incl   -0x1c(%ebp)
                                } else {
                                        --fmt;
                                }
                                continue;
 804c57d:	e9 1b 01 00 00       	jmp    804c69d <.L138+0x10f>
                                if (*fmt) {
                                        if (str <= end)
                                                *str = *fmt;
                                        ++str;
                                } else {
                                        --fmt;
 804c582:	8b 45 10             	mov    0x10(%ebp),%eax
 804c585:	48                   	dec    %eax
 804c586:	89 45 10             	mov    %eax,0x10(%ebp)
                                }
                                continue;
 804c589:	e9 0f 01 00 00       	jmp    804c69d <.L138+0x10f>

0804c58e <.L138>:

                        case 'd':
                        case 'i':
                                flags |= SIGN;
                        case 'u':
                                break;
 804c58e:	90                   	nop
                                } else {
                                        --fmt;
                                }
                                continue;
                }
                if (qualifier == 'L')
 804c58f:	83 7d cc 4c          	cmpl   $0x4c,-0x34(%ebp)
 804c593:	75 19                	jne    804c5ae <.L138+0x20>
                        num = va_arg(args, long long);
 804c595:	8b 45 14             	mov    0x14(%ebp),%eax
 804c598:	8d 50 08             	lea    0x8(%eax),%edx
 804c59b:	89 55 14             	mov    %edx,0x14(%ebp)
 804c59e:	8b 50 04             	mov    0x4(%eax),%edx
 804c5a1:	8b 00                	mov    (%eax),%eax
 804c5a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c5a6:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c5a9:	e9 b0 00 00 00       	jmp    804c65e <.L138+0xd0>
                else if (qualifier == 'l') {
 804c5ae:	83 7d cc 6c          	cmpl   $0x6c,-0x34(%ebp)
 804c5b2:	75 2f                	jne    804c5e3 <.L138+0x55>
                        num = va_arg(args, unsigned long);
 804c5b4:	8b 45 14             	mov    0x14(%ebp),%eax
 804c5b7:	8d 50 04             	lea    0x4(%eax),%edx
 804c5ba:	89 55 14             	mov    %edx,0x14(%ebp)
 804c5bd:	8b 00                	mov    (%eax),%eax
 804c5bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c5c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c5c9:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c5cc:	83 e0 02             	and    $0x2,%eax
 804c5cf:	85 c0                	test   %eax,%eax
 804c5d1:	0f 84 87 00 00 00    	je     804c65e <.L138+0xd0>
                                num = (signed long) num;
 804c5d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c5da:	99                   	cltd   
 804c5db:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c5de:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c5e1:	eb 7b                	jmp    804c65e <.L138+0xd0>
                } else if (qualifier == 'Z') {
 804c5e3:	83 7d cc 5a          	cmpl   $0x5a,-0x34(%ebp)
 804c5e7:	75 17                	jne    804c600 <.L138+0x72>
                        num = va_arg(args, size_t);
 804c5e9:	8b 45 14             	mov    0x14(%ebp),%eax
 804c5ec:	8d 50 04             	lea    0x4(%eax),%edx
 804c5ef:	89 55 14             	mov    %edx,0x14(%ebp)
 804c5f2:	8b 00                	mov    (%eax),%eax
 804c5f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c5f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804c5fe:	eb 5e                	jmp    804c65e <.L138+0xd0>
                } else if (qualifier == 'h') {
 804c600:	83 7d cc 68          	cmpl   $0x68,-0x34(%ebp)
 804c604:	75 2f                	jne    804c635 <.L138+0xa7>
                        num = (unsigned short) va_arg(args, int);
 804c606:	8b 45 14             	mov    0x14(%ebp),%eax
 804c609:	8d 50 04             	lea    0x4(%eax),%edx
 804c60c:	89 55 14             	mov    %edx,0x14(%ebp)
 804c60f:	8b 00                	mov    (%eax),%eax
 804c611:	0f b7 c0             	movzwl %ax,%eax
 804c614:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c617:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c61e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c621:	83 e0 02             	and    $0x2,%eax
 804c624:	85 c0                	test   %eax,%eax
 804c626:	74 36                	je     804c65e <.L138+0xd0>
                                num = (signed short) num;
 804c628:	0f bf 45 f0          	movswl -0x10(%ebp),%eax
 804c62c:	99                   	cltd   
 804c62d:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c630:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804c633:	eb 29                	jmp    804c65e <.L138+0xd0>
                } else {
                        num = va_arg(args, unsigned int);
 804c635:	8b 45 14             	mov    0x14(%ebp),%eax
 804c638:	8d 50 04             	lea    0x4(%eax),%edx
 804c63b:	89 55 14             	mov    %edx,0x14(%ebp)
 804c63e:	8b 00                	mov    (%eax),%eax
 804c640:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c643:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                        if (flags & SIGN)
 804c64a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804c64d:	83 e0 02             	and    $0x2,%eax
 804c650:	85 c0                	test   %eax,%eax
 804c652:	74 0a                	je     804c65e <.L138+0xd0>
                                num = (signed int) num;
 804c654:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c657:	99                   	cltd   
 804c658:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c65b:	89 55 f4             	mov    %edx,-0xc(%ebp)
                }

                str = number(str, end, num, base,
 804c65e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c661:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c664:	8b 4d d8             	mov    -0x28(%ebp),%ecx
 804c667:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 804c66b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
 804c66e:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 804c672:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
 804c675:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 804c679:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804c67c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 804c680:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c684:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804c688:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c68b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c68f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c692:	89 04 24             	mov    %eax,(%esp)
 804c695:	e8 ad f6 ff ff       	call   804bd47 <number>
 804c69a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (end < buf - 1) {
                end = ((void *) - 1);
                size = end - buf + 1;
        }

        for (; *fmt ; ++fmt) {
 804c69d:	8b 45 10             	mov    0x10(%ebp),%eax
 804c6a0:	40                   	inc    %eax
 804c6a1:	89 45 10             	mov    %eax,0x10(%ebp)
 804c6a4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c6a7:	0f b6 00             	movzbl (%eax),%eax
 804c6aa:	84 c0                	test   %al,%al
 804c6ac:	0f 85 96 fa ff ff    	jne    804c148 <vsnprintf+0x4d>
                }

                str = number(str, end, num, base,
                             field_width, precision, flags);
        }
        if (str <= end)
 804c6b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c6b5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804c6b8:	77 08                	ja     804c6c2 <.L138+0x134>
                *str = '\0';
 804c6ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c6bd:	c6 00 00             	movb   $0x0,(%eax)
 804c6c0:	eb 0c                	jmp    804c6ce <.L138+0x140>
        else if (size > 0)
 804c6c2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c6c6:	74 06                	je     804c6ce <.L138+0x140>
                /* don't write out a null byte if the buf size is zero */
                *end = '\0';
 804c6c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804c6cb:	c6 00 00             	movb   $0x0,(%eax)
        /* the trailing null byte doesn't count towards the total
         * ++str;
         */
        return str - buf;
 804c6ce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c6d1:	8b 45 08             	mov    0x8(%ebp),%eax
 804c6d4:	29 c2                	sub    %eax,%edx
 804c6d6:	89 d0                	mov    %edx,%eax
}
 804c6d8:	83 c4 64             	add    $0x64,%esp
 804c6db:	5b                   	pop    %ebx
 804c6dc:	5d                   	pop    %ebp
 804c6dd:	c3                   	ret    

0804c6de <__x86.get_pc_thunk.dx>:
 804c6de:	8b 14 24             	mov    (%esp),%edx
 804c6e1:	c3                   	ret    

0804c6e2 <__x86.get_pc_thunk.si>:
 804c6e2:	8b 34 24             	mov    (%esp),%esi
 804c6e5:	c3                   	ret    

0804c6e6 <shl>:
 * `fall out' the left (there never will be any such anyway).
 * We may assume len >= 0.  NOTE THAT THIS WRITES len+1 DIGITS.
 */
static void
shl(register digit *p, register int len, register int sh)
{
 804c6e6:	55                   	push   %ebp
 804c6e7:	89 e5                	mov    %esp,%ebp
 804c6e9:	57                   	push   %edi
 804c6ea:	56                   	push   %esi
 804c6eb:	53                   	push   %ebx
 804c6ec:	83 ec 04             	sub    $0x4,%esp
 804c6ef:	e8 cd c9 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804c6f4:	05 0c 29 00 00       	add    $0x290c,%eax
 804c6f9:	8b 75 08             	mov    0x8(%ebp),%esi
        register int i;

        for (i = 0; i < len; i++)
 804c6fc:	bb 00 00 00 00       	mov    $0x0,%ebx
 804c701:	eb 41                	jmp    804c744 <shl+0x5e>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
 804c703:	89 d8                	mov    %ebx,%eax
 804c705:	c1 e0 02             	shl    $0x2,%eax
 804c708:	8d 3c 06             	lea    (%esi,%eax,1),%edi
 804c70b:	89 d8                	mov    %ebx,%eax
 804c70d:	c1 e0 02             	shl    $0x2,%eax
 804c710:	01 f0                	add    %esi,%eax
 804c712:	8b 00                	mov    (%eax),%eax
 804c714:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c718:	d3 e0                	shl    %cl,%eax
 804c71a:	0f b7 c0             	movzwl %ax,%eax
 804c71d:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804c720:	89 d8                	mov    %ebx,%eax
 804c722:	40                   	inc    %eax
 804c723:	c1 e0 02             	shl    $0x2,%eax
 804c726:	01 f0                	add    %esi,%eax
 804c728:	8b 00                	mov    (%eax),%eax
 804c72a:	89 c1                	mov    %eax,%ecx
 804c72c:	8b 55 10             	mov    0x10(%ebp),%edx
 804c72f:	b8 10 00 00 00       	mov    $0x10,%eax
 804c734:	29 d0                	sub    %edx,%eax
 804c736:	89 ca                	mov    %ecx,%edx
 804c738:	88 c1                	mov    %al,%cl
 804c73a:	d3 ea                	shr    %cl,%edx
 804c73c:	89 d0                	mov    %edx,%eax
 804c73e:	0b 45 f0             	or     -0x10(%ebp),%eax
 804c741:	89 07                	mov    %eax,(%edi)
static void
shl(register digit *p, register int len, register int sh)
{
        register int i;

        for (i = 0; i < len; i++)
 804c743:	43                   	inc    %ebx
 804c744:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
 804c747:	7c ba                	jl     804c703 <shl+0x1d>
                p[i] = LHALF(p[i] << sh) | (p[i + 1] >> (HALF_BITS - sh));
        p[i] = LHALF(p[i] << sh);
 804c749:	89 d8                	mov    %ebx,%eax
 804c74b:	c1 e0 02             	shl    $0x2,%eax
 804c74e:	8d 14 06             	lea    (%esi,%eax,1),%edx
 804c751:	89 d8                	mov    %ebx,%eax
 804c753:	c1 e0 02             	shl    $0x2,%eax
 804c756:	01 f0                	add    %esi,%eax
 804c758:	8b 00                	mov    (%eax),%eax
 804c75a:	0f b6 4d 10          	movzbl 0x10(%ebp),%ecx
 804c75e:	d3 e0                	shl    %cl,%eax
 804c760:	0f b7 c0             	movzwl %ax,%eax
 804c763:	89 02                	mov    %eax,(%edx)
}
 804c765:	90                   	nop
 804c766:	83 c4 04             	add    $0x4,%esp
 804c769:	5b                   	pop    %ebx
 804c76a:	5e                   	pop    %esi
 804c76b:	5f                   	pop    %edi
 804c76c:	5d                   	pop    %ebp
 804c76d:	c3                   	ret    

0804c76e <__qdivrem>:
 * divisor are 4 `digits' in this base (they are shorter if they have
 * leading zeros).
 */
unsigned long long
__qdivrem(unsigned long long uq, unsigned long long vq, unsigned long long *arq)
{
 804c76e:	55                   	push   %ebp
 804c76f:	89 e5                	mov    %esp,%ebp
 804c771:	57                   	push   %edi
 804c772:	56                   	push   %esi
 804c773:	53                   	push   %ebx
 804c774:	81 ec b8 00 00 00    	sub    $0xb8,%esp
 804c77a:	e8 42 c9 ff ff       	call   80490c1 <__x86.get_pc_thunk.ax>
 804c77f:	05 81 28 00 00       	add    $0x2881,%eax
 804c784:	8b 55 08             	mov    0x8(%ebp),%edx
 804c787:	89 95 58 ff ff ff    	mov    %edx,-0xa8(%ebp)
 804c78d:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c790:	89 95 5c ff ff ff    	mov    %edx,-0xa4(%ebp)
 804c796:	8b 55 10             	mov    0x10(%ebp),%edx
 804c799:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
 804c79f:	8b 55 14             	mov    0x14(%ebp),%edx
 804c7a2:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
        digit uspace[5], vspace[5], qspace[5];

        /*
         * Take care of special cases: divide by zero, and u < v.
         */
        if (vq == 0) {
 804c7a8:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c7ae:	0b 95 50 ff ff ff    	or     -0xb0(%ebp),%edx
 804c7b4:	85 d2                	test   %edx,%edx
 804c7b6:	75 40                	jne    804c7f8 <__qdivrem+0x8a>
                /* divide by zero. */
                static volatile const unsigned int zero = 0;

                tmp.ul[H] = tmp.ul[L] = 1 / zero;
 804c7b8:	8b b8 60 01 00 00    	mov    0x160(%eax),%edi
 804c7be:	b8 01 00 00 00       	mov    $0x1,%eax
 804c7c3:	ba 00 00 00 00       	mov    $0x0,%edx
 804c7c8:	f7 f7                	div    %edi
 804c7ca:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c7cd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c7d0:	89 45 a8             	mov    %eax,-0x58(%ebp)
                if (arq)
 804c7d3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c7d7:	74 14                	je     804c7ed <__qdivrem+0x7f>
                        *arq = uq;
 804c7d9:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c7dc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c7e2:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c7e8:	89 01                	mov    %eax,(%ecx)
 804c7ea:	89 51 04             	mov    %edx,0x4(%ecx)
                return (tmp.q);
 804c7ed:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c7f0:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c7f3:	e9 eb 05 00 00       	jmp    804cde3 <__qdivrem+0x675>
        }
        if (uq < vq) {
 804c7f8:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c7fe:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c804:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c80a:	77 39                	ja     804c845 <__qdivrem+0xd7>
 804c80c:	3b 95 54 ff ff ff    	cmp    -0xac(%ebp),%edx
 804c812:	72 08                	jb     804c81c <__qdivrem+0xae>
 804c814:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
 804c81a:	73 29                	jae    804c845 <__qdivrem+0xd7>
                if (arq)
 804c81c:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c820:	74 14                	je     804c836 <__qdivrem+0xc8>
                        *arq = uq;
 804c822:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c825:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c82b:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c831:	89 01                	mov    %eax,(%ecx)
 804c833:	89 51 04             	mov    %edx,0x4(%ecx)
                return (0);
 804c836:	b8 00 00 00 00       	mov    $0x0,%eax
 804c83b:	ba 00 00 00 00       	mov    $0x0,%edx
 804c840:	e9 9e 05 00 00       	jmp    804cde3 <__qdivrem+0x675>
        }
        u = &uspace[0];
 804c845:	8d 45 90             	lea    -0x70(%ebp),%eax
 804c848:	89 45 ec             	mov    %eax,-0x14(%ebp)
        v = &vspace[0];
 804c84b:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
 804c851:	89 45 e8             	mov    %eax,-0x18(%ebp)
        q = &qspace[0];
 804c854:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
 804c85a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         *      m >= 0 (otherwise u < v, which we already checked)
         *      m + n = 4
         * and thus
         *      m = 4 - n <= 2
         */
        tmp.uq = uq;
 804c85d:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
 804c863:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
 804c869:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c86c:	89 55 a8             	mov    %edx,-0x58(%ebp)
        u[0] = 0;
 804c86f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c872:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        u[1] = HHALF(tmp.ul[H]);
 804c878:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c87b:	83 c0 04             	add    $0x4,%eax
 804c87e:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c881:	c1 ea 10             	shr    $0x10,%edx
 804c884:	89 10                	mov    %edx,(%eax)
        u[2] = LHALF(tmp.ul[H]);
 804c886:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c889:	8d 50 08             	lea    0x8(%eax),%edx
 804c88c:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804c88f:	0f b7 c0             	movzwl %ax,%eax
 804c892:	89 02                	mov    %eax,(%edx)
        u[3] = HHALF(tmp.ul[L]);
 804c894:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c897:	83 c0 0c             	add    $0xc,%eax
 804c89a:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c89d:	c1 ea 10             	shr    $0x10,%edx
 804c8a0:	89 10                	mov    %edx,(%eax)
        u[4] = LHALF(tmp.ul[L]);
 804c8a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c8a5:	8d 50 10             	lea    0x10(%eax),%edx
 804c8a8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c8ab:	0f b7 c0             	movzwl %ax,%eax
 804c8ae:	89 02                	mov    %eax,(%edx)
        tmp.uq = vq;
 804c8b0:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 804c8b6:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
 804c8bc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804c8bf:	89 55 a8             	mov    %edx,-0x58(%ebp)
        v[1] = HHALF(tmp.ul[H]);
 804c8c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8c5:	83 c0 04             	add    $0x4,%eax
 804c8c8:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c8cb:	c1 ea 10             	shr    $0x10,%edx
 804c8ce:	89 10                	mov    %edx,(%eax)
        v[2] = LHALF(tmp.ul[H]);
 804c8d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8d3:	8d 50 08             	lea    0x8(%eax),%edx
 804c8d6:	8b 45 a8             	mov    -0x58(%ebp),%eax
 804c8d9:	0f b7 c0             	movzwl %ax,%eax
 804c8dc:	89 02                	mov    %eax,(%edx)
        v[3] = HHALF(tmp.ul[L]);
 804c8de:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8e1:	83 c0 0c             	add    $0xc,%eax
 804c8e4:	8b 55 a4             	mov    -0x5c(%ebp),%edx
 804c8e7:	c1 ea 10             	shr    $0x10,%edx
 804c8ea:	89 10                	mov    %edx,(%eax)
        v[4] = LHALF(tmp.ul[L]);
 804c8ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c8ef:	8d 50 10             	lea    0x10(%eax),%edx
 804c8f2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c8f5:	0f b7 c0             	movzwl %ax,%eax
 804c8f8:	89 02                	mov    %eax,(%edx)
        for (n = 4; v[1] == 0; v++) {
 804c8fa:	c7 45 d4 04 00 00 00 	movl   $0x4,-0x2c(%ebp)
 804c901:	e9 fc 00 00 00       	jmp    804ca02 <__qdivrem+0x294>
                if (--n == 1) {
 804c906:	ff 4d d4             	decl   -0x2c(%ebp)
 804c909:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
 804c90d:	0f 85 eb 00 00 00    	jne    804c9fe <__qdivrem+0x290>
                         *      for j = 1..4:
                         *              q[j] = floor((r*B + u[j]) / v),
                         *              r = (r*B + u[j]) % v;
                         * We unroll this completely here.
                         */
                        t = v[2];       /* nonzero, by definition */
 804c913:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c916:	8b 40 08             	mov    0x8(%eax),%eax
 804c919:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        q1 = u[1] / t;
 804c91c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c91f:	83 c0 04             	add    $0x4,%eax
 804c922:	8b 00                	mov    (%eax),%eax
 804c924:	ba 00 00 00 00       	mov    $0x0,%edx
 804c929:	f7 75 dc             	divl   -0x24(%ebp)
 804c92c:	89 45 c0             	mov    %eax,-0x40(%ebp)
                        rbj = COMBINE(u[1] % t, u[2]);
 804c92f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c932:	83 c0 04             	add    $0x4,%eax
 804c935:	8b 00                	mov    (%eax),%eax
 804c937:	ba 00 00 00 00       	mov    $0x0,%edx
 804c93c:	f7 75 dc             	divl   -0x24(%ebp)
 804c93f:	89 d0                	mov    %edx,%eax
 804c941:	c1 e0 10             	shl    $0x10,%eax
 804c944:	89 c2                	mov    %eax,%edx
 804c946:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c949:	83 c0 08             	add    $0x8,%eax
 804c94c:	8b 00                	mov    (%eax),%eax
 804c94e:	09 d0                	or     %edx,%eax
 804c950:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q2 = rbj / t;
 804c953:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c956:	ba 00 00 00 00       	mov    $0x0,%edx
 804c95b:	f7 75 dc             	divl   -0x24(%ebp)
 804c95e:	89 45 b8             	mov    %eax,-0x48(%ebp)
                        rbj = COMBINE(rbj % t, u[3]);
 804c961:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c964:	ba 00 00 00 00       	mov    $0x0,%edx
 804c969:	f7 75 dc             	divl   -0x24(%ebp)
 804c96c:	89 d0                	mov    %edx,%eax
 804c96e:	c1 e0 10             	shl    $0x10,%eax
 804c971:	89 c2                	mov    %eax,%edx
 804c973:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c976:	83 c0 0c             	add    $0xc,%eax
 804c979:	8b 00                	mov    (%eax),%eax
 804c97b:	09 d0                	or     %edx,%eax
 804c97d:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q3 = rbj / t;
 804c980:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c983:	ba 00 00 00 00       	mov    $0x0,%edx
 804c988:	f7 75 dc             	divl   -0x24(%ebp)
 804c98b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                        rbj = COMBINE(rbj % t, u[4]);
 804c98e:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c991:	ba 00 00 00 00       	mov    $0x0,%edx
 804c996:	f7 75 dc             	divl   -0x24(%ebp)
 804c999:	89 d0                	mov    %edx,%eax
 804c99b:	c1 e0 10             	shl    $0x10,%eax
 804c99e:	89 c2                	mov    %eax,%edx
 804c9a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c9a3:	83 c0 10             	add    $0x10,%eax
 804c9a6:	8b 00                	mov    (%eax),%eax
 804c9a8:	09 d0                	or     %edx,%eax
 804c9aa:	89 45 bc             	mov    %eax,-0x44(%ebp)
                        q4 = rbj / t;
 804c9ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c9b0:	ba 00 00 00 00       	mov    $0x0,%edx
 804c9b5:	f7 75 dc             	divl   -0x24(%ebp)
 804c9b8:	89 45 b0             	mov    %eax,-0x50(%ebp)
                        if (arq)
 804c9bb:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c9bf:	74 1a                	je     804c9db <__qdivrem+0x26d>
                                *arq = rbj % t;
 804c9c1:	8b 45 bc             	mov    -0x44(%ebp),%eax
 804c9c4:	ba 00 00 00 00       	mov    $0x0,%edx
 804c9c9:	f7 75 dc             	divl   -0x24(%ebp)
 804c9cc:	89 d0                	mov    %edx,%eax
 804c9ce:	ba 00 00 00 00       	mov    $0x0,%edx
 804c9d3:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804c9d6:	89 01                	mov    %eax,(%ecx)
 804c9d8:	89 51 04             	mov    %edx,0x4(%ecx)
                        tmp.ul[H] = COMBINE(q1, q2);
 804c9db:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804c9de:	c1 e0 10             	shl    $0x10,%eax
 804c9e1:	0b 45 b8             	or     -0x48(%ebp),%eax
 804c9e4:	89 45 a8             	mov    %eax,-0x58(%ebp)
                        tmp.ul[L] = COMBINE(q3, q4);
 804c9e7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 804c9ea:	c1 e0 10             	shl    $0x10,%eax
 804c9ed:	0b 45 b0             	or     -0x50(%ebp),%eax
 804c9f0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                        return (tmp.q);
 804c9f3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804c9f6:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804c9f9:	e9 e5 03 00 00       	jmp    804cde3 <__qdivrem+0x675>
        tmp.uq = vq;
        v[1] = HHALF(tmp.ul[H]);
        v[2] = LHALF(tmp.ul[H]);
        v[3] = HHALF(tmp.ul[L]);
        v[4] = LHALF(tmp.ul[L]);
        for (n = 4; v[1] == 0; v++) {
 804c9fe:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
 804ca02:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ca05:	83 c0 04             	add    $0x4,%eax
 804ca08:	8b 00                	mov    (%eax),%eax
 804ca0a:	85 c0                	test   %eax,%eax
 804ca0c:	0f 84 f4 fe ff ff    	je     804c906 <__qdivrem+0x198>
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804ca12:	b8 04 00 00 00       	mov    $0x4,%eax
 804ca17:	2b 45 d4             	sub    -0x2c(%ebp),%eax
 804ca1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804ca1d:	eb 07                	jmp    804ca26 <__qdivrem+0x2b8>
                m--;
 804ca1f:	ff 4d d8             	decl   -0x28(%ebp)
        /*
         * By adjusting q once we determine m, we can guarantee that
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
 804ca22:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
 804ca26:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ca29:	83 c0 04             	add    $0x4,%eax
 804ca2c:	8b 00                	mov    (%eax),%eax
 804ca2e:	85 c0                	test   %eax,%eax
 804ca30:	74 ed                	je     804ca1f <__qdivrem+0x2b1>
                m--;
        for (i = 4 - m; --i >= 0;)
 804ca32:	b8 04 00 00 00       	mov    $0x4,%eax
 804ca37:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804ca3a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804ca3d:	eb 15                	jmp    804ca54 <__qdivrem+0x2e6>
                q[i] = 0;
 804ca3f:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804ca42:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804ca49:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804ca4c:	01 d0                	add    %edx,%eax
 804ca4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
         * there is a complete four-digit quotient at &qspace[1] when
         * we finally stop.
         */
        for (m = 4 - n; u[1] == 0; u++)
                m--;
        for (i = 4 - m; --i >= 0;)
 804ca54:	ff 4d c8             	decl   -0x38(%ebp)
 804ca57:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804ca5b:	79 e2                	jns    804ca3f <__qdivrem+0x2d1>
                q[i] = 0;
        q += 4 - m;
 804ca5d:	b8 04 00 00 00       	mov    $0x4,%eax
 804ca62:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804ca65:	c1 e0 02             	shl    $0x2,%eax
 804ca68:	01 45 c4             	add    %eax,-0x3c(%ebp)
         * Here we run Program D, translated from MIX to C and acquiring
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
 804ca6b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        for (t = v[1]; t < B / 2; t <<= 1)
 804ca72:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ca75:	8b 40 04             	mov    0x4(%eax),%eax
 804ca78:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804ca7b:	eb 06                	jmp    804ca83 <__qdivrem+0x315>
                d++;
 804ca7d:	ff 45 d0             	incl   -0x30(%ebp)
         * a few minor changes.
         *
         * D1: choose multiplier 1 << d to ensure v[1] >= B/2.
         */
        d = 0;
        for (t = v[1]; t < B / 2; t <<= 1)
 804ca80:	d1 65 dc             	shll   -0x24(%ebp)
 804ca83:	81 7d dc ff 7f 00 00 	cmpl   $0x7fff,-0x24(%ebp)
 804ca8a:	76 f1                	jbe    804ca7d <__qdivrem+0x30f>
                d++;
        if (d > 0) {
 804ca8c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804ca90:	7e 3d                	jle    804cacf <__qdivrem+0x361>
                shl(&u[0], m + n, d);           /* u <<= d */
 804ca92:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804ca95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804ca98:	01 c2                	add    %eax,%edx
 804ca9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ca9d:	89 44 24 08          	mov    %eax,0x8(%esp)
 804caa1:	89 54 24 04          	mov    %edx,0x4(%esp)
 804caa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804caa8:	89 04 24             	mov    %eax,(%esp)
 804caab:	e8 36 fc ff ff       	call   804c6e6 <shl>
                shl(&v[1], n - 1, d);           /* v <<= d */
 804cab0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cab3:	8d 48 ff             	lea    -0x1(%eax),%ecx
 804cab6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cab9:	8d 50 04             	lea    0x4(%eax),%edx
 804cabc:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cabf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cac3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804cac7:	89 14 24             	mov    %edx,(%esp)
 804caca:	e8 17 fc ff ff       	call   804c6e6 <shl>
        }
        /*
         * D2: j = 0.
         */
        j = 0;
 804cacf:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
        v1 = v[1];      /* for D3 -- note that v[1..n] are constant */
 804cad6:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cad9:	8b 58 04             	mov    0x4(%eax),%ebx
        v2 = v[2];      /* for D3 */
 804cadc:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cadf:	8b 40 08             	mov    0x8(%eax),%eax
 804cae2:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
                 * let rhat = (u[j]*B + u[j+1]) mod v[1].
                 * While rhat < B and v[2]*qhat > rhat*B+u[j+2],
                 * decrement qhat and increase rhat correspondingly.
                 * Note that if rhat >= B, v[2]*qhat < rhat*B.
                 */
                uj0 = u[j + 0]; /* for D3 only -- note that u[j+...] change */
 804cae8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804caeb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804caf2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804caf5:	01 d0                	add    %edx,%eax
 804caf7:	8b 38                	mov    (%eax),%edi
                uj1 = u[j + 1]; /* for D3 only */
 804caf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cafc:	40                   	inc    %eax
 804cafd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb04:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb07:	01 d0                	add    %edx,%eax
 804cb09:	8b 30                	mov    (%eax),%esi
                uj2 = u[j + 2]; /* for D3 only */
 804cb0b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb0e:	83 c0 02             	add    $0x2,%eax
 804cb11:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb18:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cb1b:	01 d0                	add    %edx,%eax
 804cb1d:	8b 00                	mov    (%eax),%eax
 804cb1f:	89 c1                	mov    %eax,%ecx
                if (uj0 == v1) {
 804cb21:	39 df                	cmp    %ebx,%edi
 804cb23:	75 0c                	jne    804cb31 <__qdivrem+0x3c3>
                        qhat = B;
 804cb25:	c7 45 e4 00 00 01 00 	movl   $0x10000,-0x1c(%ebp)
                        rhat = uj1;
 804cb2c:	89 75 e0             	mov    %esi,-0x20(%ebp)
                        goto qhat_too_big;
 804cb2f:	eb 26                	jmp    804cb57 <__qdivrem+0x3e9>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
 804cb31:	89 f8                	mov    %edi,%eax
 804cb33:	c1 e0 10             	shl    $0x10,%eax
 804cb36:	09 f0                	or     %esi,%eax
 804cb38:	89 45 ac             	mov    %eax,-0x54(%ebp)
                        qhat = nn / v1;
 804cb3b:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804cb3e:	ba 00 00 00 00       	mov    $0x0,%edx
 804cb43:	f7 f3                	div    %ebx
 804cb45:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                        rhat = nn % v1;
 804cb48:	8b 45 ac             	mov    -0x54(%ebp),%eax
 804cb4b:	ba 00 00 00 00       	mov    $0x0,%edx
 804cb50:	f7 f3                	div    %ebx
 804cb52:	89 55 e0             	mov    %edx,-0x20(%ebp)
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804cb55:	eb 0f                	jmp    804cb66 <__qdivrem+0x3f8>
qhat_too_big:
                        qhat--;
 804cb57:	ff 4d e4             	decl   -0x1c(%ebp)
                        if ((rhat += v1) >= B)
 804cb5a:	01 5d e0             	add    %ebx,-0x20(%ebp)
 804cb5d:	81 7d e0 ff ff 00 00 	cmpl   $0xffff,-0x20(%ebp)
 804cb64:	77 1a                	ja     804cb80 <__qdivrem+0x412>
                } else {
                        unsigned long nn = COMBINE(uj0, uj1);
                        qhat = nn / v1;
                        rhat = nn % v1;
                }
                while (v2 * qhat > COMBINE(rhat, uj2)) {
 804cb66:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
 804cb6c:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804cb70:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804cb73:	c1 e2 10             	shl    $0x10,%edx
 804cb76:	89 cf                	mov    %ecx,%edi
 804cb78:	09 fa                	or     %edi,%edx
 804cb7a:	39 d0                	cmp    %edx,%eax
 804cb7c:	77 d9                	ja     804cb57 <__qdivrem+0x3e9>
 804cb7e:	eb 01                	jmp    804cb81 <__qdivrem+0x413>
qhat_too_big:
                        qhat--;
                        if ((rhat += v1) >= B)
                                break;
 804cb80:	90                   	nop
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804cb81:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804cb88:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cb8b:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cb8e:	eb 64                	jmp    804cbf4 <__qdivrem+0x486>
                        t = u[i + j] - v[i] * qhat - t;
 804cb90:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cb93:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cb96:	01 d0                	add    %edx,%eax
 804cb98:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cb9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cba2:	01 d0                	add    %edx,%eax
 804cba4:	8b 10                	mov    (%eax),%edx
 804cba6:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cba9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cbb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cbb3:	01 c8                	add    %ecx,%eax
 804cbb5:	8b 00                	mov    (%eax),%eax
 804cbb7:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
 804cbbb:	29 c2                	sub    %eax,%edx
 804cbbd:	89 d0                	mov    %edx,%eax
 804cbbf:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804cbc2:	89 45 dc             	mov    %eax,-0x24(%ebp)
                        u[i + j] = LHALF(t);
 804cbc5:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cbc8:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cbcb:	01 d0                	add    %edx,%eax
 804cbcd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cbd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cbd7:	01 c2                	add    %eax,%edx
 804cbd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cbdc:	0f b7 c0             	movzwl %ax,%eax
 804cbdf:	89 02                	mov    %eax,(%edx)
                        t = (B - HHALF(t)) & (B - 1);
 804cbe1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cbe4:	c1 e8 10             	shr    $0x10,%eax
 804cbe7:	f7 d8                	neg    %eax
 804cbe9:	25 ff ff 00 00       	and    $0xffff,%eax
 804cbee:	89 45 dc             	mov    %eax,-0x24(%ebp)
                 * D4: Multiply and subtract.
                 * The variable `t' holds any borrows across the loop.
                 * We split this up so that we do not require v[0] = 0,
                 * and to eliminate a final special case.
                 */
                for (t = 0, i = n; i > 0; i--) {
 804cbf1:	ff 4d c8             	decl   -0x38(%ebp)
 804cbf4:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804cbf8:	7f 96                	jg     804cb90 <__qdivrem+0x422>
                        t = u[i + j] - v[i] * qhat - t;
                        u[i + j] = LHALF(t);
                        t = (B - HHALF(t)) & (B - 1);
                }
                t = u[j] - t;
 804cbfa:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cbfd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc04:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc07:	01 d0                	add    %edx,%eax
 804cc09:	8b 00                	mov    (%eax),%eax
 804cc0b:	2b 45 dc             	sub    -0x24(%ebp),%eax
 804cc0e:	89 45 dc             	mov    %eax,-0x24(%ebp)
                u[j] = LHALF(t);
 804cc11:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cc14:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc1e:	01 c2                	add    %eax,%edx
 804cc20:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cc23:	0f b7 c0             	movzwl %ax,%eax
 804cc26:	89 02                	mov    %eax,(%edx)
                 * D5: test remainder.
                 * There is a borrow if and only if HHALF(t) is nonzero;
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
 804cc28:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cc2b:	c1 e8 10             	shr    $0x10,%eax
 804cc2e:	85 c0                	test   %eax,%eax
 804cc30:	0f 84 91 00 00 00    	je     804ccc7 <__qdivrem+0x559>
                        qhat--;
 804cc36:	ff 4d e4             	decl   -0x1c(%ebp)
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804cc39:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
 804cc40:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cc43:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cc46:	eb 4f                	jmp    804cc97 <__qdivrem+0x529>
                                t += u[i + j] + v[i];
 804cc48:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cc4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cc4e:	01 d0                	add    %edx,%eax
 804cc50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc57:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc5a:	01 d0                	add    %edx,%eax
 804cc5c:	8b 10                	mov    (%eax),%edx
 804cc5e:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cc61:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cc68:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cc6b:	01 c8                	add    %ecx,%eax
 804cc6d:	8b 00                	mov    (%eax),%eax
 804cc6f:	01 d0                	add    %edx,%eax
 804cc71:	01 45 dc             	add    %eax,-0x24(%ebp)
                                u[i + j] = LHALF(t);
 804cc74:	8b 55 c8             	mov    -0x38(%ebp),%edx
 804cc77:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cc7a:	01 d0                	add    %edx,%eax
 804cc7c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cc83:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cc86:	01 c2                	add    %eax,%edx
 804cc88:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804cc8b:	0f b7 c0             	movzwl %ax,%eax
 804cc8e:	89 02                	mov    %eax,(%edx)
                                t = HHALF(t);
 804cc90:	c1 6d dc 10          	shrl   $0x10,-0x24(%ebp)
                 * in that (rare) case, qhat was too large (by exactly 1).
                 * Fix it by adding v[1..n] to u[j..j+n].
                 */
                if (HHALF(t)) {
                        qhat--;
                        for (t = 0, i = n; i > 0; i--) { /* D6: add back. */
 804cc94:	ff 4d c8             	decl   -0x38(%ebp)
 804cc97:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
 804cc9b:	7f ab                	jg     804cc48 <__qdivrem+0x4da>
                                t += u[i + j] + v[i];
                                u[i + j] = LHALF(t);
                                t = HHALF(t);
                        }
                        u[j] = LHALF(u[j] + t);
 804cc9d:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cca0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ccaa:	01 c2                	add    %eax,%edx
 804ccac:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ccaf:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804ccb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ccb9:	01 c8                	add    %ecx,%eax
 804ccbb:	8b 08                	mov    (%eax),%ecx
 804ccbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804ccc0:	01 c8                	add    %ecx,%eax
 804ccc2:	0f b7 c0             	movzwl %ax,%eax
 804ccc5:	89 02                	mov    %eax,(%edx)
                }
                q[j] = qhat;
 804ccc7:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804ccca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804ccd1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804ccd4:	01 c2                	add    %eax,%edx
 804ccd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ccd9:	89 02                	mov    %eax,(%edx)
        } while (++j <= m);             /* D7: loop on j. */
 804ccdb:	ff 45 cc             	incl   -0x34(%ebp)
 804ccde:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804cce1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804cce4:	0f 8e fe fd ff ff    	jle    804cae8 <__qdivrem+0x37a>
        /*
         * If caller wants the remainder, we have to calculate it as
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
 804ccea:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804ccee:	0f 84 bd 00 00 00    	je     804cdb1 <__qdivrem+0x643>
                if (d) {
 804ccf4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
 804ccf8:	0f 84 85 00 00 00    	je     804cd83 <__qdivrem+0x615>
                        for (i = m + n; i > m; --i)
 804ccfe:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804cd01:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804cd04:	01 d0                	add    %edx,%eax
 804cd06:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804cd09:	eb 5b                	jmp    804cd66 <__qdivrem+0x5f8>
                                u[i] = (u[i] >> d) |
 804cd0b:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cd15:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd18:	01 c2                	add    %eax,%edx
 804cd1a:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd1d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cd24:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd27:	01 c8                	add    %ecx,%eax
 804cd29:	8b 18                	mov    (%eax),%ebx
 804cd2b:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cd2e:	89 de                	mov    %ebx,%esi
 804cd30:	88 c1                	mov    %al,%cl
 804cd32:	d3 ee                	shr    %cl,%esi
                                       LHALF(u[i - 1] << (HALF_BITS - d));
 804cd34:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd37:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
 804cd3c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
 804cd43:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd46:	01 c8                	add    %ecx,%eax
 804cd48:	8b 18                	mov    (%eax),%ebx
 804cd4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804cd4d:	b9 10 00 00 00       	mov    $0x10,%ecx
 804cd52:	29 c1                	sub    %eax,%ecx
 804cd54:	89 c8                	mov    %ecx,%eax
 804cd56:	88 c1                	mov    %al,%cl
 804cd58:	d3 e3                	shl    %cl,%ebx
 804cd5a:	89 d8                	mov    %ebx,%eax
 804cd5c:	0f b7 c0             	movzwl %ax,%eax
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
                                u[i] = (u[i] >> d) |
 804cd5f:	09 f0                	or     %esi,%eax
 804cd61:	89 02                	mov    %eax,(%edx)
         * u[m..m+n] >> d (this is at most n digits and thus fits in
         * u[m+1..m+n], but we may need more source digits).
         */
        if (arq) {
                if (d) {
                        for (i = m + n; i > m; --i)
 804cd63:	ff 4d c8             	decl   -0x38(%ebp)
 804cd66:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd69:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 804cd6c:	7f 9d                	jg     804cd0b <__qdivrem+0x59d>
                                u[i] = (u[i] >> d) |
                                       LHALF(u[i - 1] << (HALF_BITS - d));
                        u[i] = 0;
 804cd6e:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804cd71:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 804cd78:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804cd7b:	01 d0                	add    %edx,%eax
 804cd7d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                }
                tmp.ul[H] = COMBINE(uspace[1], uspace[2]);
 804cd83:	8b 45 94             	mov    -0x6c(%ebp),%eax
 804cd86:	c1 e0 10             	shl    $0x10,%eax
 804cd89:	89 c2                	mov    %eax,%edx
 804cd8b:	8b 45 98             	mov    -0x68(%ebp),%eax
 804cd8e:	09 d0                	or     %edx,%eax
 804cd90:	89 45 a8             	mov    %eax,-0x58(%ebp)
                tmp.ul[L] = COMBINE(uspace[3], uspace[4]);
 804cd93:	8b 45 9c             	mov    -0x64(%ebp),%eax
 804cd96:	c1 e0 10             	shl    $0x10,%eax
 804cd99:	89 c2                	mov    %eax,%edx
 804cd9b:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804cd9e:	09 d0                	or     %edx,%eax
 804cda0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
                *arq = tmp.q;
 804cda3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804cda6:	8b 55 a8             	mov    -0x58(%ebp),%edx
 804cda9:	8b 4d 18             	mov    0x18(%ebp),%ecx
 804cdac:	89 01                	mov    %eax,(%ecx)
 804cdae:	89 51 04             	mov    %edx,0x4(%ecx)
        }

        tmp.ul[H] = COMBINE(qspace[1], qspace[2]);
 804cdb1:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
 804cdb7:	c1 e0 10             	shl    $0x10,%eax
 804cdba:	89 c2                	mov    %eax,%edx
 804cdbc:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
 804cdc2:	09 d0                	or     %edx,%eax
 804cdc4:	89 45 a8             	mov    %eax,-0x58(%ebp)
        tmp.ul[L] = COMBINE(qspace[3], qspace[4]);
 804cdc7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
 804cdcd:	c1 e0 10             	shl    $0x10,%eax
 804cdd0:	89 c2                	mov    %eax,%edx
 804cdd2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
 804cdd8:	09 d0                	or     %edx,%eax
 804cdda:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        return (tmp.q);
 804cddd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804cde0:	8b 55 a8             	mov    -0x58(%ebp),%edx
}
 804cde3:	81 c4 b8 00 00 00    	add    $0xb8,%esp
 804cde9:	5b                   	pop    %ebx
 804cdea:	5e                   	pop    %esi
 804cdeb:	5f                   	pop    %edi
 804cdec:	5d                   	pop    %ebp
 804cded:	c3                   	ret    

0804cdee <__divdi3>:
/*
 * Divide two signed quads.
 * ??? if -1/2 should produce -1 on this machine, this code is wrong
 */
long long __divdi3(long long a, long long b)
{
 804cdee:	55                   	push   %ebp
 804cdef:	89 e5                	mov    %esp,%ebp
 804cdf1:	53                   	push   %ebx
 804cdf2:	83 ec 54             	sub    $0x54,%esp
 804cdf5:	e8 cb c2 ff ff       	call   80490c5 <__x86.get_pc_thunk.cx>
 804cdfa:	81 c1 06 22 00 00    	add    $0x2206,%ecx
 804ce00:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce03:	89 45 d0             	mov    %eax,-0x30(%ebp)
 804ce06:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ce09:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804ce0c:	8b 45 10             	mov    0x10(%ebp),%eax
 804ce0f:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804ce12:	8b 45 14             	mov    0x14(%ebp),%eax
 804ce15:	89 45 cc             	mov    %eax,-0x34(%ebp)
        unsigned long long ua, ub, uq;
        int neg;

        if (a < 0)
 804ce18:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
 804ce1c:	79 1c                	jns    804ce3a <__divdi3+0x4c>
                ua = -(unsigned long long)a, neg = 1;
 804ce1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ce21:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804ce24:	f7 d8                	neg    %eax
 804ce26:	83 d2 00             	adc    $0x0,%edx
 804ce29:	f7 da                	neg    %edx
 804ce2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ce2e:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ce31:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
 804ce38:	eb 13                	jmp    804ce4d <__divdi3+0x5f>
        else
                ua = a, neg = 0;
 804ce3a:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804ce3d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804ce40:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804ce43:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804ce46:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if (b < 0)
 804ce4d:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
 804ce51:	79 19                	jns    804ce6c <__divdi3+0x7e>
                ub = -(unsigned long long)b, neg ^= 1;
 804ce53:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804ce56:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ce59:	f7 d8                	neg    %eax
 804ce5b:	83 d2 00             	adc    $0x0,%edx
 804ce5e:	f7 da                	neg    %edx
 804ce60:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804ce63:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804ce66:	83 75 e4 01          	xorl   $0x1,-0x1c(%ebp)
 804ce6a:	eb 0c                	jmp    804ce78 <__divdi3+0x8a>
        else
                ub = b;
 804ce6c:	8b 45 c8             	mov    -0x38(%ebp),%eax
 804ce6f:	8b 55 cc             	mov    -0x34(%ebp),%edx
 804ce72:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804ce75:	89 55 ec             	mov    %edx,-0x14(%ebp)
        uq = __qdivrem(ua, ub, (unsigned long long *)0);
 804ce78:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804ce7f:	00 
 804ce80:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ce83:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ce86:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ce8a:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804ce8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ce91:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ce94:	89 04 24             	mov    %eax,(%esp)
 804ce97:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ce9b:	89 cb                	mov    %ecx,%ebx
 804ce9d:	e8 cc f8 ff ff       	call   804c76e <__qdivrem>
 804cea2:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804cea5:	89 55 dc             	mov    %edx,-0x24(%ebp)
        return (neg ? -uq : uq);
 804cea8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804ceac:	74 0f                	je     804cebd <__divdi3+0xcf>
 804ceae:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804ceb1:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804ceb4:	f7 d8                	neg    %eax
 804ceb6:	83 d2 00             	adc    $0x0,%edx
 804ceb9:	f7 da                	neg    %edx
 804cebb:	eb 06                	jmp    804cec3 <__divdi3+0xd5>
 804cebd:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cec0:	8b 55 dc             	mov    -0x24(%ebp),%edx
}
 804cec3:	83 c4 54             	add    $0x54,%esp
 804cec6:	5b                   	pop    %ebx
 804cec7:	5d                   	pop    %ebp
 804cec8:	c3                   	ret    

0804cec9 <__udivdi3>:
/*
 * Divide two unsigned quads.
 */
unsigned long long
__udivdi3(unsigned long long a, unsigned long long b)
{
 804cec9:	55                   	push   %ebp
 804ceca:	89 e5                	mov    %esp,%ebp
 804cecc:	53                   	push   %ebx
 804cecd:	83 ec 34             	sub    $0x34,%esp
 804ced0:	e8 f0 c1 ff ff       	call   80490c5 <__x86.get_pc_thunk.cx>
 804ced5:	81 c1 2b 21 00 00    	add    $0x212b,%ecx
 804cedb:	8b 45 08             	mov    0x8(%ebp),%eax
 804cede:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804cee1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cee4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804cee7:	8b 45 10             	mov    0x10(%ebp),%eax
 804ceea:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804ceed:	8b 45 14             	mov    0x14(%ebp),%eax
 804cef0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return (__qdivrem(a, b, (unsigned long long *)0));
 804cef3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804cefa:	00 
 804cefb:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804cefe:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804cf01:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cf05:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804cf09:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cf0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804cf0f:	89 04 24             	mov    %eax,(%esp)
 804cf12:	89 54 24 04          	mov    %edx,0x4(%esp)
 804cf16:	89 cb                	mov    %ecx,%ebx
 804cf18:	e8 51 f8 ff ff       	call   804c76e <__qdivrem>
}
 804cf1d:	83 c4 34             	add    $0x34,%esp
 804cf20:	5b                   	pop    %ebx
 804cf21:	5d                   	pop    %ebp
 804cf22:	c3                   	ret    

0804cf23 <__umoddi3>:
/*
 * Return remainder after dividing two unsigned quads.
 */
unsigned long long
__umoddi3(unsigned long long a, unsigned long long b)
{
 804cf23:	55                   	push   %ebp
 804cf24:	89 e5                	mov    %esp,%ebp
 804cf26:	53                   	push   %ebx
 804cf27:	83 ec 44             	sub    $0x44,%esp
 804cf2a:	e8 96 c1 ff ff       	call   80490c5 <__x86.get_pc_thunk.cx>
 804cf2f:	81 c1 d1 20 00 00    	add    $0x20d1,%ecx
 804cf35:	8b 45 08             	mov    0x8(%ebp),%eax
 804cf38:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804cf3b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cf3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804cf41:	8b 45 10             	mov    0x10(%ebp),%eax
 804cf44:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804cf47:	8b 45 14             	mov    0x14(%ebp),%eax
 804cf4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        unsigned long long r;

        (void)__qdivrem(a, b, &r);
 804cf4d:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804cf50:	89 44 24 10          	mov    %eax,0x10(%esp)
 804cf54:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804cf57:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804cf5a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cf5e:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804cf62:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804cf65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804cf68:	89 04 24             	mov    %eax,(%esp)
 804cf6b:	89 54 24 04          	mov    %edx,0x4(%esp)
 804cf6f:	89 cb                	mov    %ecx,%ebx
 804cf71:	e8 f8 f7 ff ff       	call   804c76e <__qdivrem>
        return (r);
 804cf76:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804cf79:	8b 55 f4             	mov    -0xc(%ebp),%edx
}
 804cf7c:	83 c4 44             	add    $0x44,%esp
 804cf7f:	5b                   	pop    %ebx
 804cf80:	5d                   	pop    %ebp
 804cf81:	c3                   	ret    
